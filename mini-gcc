#!/bin/bash

REAL_CC=gcc
REAL_LD=ld

verbose=1

# grep mini-gcc path 
MLIBDIR=$(echo -e $0 | sed -E "s/(.*)\/mini-gcc/\1/")


echo_verbose(){
		if [ $verbose == 1 ]; then
		>&2 echo $@
		fi
}



echo_verbose minilibdir: $MLIBDIR





# gcc options
# only linux x64 for now.

COMMONCFLAGS="-I. -fno-stack-protector -fdata-sections -fomit-frame-pointer -ffunction-sections \
		-Wno-unused-variable -Wno-unused-but-set-variable -Wno-unused-const-variable -Wall \
		-nodefaultlibs -static -nostdlib -DMLIB -fno-builtin -nostdinc\
		-I$MLIBDIR/compat -I$MLIBDIR/headers/common-links -I$MLIBDIR/headers/common -I$MLIBDIR/headers/linux_x64 -I$MLIBDIR -I./ \
		-I$MLIBDIR/include -Os"

# needs os detection. but not important for now
CFLAGS="$COMMONCFLAGS -DLINUX -DX64"

# ld options 
CFLAGS="$CFLAGS -Wl,-n,-s,--gc-sections,-nostdlib"

# (default) linker script 
LDSCRIPT=",-T$MLIBDIR/ldscripts/ld.script"

#LDFLAGS=-nostdlib -nodefaultlibs --gc-sections -static -n -s $(LSCRIPT) -nostartfiles -O 2

PARSE=1

while [ 1 ]; do
if [ $PARSE == 0 ]; then 

usage(){
		echo 
		echo "Usage: mini-gcc [options] [gcc-options] -o outputfile inputfile(s).c

mini-gcc compiles binaries and links them statically with minilib.
It's a wrapper to call gcc with the right compile options.

mini-gcc passes all options it's invoked with on to gcc,
besides the options described below, which must be passed 
before options and parameters for gcc.

-h, --help:	shows this help
--license:	shows the license (BSD 3-clause)

--config 'file': 
        when the --config 'file' option is given
        mini-gcc also parses the config in 'file',
        writes the configuration into 'file'.h and includes
        this into every compiled file. 
        The configfile syntax is described within the file
        'minilib.conf', which is also a minimal configuration file
        for the hello world examples.

--ldscript-file 'file':
        Uses the supplied 'file' as linker script for ld.

--ldscript 'name': 
        Either includes the according ld.script.'name' file 
        from the directory ldscripts, if existent, or extracts the according
        script and writes it into minilib.ldscript.
        This script is passed to ld with the option -T


(c) 2019 Michael misc Myer - BSD 3-clause
 ('mini-gcc --license' shows the terms)

"
		exit
}


exec_gcc(){
		if [ $verbose == 1 ]; then
			echo_verbose $REAL_CC $CFLAGS$LDSCRIPT $@
		else
			echo $REAL_CC $@
		fi
		$REAL_CC $CFLAGS$LDSCRIPT $@
		return $?
}



checkconfig (){
	  #( (echo "#define macro(a1,a2) M a1" && echo "macro(12,13)" && cat $1 ) | gcc -include tmp2.h -E - )
		echo_verbose $1
		ERR=$((source $1 > $1.h) 2>&1)
		#sed "s/command/function/"
		echo_verbose var: $VAR
		if [ -n "$ERR" ]; 
		then
				echo -e "Error: \n $ERR"
				exit 1;
		fi
		echo_verbose ARCH: $MINI_ARCH
		echo_verbose OS: $MINI_OS
		#echo GCC-Options: $REAL_CC $CFLAGS
		CFLAGS="--include $1.h $CFLAGS"
}


ARGS=$@

if [ "$1" = "" ]
then
		usage
fi


opt=1
while [ "$1" != "" ] && [ $opt = 1 ]
do
		opt=0
		case $1 in
				--config )   
						shift
						config=$1
						checkconfig $config 
						shift
						opt=1
						;;
				--ldscript )
						shift
						if [ -e "$MLIBDIR/ldscripts/ld.script.$1" ]; then
								LDSCRIPT=",-T$MLIBDIR/ldscripts/ld.script.onlytext"
						else
								LDSCRIPT=",-Tminilib.ldscript"
								var="ld_script_$1"
								echo_verbose "Writing ld.script"
								echo "${!var}" > minilib.ldscript
						fi
						shift
						opt=1
						;;
				--ldscript-file )
						shift
						LDSCRIPT=",-T$1"
						shift
						opt=1
						;;

			 	-h | --help )   
						usage
						exit
						;;
				--license )
						echo "$LICENSE"
						echo
						exit
						;;

		esac
done

if [ "$1" == "" ]; then
		# Assume, everythibng is alright and there havent been parameters forgotten
		exit 0;
fi

#echo args: $@

exec_gcc $@
ret=$?
if [ $ret != 0 ]; then
		echo Error.
		echo Failed command:
		echo $REAL_CC $CFLAGS$LDSCRIPT $@
fi

exit $ret

fi
# end of if PARSE==1
PARSE=0


# ==================================================
# configfiles and embedded scripts start below. 
# They are generated and included by "make mini-gcc"
# ==================================================

# prefer the genconfig script, if present.
if [ -e $MLIBDIR/scripts/genconfig.sh ]; then
		echo_verbose Parsing genconfig.sh
		source $MLIBDIR/scripts/genconfig.sh
else
		echo "Parsing builtin config"	

# --- genconfig-start: TMPL ---
#
# Script, updated from "make header" / genheaders.pl
# The functions are callen from minilib.conf 
# (or another config file)
# The output of this script generates minilib.conf.h
# 

mini_start(){
		echo "#define mini_start $1"
}
mini_exit(){
		echo "#define mini_exit $1"
}

ARCH(){
		echo "#define MINILIB_ARCH $1"
		export MINI_ARCH=$1
}
OS(){
		echo "#define MINILIB_OS $1"
		export MINI_OS=$1
}
mini_buf(){
		echo "#define mini_buf $1"
}

mini_INCLUDESRC(){
		echo "#define INCLUDESRC"
}

INCLUDESRC(){
		echo "#define INCLUDESRC"
}

# Everything below will be silently overwritten,
# when make header ist invoked

# --- define_functions-start: generate --- #
mini_isprint(){ 
  echo "#define mini_isprint generate" 
}
mini_rewind(){ 
  echo "#define mini_rewind generate" 
}
mini_strncpy(){ 
  echo "#define mini_strncpy generate" 
}
mini_dup3(){ 
  echo "#define mini_dup3 generate" 
}
mini_creat(){ 
  echo "#define mini_creat generate" 
}
mini_unlink(){ 
  echo "#define mini_unlink generate" 
}
mini_rename(){ 
  echo "#define mini_rename generate" 
}
mini_rand(){ 
  echo "#define mini_rand generate" 
}
mini_tcsetattr(){ 
  echo "#define mini_tcsetattr generate" 
}
mini_fputc(){ 
  echo "#define mini_fputc generate" 
}
mini_isspace(){ 
  echo "#define mini_isspace generate" 
}
mini_fclose(){ 
  echo "#define mini_fclose generate" 
}
mini_tcgetattr(){ 
  echo "#define mini_tcgetattr generate" 
}
mini_ftell(){ 
  echo "#define mini_ftell generate" 
}
mini_strcpy(){ 
  echo "#define mini_strcpy generate" 
}
mini_snprintf(){ 
  echo "#define mini_snprintf generate" 
}
mini_dtodec(){ 
  echo "#define mini_dtodec generate" 
}
mini_itoHEX(){ 
  echo "#define mini_itoHEX generate" 
}
mini_strerror(){ 
  echo "#define mini_strerror generate" 
}
mini_fstat(){ 
  echo "#define mini_fstat generate" 
}
mini_lseek(){ 
  echo "#define mini_lseek generate" 
}
mini_strlen(){ 
  echo "#define mini_strlen generate" 
}
mini_dup2(){ 
  echo "#define mini_dup2 generate" 
}
mini_sprintf(){ 
  echo "#define mini_sprintf generate" 
}
mini_strcat(){ 
  echo "#define mini_strcat generate" 
}
mini_def(){ 
  echo "#define mini_def generate" 
}
mini_malloc(){ 
  echo "#define mini_malloc generate" 
}
mini_uitodec(){ 
  echo "#define mini_uitodec generate" 
}
mini_itohex(){ 
  echo "#define mini_itohex generate" 
}
mini_fsync(){ 
  echo "#define mini_fsync generate" 
}
mini_fwrite(){ 
  echo "#define mini_fwrite generate" 
}
mini_free(){ 
  echo "#define mini_free generate" 
}
mini_mprotect(){ 
  echo "#define mini_mprotect generate" 
}
mini_printf(){ 
  echo "#define mini_printf generate" 
}
mini_fseek(){ 
  echo "#define mini_fseek generate" 
}
mini_memcmp(){ 
  echo "#define mini_memcmp generate" 
}
mini_fsetpos(){ 
  echo "#define mini_fsetpos generate" 
}
mini_atoi(){ 
  echo "#define mini_atoi generate" 
}
mini_stat(){ 
  echo "#define mini_stat generate" 
}
mini_dprintf(){ 
  echo "#define mini_dprintf generate" 
}
mini_fgetpos(){ 
  echo "#define mini_fgetpos generate" 
}
mini_strcmp(){ 
  echo "#define mini_strcmp generate" 
}
mini_open(){ 
  echo "#define mini_open generate" 
}
mini__itobin(){ 
  echo "#define mini__itobin generate" 
}
mini_memfrob(){ 
  echo "#define mini_memfrob generate" 
}
mini__itohex(){ 
  echo "#define mini__itohex generate" 
}
mini_read(){ 
  echo "#define mini_read generate" 
}
mini_getpid(){ 
  echo "#define mini_getpid generate" 
}
mini_select(){ 
  echo "#define mini_select generate" 
}
mini_time(){ 
  echo "#define mini_time generate" 
}
mini_putchar(){ 
  echo "#define mini_putchar generate" 
}
mini_ioctl(){ 
  echo "#define mini_ioctl generate" 
}
mini_printl(){ 
  echo "#define mini_printl generate" 
}
mini_write(){ 
  echo "#define mini_write generate" 
}
mini_fileno(){ 
  echo "#define mini_fileno generate" 
}
mini_vsnprintf(){ 
  echo "#define mini_vsnprintf generate" 
}
mini_strncmp(){ 
  echo "#define mini_strncmp generate" 
}
mini_memset(){ 
  echo "#define mini_memset generate" 
}
mini_getcwd(){ 
  echo "#define mini_getcwd generate" 
}
mini_ftruncate(){ 
  echo "#define mini_ftruncate generate" 
}
mini_srand(){ 
  echo "#define mini_srand generate" 
}
mini_fprintf(){ 
  echo "#define mini_fprintf generate" 
}
mini_fopen(){ 
  echo "#define mini_fopen generate" 
}
mini_memcpy(){ 
  echo "#define mini_memcpy generate" 
}
mini_fread(){ 
  echo "#define mini_fread generate" 
}
mini_getenv(){ 
  echo "#define mini_getenv generate" 
}
mini_fputs(){ 
  echo "#define mini_fputs generate" 
}
mini_dup(){ 
  echo "#define mini_dup generate" 
}
mini_gettimeofday(){ 
  echo "#define mini_gettimeofday generate" 
}
mini_feof(){ 
  echo "#define mini_feof generate" 
}
mini_print(){ 
  echo "#define mini_print generate" 
}
mini_itodec(){ 
  echo "#define mini_itodec generate" 
}
mini_close(){ 
  echo "#define mini_close generate" 
}
mini_puts(){ 
  echo "#define mini_puts generate" 
}
# --- define_functions-end: generate --- #

# --- genconfig-end: TMPL ---

fi


# .. note: read -r -d '' << ENDVAR 
# ...
# --- content-ldscript-start: TMPL ---
ld_script='
SECTIONS {                                                                                                                                                    
		/DISCARD/ : { 
			*(.comment) 
			*(.eh_frame)
			*(.plt)
			*(.got.plt)
			*(.rel.plt)
		}
}
INSERT AFTER .text

'
ld_script_onlytext='
/*OUTPUT_FORMAT("elf32-i386")
OUTPUT_ARCH(i386)
*/

PHDRS {
	text PT_LOAD FILEHDR PHDRS ;
	/*bss PT_LOAD;*/
}

ENTRY(_start)

SECTIONS
{
		/* Read-only sections, merged into text segment: */
		/*__executable_start = SEGMENT_START("text-segment", 0x08048000); */
		start = _start;
		/*. = SEGMENT_START("text-segment", 0x08048000) + SIZEOF_HEADERS;*/
		. = 0x08048000 + SIZEOF_HEADERS;

		.text           :
		{
				*(.text.unlikely .text.*_unlikely)
						*(.text._start .text._start.*)
						*(.text.main .text.main.*)
						*(.text.cexit)
						*(.text._exit .text._exit.*)
						*(.text.__exit .text.__exit.*)
						*(.text.startup .text.startup.*)
						*(.text.hot .text.hot.*)
						*(.text .stub .text.* .gnu.linkonce.t.*)
						/* .gnu.warning sections are handled specially by elf32.em.  */
						*(.gnu.warning)

/*		 }
		.bss            :
		{ 
*/
/*misc: Seems to work without a bss segment ( for readonly data only) , so commented it out.
saves 15 bytes. ( needs -N for linking )*/


						*(.dynbss)
						*(.bss .bss.* .gnu.linkonce.b.*)
						*(COMMON)
						*(.rodata .rodata.* .gnu.linkonce.r.*)
						/* Align here to ensure that the .bss section occupies space up to
							 _end.  Align after .bss to ensure correct alignment even if the
							 .bss section disappears because there are no input sections.
							 FIXME: Why do we need it? When there is no .bss section, we dont
							 pad the .data section.  
misc: deleted : . = ALIGN(. != 0 ? 32 / 8 : 1);*/
		} :text

		/DISCARD/ : { 
			*(.note.GNU-stack) 
			*(.gnu_debuglink) 
			*(.gnu.lto_*) 
			*(.iplt*) 
			*(.igot*) 
			*(.rel*) 
			*(.comment)
			*(.eh_frame)
			*(.plt*)
			*(.got.plt*)
			*(.rel.*)
			*(.note*)
			*(*)
			}
}


'
ld_script_bloating='

/*OUTPUT_FORMAT("elf32-i386")
OUTPUT_ARCH(i386)*/

PHDRS {
	text PT_LOAD FILEHDR PHDRS ;
	/*bss PT_LOAD;*/
}

ENTRY(_start)

SECTIONS
{
		/* Read-only sections, merged into text segment: */
		/*__executable_start = SEGMENT_START("text-segment", 0x08048000); */
		start = _start;
		/*. = SEGMENT_START("text-segment", 0x08048000) + SIZEOF_HEADERS;*/
		. = 0x08048000 + SIZEOF_HEADERS;

		.text           :
		{
				*(.text.unlikely .text.*_unlikely)
						*(.text.exit .text.exit.*)
						*(.text.startup .text.startup.*)
						*(.text.hot .text.hot.*)
						*(.text .stub .text.* .gnu.linkonce.t.*)
						/* .gnu.warning sections are handled specially by elf32.em.  */
						*(.gnu.warning)

		 }
		.bss            :
		{ 
						*(.dynbss)
						*(.bss .bss.* .gnu.linkonce.b.*)
						*(.bss)
						*(.shstrtab)
						*(COMMON)
						*(.rodata .rodata.* .gnu.linkonce.r.*)
						/* Align here to ensure that the .bss section occupies space up to
							 _end.  Align after .bss to ensure correct alignment even if the
							 .bss section disappears because there are no input sections.
							 FIXME: Why do we need it? When there is no .bss section, we dont
							 pad the .data section.  */
						. = ALIGN(. != 0 ? 32 / 8 : 1);
						_bssend = . ;
						_brk = .;
		} :text

		/DISCARD/ : { 
			*(.note.GNU-stack) 
			*(.gnu_debuglink) 
			*(.gnu.lto_*) 
			*(.iplt*) 
			*(.igot*) 
			*(.rel*) 
			*(.comment)
			*(.eh_frame)
			*(.plt*)
			*(.got.plt*)
			*(.rel.*)
			*(.note*)
			}
}


'
ld_script_text_and_bss='
/*OUTPUT_FORMAT("elf32-i386")
OUTPUT_ARCH(i386)*/

PHDRS {
	text PT_LOAD FILEHDR PHDRS ;
	/*bss PT_LOAD;*/
}

ENTRY(_start)

SECTIONS
{
		/* Read-only sections, merged into text segment: */
		/*__executable_start = SEGMENT_START("text-segment", 0x08048000); */
		start = _start;
		/*. = SEGMENT_START("text-segment", 0x08048000) + SIZEOF_HEADERS;*/
		. = 0x08048000 + SIZEOF_HEADERS;

		.text           :
		{
				*(.text.unlikely .text.*_unlikely)
						*(.text.exit .text.exit.*)
						*(.text.startup .text.startup.*)
						*(.text.hot .text.hot.*)
						*(.text .stub .text.* .gnu.linkonce.t.*)
						/* .gnu.warning sections are handled specially by elf32.em.  */
						*(.gnu.warning)

		 }
		.bss            :
		{ 

						*(.dynbss)
						*(.bss .bss.* .gnu.linkonce.b.*)
						*(COMMON)
						*(.rodata .rodata.* .gnu.linkonce.r.*)
						/* Align here to ensure that the .bss section occupies space up to
							 _end.  Align after .bss to ensure correct alignment even if the
							 .bss section disappears because there are no input sections.
							 FIXME: Why do we need it? When there is no .bss section, we dont
							 pad the .data section.  
misc: deleted : . = ALIGN(. != 0 ? 32 / 8 : 1);*/
		} :text

		/DISCARD/ : { 
			*(.note.GNU-stack) 
			*(.gnu_debuglink) 
			*(.gnu.lto_*) 
			*(.iplt*) 
			*(.igot*) 
			*(.rel*) 
			*(.comment)
			*(.eh_frame)
			*(.plt*)
			*(.got.plt*)
			*(.rel.*)
			*(.note*)
			}
}


'
# Parsing
# --- content-ldscript-end: TMPL ---


LICENSE='
Copyright (c) 2012-2019, Michael (Misc) Myer 
(misc.myer@zoho.com, www.github.com/michael105)
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright notice,
   the file NOTICE, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
   the file NOTICE, this list of conditions and the following disclaimer in 
   the documentation and/or other materials provided with the distribution.
 * Neither the name of the minilib nor the
   names of its contributors may be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Michael Myer BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.'



# the "main loop". Continue at top after parsing the config switches
done


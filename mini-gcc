#!/bin/bash

REAL_CC=gcc
REAL_LD=ld

verbose=1

# grep mini-gcc path 
MLIBDIR=$(echo -e $0 | sed -E "s/(.*)\/mini-gcc/\1/")


echo_verbose(){
		>&2 echo $@
}



echo_verbose minilibdir: $MLIBDIR





# gcc options
# only linux x64 for now.

COMMONCFLAGS="-I. -fno-stack-protector -fdata-sections -fomit-frame-pointer -ffunction-sections \
		-Wno-unused-variable -Wno-unused-but-set-variable -Wno-unused-const-variable -Wall \
		-nodefaultlibs -static -nostdlib -DMLIB -fno-builtin -nostdinc\
		-I$MLIBDIR/compat -I$MLIBDIR/headers/common-links -I$MLIBDIR/headers/common -I$MLIBDIR/headers/linux_x64 -I$MLIBDIR -I./ -Os"

# needs os detection. but not important for now
CFLAGS="$COMMONCFLAGS -DLINUX -DX64"

# ld options 
CFLAGS="$CFLAGS -Wl,-n,-s,--gc-sections,-nostdlib"

# (default) linker script 
LDSCRIPT=",-T$MLIBDIR/ldscripts/ld.script"

#LDFLAGS=-nostdlib -nodefaultlibs --gc-sections -static -n -s $(LSCRIPT) -nostartfiles -O 2

PARSE=1

while [ 1 ]; do
if [ $PARSE == 0 ]; then 

usage(){
		echo
		echo mini-gcc is a wrapper to call gcc with the right compile options.
		echo mini-gcc also creates the files "minilib.conf.h" out of minilib.conf,
		echo when invoked with --config "minilib.conf"
		echo and creates minilib.ld.script, the linker script for ld.
		echo 
		echo when the --config "file" option is given \(must be the first argument for now, when supplied\)
		echo mini-gcc also includes the config "file" into every file compiled.
		echo 
		echo "mini-gcc passes all options it's invoked with on to gcc."
		echo When you need to change the invocation of gcc itself,
		echo please edit mini-gcc for now. 
		echo It\'s a shell script, 
		echo the invocation of gcc is defined via the variable REAL_CC
		echo at the top.
		echo 
		echo  "(c) 2019 Michael misc Myer - BSD 3-clause" 
		echo  "( 'mini-gcc --license' shows the license)"
		echo
		echo dbg
		echo "$ld_script_onlytext"
		exit
}


exec_gcc(){
		if [ $verbose == 1 ]; then
			echo_verbose $REAL_CC $CFLAGS$LDSCRIPT $@
		else
			echo $REAL_CC $@
		fi
		$REAL_CC $CFLAGS$LDSCRIPT $@
		return $?
}



checkconfig (){
	  #( (echo "#define macro(a1,a2) M a1" && echo "macro(12,13)" && cat $1 ) | gcc -include tmp2.h -E - )
		echo_verbose $1
		ERR=$((source $1 > $1.h) 2>&1)
		#sed "s/command/function/"
		echo_verbose var: $VAR
		if [ -n "$ERR" ]; 
		then
				echo -e "Error: \n $ERR"
				exit 1;
		fi
		echo_verbose ARCH: $MINI_ARCH
		echo_verbose OS: $MINI_OS
		#echo GCC-Options: $REAL_CC $CFLAGS
		CFLAGS="--include $1.h $CFLAGS"
}


ARGS=$@

if [ "$1" = "" ]
then
		usage
fi


opt=1
while [ "$1" != "" ] && [ $opt = 1 ]
do
		opt=0
		case $1 in
				--config )   
						shift
						config=$1
						checkconfig $config 
						shift
						opt=1
						;;
				--only-text )
						LDSCRIPT=,-T$MLIBDIR/ldscripts/ld.script.onlytext
						shift
						opt=1
						;;
				--ld-script )
						shift
						LDSCRIPT=$1
						shift
						opt=1
						;;

			 	-h | --help )   
						usage
						exit
						;;
				--license )
						echo "$LICENSE"
						echo
						exit
						;;

		esac
done

#echo args: $@

exec_gcc $@
ret=$?
if [ $ret != 0 ]; then
		echo Error.
		echo Failed command:
		echo $REAL_CC $CFLAGS $@
fi

exit $ret

# Parse first the config switches. (if parse..)
else

# prefer the genconfig script, if present.
if [ -e $MLIBDIR/scripts/genconfig.sh ]; then
		echo_verbose Parsing genconfig.sh
		source $MLIBDIR/scripts/genconfig.sh
else
		echo "Parsing builtin config"	

# --- tmpl-config-start: TMPL ---
# genconfig.sh goes here
# --- tmpl-config-end: TMPL ---

fi

# if parse ..
PARSE=0
fi
# .. note: read -r -d '' << ENDVAR 
# ...
# --- content-ldscript-start: TMPL ---
ld_script='
SECTIONS {                                                                                                                                                    
		/DISCARD/ : { 
			*(.comment) 
			*(.eh_frame)
			*(.plt)
			*(.got.plt)
			*(.rel.plt)
		}
}
INSERT AFTER .text

'
ld_script_onlytext='
/*OUTPUT_FORMAT("elf32-i386")
OUTPUT_ARCH(i386)
*/

PHDRS {
	text PT_LOAD FILEHDR PHDRS ;
	/*bss PT_LOAD;*/
}

ENTRY(_start)

SECTIONS
{
		/* Read-only sections, merged into text segment: */
		/*__executable_start = SEGMENT_START("text-segment", 0x08048000); */
		start = _start;
		/*. = SEGMENT_START("text-segment", 0x08048000) + SIZEOF_HEADERS;*/
		. = 0x08048000 + SIZEOF_HEADERS;

		.text           :
		{
				*(.text.unlikely .text.*_unlikely)
						*(.text._start .text._start.*)
						*(.text.main .text.main.*)
						*(.text.cexit)
						*(.text._exit .text._exit.*)
						*(.text.__exit .text.__exit.*)
						*(.text.startup .text.startup.*)
						*(.text.hot .text.hot.*)
						*(.text .stub .text.* .gnu.linkonce.t.*)
						/* .gnu.warning sections are handled specially by elf32.em.  */
						*(.gnu.warning)

/*		 }
		.bss            :
		{ 
*/
/*misc: Seems to work without a bss segment ( for readonly data only) , so commented it out.
saves 15 bytes. ( needs -N for linking )*/


						*(.dynbss)
						*(.bss .bss.* .gnu.linkonce.b.*)
						*(COMMON)
						*(.rodata .rodata.* .gnu.linkonce.r.*)
						/* Align here to ensure that the .bss section occupies space up to
							 _end.  Align after .bss to ensure correct alignment even if the
							 .bss section disappears because there are no input sections.
							 FIXME: Why do we need it? When there is no .bss section, we dont
							 pad the .data section.  
misc: deleted : . = ALIGN(. != 0 ? 32 / 8 : 1);*/
		} :text

		/DISCARD/ : { 
			*(.note.GNU-stack) 
			*(.gnu_debuglink) 
			*(.gnu.lto_*) 
			*(.iplt*) 
			*(.igot*) 
			*(.rel*) 
			*(.comment)
			*(.eh_frame)
			*(.plt*)
			*(.got.plt*)
			*(.rel.*)
			*(.note*)
			*(*)
			}
}


'
ld_script_bloating='

/*OUTPUT_FORMAT("elf32-i386")
OUTPUT_ARCH(i386)*/

PHDRS {
	text PT_LOAD FILEHDR PHDRS ;
	/*bss PT_LOAD;*/
}

ENTRY(_start)

SECTIONS
{
		/* Read-only sections, merged into text segment: */
		/*__executable_start = SEGMENT_START("text-segment", 0x08048000); */
		start = _start;
		/*. = SEGMENT_START("text-segment", 0x08048000) + SIZEOF_HEADERS;*/
		. = 0x08048000 + SIZEOF_HEADERS;

		.text           :
		{
				*(.text.unlikely .text.*_unlikely)
						*(.text.exit .text.exit.*)
						*(.text.startup .text.startup.*)
						*(.text.hot .text.hot.*)
						*(.text .stub .text.* .gnu.linkonce.t.*)
						/* .gnu.warning sections are handled specially by elf32.em.  */
						*(.gnu.warning)

		 }
		.bss            :
		{ 
						*(.dynbss)
						*(.bss .bss.* .gnu.linkonce.b.*)
						*(.bss)
						*(.shstrtab)
						*(COMMON)
						*(.rodata .rodata.* .gnu.linkonce.r.*)
						/* Align here to ensure that the .bss section occupies space up to
							 _end.  Align after .bss to ensure correct alignment even if the
							 .bss section disappears because there are no input sections.
							 FIXME: Why do we need it? When there is no .bss section, we dont
							 pad the .data section.  */
						. = ALIGN(. != 0 ? 32 / 8 : 1);
						_bssend = . ;
						_brk = .;
		} :text

		/DISCARD/ : { 
			*(.note.GNU-stack) 
			*(.gnu_debuglink) 
			*(.gnu.lto_*) 
			*(.iplt*) 
			*(.igot*) 
			*(.rel*) 
			*(.comment)
			*(.eh_frame)
			*(.plt*)
			*(.got.plt*)
			*(.rel.*)
			*(.note*)
			}
}


'
ld_script_text_and_bss='
/*OUTPUT_FORMAT("elf32-i386")
OUTPUT_ARCH(i386)*/

PHDRS {
	text PT_LOAD FILEHDR PHDRS ;
	/*bss PT_LOAD;*/
}

ENTRY(_start)

SECTIONS
{
		/* Read-only sections, merged into text segment: */
		/*__executable_start = SEGMENT_START("text-segment", 0x08048000); */
		start = _start;
		/*. = SEGMENT_START("text-segment", 0x08048000) + SIZEOF_HEADERS;*/
		. = 0x08048000 + SIZEOF_HEADERS;

		.text           :
		{
				*(.text.unlikely .text.*_unlikely)
						*(.text.exit .text.exit.*)
						*(.text.startup .text.startup.*)
						*(.text.hot .text.hot.*)
						*(.text .stub .text.* .gnu.linkonce.t.*)
						/* .gnu.warning sections are handled specially by elf32.em.  */
						*(.gnu.warning)

		 }
		.bss            :
		{ 

						*(.dynbss)
						*(.bss .bss.* .gnu.linkonce.b.*)
						*(COMMON)
						*(.rodata .rodata.* .gnu.linkonce.r.*)
						/* Align here to ensure that the .bss section occupies space up to
							 _end.  Align after .bss to ensure correct alignment even if the
							 .bss section disappears because there are no input sections.
							 FIXME: Why do we need it? When there is no .bss section, we dont
							 pad the .data section.  
misc: deleted : . = ALIGN(. != 0 ? 32 / 8 : 1);*/
		} :text

		/DISCARD/ : { 
			*(.note.GNU-stack) 
			*(.gnu_debuglink) 
			*(.gnu.lto_*) 
			*(.iplt*) 
			*(.igot*) 
			*(.rel*) 
			*(.comment)
			*(.eh_frame)
			*(.plt*)
			*(.got.plt*)
			*(.rel.*)
			*(.note*)
			}
}


'
# Parsing
# --- content-ldscript-end: TMPL ---


LICENSE='
Copyright (c) 2012-2019, Michael (Misc) Myer 
(misc.myer@zoho.com, www.github.com/michael105)
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright notice,
   the file NOTICE, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
   the file NOTICE, this list of conditions and the following disclaimer in 
   the documentation and/or other materials provided with the distribution.
 * Neither the name of the minilib nor the
   names of its contributors may be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Michael Myer BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.'



# the "main loop". Continue at top after parsing the config switches
done


<HTML>

<HEAD>
<TITLE>
The ANSI C Standard Library
</TITLE>
</HEAD>

<BODY BGCOLOR="#ffffff" VLINK="#ff0000">

<h2>The ANSI C Standard Library - Contents</h2>

<UL>
<LI><A HREF="#assert"><CODE>&lt;assert.h&gt;</CODE> : Diagnostics</A>
<LI><A HREF="#ctype"><CODE>&lt;ctype.h&gt;</CODE> : Character Class Tests</A>
<LI><A HREF="#errno"><CODE>&lt;errno.h&gt;</CODE> : Error Number</A>
<LI><A HREF="#float"><CODE>&lt;float.h&gt;</CODE> : Implementation-defined Floating-Point Limits</A>
<LI><A HREF="#limits"><CODE>&lt;limits.h&gt;</CODE> : Implementation-defined Limits</A>
<LI><CODE>&lt;locale.h&gt;</CODE>
<LI><A HREF="#math"><CODE>&lt;math.h&gt;</CODE> : Mathematical Functions</A>
<LI><A HREF="#setjmp"><CODE>&lt;setjmp.h&gt;</CODE> : Non-local Jumps</A>
<LI><A HREF="#signal"><CODE>&lt;signal.h&gt;</CODE> : Signals</A>
<LI><A HREF="#stdarg"><CODE>&lt;stdarg.h&gt;</CODE> : Variable Argument Lists</A>
<LI><CODE>&lt;stddef.h&gt;</CODE>
<LI><A HREF="#stdio"><CODE>&lt;stdio.h&gt;</CODE> : Input and Output</A>
<LI><A HREF="#stdlib"><CODE>&lt;stdlib.h&gt;</CODE> : Utility functions</A>
<LI><A HREF="#string"><CODE>&lt;string.h&gt;</CODE> : String functions</A>
<LI><A HREF="#time"><CODE>&lt;time.h&gt;</CODE> : Time and Date functions</A>
</UL>


<hr>
<H3><A NAME="assert">&lt;assert.h&gt;</A></H3>
<DL>
<DT><CODE>void assert(int <VAR>expression</VAR>);</CODE>
<DD><EM>Macro</EM> used to add diagnostics.
If <VAR>expression</VAR> is false, message printed on
<CODE><A HREF="#stderr">stderr</A></CODE>
and abort called to terminate execution.
Source file and line number in message come from preprocessor macros
<CODE>__FILE__</CODE>
and
<CODE>__LINE__</CODE>.
If <CODE>NDEBUG</CODE> is defined where <CODE>&lt;assert.h&gt;</CODE>
is included, <CODE>assert</CODE> macro is ignored.
</DL>


<hr>
<H3><A NAME="ctype">&lt;ctype.h&gt;</A></H3>
<DL>
<DT><CODE>int isalnum(int <VAR>c</VAR>);</CODE>
<DD><CODE>isalpha(<VAR>c</VAR>)</CODE> or <CODE>isdigit(<VAR>c</VAR>)</CODE>
<DT><CODE>int isalpha(int <VAR>c</VAR>);</CODE>
<DD><CODE>isupper(<VAR>c</VAR>)</CODE> or <CODE>islower(<VAR>c</VAR>)</CODE>
<DT><CODE>int iscntrl(int <VAR>c</VAR>);</CODE>
<DD>is control character
<DT><CODE>int isdigit(int <VAR>c</VAR>);</CODE>
<DD>is decimal digit
<DT><CODE>int isgraph(int <VAR>c</VAR>);</CODE>
<DD>is printing character other than space
<DT><CODE>int islower(int <VAR>c</VAR>);</CODE>
<DD>is lower-case letter
<DT><CODE>int isprint(int <VAR>c</VAR>);</CODE>
<DD>is printing character (including space)
<DT><CODE>int ispunct(int <VAR>c</VAR>);</CODE>
<DD>is printing character other than space, letter, digit
<DT><CODE>int isspace(int <VAR>c</VAR>);</CODE>
<DD>is space, formfeed, newline, carriage return, tab, vertical tab
<DT><CODE>int isupper(int <VAR>c</VAR>);</CODE>
<DD>is upper-case letter
<DT><CODE>int isxdigit(int <VAR>c</VAR>);</CODE>
<DD>is hexadecimal digit
<DT><CODE>int tolower(int <VAR>c</VAR>);</CODE>
<DD>return lower-case equivalent
<DT><CODE>int toupper(int <VAR>c</VAR>);</CODE>
<DD>return upper-case equivalent
</DL>
Notes:
<UL>
<LI>In ASCII (7-bit), printing characters are
<CODE>0x20 (' ')</CODE>
to
<CODE>0x7E ('~')</CODE>;
control characters are
<CODE>0x00 (NUL)</CODE>
to
<CODE>0x1F (US)</CODE>
and
<CODE>0x7F (DEL)</CODE>
</UL>


<hr>
<H3><A NAME="errno">&lt;errno.h&gt;</A></H3>
<DL>
<DT><CODE><A NAME="verrno">extern int errno;</A></CODE>
<DD>An error code value set by some functions.
It is generally the responsibility of the programmer to
clear <CODE>errno</CODE> before calling such a function.
</DL>


<hr>
<H3><A NAME="float">&lt;float.h&gt;</A></H3>
<DL>
<DT><CODE>FLT_RADIX</CODE>
<DT><CODE>FLT_ROUNDS</CODE>
<DT><CODE>FLT_DIG</CODE>
<DT><CODE>FLT_EPSILON</CODE>
<DD>smallest number <VAR>x</VAR> such that <CODE>1.0 + <VAR>x</VAR> != 1.0</CODE>
<DT><CODE>FLT_MANT_DIG</CODE>
<DT><CODE>FLT_MAX</CODE>
<DD>maximum floating-point number
<DT><CODE>FLT_MAX_EXP</CODE>
<DT><CODE>FLT_MIN</CODE>
<DD>minimum normalised floating-point number
<DT><CODE>FLT_MIN_EXP</CODE>
<DT><CODE>DBL_DIG</CODE>
<DT><CODE>DBL_EPSILON</CODE>
<DT><CODE>DBL_MANT_DIG</CODE>
<DT><CODE>DBL_MAX</CODE>
<DD>maximum <CODE>double</CODE> floating-point number
<DT><CODE>DBL_MAX_EXP</CODE>
<DT><CODE>DBL_MIN</CODE>
<DD>minimum normalised <CODE>double</CODE> floating-point number
<DT><CODE>DBL_MIN_EXP</CODE>
</DL>


<hr>
<H3><A NAME="limits">&lt;limits.h&gt;</A></H3>
<DL>
<DT><CODE>CHAR_BIT</CODE>
<DD>number of bits in a <CODE>char</CODE>
<DT><CODE>CHAR_MAX</CODE>
<DD>maximum value of <CODE>char</CODE>
<DT><CODE>CHAR_MIN</CODE>
<DD>minimum value of <CODE>char</CODE>
<DT><CODE>INT_MAX</CODE>
<DD>maximum value of <CODE>int</CODE>
<DT><CODE>INT_MIN</CODE>
<DD>minimum value of <CODE>int</CODE>
<DT><CODE>LONG_MAX</CODE>
<DD>maximum value of <CODE>long</CODE>
<DT><CODE>LONG_MIN</CODE>
<DD>minimum value of <CODE>long</CODE>
<DT><CODE>SCHAR_MAX</CODE>
<DD>maximum value of <CODE>signed char</CODE>
<DT><CODE>SCHAR_MIN</CODE>
<DD>minimum value of <CODE>signed char</CODE>
<DT><CODE>SHRT_MAX</CODE>
<DD>maximum value of <CODE>short</CODE>
<DT><CODE>SHRT_MIN</CODE>
<DD>minimum value of <CODE>short</CODE>
<DT><CODE>UCHAR_MAX</CODE>
<DD>maximum value of <CODE>unsigned char</CODE>
<DT><CODE>UCHAR_MIN</CODE>
<DD>minimum value of <CODE>unsigned char</CODE>
<DT><CODE>UINT_MAX</CODE>
<DD>maximum value of <CODE>unsigned int</CODE>
<DT><CODE>ULONG_MAX</CODE>
<DD>maximum value of <CODE>unsigned long</CODE>
<DT><CODE>USHRT_MAX</CODE>
<DD>maximum value of <CODE>unsigned short</CODE>
</DL>


<hr>
<H3><A NAME="math">&lt;math.h&gt;</A></H3>
<DL>
<DT><CODE>double sin(double <VAR>x</VAR>);</CODE>
<DT><CODE>double cos(double <VAR>x</VAR>);</CODE>
<DT><CODE>double tan(double <VAR>x</VAR>);</CODE>
<DT><CODE>double asin(double <VAR>x</VAR>);</CODE>
<DT><CODE>double acos(double <VAR>x</VAR>);</CODE>
<DT><CODE>double atan(double <VAR>x</VAR>);</CODE>
<DT><CODE>double atan2(double <VAR>y</VAR>, double <VAR>x</VAR>);</CODE>
<DT><CODE>double sinh(double <VAR>x</VAR>);</CODE>
<DT><CODE>double cosh(double <VAR>x</VAR>);</CODE>
<DT><CODE>double tanh(double <VAR>x</VAR>);</CODE>
<DT><CODE>double exp(double <VAR>x</VAR>);</CODE>
<DT><CODE>double log(double <VAR>x</VAR>);</CODE>
<DT><CODE>double log10(double <VAR>x</VAR>);</CODE>
<DT><CODE>double pow(double <VAR>x</VAR>, double <VAR>y</VAR>);</CODE>
<DD><VAR>x</VAR> raised to power <VAR>y</VAR>
<DT><CODE>double sqrt(double <VAR>x</VAR>);</CODE>
<DT><CODE>double ceil(double <VAR>x</VAR>);</CODE>
<DD>smallest integer not less than <VAR>x</VAR>
<DT><CODE>double floor(double <VAR>x</VAR>);</CODE>
<DD>largest integer not greater than <VAR>x</VAR>
<DT><CODE>double fabs(double <VAR>x</VAR>);</CODE>
<DT><CODE>double ldexp(double <VAR>x</VAR>, int <VAR>n</VAR>);</CODE>
<DT><CODE>double frexp(double <VAR>x</VAR>, int* <VAR>exp</VAR>);</CODE>
<DT><CODE>double modf(double <VAR>x</VAR>, double* <VAR>ip</VAR>);</CODE>
<DT><CODE>double fmod(double <VAR>x</VAR>, double <VAR>y</VAR>);</CODE>
</DL>


<hr>
<H3><A NAME="setjmp">&lt;setjmp.h&gt;</A></H3>
<DL>
<DT><CODE>int setjmp(jmp_buf <VAR>env</VAR>);</CODE>
<DD>Save state information in <VAR>env</VAR>.
Zero returned from direct call;
non-zero from subsequent call of <CODE>longjmp</CODE>.
<DT><CODE>void longjmp(jmp_buf <VAR>env</VAR>, int <VAR>val</VAR>);</CODE>
<DD>Restore state saved by most recent call to <CODE>setjmp</CODE>
using information saved in <VAR>env</VAR>.
Execution resumes as if <CODE>setjmp</CODE>
just executed and returned non-zero value <VAR>val</VAR>.
</DL>


<hr>
<H3><A NAME="signal">&lt;signal.h&gt;</A></H3>
Handling exceptional conditions.
<DL>
<DT><CODE><A NAME="sigabrt">SIGABRT</A></CODE>
<DD>abnormal termination
<DT><CODE>SIGFPE</CODE>
<DD>arithmetic error
<DT><CODE>SIGILL</CODE>
<DD>illegal function image
<DT><CODE>SIGINT</CODE>
<DD>interactive attention
<DT><CODE>SIGSEGV</CODE>
<DD>illegal storage access
<DT><CODE>SIGTERM</CODE>
<DD>termination request sent to program
<DT><CODE>void (*signal(int <VAR>sig</VAR>, void (*<VAR>handler</VAR>)(int)))(int);</CODE>
<DD>Install handler for subsequent signal <VAR>sig</VAR>.
If <VAR>handler</VAR> is <CODE>SIG_DFL</CODE>, implementation-defined default
behaviour is used;
if <VAR>handler</VAR> is <CODE>SIG_IGN</CODE>, signal is ignored;
otherwise function pointed to by <VAR>handler</VAR> is called
with argument <VAR>sig</VAR>.
<CODE>signal</CODE> returns the previous handler or
<CODE>SIG_ERR</CODE> on error.
When signal <VAR>sig</VAR> subsequently occurs, the signal is
<STRONG>restored to its default behaviour</STRONG>
and the handler is called.
If the handler returns, execution resumes where signal occurred.
Initial state of signals is implementation-defined.
<DT><CODE><A NAME="raise">int raise(int <VAR>sig</VAR>);</A></CODE>
<DD>Send signal <VAR>sig</VAR> to the program.
Non-zero returned if unsuccessful.
</DL>


<hr>
<H3><A NAME="stdarg">&lt;stdarg.h&gt;</A></H3>
Facilities for stepping through a list of function arguments
of unknown number and type.
<DL>
<DT><CODE><A NAME="vastart">void va_start(va_list <VAR>ap</VAR>, <VAR>lastarg</VAR>);</A></CODE>
<DD>Initialisation macro to be called once before any
unnamed argument is accessed.
<VAR>ap</VAR> must be declared as a local variable, and
<VAR>lastarg</VAR> is the last named parameter of the function.
<DT><CODE><A NAME="vaarg"><VAR>type</VAR> va_arg(va_list <VAR>ap</VAR>, <VAR>type</VAR>);</A></CODE>
<DD>Produce a value of the type (<VAR>type</VAR>) and value
of the next unnamed argument.
Modifies <VAR>ap</VAR>.
<DT><CODE>void va_end(va_list <VAR>ap</VAR>);</CODE>
<DD>Must be called once after arguments processed and before function exit.
</DL>


<hr>
<H3><A NAME="stdio">&lt;stdio.h&gt;</A></H3>
<DL>
<DT><CODE>FILE</CODE>
<DD>Type which records information necessary to control a stream.
<DT><CODE><A NAME="stdin">stdin</A></CODE>
<DD>Standard input stream.
Automatically opened when a program begins execution.
<DT><CODE><A NAME="stdout">stdout</A></CODE>
<DD>Standard output stream.
Automatically opened when a program begins execution.
<DT><CODE><A NAME="stderr">stderr</A></CODE>
<DD>Standard error stream.
Automatically opened when a program begins execution.
<DT>FILENAME_MAX
<DD>Maximum permissible length of a file name
<DT>FOPEN_MAX
<DD>Maximum number of files which may be open simultaneously.
<DT>TMP_MAX
<DD>Maximum number of temporary files during program execution.
<DT><CODE>FILE* fopen(const char* <VAR>filename</VAR>, const char* <VAR>mode</VAR>);</CODE>
<DD>Opens file <VAR>filename</VAR> and returns a stream,
or <CODE>NULL</CODE> on failure.
<VAR>mode</VAR> may be (combinations of):
<DL>
<DT><CODE>"r"</CODE>
<DD>text reading
<DT><CODE>"w"</CODE>
<DD>text writing; discard previous content
<DT><CODE>"a"</CODE>
<DD>text append; writing at end
<DT><CODE>"r+"</CODE>
<DD>text update
<DT><CODE>"w+"</CODE>
<DD>text update; discard previous content
<DT><CODE>"a+"</CODE>
<DD>text append; writing at end
</DL>
<DT><CODE>FILE* freopen(const char* <VAR>filename</VAR>, const char* <VAR>mode</VAR>, FILE* <VAR>stream</VAR>);</CODE>
<DD>Opens file <VAR>filename</VAR> with the specified mode
and associates with it the specified stream.
Returns <VAR>stream</VAR> or <CODE>NULL</CODE> on error.
Usually used to change files associated with
<CODE><A HREF="#stdin">stdin</A></CODE>,
<CODE><A HREF="#stdout">stdout</A></CODE>,
<CODE><A HREF="#stderr">stderr</A></CODE>.
<DT><CODE>int fflush(FILE* <VAR>stream</VAR>);</CODE>
<DD>Flushes stream <VAR>stream</VAR>.
Effect undefined for input stream.
Returns <CODE>EOF</CODE> for write error, zero otherwise.
<CODE>fflush(NULL)</CODE> flushes all output streams.
<DT><CODE>int fclose(FILE* <VAR>stream</VAR>);</CODE>
<DD>Closes stream <VAR>stream</VAR> (after flushing, if output stream).
Returns <CODE>EOF</CODE> on error, zero otherwise.
<DT><CODE>int remove(const char* <VAR>filename</VAR>);</CODE>
<DD>Removes file <VAR>filename</VAR>.
Returns non-zero on failure.
<DT><CODE>int rename(const char* <VAR>oldname</VAR>, const char* <VAR>newname</VAR>);</CODE>
<DD>Changes name of file <VAR>oldname</VAR> to <VAR>newname</VAR>.
Returns non-zero on failure.
<DT><CODE>FILE* tmpfile();</CODE>
<DD>Creates temporary file (mode <CODE>"wb+"</CODE>) which will be removed
when closed or on normal program termination.
Returns stream or <CODE>NULL</CODE> on failure.
<DT><CODE>char* tmpname(char <VAR>s</VAR>[L_tmpnam]);</CODE>
<DD>Assigns to <VAR>s</VAR> and returns unique name for temporary file.
<DT><CODE>int setvbuf(FILE* <VAR>stream</VAR>, char* <VAR>buf</VAR>, int <VAR>mode</VAR>, size_t <VAR>size</VAR>);</CODE>
<DD>Controls buffering for stream <VAR>stream</VAR>.
<DT><CODE>void setbuf(FILE* <VAR>stream</VAR>, char* <VAR>buf</VAR>);</CODE>
<DD>Controls buffering for stream <VAR>stream</VAR>.
<DT><CODE><A NAME="fprintf">int fprintf(FILE* <VAR>stream</VAR>, const char* <VAR>format</VAR>, ...);</A></CODE>
<DD>Converts (with format <VAR>format</VAR>) and writes output
to stream <VAR>stream</VAR>.
Number of characters written [negative on error] is returned.
Between % and format conversion character:
<UL>
<LI>Flags:
<DL>
<DT><CODE>-</CODE>
<DD>left adjust
<DT><CODE>+</CODE>
<DD>always sign
<DT><EM>space</EM>
<DD>space if no sign
<DT><CODE>0</CODE>
<DD>zero pad
<DT><CODE>#</CODE>
<DD>Alternate form: for conversion character <CODE>o</CODE>, first digit will be zero,
for [<CODE>xX</CODE>], prefix <CODE>0x</CODE> or <CODE>0X</CODE> to non-zero,
for [<CODE>eEfgG</CODE>], always decimal point,
for [<CODE>gG</CODE>] trailing zeros not removed.
</DL>
<LI>Width:
<LI>Period:
<LI>Precision: for conversion character <CODE>s</CODE>,
maximum characters to be printed from the string,
for [<CODE>eEf</CODE>], digits after decimal point,
for [<CODE>gG</CODE>], significant digits,
for an integer, minimum number of digits to be printed.
<LI>Length modifier:
<DL>
<DT>h
<DD>short or unsigned short
<DT>l
<DD>long or unsigned long
<DT>L
<DD>long double
</DL>
</UL>
Conversions:
<DL>
<DT><CODE>d, i</CODE>
<DD>int; signed decimal notation
<DT><CODE>o</CODE>
<DD>int; unsigned octal notation
<DT><CODE>x,X</CODE>
<DD>int; unsigned hexadecimal notation
<DT><CODE>u</CODE>
<DD>int; unsigned decimal notation
<DT><CODE>c</CODE>
<DD>int; single character
<DT><CODE>s</CODE>
<DD>char*;
<DT><CODE>f</CODE>
<DD>double; [-]mmm.ddd
<DT><CODE>e,E</CODE>
<DD>double; [-]m.dddddde(+|-)xx
<DT><CODE>g,G</CODE>
<DD>double
<DT><CODE>p</CODE>
<DD>void*; print as pointer
<DT><CODE>n</CODE>
<DD>int*; number of chars written into arg
<DT><CODE>%</CODE>
<DD>print %
</DL>
<DT><CODE><A NAME="printf">int printf(const char* <VAR>format</VAR>, ...);</A></CODE>
<DD><CODE>printf(f, ...)</CODE> is equivalent to
<CODE><A HREF="#fprintf">fprintf</A>(<A HREF="#stdout">stdout</A>, f, ...)</CODE>
<DT><CODE><A NAME="sprintf">int sprintf(char* <VAR>s</VAR>, const char* <VAR>format</VAR>, ...);</A></CODE>
<DD>Like <A HREF="#fprintf">fprintf</A>,
but output written into string <VAR>s</VAR>,
<STRONG>which must be large enough to hold the output</STRONG>,
rather than to a stream.
Output is <CODE>NUL</CODE>-terminated.
Return length does not include the <CODE>NUL</CODE>.
<DT><CODE>int vfprintf(FILE* <VAR>stream</VAR>, const char* <VAR>format</VAR>, va_list <VAR>arg</VAR>);</CODE>
<DD>Equivalent to <A HREF="#fprintf">fprintf</A> except that the variable
argument list is replaced by <VAR>arg</VAR>,
which must have been initialised by the <CODE>va_start</CODE> macro
and may have been used in calls to <CODE>va_arg</CODE>.
See <A HREF="#stdarg"><stdarg.h></A>
<DT><CODE>int vprintf(const char* <VAR>format</VAR>, va_list <VAR>arg</VAR>);</CODE>
<DD>Equivalent to <A HREF="#printf">printf</A> except that the variable
argument list is replaced by <VAR>arg</VAR>,
which must have been initialised by the <CODE>va_start</CODE> macro
and may have been used in calls to <CODE>va_arg</CODE>.
See <A HREF="#stdarg"><stdarg.h></A>
<DT><CODE>int vsprintf(char* <VAR>s</VAR>, const char* <VAR>format</VAR>, va_list <VAR>arg</VAR>);</CODE>
<DD>Equivalent to <A HREF="#sprintf">sprintf</A> except that the variable
argument list is replaced by <VAR>arg</VAR>,
which must have been initialised by the <CODE><A HREF="#vastart">va_start</A></CODE> macro
and may have been used in calls to <CODE><A HREF="#vaarg">va_arg</A></CODE>.
See <A HREF="#stdarg"><stdarg.h></A>
<DT><CODE><A NAME="fscanf">int fscanf(FILE* <VAR>stream</VAR>, const char* <VAR>format</VAR>, ...);</A></CODE>
<DD>Performs formatted input conversion, reading from
stream <VAR>stream</VAR> according to format <VAR>format</VAR>.
The function returns when <VAR>format</VAR> is fully processed.
Returns <CODE>EOF</CODE> if end-of-file or error occurs before any conversion;
otherwise, the number of items converted and assigned.
Each of the arguments following <VAR>format</VAR>
<STRONG>must be a pointer</STRONG>.
Format string may contain
<UL>
<LI><EM>Blanks</EM>, <EM>Tabs</EM> : ignored
<LI><EM>ordinary characters</EM> : expected to match next non-white-space
<LI><CODE>%</CODE> : Conversion specification, consisting of <CODE>%</CODE>,
optional assignment suppression character <CODE>*</CODE>,
optional number indicating maximum field width,
optional [<CODE>hlL</CODE>] indicating width of target,
conversion character.
</UL>
Conversion characters:
<DL>
<DT><CODE>d</CODE>
<DD>decimal integer; <CODE>int*</CODE> parameter required
<DT><CODE>i</CODE>
<DD>integer; <CODE>int*</CODE> parameter required; decimal, octal or hex
<DT><CODE>o</CODE>
<DD>octal integer; <CODE>int*</CODE> parameter required
<DT><CODE>u</CODE>
<DD>unsigned decimal integer; <CODE>unsigned int*</CODE> parameter required
<DT><CODE>x</CODE>
<DD>hexadecimal integer; <CODE>int*</CODE> parameter required
<DT><CODE>c</CODE>
<DD>characters; <CODE>char*</CODE> parameter required; up to width;
no <CODE>'\0'</CODE> added; no skip
<DT><CODE>s</CODE>
<DD>string of non-white-space; <CODE>char*</CODE> parameter required;
<CODE>'\0'</CODE> added
<DT><CODE>e,f,g</CODE>
<DD>floating-point number; <CODE>float*</CODE> parameter required
<DT><CODE>p</CODE>
<DD>pointer value; <CODE>void*</CODE> parameter required
<DT><CODE>n</CODE>
<DD>chars read so far; <CODE>int*</CODE> parameter required
<DT>[...]
<DD>longest non-empty string from set; <CODE>char*</CODE> parameter required; '\0'
<DT>[<CODE>^</CODE>...]
<DD>longest non-empty string not from set; <CODE>char*</CODE> parameter required; '\0'
<DT><CODE>%</CODE>
<DD>literal <CODE>%</CODE>; no assignment
</DL>
<DT><CODE>int scanf(const char* <VAR>format</VAR>, ...);</CODE>
<DD><CODE>scanf(f, ...)</CODE> is equivalent to
<CODE><A HREF="#fscanf">fscanf</A>(<A HREF="#stdin">stdin</A>, f, ...)</CODE>
<DT><CODE>int sscanf(char* <VAR>s</VAR>, const char* <VAR>format</VAR>, ...);</CODE>
<DD>Like <A HREF="#fscanf">fscanf</A>,
but input read from string <VAR>s</VAR>.
<DT><CODE><A NAME="fgetc">int fgetc(FILE* <VAR>stream</VAR>);</A></CODE>
<DD>Returns next character from stream <VAR>stream</VAR>
as an <CODE>unsigned char</CODE>, or <CODE>EOF</CODE> on end-of-file or error.
<DT><CODE>char* fgets(char* <VAR>s</VAR>, int <VAR>n</VAR>, FILE* <VAR>stream</VAR>);</CODE>
<DD>Reads at most the next <VAR>n</VAR>-1 characters from stream
<VAR>stream</VAR> into <VAR>s</VAR>, stopping if a newline is
encountered (after copying the newline to <VAR>s</VAR>).
<VAR>s</VAR> is <CODE>NUL</CODE>-terminated.
Returs <VAR>s</VAR>, or <CODE>EOF</CODE> on end-of-file or error. 
<DT><CODE><A NAME="fputc">int fputc(int <VAR>c</VAR>, FILE* <VAR>stream</VAR>);</A></CODE>
<DD>Writes <VAR>c</VAR>, converted to <CODE>unsigned char</CODE>,
to stream <VAR>stream</VAR>.
Returns the character written, or <CODE>EOF</CODE> on error.
<DT><CODE>char* fputs(const char* <VAR>s</VAR>, FILE* <VAR>stream</VAR>);</CODE>
<DD>Writes <VAR>s</VAR>, which need not contain <CODE>'\n'</CODE>
on stream stream.
Returns non-negative on success, <CODE>EOF</CODE> on error.
<DT><CODE><A NAME="getc">int getc(FILE* <VAR>stream</VAR>);</A></CODE>
<DD>Equivalent to <CODE><A HREF="#fgetc">fgetc</A></CODE>
except that it may be a macro.
<DT><CODE>int getchar();</CODE>
<DD>Equivalent to <CODE><A HREF="#getc">getc</A>(<A HREF="#stdin">stdin</A>)</CODE>.
<DT><CODE>char* gets(char* <VAR>s</VAR>);</CODE>
<DD>Reads next line from <A HREF="#stdin">stdin</A> into <VAR>s</VAR>.
Replaces terminating newline with <CODE>'\0'</CODE>.
Returns <VAR>s</VAR>, or <CODE>NULL</CODE> on end-of-file or error.
<DT><CODE><A NAME="putc">int putc(int <VAR>c</VAR>, FILE* <VAR>stream</VAR>);</A></CODE>
<DD>Equivalent to <CODE><A HREF="#fputc">fputc</A></CODE>
except that it may be a macro.
<DT><CODE>int putchar(int <VAR>c</VAR>);</CODE>
<DD><CODE>putchar(<VAR>c</VAR>)</CODE> is equivalent to
<CODE><A HREF="#putc">putc</A>(<VAR>c</VAR>, <A HREF="#stdout">stdout</A>)</CODE>.
<DT><CODE>int puts(const char* <VAR>s</VAR>);</CODE>
<DD>Writes s and a newline to stdout.
Returns non-negative on success, <CODE>EOF</CODE> on error.
<DT><CODE>int unget(int <VAR>c</VAR>, FILE* <VAR>stream</VAR>);</CODE>
<DD>Pushes <VAR>c</VAR> (which must not be <CODE>EOF</CODE>),
converted to unsigned char, onto stream <VAR>stream</VAR>
such that it will be returned by the next read.
Only one character of pushback is guaranteed for a stream.
Returns <VAR>c</VAR>, or <CODE>EOF</CODE> on error.
<DT><CODE>size_t fread(void* <VAR>ptr</VAR>, size_t <VAR>size</VAR>, size_t <VAR>nobj</VAR>, FILE* <VAR>stream</VAR>);</CODE>
<DD>Reads at most <VAR>nobj</VAR> objects of size <VAR>size</VAR>
from stream <VAR>stream</VAR> into <VAR>ptr</VAR>.
Returns the number of objects read.
<CODE><A HREF="#feof">feof</A></CODE> and
<CODE><A HREF="#ferror">ferror</A></CODE>
must be used to determine status.
<DT><CODE>size_t fwrite(const void* <VAR>ptr</VAR>, size_t <VAR>size</VAR>, size_t <VAR>nobj</VAR>, FILE* <VAR>stream</VAR>);</CODE>
<DD>Writes to stream <VAR>stream</VAR>, <VAR>nobj</VAR> objects
of size <VAR>size</VAR> from array <VAR>ptr</VAR>.
Returns the number of objects written
(which will be less than <VAR>nobj</VAR> on error).
<DT><CODE><A NAME="fseek">int fseek(FILE* <VAR>stream</VAR>, long <VAR>offset</VAR>, int <VAR>origin</VAR>);</A></CODE>
<DD>Sets file position for stream <VAR>stream</VAR>.
For a binary file, position is set to <VAR>offset</VAR> characters
from <VAR>origin</VAR>, which may be <CODE>SEEK_SET</CODE> (beginning),
<CODE>SEEK_CUR</CODE>(current position) or <CODE>SEEK_END</CODE> (end-of-file);
for a text stream, <VAR>offset</VAR> must be zero
or a value returned by <CODE><A HREF="#ftell">ftell</A></CODE>
(in which case <VAR>origin</VAR> must be <CODE>SEEK_SET</CODE>).
Returns non-zero on error.
<DT><CODE><A NAME="ftell">long ftell(FILE* <VAR>stream</VAR>);</A></CODE>
<DD>Returns current file position for stream <VAR>stream</VAR>,
or <CODE>-1L</CODE> on error.
<DT><CODE>void rewind(FILE* <VAR>stream</VAR>);</CODE>
<DD><CODE>rewind(<VAR>stream</VAR>)</CODE> is equivalent to
<CODE><A HREF="#fseek">fseek</A>(<VAR>stream</VAR>, 0L, SEEK_SET);
<A HREF="#clearerr">clearerr</A>(<VAR>stream</VAR>)</CODE>.
<DT><CODE>int fgetpos(FILE* <VAR>stream</VAR>, fpos_t* <VAR>ptr</VAR>);</CODE>
<DD>Assigns current position in stream <VAR>stream</VAR>
to <CODE>*<VAR>ptr</VAR></CODE>.
Type <CODE>fpos_t</CODE> is suitable for recording such values.
Returns non-zero on error.
<DT><CODE>int fsetpos(FILE* <VAR>stream</VAR>, const fpos_t* <VAR>ptr</VAR>);</CODE>
<DD>Sets current position of stream <VAR>stream</VAR>
to <CODE>*<VAR>ptr</VAR></CODE>.
Returns non-zero on error.
<DT><CODE><A NAME="clearerr">void clearerr(FILE* <VAR>stream</VAR>);</A></CODE>
<DD>Clears the end-of-file and error indicators
for stream <VAR>stream</VAR>.
<DT><CODE><A NAME="feof">int feof(FILE* <VAR>stream</VAR>);</A></CODE>
<DD>Returns non-zero if end-of-file indicator
for stream <VAR>stream</VAR> is set.
<DT><CODE><A NAME="ferror">int ferror(FILE* <VAR>stream</VAR>);</A></CODE>
<DD>Returns non-zero if error indicator
for stream <VAR>stream</VAR> is set.
<DT><CODE>void perror(const char* <VAR>s</VAR>);</CODE>
<DD>Prints <VAR>s</VAR> and implementation-defined error message
corresponding to <CODE><A HREF="#verrno">errno</A></CODE>:<BR>
<CODE><A HREF="#fprintf">fprintf</A>(<A HREF="#stderr">stderr</A>, "%s: %s\n", <VAR>s</VAR>, "<EM>error message</EM>")</CODE><BR>
See <A HREF="#strerror">strerror</A>.
</DL>


<hr>
<H3><A NAME="stdlib">&lt;stdlib.h&gt;</A></H3>
<DL>
<DT><CODE>double atof(const char* <VAR>s</VAR>);</CODE>
<DD>Returns numerical value of <VAR>s</VAR>.
Equivalent to <CODE><A HREF="#strtod">strtod</A>(<VAR>s</VAR>, (char**)NULL)</CODE>.
<DT><CODE>int atoi(const char* <VAR>s</VAR>);</CODE>
<DD>Returns numerical value of <VAR>s</VAR>.
Equivalent to <CODE>(int)<A HREF="#strtol">strtol</A>(<VAR>s</VAR>, (char**)NULL, 10)</CODE>.
<DT><CODE>long atol(const char* <VAR>s</VAR>);</CODE>
<DD>Returns numerical value of <VAR>s</VAR>.
Equivalent to <CODE><A HREF="#strtol">strtol</A>(<VAR>s</VAR>, (char**)NULL, 10)</CODE>.
<DT><CODE><A NAME="strtod">double strtod(const char* <VAR>s</VAR>, char** <VAR>endp</VAR>);</A></CODE>
<DD>Converts prefix of <VAR>s</VAR> to <CODE>double</CODE>,
ignoring leading quite space.
Stores a pointer to any unconverted suffix in <CODE>*<VAR>endp</VAR></CODE>
if <VAR>endp</VAR> non-<CODE>NULL</CODE>.
If answer would overflow, <CODE>HUGE_VAL</CODE> is returned
with the appropriate sign; if underflow, zero returned.
In either case, <CODE><A HREF="#verrno">errno</A></CODE>
is set to <CODE>ERANGE</CODE>.
<DT><CODE><A NAME="strtol">long strtol(const char* <VAR>s</VAR>, char** <VAR>endp</VAR>, int <VAR>base</VAR>);</A></CODE>
<DD>Converts prefix of <VAR>s</VAR> to <CODE>long</CODE>,
ignoring leading quite space.
Stores a pointer to any unconverted suffix in <CODE>*<VAR>endp</VAR></CODE>
if <VAR>endp</VAR> non-<CODE>NULL</CODE>.
If <VAR>base</VAR> between 2 and 36, that base used;
if zero, leading <CODE>0X</CODE> or <CODE>0x</CODE> implies hexadecimal,
leading <CODE>0</CODE>implies octal, otherwise decimal.
Leading <CODE>0X</CODE> or <CODE>0x</CODE> permitted for base 16.
If answer would overflow, <CODE>LONG_MAX</CODE> or <CODE>LONG_MIN</CODE>
returned and <CODE><A HREF="#verrno">errno</A></CODE>
is set to <CODE>ERANGE</CODE>.
<DT><CODE>unsigned long strtoul(const char* <VAR>s</VAR>, char** <VAR>endp</VAR>, int <VAR>base</VAR>);</CODE>
<DD>As for <CODE><A HREF="#strtol">strtol</A></CODE>
except result is <CODE>unsigned long</CODE>
and error value is <CODE>ULONG_MAX</CODE>.
<DT><CODE>int rand();</CODE>
<DD>Returns pseudo-random number in range
<CODE>0</CODE> to <CODE>RAND_MAX</CODE>.
<DT><CODE>void srand(unsigned int <VAR>seed</VAR>);</CODE>
<DD>Uses <VAR>seed</VAR> as seed for new sequence of pseudo-random numbers.
Initial seed is <CODE>1</CODE>.
<DT><CODE>void* calloc(size_t <VAR>nobj</VAR>, size_t <VAR>size</VAR>);</CODE>
<DD>Returns pointer to zero-initialised newly-allocated space for an array
of <VAR>nobj</VAR> objects each of size <VAR>size</VAR>,
or <CODE>NULL</CODE> if request cannot be satisfied.
<DT><CODE>void* malloc(size_t <VAR>size</VAR>);</CODE>
<DD>Returns pointer to uninitialised newly-allocated space for an
object of size <VAR>size</VAR>,
or <CODE>NULL</CODE> if request cannot be satisfied.
<DT><CODE>void* realloc(void* <VAR>p</VAR>, size_t <VAR>size</VAR>);</CODE>
<DD>Changes to <VAR>size</VAR> the size of the object to which
<VAR>p</VAR> points.
Contents unchanged to minimum of old and new sizes.
If new size larger, new space is uninitialised.
Returns ponter to the new space or, if request cannot be satisfied
<CODE>NULL</CODE> leaving <CODE><VAR>p</VAR></CODE> unchanged.
<DT><CODE>void free(void* <VAR>p</VAR>);</CODE>
<DD>Deallocats space to which <VAR>p</VAR> points.
<VAR>p</VAR> must be <CODE>NULL</CODE>, in which case there is no effect,
or a pointer returned by <CODE>calloc</CODE>, <CODE>malloc</CODE> or
<CODE>realloc</CODE>.
<DT><CODE>void abort();</CODE>
<DD>Causes program to terminate abnormally, as if by
<CODE><A HREF="#raise">raise</A>(<A HREF="#sigabrt">SIGABRT</A>)</CODE>.
<DT><CODE>void exit(int <VAR>status</VAR>);</CODE>
<DD>Causes normal program termination.
Functions installed using <CODE><A HREF="#atexit">atexit</A></CODE>
are called in reverse order of registration, open files are flushed,
open streams are closed and control is returned to environment.
<VAR>status</VAR> is returned to environment in implementation-dependent
manner.
Zero indicates successful termination and the values
<CODE>EXIT_SUCCESS</CODE> and <CODE>EXIT_FAILURE</CODE> may be used.
<DT><CODE><A NAME="atexit">int atexit(void (*<VAR>fcm</VAR>)(void));</A></CODE>
<DD>Registers <VAR>fcn</VAR> to be called when program
terminates normally.
Non-zero returned if registration cannot be made.
<DT><CODE>int system(const char* <VAR>s</VAR>);</CODE>
<DD>Passes <VAR>s</VAR> to environment for execution.
If <VAR>s</VAR> is <CODE>NULL</CODE>, non-zero returned
if command processor exists;
return value is implementation-dependent if
<VAR>s</VAR> is non-<CODE>NULL</CODE>.
<DT><CODE>char getenv(const char* <VAR>name</VAR>);</CODE>
<DD>Returns (implementation-dependent) environment string
associated with <VAR>name</VAR>,
or <CODE>NULL</CODE> if no such string exists.
<DT><CODE>void bsearch(const void* <VAR>key</VAR>, const void* <VAR>base</VAR>, size_t <VAR>n</VAR>, size_t <VAR>size</VAR>, int (*<VAR>cmp</VAR>)(const void* keyval, const void* datum);</CODE>
<DD>Searches <CODE><VAR>base</VAR>[0]...<VAR>base</VAR>[<VAR>n</VAR>-1]</CODE>
for item matching <CODE>*<VAR>key</VAR></CODE>.
Comparison function <VAR>cmp</VAR> must return negative if
first argument is less than second, zero if equal and positive if greater.
The <VAR>n</VAR> items of <VAR>base</VAR> must be in ascending order.
Returns a pointer to the matching entry or <CODE>NULL</CODE> if not found.
<DT><CODE>void qsort(void* <VAR>base</VAR>, size_t <VAR>n</VAR>, size_t <VAR>size</VAR>, int (*<VAR>cmp</VAR>)(const void*, const void/);</CODE>
<DD>Arranges into ascending order the array
<CODE><VAR>base</VAR>[0]...<VAR>base</VAR>[<VAR>n</VAR>-1]</CODE>
of objects of size <VAR>size</VAR>.
Comparison function <VAR>cmp</VAR> must return negative if
first argument is less than second, zero if equal and positive if greater.
<DT><CODE>int abs(int <VAR>n</VAR>);</CODE>
<DD>Returns absolute value of <VAR>n</VAR>
<DT><CODE>long labs(long <VAR>n</VAR>);</CODE>
<DD>Returns absolute value of <VAR>n</VAR>
<DT><CODE>div_t div(int <VAR>num</VAR>, int <VAR>denom</VAR>);</CODE>
<DD>Returns in fields <CODE>quot</CODE> and <CODE>rem</CODE> of structure
of type <CODE>div_t</CODE> the quotient and remainder of
<CODE><VAR>num</VAR>/<VAR>denom</VAR></CODE>.
<DT><CODE>ldiv_t ldiv(long <VAR>num</VAR>, long <VAR>denom</VAR>);</CODE>
<DD>Returns in fields <CODE>quot</CODE> and <CODE>rem</CODE> of structure
of type <CODE>ldiv_t</CODE> the quotient and remainder of
<CODE><VAR>num</VAR>/<VAR>denom</VAR></CODE>.
</DL>


<hr>
<H3><A NAME="string">&lt;string.h&gt;</A></H3>
<DL>
<DT><CODE>char* strcpy(char* <VAR>s</VAR>, const char* <VAR>ct</VAR>);</CODE>
<DD>Copy <VAR>ct</VAR> to <VAR>s</VAR> including terminating <CODE>NUL</CODE>.
Return <VAR>s</VAR>.
<DT><CODE>char* strncpy(char* <VAR>s</VAR>, const char* <VAR>ct</VAR>, int <VAR>n</VAR>);</CODE>
<DD>Copy at most <VAR>n</VAR> characters of <VAR>ct</VAR> to <VAR>s</VAR>
Pad with <CODE>NUL</CODE>s if <VAR>ct</VAR> is of length less than <VAR>n</VAR>.
Return <VAR>s</VAR>.
<DT><CODE>char* strcat(char* <VAR>s</VAR>, const char* <VAR>ct</VAR>);</CODE>
<DD>Concatenate <VAR>ct</VAR> to <VAR>s</VAR>.
Return <VAR>s</VAR>.
<DT><CODE>char* strncat(char* <VAR>s</VAR>, const char* <VAR>ct</VAR>, int <VAR>n</VAR>);</CODE>
<DD>Concatenate at most <VAR>n</VAR> characters of <VAR>ct</VAR> to <VAR>s</VAR>.
Terminate <VAR>s</VAR> with <CODE>NUL</CODE> and return it.
<DT><CODE>int strcmp(const char* <VAR>cs</VAR>, const char* <VAR>ct</VAR>);</CODE>
<DD>Compare <VAR>cs</VAR> and <VAR>ct</VAR>.
Return negative if <CODE><VAR>cs</VAR> < <VAR>ct</VAR></CODE>,
zero if <CODE><VAR>cs</VAR> == <VAR>ct</VAR></CODE>,
positive if <CODE><VAR>cs</VAR> > <VAR>ct</VAR></CODE>.
<DT><CODE>int strncmp(const char* <VAR>cs</VAR>, const char* <VAR>ct</VAR>, int <VAR>n</VAR>);</CODE>
<DD>Compare at most <VAR>n</VAR> characters of <VAR>cs</VAR> and <VAR>ct</VAR>.
Return negative if <CODE><VAR>cs</VAR> < <VAR>ct</VAR></CODE>,
zero if <CODE><VAR>cs</VAR> == <VAR>ct</VAR></CODE>,
positive if <CODE><VAR>cs</VAR> > <VAR>ct</VAR></CODE>.
<DT><CODE>char* strchr(const char* <VAR>cs</VAR>, int <VAR>c</VAR>);</CODE>
<DD>Return pointer to first occurrence of <VAR>c</VAR> in <VAR>cs</VAR>,
or <CODE>NULL</CODE> if not found.
<DT><CODE>char* strrchr(const char* <VAR>cs</VAR>, int <VAR>c</VAR>);</CODE>
<DD>Return pointer to last occurrence of <VAR>c</VAR> in <VAR>cs</VAR>,
or <CODE>NULL</CODE> if not found.
<DT><CODE>size_t strspn(const char* <VAR>cs</VAR>, const char* <VAR>ct</VAR>);</CODE>
<DD>Return length of prefix of <VAR>cs</VAR> consisting entirely of
characters in <VAR>ct</VAR>.
<DT><CODE>size_t strcspn(const char* <VAR>cs</VAR>, const char* <VAR>ct</VAR>);</CODE>
<DD>Return length of prefix of <VAR>cs</VAR> consisting entirely of
characters <EM>not</EM> in <VAR>ct</VAR>.
<DT><CODE>char* strpbrk(const char* <VAR>cs</VAR>, const char* <VAR>ct</VAR>);</CODE>
<DD>Return pointer to first occurrence within <VAR>cs</VAR>
of any character of <VAR>ct</VAR>,
or <CODE>NULL</CODE> if not found.
<DT><CODE>char* strstr(const char* <VAR>cs</VAR>, const char* <VAR>ct</VAR>);</CODE>
<DD>Return pointer to first occurrence of <VAR>ct</VAR> in <VAR>cs</VAR>,
or <CODE>NULL</CODE> if not found.
<DT><CODE>size_t strlen(const char* <VAR>cs</VAR>);</CODE>
<DD>Return length of <VAR>cs</VAR>.
<DT><CODE><A NAME="strerror">char* strerror(int <VAR>n</VAR>);</A></CODE>
<DD>Return pointer to implementation-defined string
corresponding with error <VAR>n</VAR>.
<DT><CODE>char* strtok(char* <VAR>s</VAR>, const char* <VAR>t</VAR>);</CODE>
<DD>A sequence of calls to <CODE>strtok</CODE> returns tokens
from <VAR>s</VAR> delimted by a character in <VAR>ct</VAR>.
Non-<CODE>NULL</CODE> <VAR>s</VAR> indicates the first call in a sequence.
<VAR>ct</VAR> may differ on each call.
Returns <CODE>NULL</CODE> when no such token found.
<DT><CODE>void* memcpy(void* <VAR>s</VAR>, const void* <VAR>ct</VAR>, int <VAR>n</VAR>);</CODE>
<DD>Copy <VAR>n</VAR> characters from <VAR>ct</VAR> to <VAR>s</VAR>.
Return <VAR>s</VAR>.
<STRONG>Does not work correctly if objects overlap.</STRONG>
<DT><CODE>void* memmove(void* <VAR>s</VAR>, const void* <VAR>ct</VAR>, int <VAR>n</VAR>);</CODE>
<DD>Copy <VAR>n</VAR> characters from <VAR>ct</VAR> to <VAR>s</VAR>.
Return <VAR>s</VAR>.
Works correctly even if objects overlap.
<DT><CODE>int memcmp(const void* <VAR>cs</VAR>, const void* <VAR>ct</VAR>, int <VAR>n</VAR>);</CODE>
<DD>Compare first <VAR>n</VAR> characters of <VAR>cs</VAR> with <VAR>ct</VAR>.
Return negative if <CODE><VAR>cs</VAR> < <VAR>ct</VAR></CODE>,
zero if <CODE><VAR>cs</VAR> == <VAR>ct</VAR></CODE>,
positive if <CODE><VAR>cs</VAR> > <VAR>ct</VAR></CODE>.
<DT><CODE>void* strchr(const char* <VAR>cs</VAR>, int <VAR>c</VAR>, int <VAR>n</VAR>);</CODE>
<DD>Return pointer to first occurrence of <VAR>c</VAR> in first <VAR>n</VAR>
characters of <VAR>cs</VAR>,
or <CODE>NULL</CODE> if not found.
<DT><CODE>void* strchr(char* <VAR>s</VAR>, int <VAR>c</VAR>, int <VAR>n</VAR>);</CODE>
<DD>Replace each of the first <VAR>n</VAR> characters of <VAR>s</VAR> by <VAR>c</VAR>.
Return <VAR>s</VAR>.
</DL>


<hr>
<H3><A NAME="time">&lt;time.h&gt;</A></H3>
<DL>
<DT><CODE>clock_t</CODE>
<DD>An arithmetic type representing time.
<DT><CODE>CLOCKS_PER_SEC</CODE>
<DD>The number of <CODE>clock_t</CODE> units per second.
<DT><CODE>time_t</CODE>
<DD>An arithmetic type representing time.
<DT><CODE>struct tm</CODE>
<DD>Represents the components of calendar time:
<DL>
<DT><CODE>int tm_sec;</CODE>
<DD>seconds after the minute
<DT><CODE>int tm_min;</CODE>
<DD>minutes after the hour
<DT><CODE>int tm_hour;</CODE>
<DD>hours since midnight
<DT><CODE>int tm_mday;</CODE>
<DD>day of the month
<DT><CODE>int tm_ymon;</CODE>
<DD>months <STRONG>since</STRONG> January
<DT><CODE>int tm_year;</CODE>
<DD>years since 1900
<DT><CODE>int tm_day;</CODE>
<DD>days since Sunday
<DT><CODE>int tm_yday;</CODE>
<DD>days since January 1
<DT><CODE>int tm_isdst;</CODE>
<DD>Daylight Saving Time flag : is positive if DST is in effect,
zero if not in effect, negative if information unavailable.
</DL>
<DT><CODE>clock_t clock();</CODE>
<DD>Returns processor time used by program
or -1 if not available.
<DT><CODE>time_t time(time_t* <VAR>tp</VAR>);</CODE>
<DD>Returns current calendar time or -1 if not available.
If <VAR>tp</VAR> is non-<CODE>NULL</CODE>,
return value is also assigned to <CODE>*<VAR>tp</VAR></CODE>.
<DT><CODE>double difftime(time_t <VAR>time2</VAR>, time_t <VAR>time1</VAR>);</CODE>
<DD>Returns the difference is seconds between
<VAR>time2</VAR> and <VAR>time1</VAR>.
<DT><CODE>time_t mktime(struct tm* <VAR>tp</VAR>);</CODE>
<DD>Returns the local time corresponding to
<CODE>*<VAR>tp</VAR></CODE>, or <CODE>-1</CODE> if it cannot be represented.
<DT><CODE><A NAME="asctime">char* asctime(const struct tm* <VAR>tp</VAR>);</A></CODE>
<DD>Returns the given time as a string of the form:<BR>
<CODE>Sun Jan   3 14:14:13 1988\n\0</CODE>
<DT><CODE>char* ctime(const time_t <VAR>tp</VAR>);</CODE>
<DD>Converts the given calendar time to a local time
and returns the equivalent string.
Equivalent to:<BR>
<CODE><A HREF="#asctime">asctime</A>(<A HREF="#localtime">localtime</A>(tp))</CODE>
<DT><CODE>struct tm* gmtime(const time_t <VAR>tp</VAR>);</CODE>
<DD>Returns the given calendar time converted into
Coordinated Universal Time,
or <CODE>NULL</CODE> if not available.
<DT><CODE><A NAME="localtime">struct tm* localtime(const time_t <VAR>tp</VAR>);</A></CODE>
<DD>Returns calendar time <CODE>*<VAR>tp</VAR></CODE>
converted into local time.
<DT><CODE>size_t strftime(char* <VAR>s</VAR>, size_t <VAR>smax</VAR>, const char* <VAR>fmt</VAR>, const struct tm* <VAR>tp</VAR>);</CODE>
<DD>Formats <CODE>*<VAR>tp</VAR></CODE> into
<VAR>s</VAR> according to <VAR>fmt</VAR>.
</DL>
Notes:
<UL>
<LI><EM>Local</EM> time may differ from <EM>calendar</EM> time,
for example because of time zone.
</UL>


<HR>
</BODY>
</HTML>

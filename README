This is the miniature c linux systemcalls library.
Michael (Misc) Myer (misc.myer@zoho.com), 2012-2019, GPLv3.


********************
Warning
********************

This library is more or less alpha.
If you have no special interest in using it,
better head for something like musl, dietlibc, klib, ...

I'd especially like to hint you at: 
https://github.com/attractivechaos/klib

It's not very well known, 
but looks good and is active.

Just got minilib running on OSX (10.11, x64),
enabling static linking for small tools.
Ported it from linux 32bit, 
so for the moment it's not sure
it will compile at linux without a little bit of work.

Anyways, being able to link small tools statically 
on osx is a great thing. 
This doesn't work with the native libs,
and there are reasons, you might want to link statically.

Hacking the OS, or executing security critical code,
for example. If the kernel has been hacked, well...
But statically linking prevents from lib injection.


Happy hacking



********************
About
********************

Minilib evolved out of some assembler experiments,
where I saw how tiny executables can be if not linked with glibc.
With some more fiddling I got a C "Hello World!" program with 151 bytes,
compiled and linked with the standard gcc makechain.
This is more than 3,000 times less than a hello world program 
linked statically with glibc,
which shows up with 504kB on my system. (5.4kB linked dynamic)

(On OSX there are some limits, 
files with less than 4k aren't executed, 
so that's hello world's size there..)

Just for fun, but this minilib also beats klibc, dietlib and musl 
in the matter of hello world's size..
musl: 7.6k
dietlibc: 672
klibc: 367
minilib: 151



Being in syscalls, linker scripts and gcc optimization hell,
I realized that after I got over the fundamental problems adding 
more standard c routines would be cheap.
So I started to port some more little c tools to minilib,
adding more functionality to minilib as well.

Since I hate todays usual overhead in modern libraries,
resulting in the unbelievable size of hundreds of Megabytes 
for simple applications as well as minutes for just starting them up,
I also tried to optimize functions like printf where sensible.

You are able to customize the compilation of the library
and define just only the functions you need.


This whole project exaggerated out of fun.

I decided to publish this anyway,
since I hope this could be of some use and there's too much on 
my harddisk lying around and dying.




********************
Development
********************


At the moment minilib is far of being complete,
but especially adding more syscalls is easy.

Look into include/lseek.h for examples.








********************
Usage
********************


include minilib.h in all sourcefiles, needing definitions from minilib.
define in minilib.h all features needed.

include minilib_implementation.c into a sourcefile or add minilib.c to the sources

copy makefile.template to your sourcedir, rename to makefile.
Edit makefile, set PROG to your prog's name.

done..


*******************
Notes
*******************

letztes makefile: in test-embutils.
(probleme mit den flags...)


include dateien: nach c standard.
(können dann mit gcc -I... überschrieben werden,
ohne Dateien zu verändern.)

"Nutzer" Datei(en) einbinden lassen durch minilib.c (?)



TODO: errno.h : set errno..


*******************
*******************
Michael (Misc) Myer, 2012-2019
misc.myer@zoho.com
(my "programming enthusiastic persona".. 
There are reasons, I have to separate my "images".
If you'd really like to know why, contact me..)

*******************
*******************


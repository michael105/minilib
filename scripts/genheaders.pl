#!/bin/perl -w
#
my $fhhash;
# Where to put the generated ansi/posix headers
my $headerdir = shift;
# Header file for storing defines
#my $mlh = shift;

my $funchash;
my $mlfunchash; # Non standard functions
my $allfunchash; # Allfuncs.
my $depends;


BEGIN{
		use File::Basename;
		($name,$path,$suffix) = fileparse ($0);
		print "path: $path";
		push @INC, "$path";
}



require "cref.pm";


# ansicolors
#define AC_BLACK "\033[0;30m"
#define AC_RED "\033[0;31m"
$G= "\033[32;0m"; # Green
#define AC_BROWN "\033[0;33m"
#define AC_BLUE "\033[0;34m"
$C = "\033[0;35m"; # Cyan
$M = "\033[0;36m"; # Marine
#define AC_LGREY "\033[0;37m"
$N= "\033[0;38m"; # White

#define AC_GREY "\033[1;30m" 
$LR = "\033[1;31m"; # Light red
$LG =  "\033[1;32m"; # Light green
$Y =  "\033[1;33m"; # Yellow
#define AC_LBLUE "\033[1;34m"
#define AC_LMAGENTA "\033[1;35m"
#define AC_LMARINE "\033[1;36m"
#define AC_LWHITE "\033[1;37m"


sub dbg{
		while ( my $s = shift ){
				print $s;
		}
		print "\n";
}


# gets callen for each header referenced
# if the file isn't open yet,
# creates and returns a new filehandle
# Copies also header.h.in at the beginning.
sub headerfh{
		my $header = shift;
		print ("Header: $header\n");
		if ( ! exists($fhhash->{fh}->{$header}) ){
				open( $fhhash->{fh}->{$header}, ">", "$headerdir/$header" ) or die;
				my $h = $header;
				$h =~ s/\./_/g;
				print {$fhhash->{fh}->{$header}} "// Header generated by tools/genheaders.pl\n".
				"// Put changes into $header.in\n\n#ifndef header_$h\n#define header_$h\n\n";

				if ( -e "$headerdir/$header.in" ){
						open(FH,"<", "$headerdir/$header.in" ) or die;
						while ( <FH> ){
								print {$fhhash->{fh}->{$header}} $_;
						}
						print {$fhhash->{fh}->{$header}} "\n\n";
						close FH;
				} 

		}
		return( $fhhash->{fh}->{$header} );
}

# iterate over commandline args
while ( my $file = shift ){
		open (F, "<", $file) or die;

		my $header = 0;

		while ( my $l= <F>){
				my $f;
				my $tag = 0;
				my $func = 0;
				$f->{file} = $file;

				if ($l=~ /^\/\/\+/){
						do {
								print ( "$M l: $l $N\n" );
								$l=~ /^\/\/\+(\S*)\s?(.*)?$/;
								$tag = $1;
								my $c = $2 || 0;
								print "tag: $tag c: $c\n";

								if ( $tag eq 'header' ){
										print "l: $l";
										#$l =~ /^\/\/\+header (\S*)/;
										$header = $c or die;
								} elsif ( $tag eq 'def' ){
										$f->{def} = <F>;
										print "def: $f->{def} $file: $l";
										if ( $f->{def} =~ /^DEF_syscall(ret)*.(.*?),/ ){
												$func = $2;
										} else {
												$f->{def} =~ /.* \**(\S*)\(.+?\)\{.*$/;
												$func = $1;
										}
										print "func: $LR $func $N\n";
										$f->{def} =~ s/\{.*$/;/;
										print "def: $Y $f->{def} $N l: $l";
								} elsif ( $tag eq 'needs' ){
										#$l =~ /^\/\/\+needs\s?(\S*)/;
										$f->{needs} = $c;
										print "$LG needs: $f->{needs} $N\n";
								} elsif ( $tag eq 'depends' ){
										$f->{dep} = $c;
										print "$LG depends: $f->{dep} $N\n";
								} elsif ( $tag eq 'after' ){
										$f->{after} = $c; # e.g. printf after atoi (when defined atoi)
								} elsif( $tag eq 'inc' ){
										print {headerfh($header)} "// file: $file\n#include \"$file\"\n";
										$f->{inc} = 1;
								}
								$l = <F>;
								$tag = 0;
						} while (defined($l) && ($l=~ /^\/\/\+(\S*)/) );
						if ( $func ){
								if ( exists($functiondict->{$func}) ){ # standard function.
										$f->{header} = $functiondict->{$func}->{header};
										#$header} = $functiondict->{$func}->{header};
										$functiondict->{$func}->{implementation} = $file;
								} else { 
										#$mlfunchash->{$func}= $f; # no standard function
										print "Header::: XXXX $f->{header}\n";
										if ( !$header ){
												$f->{header} = "miniextras.h";
										}
								}
								$funchash->{$func} = $f;
								if ( exists($f->{dep} )){
										$depends->{$func} = $f->{dep};
								}

								if ( $f->{header} && $f->{def} ){
										print "header: $f->{header}\n def: $f->{def}\n";
										print ${headerfh($f->{header})} "// file: $f->{file}\n$f->{def}\n";
										$fhhash->{sources}->{$f->{header}}->{$file} = 1;
								}
						}
				}

		}
}

# write the #include "source.c" directives
# iterate over each header include filehandler
foreach my $key ( keys(%{$fhhash->{fh}}) ){
		print "key: $key\n";
		print {$fhhash->{fh}->{$key}} "\n\n#include \"include/minilib_global.h\"\n";
		print {$fhhash->{fh}->{$key}} "\n\n#ifdef mini_INCLUDESRC\n\n";
		foreach my $s ( keys(%{$fhhash->{sources}->{$key}}) ){
				print "source key: $s\n";
				print {$fhhash->{fh}->{$key}} "#include \"$s\"\n";
		}
		print {$fhhash->{fh}->{$key}} "\n// Need global included. Doesn't matter by which file.\n#include \"src/minilib_global.c\"\n";
		print {$fhhash->{fh}->{$key}} "\n// Need start.c included. Doesn't matter by which file.\n#include \"asm/start.c\"\n\n";
		print {$fhhash->{fh}->{$key}} "#endif\n\n";

		print {$fhhash->{fh}->{$key}} "#endif\n";
		close( $fhhash->{fh}->{$key} );
}


# write 
use Data::Dumper::Simple;

print Dumper( $funchash );
print Dumper( $depends );

my $includefirst;

# define functions, which are dependencies, when needed
sub printdepend{
		my $d = shift;

		print "\n#ifdef mini_$d\n";
		foreach my $on ( split( " ", $depends->{$d} ) ){
				print "#ifndef mini_$on\n#define mini_$on\n#endif\n";
				$includefirst->{$on} = 1;
		}
		print "#endif\n"
}

# include the header files first, on which we depend,
# or define the needed functions.
sub headerinclude{
		my $i = shift;
		print "\n// $funchash->{$i}->{file}\n";
		print "#ifdef mini_$i\n";
		if ( $funchash->{$i}->{file} =~ /\S\.h$/ ){
				if ( exists($funchash->{$i}->{needs}) ){
						foreach my $c ( split( " ", $funchash->{$i}->{needs} ) ){
								if ( ! exists( $alreadyincluded->{$c} ) ){ # already incuded before. e.g. syscall.h
										print "#include \"$c\"\n";
								}
						}
				}
				print "#include \"$funchash->{$i}->{file}\"\n";
		} else {
				print $funchash->{$i}->{def}."";
		}
		print "#endif\n";
}


foreach my $d ( keys (%{$depends}) ){
		printdepend($d);
}

foreach my $i ( keys(%{$includefirst}) ){
		headerinclude( $i );
}

foreach my $i ( keys(%{$funchash}) ){
		headerinclude( $i );
}


# end header file here..
dbg("$C"."==================$N");


# braucht noch, fuer source: after ( z.B. printf nach uitodec )

sub sourceinclude{
		my $i = shift;
		print "\n// $funchash->{$i}->{file}\n";
		print "#ifdef mini_$i\n";
		print "#include \"$funchash->{$i}->{file}\"\n";
		print "#endif\n";
}

foreach my $f ( keys(%{$funchash}) ){
		if ( $funchash->{$f}->{file} =~ /\S\.c$/ ){
				sourceinclude( $f );
		}
}




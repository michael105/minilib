<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="AsciiDoc 9.0.5">
<title></title>
</head>
<body>
<hr>
<h2><a name="_process"></a>process</h2>
<a name="abort"></a><dl>
<dt>
abort
</dt>
<dd>
<p>
  <em>void abort()</em><br>
 <strong>Defines:</strong> memcpy getpid write rt_sigaction kill<br>
<a href="../../src/process/abort.c">../src/process/abort.c</a> l.3 manpage: <a href="../manpages/stdlib/abort.3.rst.html">abort</a><br>
</p>
</dd>
<dt>
atexit
</dt>
<dd>
<p>
  <em>int atexit( functionp* func )</em><br>
 <strong>Defines:</strong> globals<br>
</p>
</dd>
</dl>
<a name="atexit"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>register functions, which are callen on exit in reverse order
 the switch mini_atexit takes a optional number,
 which defines the maximum numbers of functions to be registered.
 (defaults to 8)</code></pre>
</td></tr></table>
<p><a href="../../src/process/atexit.c">../src/process/atexit.c</a> l.7 manpage: <a href="../manpages/stdlib/atexit.3.rst.html">atexit</a><br></p>
<a name="clone"></a><dl>
<dt>
clone
</dt>
<dd>
<p>
  <em>int clone( int clone_flags,  unsigned long stack,  void *parent_tid,  void *child_tid)</em><br>
<a href="../../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.211
</p>
</dd>
<dt>
clone_t
</dt>
<dd>
<p>
  <em>int clone_t(int flags)</em><br>
<a href="../../src/process/clone.c">../src/process/clone.c</a> l.7
</p>
</dd>
<dt>
execl
</dt>
<dd>
<p>
  <em>int execl(const char <strong>pathname, const char</strong> arg0,&#8230; )</em><br>
 <strong>Defines:</strong> execve environ<br>
<a href="../../src/exec/execl.c">../src/exec/execl.c</a> l.6 manpage: <a href="../manpages/gen/exec.3.rst.html">execl</a><br>
</p>
</dd>
<dt>
execv
</dt>
<dd>
<p>
  <em>int execv(const char <strong>pathname, char *const argv[])</em><br>
 *Defines:</strong> execve environ<br>
 <strong>execute a file</strong>
Size: ~300B <a href="../../src/exec/_execv.c">../src/exec/_execv.c</a> l.4 manpage: <a href="../manpages/gen/exec.3.rst.html">execv</a><br>
</p>
</dd>
<dt>
execve
</dt>
<dd>
<p>
  <em>int execve( const char <strong>filename,  char</strong> const* argv, char* const* envp)</em><br>
 <strong>execute program</strong>
Size: ~53B <a href="../../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.133 manpage: <a href="../manpages/sys/execve.2.rst.html">execve</a><br>
</p>
</dd>
<dt>
execveat
</dt>
<dd>
<p>
  <em>int execveat( int dirfd, const char <strong>filename,  char</strong> const* argv, char* const* envp, int flags)</em><br>
 <strong>execute program relative to a directory file descriptor</strong>
Size: ~158B <a href="../../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.164
</p>
</dd>
<dt>
execvp
</dt>
<dd>
<p>
  <em>int execvp(const char <strong>file, char *const argv[])</em><br>
 *Defines:</strong> access execve environ<br>
 <strong>execute a file</strong>
Size: ~556B <a href="../../src/exec/_execvp.c">../src/exec/_execvp.c</a> l.4 manpage: <a href="../manpages/gen/exec.3.rst.html">execvp</a><br>
</p>
</dd>
<dt>
execvpe
</dt>
<dd>
<p>
  <em>int execvpe(const char <strong>file, char *const argv[], char *const envp[])</em><br>
 *Defines:</strong> environ execve access<br>
 <strong>execute a file</strong>
</p>
</dd>
</dl>
<a name="execvpe"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>When invoked with a filename, starting with "." or "/",
 interprets this as absolute path. (calls execve with the pathname)
 Looks for file in the PATH environment, othwerise.</code></pre>
</td></tr></table>
<p>Size: ~556B <a href="../../src/exec/execvp.c">../src/exec/execvp.c</a> l.11</p>
<a name="fexecve"></a><dl>
<dt>
fexecve
</dt>
<dd>
<p>
  <em>int fexecve(int fd, char <strong>const argv[], char *const envp[])</em><br>
 *execute a file</strong>
Size: ~151B <a href="../../include/fexecve.h">../include/fexecve.h</a> l.3 manpage: <a href="../manpages/sys/execve.2.rst.html">fexecve</a><br>
</p>
</dd>
<dt>
fexecveat
</dt>
<dd>
<p>
  <em>int fexecveat(int fd, char *const argv[], char *const envp[])</em><br>
Size: ~151B <a href="../../include/fexecveat.h">../include/fexecveat.h</a> l.3
</p>
</dd>
<dt>
fork
</dt>
<dd>
<p>
  <em>int DEF_syscall(fork,0)</em><br>
 <strong>create a new process</strong>
<a href="../../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.137 manpage: <a href="../manpages/sys/fork.2.rst.html">fork</a><br>
</p>
</dd>
<dt>
getenv
</dt>
<dd>
<p>
  <em>char* getenv(const char* name)</em><br>
 <strong>Defines:</strong> environ<br>
 <strong>get value of an environment variable</strong>
Size: ~106B <a href="../../src/system/getenv.c">../src/system/getenv.c</a> l.5 manpage: <a href="../manpages/stdlib/getenv.3.rst.html">getenv</a><br>
</p>
</dd>
<dt>
getpgrp
</dt>
<dd>
<p>
  <em>int DEF_syscall(getpgrp,0)</em><br>
 <strong>get the process group ID of the calling process</strong>
<a href="../../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.198 manpage: <a href="../manpages/sys/getpgrp.2.rst.html">getpgrp</a><br>
</p>
</dd>
<dt>
getpid
</dt>
<dd>
<p>
  <em>int DEF_syscall(getpid,0 )</em><br>
 <strong>get the process ID</strong>
<a href="../../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.151 manpage: <a href="../manpages/sys/getpid.2.rst.html">getpid</a><br>
</p>
</dd>
<dt>
getppid
</dt>
<dd>
<p>
  <em>int DEF_syscall(getppid,0)</em><br>
 <strong>get the parent process ID</strong>
<a href="../../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.195 manpage: <a href="../manpages/sys/getpid.2.rst.html">getppid</a><br>
</p>
</dd>
<dt>
setpgid
</dt>
<dd>
<p>
  <em>int setpgid( pid_t pid, pid_t pgid)</em><br>
 <strong>set process group ID for job control</strong>
Size: ~63B <a href="../../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.196 manpage: <a href="../manpages/sys/setpgid.2.rst.html">setpgid</a><br>
</p>
</dd>
<dt>
setsid
</dt>
<dd>
<p>
  <em>int DEF_syscall(setsid,0 )</em><br>
 <strong>create session and set process group ID</strong>
<a href="../../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.152 manpage: <a href="../manpages/sys/setsid.2.rst.html">setsid</a><br>
</p>
</dd>
<dt>
system
</dt>
<dd>
<p>
  <em>int system( const char* command )</em><br>
 <strong>Defines:</strong> wait4 execve environ write vfork<br>
 <strong>issue a command</strong>
Size: ~326B <a href="../../src/exec/system.c">../src/exec/system.c</a> l.4 manpage: <a href="../manpages/stdlib/system.3.rst.html">system</a><br>
</p>
</dd>
<dt>
vexec
</dt>
<dd>
<p>
  <em>int vexec( const char* path, char* const* argv, char* const* envp )</em><br>
 <strong>Defines:</strong> execve wait4 exit vfork seterrno<br>
</p>
</dd>
</dl>
<a name="vexec"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>execute a path, wait until the executed file exits.
 Deviating of system() an absolute pathname is taken.
 sets errno on error.</code></pre>
</td></tr></table>
<p><a href="../../src/exec/vexec.c">../src/exec/vexec.c</a> l.6</p>
<a name="vexec_q"></a><dl>
<dt>
vexec_q
</dt>
<dd>
<p>
  <em>int vexec_q( const char* path, char* const* argv, char* const* envp )</em><br>
 <strong>Defines:</strong> wait4 execve exit seterrno vfork<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>execute a path, wait until the executed file exits,
 do not write any output of the process. (close stdout)
 Deviating of system() an absolute pathname is taken.</code></pre>
</td></tr></table>
<p><a href="../../src/exec/vexec_q.c">../src/exec/vexec_q.c</a> l.6</p>
<a name="vfork"></a><dl>
<dt>
vfork
</dt>
<dd>
<p>
  <em>int DEF_syscall(vfork,0)</em><br>
 <strong>create a child process and block parent</strong>
<a href="../../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.138 manpage: <a href="../manpages/sys/vfork.2.rst.html">vfork</a><br>
</p>
</dd>
</dl>
<p></p>
<p></p>
<hr><p><small>
Last updated
 2021-08-04 15:28:59 UTC
</small></p>
</body>
</html>

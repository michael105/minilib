== unsorted



[[OPTFENCE]]
OPTFENCE::

  _void  opt_fence(void*p,...)_ + 
-----
prevent gcc to optimize away registers and variables
 the macro OPTFENCE(...) can be invoked with any parameter.
 The parameters will get calculated, even if gcc doesn't recognize
 the use of the parameters, e.g. cause they are needed for an inlined asm syscall.

 The macro translates to an asm jmp and a function call to the function 
 opt_fence, which is defined with the attribute "noipa" -
 (the compiler "forgets" the function body, so gcc is forced
 to generate all arguments for the function)
 The generated asm jump hops over the call to the function,
 but this gcc doesn't recognize.

 This generates some overhead, 
 (a few (never reached) bytes for setting up the function call, and the jmp)
 but I didn't find any other solution,
 which gcc wouldn't cut for optimizations from time to time.
 (volatile, volatile asm, optimize attributes, 
 andsoon have all shown up to be unreliable - sometimes(!)).

 Had some fun debugging these bugs, which naturally showed up only sometimes.
 (Many syscalls also work with scrambled arguments..)
 And, I believe it IS a compiler bug. 
 Volatile should be volatile for sure, not only sometimes.
 I mean, why the heck do I write volatile?? 
-----
link:../../include/syscall.h[../include/syscall.h] l.65 

[[def]]
def::

  _#define SETOPT_short( opts, option ) (_ + 
-----
Set a option flag(s) (bit(s))  manually.
		param options: e.g. just a, or ( a+h+l) to check for several flags at once
-----
link:../../macros/getoptm.h[../macros/getoptm.h] l.52 

[[group_printf]]
group_printf::

  _//_ + 
 *Defines:* uitodec eprintf fileno write ltodec + 
-----
printf, eprintf, fprintf, itodec and ltodec (conversions %d %l), 
-----
link:../../macros/defgroups.h[../macros/defgroups.h] l.29 

[[optimization_fence]]
optimization_fence::

  _void  optimization_fence(void*p)_ + 
-----
prevent optimizations.
 cast a var to void*, and calling this,
 leaves the compiler unknown on what he can strip.
 (noipa) means the compiler doesn't know, what the function itself does.
 (the function does nothing, but don't tell that gcc, please..)
 therefore, everything used as parameter to this function,
 will be calculated, defined, and so on before.
 It's used for the globals, 
 shich are pushed within _start onto the stack.
 since _start itself only provides a global pointer,
 and initialitzes some of the globals,
 but doesn't use them again,
 this construction is needed.
 more funnily, the function will never be called.
 It's past the asm inline syscall to exit.
 But again, luckily gcc doesn't know.
 All other options, like having the globals volatile, 
 setting the optimization flag of _start to 0, 
 having a volatile asm call with the globals as param, and so on,
 have been useless. All after all, seems to me, ai has it's restrictions.
-----
link:../../include/minilib_global.h[../include/minilib_global.h] l.90 

[[qsort]]
qsort::

  _void qsort(void  *base,	size_t nel,	size_t width,	int (*comp)(const void *, const void *))_ + 
-----
(quick) shell sort routine
 following the tradition, this isn't exactly a quicksort algorithm,
 albite named quicksort.
 It is a shell sort implementation, originally done by Ray Gardner, 5/90;
 which in turn I did find within musl.
-----
link:../../src/qsort.c[../src/qsort.c] l.57 manpage: link:../manpages/stdlib/qsort.3.rst[qsort] +

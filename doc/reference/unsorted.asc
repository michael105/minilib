== unsorted



[[ALIGN]]
ALIGN::

  __ + 
-----
macros for alignment.
 They take a number or pointer, and align upwards to 2,4,8,..256
 There are the macros ALIGN_2 ALIGN_4 ALIGN_8 ...,
 and ALIGN_P, which aligns to the size of a pointer. (8 for amd64)
-----
link:../macros/alignment.h[../macros/alignment.h] l.9 

[[OPTFENCE]]
OPTFENCE::

  _void  opt_fence(void*p,...)_ + 
-----
prevent gcc to optimize away registers and variables
 the macro OPTFENCE(...) can be invoked with any parameter.
 The parameters will get calculated, even if gcc doesn't recognize
 the use of the parameters, e.g. cause they are needed for an inlined asm syscall.

 The macro translates to an asm jmp and a function call to the function 
 opt_fence, which is defined with the attribute "noipa" -
 (the compiler "forgets" the function body, so gcc is forced
 to generate all arguments for the function)
 The generated asm jump hops over the call to the function,
 but this gcc doesn't recognize.

 This generates some overhead, 
 (a few (never reached) bytes for setting up the function call, and the jmp)
 but I didn't find any other solution,
 which gcc wouldn't cut for optimizations from time to time.
 (volatile, volatile asm, optimize attributes, 
 andsoon have all shown up to be unreliable - sometimes(!)).

 Had some fun debugging these bugs, which naturally showed up only sometimes.
 (Many syscalls also work with scrambled arguments..)
 And, I believe it IS a compiler bug. 
 Volatile should be volatile for sure, not only sometimes.
 I mean, why the heck do I write volatile?? 
-----
link:../include/syscall.h[../include/syscall.h] l.65 

[[OPTIMIZATIONS]]
OPTIMIZATIONS::

  __ + 
-----
enable some optimizations,
 with a slitghtly bigger memory footprint.
 defaults to off
 (yet only calloc is optimized. todo)
-----
link:../include/config.h[../include/config.h] l.33 

[[_die]]
_die::

  _void _die()_ + 
-----
internal implementation of die
-----
link:../src/die.c[../src/die.c] l.36 

[[_match]]
_match::

  _int _match(char *text, const char *re, text_match *st_match)_ + 
link:../src/match.c[../src/match.c] l.96 

[[_match_ext2]]
_match_ext2::

  _char* _match_ext2(char *text, char *re, void(*p_matched_cb)(int number, char *pos,int len), int(*p_wildcard_cb)(int number, char *match_char), text_match *st_match)_ + 
-----
internal implementation of match_ext
-----
link:../src/match_ext2.c[../src/match_ext2.c] l.326 

[[bsd_cksum]]
bsd_cksum::

  _unsigned int bsd_cksum( const char* p, unsigned int len )_ + 
-----
bsd checksum
-----
link:../src/cksum.c[../src/cksum.c] l.31 

[[bsd_cksumblock]]
bsd_cksumblock::

  _unsigned int bsd_cksumblock( unsigned int hash, const char* p, unsigned int len )_ + 
-----
bsd checksum, called by bsd_cksum,
 with initial hash value
-----
link:../src/cksum.c[../src/cksum.c] l.20 

[[calloc]]
calloc::

  _void* calloc(int size)_ + 
link:../src/calloc.c[../src/calloc.c] l.2 manpage: link:manpages/stdlib/memory.3.rst[calloc] +


[[cfmakeraw]]
cfmakeraw::

  _void cfmakeraw(struct termios *tp)_ + 
link:../src/termios/cfmakeraw.c[../src/termios/cfmakeraw.c] l.3 manpage: link:manpages/gen/tcsetattr.3.rst[cfmakeraw] +


[[config]]
config::

  __ + 
-----
configuration settings, to be compiled statically.
 System specific paths, maximums, etc go here.
 Other values are within globaldefs.h;
 architecture specific values are within the folder headers.
-----
link:../include/config.h[../include/config.h] l.6 

[[def]]
def::

  _#define SETOPT_short( opts, option ) (_ + 
-----
Set a option flag(s) (bit(s))  manually.
		param options: e.g. just a, or ( a+h+l) to check for several flags at once
-----
link:../macros/getoptm.h[../macros/getoptm.h] l.52 

[[die]]
die::

  _#define die(errnum,msg) {ewritesl(msg);exit_errno(errnum);}_ + 
 *Defines:* execve errno_str exit write + 
-----
write msg to stderr and exit with failure
 if errno is defined and set, /bin/errno is executed to give a verbose error 
 message
 if errno is either not defined or not set,
 exit with -1
 
-----
link:../src/die.c[../src/die.c] l.11 

[[die_if]]
die_if::

  _#define die_if( when, errnum, msg ) if( when ) die( errnum, msg )_ + 
 *Defines:* execve errno_str exit write + 
-----
when arg1 is true, write msg to stderr and exit with failure
 if errno is defined and set, /bin/errno is executed to give a verbose error 
 message
 if errno is either not defined or not set,
 exit with -1
 
-----
link:../src/die.c[../src/die.c] l.59 

[[dief]]
dief::

  _#define dief(errnum,fmt,...) {fprintf(stderr,fmt,__VA_ARGS__);exit_errno(errnum);}_ + 
 *Defines:* fileno write strlen execve exit errno_str + 
-----
write fmt andargs via fprintf to stderr and exit with failure
 if errno is defined and set, /bin/errno is executed to give a verbose error 
 message
 if errno is either not defined or not set,
 exit with -1
 
-----
link:../src/die.c[../src/die.c] l.20 

[[dief_if]]
dief_if::

  _#define dief_if( when, errnum, fmt,... ) if( when ) dief( errnum, fmt, __VA_ARGS__ )_ + 
 *Defines:* execve errno_str exit write + 
-----
when arg1 is true, vall dief(errnum,fmt)
 if errno is defined and set, /bin/errno is executed to give a verbose error 
 message
 if errno is either not defined or not set,
 exit with -1
 
-----
link:../src/die.c[../src/die.c] l.69 

[[dies]]
dies::

  _#define dies(errnum,...) {eprintsl(__VA_ARGS__);exit_errno(errnum);}_ + 
 *Defines:* errno_str execve write exit + 
-----
write variable string list to stderr and exit with failure
 if errno is defined and set, /bin/errno is executed to give a verbose error 
 message
 if errno is either not defined or not set,
 exit with -1
 
-----
link:../src/die.c[../src/die.c] l.30 

[[dies_if]]
dies_if::

  _#define dies_if( when, errnum, ... ) if( when ) dies( errnum, __VA_ARGS__ )_ + 
 *Defines:* exit write execve errno_str + 
-----
when arg1 is true, vall dies(errnum, ... )
 if errno is defined and set, /bin/errno is executed to give a verbose error 
 message
 if errno is either not defined or not set,
 exit with -1
 
-----
link:../src/die.c[../src/die.c] l.80 

[[dirbuf_malloc]]
dirbuf_malloc::

  _#ifndef mini_dirbuf_malloc_ + 
-----
which malloc to use for allocating the dir handles
 malloc : use malloc, therefore the minibuf
 malloc_brk : use malloc_brk 
 defaults to malloc
-----
link:../include/dirent.h[../include/dirent.h] l.31 

[[eprintf]]
eprintf::

  _#define eprintf(fmt,...) fprintf(stderr, fmt, __VA_ARGS__)_ + 
 *Defines:* strlen fileno write + 
-----
write fmt and arguments to stderr. 
-----
link:../include/prints.h[../include/prints.h] l.132 

[[ewritesl]]
ewritesl::

  _#define ewritesl(str) write(STDERR_FILENO,str,sizeof(str));write(STDERR_FILENO,"\n",1)_ + 
 *Defines:* write + 
-----
write the constant str to stderr, followed by a newline. 
 Computes length with sizeof(str) at compile time.
-----
link:../include/prints.h[../include/prints.h] l.101 

[[fgetsn]]
fgetsn::

  _int fgetsn(char *buf, int size, FILE* F)_ + 
 *Defines:* fileno read + 
-----
get a line like fgets, but return the len of the read string.
-----
link:../src/fgetsn.c[../src/fgetsn.c] l.4 

[[fgetsp]]
fgetsp::

  _char* fgetsp(char *buf, int size, FILE* F)_ + 
 *Defines:* read fileno + 
-----
read a line from F into buf with max chars size.
 Return a pointer to the terminating '0' byte.
 A terminating linebreak is not written to buf.
-----
link:../src/fgetsp.c[../src/fgetsp.c] l.7 

[[fgetud]]
fgetud::

  _unsigned int fgetud(FILE* F)_ + 
 *Defines:* read fileno + 
-----
read an unsigned integer from the stream F
 reads all digits until a nondigit is read.
-----
link:../src/fgetud.c[../src/fgetud.c] l.5 

[[fgetul]]
fgetul::

  _unsigned long int fgetul(FILE* F)_ + 
 *Defines:* fileno read + 
-----
read an unsigned long integer from the stream F
 reads all digits until a nondigit is read.
-----
link:../src/fgetul.c[../src/fgetul.c] l.5 

[[flock]]
flock::

  _int flock( unsigned int fd,  unsigned int cmd)_ + 
link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.127 manpage: link:manpages/sys/flock.2.rst[flock] +


[[fwritesl]]
fwritesl::

  _#define fwritesl(fd,str) write(fd,str,sizeof(str));write(fd,"\n",1)_ + 
 *Defines:* write + 
-----
write the constant str to fd,followed by a newline. 
 Computes length with sizeof(str) at compile time.
-----
link:../include/prints.h[../include/prints.h] l.114 

[[getgrouplist]]
getgrouplist::

  _int getgrouplist(const char* user, gid_t group, gid_t *groups, int *ngroups)_ + 
 *Defines:* write passwdfile_open setgrent mmap setpwent grent pwent token_i token_s open + 
-----
needs rewrite.
 now nonstandard.
-----
link:../src/userdb/getgrouplist.c[../src/userdb/getgrouplist.c] l.5 manpage: link:manpages/gen/getgrouplist.3.rst[getgrouplist] +


[[getgroups]]
getgroups::

  _int getgroups(int maxgroups, int *list)_ + 
 *Defines:* token_s token_i open mmap setpwent passwdfile_open pwent setgrent write getuid grent + 
-----
get the groups of the calling process
 does not necessarily contain the primary group,
 which is given in the passwd entry.
 This function calls internally setgrent() and getgrent();
 therefore any iteration with getgrent will be resetted.
-----
link:../src/userdb/getgroups.c[../src/userdb/getgroups.c] l.8 manpage: link:manpages/sys/getgroups.2.rst[getgroups] +


[[getusergroups]]
getusergroups::

  _int getusergroups(const char* user, int maxgroups, int *list)_ + 
 *Defines:* open token_i token_s grent pwent write setgrent mmap setpwent passwdfile_open + 
-----
get the supplementary groups for the user uid.
 does not necessarily contain the primary group,
 which is given in the passwd entry.
 This function calls internally setgrent() and getgrent();
 therefore any iteration with getgrent will be resetted.
-----
link:../src/userdb/getusergroups.c[../src/userdb/getusergroups.c] l.8 

[[group_printf]]
group_printf::

  _//_ + 
 *Defines:* write fileno atoi itooct uitoHEX strlen globals uitodec uitohex ltodec + 
-----
printf, eprintf, fprintf, itodec, ltodec, itohex, anprintf, sprintf (conversions %d %l %x %ud %ul %ux ), 
-----
link:../macros/defgroups.h[../macros/defgroups.h] l.29 

[[initgroups]]
initgroups::

  _int initgroups(const char* user, gid_t group)_ + 
link:../src/userdb/initgroups.c[../src/userdb/initgroups.c] l.2 manpage: link:manpages/gen/initgroups.3.rst[initgroups] +


[[lstat]]
lstat::

  _int lstat(const char* filename,struct stat* statbuf)_ + 
link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.111 manpage: link:manpages/sys/stat.2.rst[lstat] +


[[match_ext]]
match_ext::

  _int match_ext(char *text, const char *re, void(*p_match)(int number, char *pos,int len, void *userdata), int(*p_match_char)(int number, char *match_char, void *userdata), tmatch_ext *st_match, void *userdata)_ + 
-----
text matching engine

 This is somewhere between a fully fledged expression machine,
 and a simplicistic solution.
 Consciusly named 'text matching', since the inherent logic
 is quite different to a regular expression machine.

 The engine matches from left to right,
 backtracking is done as less as possible.
 Since the matching is nongreedy in general,
 many tries can be spared. Opposed to another route,
 where most patterns are per default greedy, and therfore
 not the first matching next char is seeked for, but the first
 solution while matching the most chars.
 (I do not want to make this a hard statement, and it 
 depends onto each pattern. But it is the way, the solution
 of the pattern is searched for, in most patterns.)
 This shows up in the logic of the patterns, which is more natural to me.

 It is a compromise between performance, size
 and capabilities.
 The logic is different of a "regular" regular expression
 machine, but has advantages (and disadvantages).
 I'd say, the main advantage is the easiness of adding callbacks,
 and defining your own matching/logic within these. 
 Performance might be better as well overall,
 but this depends also on the expressions.

 A few nonextensive benchmarks show,
 this engine is a bit faster than perl's regular expression machine,
 slower than gnu grep (around factor2), and has the same speed as sed.
 This might however vary with each usecase.
 In favor of codesize I'm not going to optimize match_ext,
 but there would be several possibilities, if you'd need a faster engine.
 (Albite I'd like to emphasise, sed (and match_ext), also perl, are quite fast.
 About 10 times faster than most expression engines.)

 matches: 
 
 * for every count of any char
 + for 1 or more chars
 ? for 1 char
 # for space or end of text (0)
 $ match end of text

 backslash: escape *,?,%,$,!,+,#,& and backslash itself.
 !: invert the matching of the next character or character class
 ,: separator. e.g. %,1 matches like ?*1. 
   ( without the commata, the '1' would be part of the % match)
  

 predefined character classes:
 \d - digit
 \D - nondigit
 \s - space
 \S - nonspace
 \w - word character ( defined as ascii 32-126,160-255 )
 \W - nonword character ( defined as ascii 0-31,127-159 )


 [xyz]: character classes, here x,y or z 
   the characters are matched literally, also \,*,?,+,..
   it is not possible to match the closing bracket (])
   within a character class

 {nX}: counted match
  Match n times X.
  For X, all expressions are allowed.
  If you need to match a number at the first char of 'X',
  separate X by a commata. E.g. {5,0} matches 5 times '0'.

 %[1]..%[9]: matches like a '+',
  and calls the callback supplied as 3rd argument (when not null).
  the number past the %, e.g. %1, is optional,
  p_match will be callen with this number
  as first parameter.
  When not supplied, p_matched will be callen with 
  the parameter 'number' set to 0.

  The matching is 'nongreedy'.
  It is possible to rewrite the string to match
  from within the p_matched callback.
  This will not have an effect onto the current matching,
  even if text is e.g. deleted by writing 0's.
  The matched positions are called in reverse order.
  (The last matched % in the regex calls p_match first, 
  the first % in the regex from the left will be callen last)

 supply 0 for p_matched, when you do not need to extract matches.
 This will treat % in the regex like a *, 
 a following digit (0..9) in the regex is ignored.
 if the 5th argument, a pointer to a tmatch_ext struct, 
 is supplied, it will be filled with the first match.
 (counting from left)


 &[1] .. &[9]
  "match" like a '?' and call p_match_char
  p_match_char has to return either RE_MATCH, RE_NOMATCH, RE_MATCHEND
  or a number of the count of chars, which have been matched.

  Therefore it is possible to e.g. rule your own
  character classes, defined at runtime, 
  or do further tricks like changing the matched chars,
  match several chars, andsoon.
  When returning RE_NOMATCH,
  it is possible, the p_match and p_match_char callbacks are callen several times,
  but with different pos or len parameters.

  The matching works straight from left to right.
  So, a "*&*" will call the callback & for the first char.
  When returning RE_NOMATCH, the second char will be matched.
  Until either RE_MATCH is returned from the callback,
  or the last char has been matched.

  Matching several characters is also posssible from within the callback,
  the position within the text will be incremented by that number,
  you return from the callback.

  When returning RE_MATCHEND from the callback, 
  the whole regular expression is aborted, and returns with matched;
  no matter, if there are chars left in the expression.


  The difference between % and & is the logic.
  % matches nongreedy, and has to check therefore the right side of the star
  for its matching.
  Possibly this has to be repeated, when following chars do not match.

  & is matched straight from left to right.
  Whatever number you return, the textpointer will be incremented by that value.
  However, a & isn't expanded on it's own. ( what a % is ).
  e.g. "x%x" will match 'aa' in xaax, x&x will match the whole expression
  only, when you return '2' from the callback.

  Performancewise, matching with & is faster,
  since the % has on its right side to be matched
  with recursing calls of match_ext.

 When using closures for the callbacks, you will possibly have to
 enable an executable stack for the trampoline code
 of gcc. Here, gcc complains about that. 
 For setting this bit, have a look into the ldscripts in the folder
 with the same name.

 supply 0 for p_match_char, when you don't need it.
 This will treat & in the regex like ?, 
 and match a following digit (0..9) in the text,
 a following digit (0..9) in the regex is ignored.
 
 -----
 In general, you have to somehow invert the logic of regular expressions
 when using match_ext.
 e.g. when matching the parameter 'runlevel=default' at the kernel's
 commandline, a working regular expression would be
 "runlevel=(\S*)". This could be written here as "*runlevel=%#".
 For matching e.g. numbers, you'd most possibly best of
 with writing your own & callback.

 returns: 1 on match, 0 on no match
 ( RE_MATCH / RE_NOMATCH )

 if the pointer (argument 5) st_match is nonnull,
 the supplied struct tmatch_ext will be set to the first matching '%' location;
 if there is no match, tmatch_ext.len will be set to 0.
 The struct is defined as: 
 typedef struct _tmatch_ext { char* pos; int len; } tmatch_ext;


 (memo) When the regex ist defined within C/cpp source code,
 a backslash has to be defined as double backslash.

 (note) - be careful when negating a following *, or ?.
  somehow - it is logical, but seems to me I overshoot a bit,
  tragically hit my own foot, and stumbled into a logical paradox.

  Negating EVERYTHING translates to true.
  However, since truth is negated as well, there's a problem,
  cause it's now 'false', but 'false' is true. This is very close
  to proving 42 is the answer. What is the escape velocity
  in km/s out of the solar system, btw.

  (I'm not kidding here. Just don't do a regex with !* or !?..
  And, please, do not ask me what is going to happen when the impossible
  gets possibilized. I have to point at the according sentences of the BSD license;//  there is NO WARRANTY for CONSEQUENTIAL DAMAGE, LOSS OF PROFIT, etc pp.)

  A "!+" will translate into nongreedy matching of any char, however;
  "%!+" will match with % everything but the last char;
  while "%+" matches with % only the first char.
  !+ basically sets the greedyness of the left * or % higher.
-----
link:../src/match_ext.c[../src/match_ext.c] l.193 

[[match_ext2]]
match_ext2::

  _int match_ext2(char *text, char *re, void(*p_matched_cb)(int number, char *pos,int len), int(*p_wildcard_cb)(int number, char *match_char),text_match *st_match)_ + 
-----
text matching engine

 WORK IN PROGRESS, please use ext_match
 Atm, please nested brackets are featureful.
 nesting {} within () seems to work.
 Nesting round brackets within {} gives sometimes
 trouble, when wildcards are used within the brackets.
 I'm leaving this at it is for now. 
 Possibly I'm going to hardcode an error message for nested brackets,
 or nested brackets with wildcards.

 This is somewhere between a fully fledged expression machine,
 and a simplicistic solution.
 Consciusly named 'text matching', since the inherent logic
 is quite different to a regular expression machine;
 "natural expressions" might fit better for the name.

 The engine matches from left to right,
 backtracking is done as less as possible.
 Since the matching is nongreedy in general,
 many tries can be spared. Opposed to another route,
 where most patterns are per default greedy, and therfore
 not the first matching next char is seeked for, but the first
 solution while matching the most chars.
 (I do not want to make this a hard statement, and it 
 depends onto each pattern. But it is the way, the solution
 of the pattern is searched for, in most patterns.)
 This shows up in the logic of the patterns, which is more natural to me.
 Your mileage might vary.


 It is a compromise between performance, size
 and capabilities.
 The logic is different of a "regular" regular expression
 machine, but has advantages (and disadvantages).
 I'd say, the main advantage is the easiness of adding callbacks,
 and defining your own matching/logic within these. 
 Performance might be better as well overall,
 but this depends on the expressions and usecases as well.

 Yet I for myself have to get a grip of the possibilities of this engine.
 However, I have the feeling, the logic is much more natural.
 With regular regexes you always have to think kind of 'backwards',
 e.g., match ".*" -> match "." (any char) x times. 
 gets to a simple "*"
 or, to match all group and user id's of /etc/passwd,
 a regular expression would be: "(\d*):(\d*)"
 This is here: "*(\d*):(\d*)*"
 The content in the brackets looks the same,
 but it's matched quite different.
 The regular expression (the first) matches x times \d, for x>=0.
 In the second expressin, the ext_match expression,
 the first digit is matched, and then nongreedy any chars, until
 the first occurence of ':'. 
 It is another logic. Whether it suits you, you have to decide.

 The callbacks have shown up to be a mighty tool, while
 at the same time having a good performance. 
 

 A few nonextensive benchmarks show,
 this engine is a bit faster than perl's regular expression machine,
 slower than gnu grep (around factor2), and has the same speed as sed.
 This might vary with each usecase, but the callbacks for extracting matches
 have some advantage, as well as the strict left to right and nongreedy parsing.

 In favor of codesize I'm not going to optimize ext_match,
 but there would be several possibilities, if you'd need a faster engine.
 (Albite I'd like to emphasise, sed (and ext_match), also perl, are quite fast.
 About 5 to 10 times faster than most expression engines.)

 matches: 
 
 * for every count of any char
 + for 1 or more chars
 ? for 1 char
 # for space, end of text (\0), linebreak, tab ( \t \n \f \r \v )
 @ matches the beginning of the text or endofline (\n) 
 $ match end of text (\0) or linebreak

 backslash: escape *,?,%,@,$,!,+,#,& and backslash itself.
 !: invert the matching of the next character or character class
 ,: separator. e.g. %,1 matches like ?*1. 
   ( without the commata, the '1' would be part of the % match)
  

 predefined character classes:
 \d - digit
 \D - nondigit
 \s - space
 \S - nonspace
 \w - word character ( defined as ascii 32-126,160-255 )
 \W - nonword character ( defined as ascii 0-31,127-159 )
 \x - hexadecimal digit (0-9,a-f,A-F)


 [xyz]: character classes, here x,y or z 
   the characters are matched literally, also \,*,?,+,..
   it is not possible to match the closing bracket (])
   within a character class

 {nX}: counted match
  Match n times X.
  For X, all expressions are allowed.
  If you need to match a number at the first char of 'X',
  separate X by a commata. E.g. {5,0} matches 5 times '0'.
  n can be a number, * or +. 
  ('*' matches 0 or more, '+' 1 or more times)

 (X): match the subexpression X. atm, no nesting of round () and {} brackets allowed

 %[1]..%[9]: matches like a '+',
  and calls the callback supplied as 3rd argument (when not null).
  the number past the %, e.g. %1, is optional,
  p_matched_cb will be callen with this number
  as first parameter.
  When not supplied, p_matched_cb will be callen with 
  the parameter 'number' set to 0.

  The matching is 'nongreedy'.
  It is possible to rewrite the string to match
  from within the p_matched_cb callback.
  This will not have an effect onto the current matching,
  even if text is e.g. deleted by writing 0's.

  The matched positions are called in reverse order.

  (The last matched % in the regex calls p_matched_cb first, 
  the first % in the regex from the left will be callen last)
  / The regex is first matched; when the regex has matched,
  the %'s are filled/ the callbacks executed.
  (x) bracketed patterns are matched the same way.

  (Not like &, which callbacks are invoked, while matching)

 supply 0 for p_matched_cb, when you do not need to extract matches.
 This will treat % in the regex like a *, 
 a following digit (0..9) in the regex is ignored.
 if the 5th argument, a pointer to a text_match struct, 
 is supplied, it will be filled with the first match.
 (counting from left)


 &[1] .. &[9]
  "match" like a '?' and call p_wildcard_cb
  p_wildcard_cb has to return either RE_MATCH, RE_NOMATCH, RE_MATCHEND
  or the number of the count of chars, which have been matched.

  Therefore it is possible to e.g. rule your own
  character classes, defined at runtime, 
  or do further tricks like changing the matched chars,
  match several chars, andsoon.
  When returning RE_NOMATCH,
  it is possible, the p_wildcard_cb callback is callen several times,
  but with different pos or len parameters, since p_wildcard_cb is
  invoked while matching.

  The matching works straight from left to right.
  So, a "*&*" will call the callback & for the first char.
  When returning RE_NOMATCH, the second char will be tried to match.
  Until either RE_MATCH is returned from the callback,
  or the last char of the text has been tried to match.

  Matching several characters is also posssible from within the callback,
  the position within the text will be incremented by that number,
  you return from the callback.

  When returning RE_MATCHEND from the callback, 
  the whole expression is aborted, and returns with matched;
  no matter, if there are chars left in the expression.


  The difference between % and & is the logic.
  % matches nongreedy, and has to check therefore the right side of the star
  for its matching.
  Possibly this has to be repeated, when following chars do not match.

  & is matched straight from left to right.
  Whatever number you return, the textpointer will be incremented by that value.
  However, a & isn't expanded on it's own. ( what a % is ).
  e.g. "x%x" will match 'aa' in xaax, x&x will match the whole expression
  only, when you return '2' from the callback.

  Performancewise, matching with & is faster,
  since the % has on its right side to be matched
  with recursing calls of ext_match.

 When using closures for the callbacks, you will possibly have to
 enable an executable stack for the trampoline code
 of gcc. Here, gcc complains about that. 
 For setting this bit, please have a look into the ldscripts in the folder
 with the same name.

 supply 0 for p_wildcard_cb, when you don't need it.
 This will treat & in the regex like ?, 
 and match a following digit (0..9) in the text,
 a following digit (0..9) in the regex is ignored.
 
 -----
 In general, you have to somehow invert the logic of regular expressions
 when using ext_match.
 Regular expressions could be regarded as "polish rpn notation",
 first the char to be matched, then the count.
 This expression machine could be described as "natural expression" machine.
 First you define the number, then the chars or expression to be matched.
 
 Furthermore, *,% and + match as less as possible.
 You have to think about what needs to follow the wildcards.

 e.g. when matching the parameter 'runlevel=default' at the kernel's
 commandline, a working regular expression would be
 "runlevel=(\S*)". This could be written here as "*runlevel=%#".
 For matching e.g. numbers, you'd most possibly best of
 with writing your own & callback.

 returns: 1 on match, 0 on no match
 ( RE_MATCH / RE_NOMATCH )

 if the pointer (argument 5) st_match is nonnull,
 the supplied struct text_match will be set to the first matching '%' location;
 if there is no match, text_match.len will be set to 0.
 The struct is defined as: 
 typedef struct _text_match { char* pos; int len; } text_match;


 (memo) When the regex ist defined within C/cpp source code,
 a backslash has to be defined as double backslash.

 (note) - be careful when negating a following *, or ?.
  somehow - it is logical, but seems to me I overshoot a bit,
  tragically hit my own foot, and stumbled into a logical paradox.

  Negating EVERYTHING translates to true.
  However, since truth is negated as well, there's a problem,
  cause it's now 'false', but 'false' is true. This is very close
  to proving 42 is the answer. What is the escape velocity
  in km/s out of the solar system, btw.

  (I'm not kidding here. Just don't do a regex with !* or !?..
  And, please, do not ask me what is going to happen when the impossible
  gets possibilized. I have to point at the according sentences of the BSD license;
  there is NO WARRANTY for CONSEQUENTIAL DAMAGE, LOSS OF PROFIT, etc pp.)

  A "!+" will translate into nongreedy matching of any char, however;
  "%!+" will match with % everything but the last char;
  while "%+" matches with % only the first char.
  !+ basically sets the greedyness of the left * or % higher.

 (work in progress here) please use ext_match
 return 0 for nomatch, the current textpos ( >0 ) for a match
 With the exception of an empty text, matched by e.g. "*".
 This will return 0, albite the regex formally matches, with 0 chars.

 (todo)
 bracket matching () and {} needs debugging. (test/extmatch2 for testing)
 Add a callback for bracket matches, and add a matchlist
 (linked list, allocated with malloc_brk)
 Trouble: e.g. *:(*) doesn't match, albite it should
  .. better. Now: # matches the end, after a bracket. Like it should
   $ doesn't. But should as well.
 change '+' to greedy matching of any char
 for {n,X} let n be * or + as well.
  (this would be closer to regular regulars again.?.)


 note. About a tokenizer:
 matching quoted string is really easy with the callback structure:
  just match with &. When a quote is matched, look forward to the next quote,
  and return that many chars. Same time, the quoted string is matched.
  That's so easy, it is hard to believe.
  When using closures for that, it is same time easy to collect all tokens.

  It is even easier. just a "*("*")*" is enough.

  ->There is something needed for partial matching. Possibly spare the last *, and return,
  as soon the pattern is at it's end (and not the text?)
  Already works this way. 

  Should start to define the language for the init scripts.
  Or better, start thinking abut that, but follow my other obligations the next time.

  Have to think thouroughly about what points would make such a language useful.
  The reason to think about that is clear - performance squeezing, faster startup time.
  And writing the startup scripts in C is. Well. little bit painful.
  However, together with minilib, there is nearly no difference between having a C program compiled
  and run, or working with scripts. To not have the overhead of linking the external libraries in,
  is of quite some advance.
  The only difference, the compiled binaries are "cached".
  have just to sort something sensible out for the systematic.
  Implement an own loader? possibly easy. Since the loading address is fixed.
  This could possibly also be the solution for the yet unclear question of the line between parsing
  arguments and calling the main function of the small core tools, andsoon.
  
 ..yet I've to fiddle out the possibilities (and quirks) of this machine.
 seems, this expression language did overpower it's creator.

 Bugs (features): 
 matching e.g. *matches*@*doesn't match*
 potentiates the *@* to many possibilities.
 One for every linebreak following 'matches'.
-----
link:../src/match_ext2.c[../src/match_ext2.c] l.306 

[[msync]]
msync::

  _int msync( void* addr,  size_t len, int flags)_ + 
link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.219 manpage: link:manpages/sys/msync.2.rst[msync] +


[[optimization_fence]]
optimization_fence::

  _void  optimization_fence(void*p)_ + 
-----
prevent optimizations.
 cast a var to void*, and calling this,
 leaves the compiler unknown on what he can strip.
 The function attribute noipa means,
 the compiler doesn't know, what the function itself does.
 (the function does nothing, but don't tell that gcc, please..)
 therefore, everything used as parameter to this function,
 will be calculated, defined, and so on before.
 It's used for the globals, 
 shich are pushed within _start onto the stack.
 since _start itself only provides a global pointer,
 and initialitzes some of the globals,
 but doesn't use them again,
 this construction is needed.
 more funnily, the function will never be called.
 It's past the asm inline syscall to exit.
 But again, luckily gcc doesn't know.
 All other options, like having the globals volatile, 
 setting the optimization flag of _start to 0, 
 having a volatile asm call with the globals as param, and so on,
 have been useless. All after all, seems to me, ai has it's restrictions.

 With less overhead the macro OPTFENCE(...) goes.
 There the call to the "ipa" function is jumped over,
 via asm inline instructions. 
-----
link:../include/minilib_global.h[../include/minilib_global.h] l.151 

[[prctl]]
prctl::

  _int prctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)_ + 
link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.225 

[[pwent]]
pwent::

  __ + 
link:../include/globaldefs.h[../include/globaldefs.h] l.218 

[[qsort]]
qsort::

  _void qsort(void  *base,	size_t nel,	size_t width,	int (*comp)(const void *, const void *))_ + 
-----
(quick) shell sort routine
 following the tradition, this isn't exactly a quicksort algorithm,
 albite named quicksort.
 It is a shell sort implementation, originally done by Ray Gardner, 5/90;
 which in turn I did find within musl.
-----
link:../src/qsort.c[../src/qsort.c] l.59 manpage: link:manpages/stdlib/qsort.3.rst[qsort] +


[[rt_sigsuspend]]
rt_sigsuspend::

  _int rt_sigsuspend( const sigset_t *mask, size_t sigsetsize)_ + 
link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.176 

[[setbrk]]
setbrk::

  _int setbrk(long addr)_ + 
 *Defines:* brk + 
-----
set the current brk
 wrapper for brk(), with type of brk changed to long
-----
link:../src/brk.c[../src/brk.c] l.39 

[[setenv]]
setenv::

  _int setenv( const char *name, const char *value, int overwrite )_ + 
 *Defines:* 0 ret_errno environ strcpy + 
-----
put a string into the environmental vars
 UNTESTED (!) TODO
 the supplied string's pointer is put into the environmental array of pointers.
 The supplied strings are copied into memory.
 If overwrite is zero, an existing environmental variable is not overritten.
 If overwrite is 1, the environmental variable is overwritten,
 but not(!) freed from memory.
 The supplied value is not checked for e.g. an '='

 Returns: 
 - 0 on success
 - EINVAL on error
-----
link:../src/setenv.c[../src/setenv.c] l.15 manpage: link:manpages/stdlib/getenv.3.rst[setenv] +


[[short_errstr]]
short_errstr::

  _const char* short_errstr(int num)_ + 
-----
short error (errno) string. 
 this adds about 2kB to the compiled binary(!)
-----
link:../include/errstrshort.h[../include/errstrshort.h] l.10 

[[sigsuspend]]
sigsuspend::

  _int sigsuspend( const sigset_t *mask )_ + 
link:../src/signal/sigaction.c[../src/signal/sigaction.c] l.51 manpage: link:manpages/sys/sigsuspend.2.rst[sigsuspend] +


[[stpcpy]]
stpcpy::

  _char *stpcpy(char *dest, const char *src)_ + 
-----
copy src to dest, return a pointer to the last char +1 ( ending '0' )
-----
link:../src/string/stpcpy.c[../src/string/stpcpy.c] l.3 manpage: link:manpages/string/string.3.rst[stpcpy] +


[[strlcpy]]
strlcpy::

  _char *strlcpy(char *dest, const char *src, int n)_ + 
-----
copy max n chars from src to dest, 
 when src is longer than dest, 
 end dest[n-1] with '\0'.
-----
link:../src/string/strlcpy.c[../src/string/strlcpy.c] l.5 manpage: link:manpages/string/strlcpy.3.rst[strlcpy] +


[[strtoll]]
strtoll::

  _long long int strtoll(const char *c, const char **endp, int base)_ + 
-----
conversion
 doesn't check for overflow(!)
 For linux x64, long long and long both have 64 bit.
 Therefore, strtoll just calls strtol
-----
link:../src/string/strtoll.c[../src/string/strtoll.c] l.7 manpage: link:manpages/stdlib/strtol.3.rst[strtoll] +


[[term_width]]
term_width::

  _int term_width()_ + 
 *Defines:* environ + 
-----
get the terminal width
 reads the environmental var COLS,
 if not present, returns 80.
 Doesn't check for the existence of a terminal.
-----
link:../src/termios/term_width.c[../src/termios/term_width.c] l.7 

[[token_i]]
token_i::

  _int token_i( userdb* udb, char **p )_ + 
link:../src/userdb/userdb.c[../src/userdb/userdb.c] l.33 

[[token_s]]
token_s::

  _char *token_s( userdb *udb, char **p )_ + 
-----
tokenizer for the passwd/group files.
 used by the group/user pwentry access functions.
 performance of subsequent calls could be improved by replacing all ':' and '\n'
 by 0's when loading the db file.
 it would be possible as well, testing not only single bytes, but
 integers of longs at once. However, in most cases, e.g.
 for big directories with many small files, in most cases 
 all files do have the same owner and group. Since the last result to calls
 of the access functions is cached,
 there wouldn't be an improvement by optimizing the tokenizing functions.
 So I'm leaving this for now, as it is.
 And most possibly it would be better to implement bsd's cached versions 
 of the user db access functions instead. 
-----
link:../src/userdb/userdb.c[../src/userdb/userdb.c] l.19 

[[unmap_protected]]
unmap_protected::

  _int unmap_protected(void *p, int len)_ + 
 *Defines:* mprotect munmap + 
link:../src/map_protected.c[../src/map_protected.c] l.41 

[[userdb_open]]
userdb_open::

  _int userdb_open(userdb *udb, const char* file)_ + 
 *Defines:* write globals + 
link:../src/userdb/userdb_open.c[../src/userdb/userdb_open.c] l.3 

[[where]]
where::

  _int where(const char *file,char *buf)_ + 
-----
locate an executable in PATH
-----
link:../src/exec/execvp.c[../src/exec/execvp.c] l.8 

[[writesl]]
writesl::

  _#define writesl(str) {write(STDOUT_FILENO,str,sizeof(str));write(STDOUT_FILENO,"\n",1);}_ + 
 *Defines:* write + 
-----
write the constant str to stdout, followed by a newline. 
 Computes length with sizeof(str) at compile time.
-----
link:../include/prints.h[../include/prints.h] l.95 
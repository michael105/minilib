minilib doc

Implemented Functions, sorted by the standard headers




==========
declarations.h
==========

chmod          chmod( const char *filename, mode_t mode)
               (include/syscall_stubs.h: 187)

dup3           dup3(int oldfd, int newfd, int flags)		
               (include/syscall_stubs.h: 114)

execveat       execveat( int dirfd, const char *filename,  char* const* argv, char* const* envp, int flags)
               (include/syscall_stubs.h: 153)

fchmod         fchmod( unsigned int fd, mode_t mode)
               (include/syscall_stubs.h: 110)

fchown         fchown( unsigned int fd, uid_t user, gid_t group)
               (include/syscall_stubs.h: 109)

fcntl          fcntl( unsigned int fd, unsigned int cmd, unsigned long arg)
               (include/syscall_stubs.h: 158)

fstat          fstat(int fd,struct stat* statbuf)
               (include/syscall_stubs.h: 105)

getcwd         getcwd( char *buf,  unsigned long size)
               (include/syscall_stubs.h: 116)

getdents       getdents( unsigned int fd, struct dirent *direntry, unsigned int count )
               (include/syscall_stubs.h: 100)

getitimer      getitimer( int which,  struct itimerval *value)
               (include/syscall_stubs.h: 201)

getppid        DEF_syscall(getppid,0)
               (include/syscall_stubs.h: 190)

gettimeofday   gettimeofday( struct timeval *a1, struct timezone *a2)
               (include/syscall_stubs.h: 132)

kill           kill( pid_t pid,  int sig)
               (include/syscall_stubs.h: 125)

memfd_create   memfd_create( const char  *uname_ptr,  unsigned int flags)
               (include/syscall_stubs.h: 170)

mknod          mknod( const char *filename,  umode_t mode,  unsigned dev)
               (include/syscall_stubs.h: 196)

mount          mount( char *dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)
               (include/syscall_stubs.h: 164)

mprotect       mprotect( POINTER *a1, POINTER a2, int a3 )
               Returns: *a1
               (include/syscall_stubs.h: 183)

munmap         munmap( unsigned long addr,  size_t len)
               (include/syscall_stubs.h: 198)

nanosleep      nanosleep( struct timespec *rqtp, struct timespec *rmtp)
               (include/syscall_stubs.h: 131)

pivot_root     pivot_root( const char *new_root,  const char *put_old)
               (include/syscall_stubs.h: 138)

readahead      readahead( int fd,  loff_t offset,  size_t count)
               (include/syscall_stubs.h: 194)

reboot         reboot( int magic1,  int magic2,  unsigned int cmd,  void *arg)
               (include/syscall_stubs.h: 162)

rt_sigaction   rt_sigaction( int sig,  const struct sigaction *act,  struct sigaction *oact,  size_t sigsetsize)
               (include/syscall_stubs.h: 134)

rt_sigprocmask rt_sigprocmask( int how,  sigset_t *nset,  sigset_t *oset,  size_t sigsetsize)
               (include/syscall_stubs.h: 166)

rt_sigreturn   rt_sigreturn( unsigned long __unused)
               (include/syscall_stubs.h: 135)

sendfile       sendfile( int out_fd,  int in_fd,  off_t *offset,  size_t count)
               (include/syscall_stubs.h: 161)

setgroups      setgroups( int gidsetsize,  gid_t *grouplist)
               (include/syscall_stubs.h: 178)

setitimer      setitimer( int which,  struct itimerval *value,  struct itimerval *ovalue)
               (include/syscall_stubs.h: 200)

splice         splice( int fd_in,  loff_t *off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)
               (include/syscall_stubs.h: 175)

stat           stat(const char* filename,struct stat* statbuf)		
               (include/syscall_stubs.h: 106)

symlink        symlink( const char *oldname,  const char *newname)
               (include/syscall_stubs.h: 119)

sync           DEF_syscall(sync,0)
               (include/syscall_stubs.h: 120)

umask          umask( int mask)
               (include/syscall_stubs.h: 186)

umount2        umount2( const char *mountpoint, int flags) 
               (include/syscall_stubs.h: 160)

uname          uname(struct old_utsname *name )
               (include/syscall_stubs.h: 148)

utime          utime( const char *filename, struct utimbuf *times)
               (include/syscall_stubs.h: 189)

vfork          DEF_syscall(vfork,0)
               (include/syscall_stubs.h: 128)

vhangup        DEF_syscall(vhangup,0 )
               (include/syscall_stubs.h: 146)

wait4          wait4( pid_t upid,  int *stat_addr,  int options,  struct rusage *ru)
               (include/syscall_stubs.h: 156)



==========
dirent.h
==========

closedir       int closedir(DIR *dir);
               Defines: brk getbrk
               (src/dirent/closedir.c: 6)

opendir        static DIR *opendir(const char *name );
               Defines: close open brk write dirbuf
               (src/dirent/opendir.c: 24)

readdir        struct dirent *readdir(DIR *dir);
               Defines: dirbuf getdents
               (src/dirent/readdir.c: 10)
               read a directory.
              return the next dirent, or 0, if the end is reached.
              return 0 on error and set errno,
              if mini_errno is not defined, return -errno on error

rewinddir      void rewinddir(DIR *dir);
               (src/dirent/rewinddir.c: 2)

scandir        int scandir(const char *path, struct dirent **listing[], int (*fp_select)(const struct dirent *),	int (*cmp)(const struct dirent **, const struct dirent **));
               Defines: brk sbrk memcpy dirbuf qsort_pp write seterrno errno open getbrk
               (src/dirent/scandir.c: 32)
               list files and dirs in a directory
              !!! sorting doesn't ork. Seems to be a gcc bug, since
              it is amongst others optimization flag dependent.
              
              I leave this for now.
             
              This implementation uses malloc_brk() for the dynamic allocation
              of the listing, and tries to do as less copies as possible.
              if the select callback is 0, meaning all entries should be returned,
              There are no copies done at all, 
              besides the copying from kernelspace to userspace.
              returns the number of the read entries,
              or the negative errno on error.
              To free the space, allocated for thelisting and the dirents, 
              either call free_brk(),
              when no other allocations via malloc_brk took place.
              Or save the brk before you call scandir,
              and restore it after the call.
              (e.g.)
              long savebrk=getbrk();
              int ret=scandir(...);
              brk(savebrk);

seekdir        void seekdir(DIR *dir, long off);
               (src/dirent/seekdir.c: 2)

telldir        long telldir(DIR *dir);
               (src/dirent/telldir.c: 2)



==========
errno.h
==========

errno          #ifdef mini_errno
               (include/seterrno.h: 3)
               set errno, but only when errno is defined.



==========
fcntl.h
==========

creat          int volatile creat( const char *s, int mode );
               Defines: open
               (src/open.c: 36)

mkfifo         static int mkfifo( const char* path, mode_t mode );
               (include/mkfifo.h: 4)



==========
ioctl.h
==========

ioctl          int volatile  __attribute__((optimize("O0"))) ioctl( int fd, unsigned long int request, ... );
               (src/ioctl.c: 11)



==========
mini_addons.h
==========

_itobin        int _itobin(int i, char*buf, int prec, int groups );
               (src/itobin.c: 8)

_mprints       #define _mprints(...) dprints(STDOUT_FILENO, __VA_ARGS__)
               Defines: write
               (src/prints.c: 69)

basename       char *basename(char *path);
               Defines: strlen
               (src/basename.c: 29)

brk            static int brk( const void* addr );
               (src/brk.c: 19)
               set the brk to addr
              return 0 on success.
              conformant brk, when mini_errno is defined return -1 and set errno.
              if errno isn't available,
              returns the negative errno value on error

def            #define SETOPT_short( opts, option ) (;
               (macros/getoptm.h: 52)
               Set a option flag(s) (bit(s))  manually.
             		param options: e.g. just a, or ( a+h+l) to check for several flags at once

dirbuf         
               (include/dirent.h: 7)
               the switch for defining the dirbuf.
              used internally

dirbufsize     #ifndef mini_dirbufsize
               (include/dirent.h: 22)
               the dir stream bufsize
              The size of the buffer can be changed by setting mini_dirbufsize
              to it's size in Bytes. (default 2048)
              The buffer is allocated via malloc,
              therefore mini_buf must be set to a value greater than dirbufsize

dirfd          int dirfd(DIR *d);
               (src/dirent/dirfd.c: 2)

dirname        char *dirname(char *s);
               Defines: strlen
               (src/dirname.c: 8)

djb2_hash      unsigned long djb2_hash(const unsigned char *str);
               (src/hashes.c: 10)
               hashes, from d.j.Bernstein
              (http://www.cse.yorku.ca/~oz/hash.html)
              I've tested djb2_hash, and it gives quite good results.
              But I'm sure, Bernstein did think and test his algorithm sincerely.
              When combining djb2_hash and sdbm_hash, the probability of collisions
              might tend to zero.
              Me I'm going this way. I guess. I might check djb2_hash for collisions within a space of around 8 digits.

dprintf        int dprintf( int fd, const char *fmt, ... );
               Defines: write
               (src/sprintf.c: 203)

dprints        int dprints(int fd, const char *msg,...);
               Defines: write
               (src/prints.c: 48)

dtodec         int dtodec(double d, char* buf, int precision);
               Defines: uitodec
               (src/dtodec.c: 10)

eprint         #define eprint(str) write(STDERR_FILENO,str,strlen(str))
               Defines: write strlen
               (include/prints.h: 42)
               write str to stderr. Needs strlen

eprintfs       #define eprintfs(fmt,...) fprintfs(stderr, fmt, __VA_ARGS__)
               Defines: strlen fileno write
               (include/prints.h: 90)
               write str to stderr. 
              only format %s is recognized

eprintl        #define eprintl() write(STDERR_FILENO,"\n",1)
               Defines: write
               (include/prints.h: 67)
               write a newline to stderr

eprints        #define eprints(...) dprints(STDERR_FILENO,__VA_ARGS__,0)
               Defines: write
               (include/prints.h: 17)
               print the string(s) supplied as arg(s) to stdout

eputs          #define eputs(msg) ( eprint(msg) + eprintl() )
               Defines: strlen write
               (include/prints.h: 77)
               write msg to stderr, append a newline. Needs strlen.

errno_str      static char *errno_str(int err);
               (src/errno_str.c: 7)
               convert errno to str, with 3 chars length
              ending the string (global) 
              with two \0\0, when errno<100
              errnum must be <200.

ewrites        #define ewrites(str) write(STDERR_FILENO,str,sizeof(str))
               Defines: write
               (include/prints.h: 52)
               write the constant str to stderr. Computes length with sizeof(str) at compile time.

exit_errno     void exit_errno( int errnum );
               Defines: write exit execve errno_str
               (src/exit_errno.c: 17)
               exit, and execute /bin/errno
              this is intended to give a error message for the 
              given errno num.
              Instead of having the error messages compiled 
              into each binary, they can stay within one executable, "errno"
              This spares about 4kB, but needs errno installed to /bin/errno
              It's the drawback of not having a shared library,
              where all executables would share the same errno messages
              in memory.
              On the other hand, a shared library would need to be installed
              as well.
              The supplied errno can be negative,
              the absolute value is supplied to errno.

ext_match      int ext_match(const char *text, const char *re);
               (src/ext_match.c: 16)
               simple regex engine.
              matches: * for every count of any char
              ? for 1 char
              backslash: escape *,?, and backslash itself.
              \d - digit
              \D - nondigit
              \s - space
              \S - nonspace
              \w - word character ( defined as ascii 32-126,160-255 )
              \W - nonword character ( defined as ascii 0-31,127-159 )
             
              (memo) When the regex ist defined as C string,
              a backslash has to be defined as double backslash
              in the source code.

fexecve        static inline int fexecve(int fd, char *const argv[], char *const envp[]);
               (include/fexecve.h: 3)

fexecveat      static inline int fexecveat(int fd, char *const argv[], char *const envp[]);
               (include/fexecveat.h: 3)

fprintfs       int fprintfs( FILE* F, char *fmt, ...);
               Defines: write fileno strlen
               (src/fprintfs.c: 10)
               prints formatted to the stream F.only %s and %c are recognized.no mini_buf needed, so using fprintfs instead of fprintf can save some sections / bytes.

fprints        #define fprints(F,str) write(fileno(F),str,strlen(str))
               Defines: write strlen fileno
               (include/prints.h: 24)
               print the string(s) supplied as arg(s) to stream

fwrites        #define fwrites(fd,str) write(fd,str,sizeof(str))
               Defines: write
               (include/prints.h: 58)
               write the constant str to fd. Computes length with sizeof(str) at compile time.

getbrk         static long getbrk();
               (src/brk.c: 39)
               get the current brk
              does either a syscall to brk,
              or returns the globally saved var

grantpt        int grantpt(int fd);
               (src/pty.c: 13)

itobin         #define itobin(A,B,...) _itobin(A,B,VARARG(SHIFT(__VA_ARGS__),0), VARARG(SHIFT(ARG( __VA_ARGS__ )),32) )
               Defines: 
               (src/itobin.c: 41)

itodec         int itodec(int i, char *buf, int prec, char limiter );
               Defines: uitodec
               (src/itodec.c: 116)

ltodec         int ltodec(long i, char *buf, int prec, char limiter );
               (src/ltodec.c: 75)

macro          static void __attribute__((noipa,cold)) optimization_fence(void*p){}
               (include/minilib_global.h: 90)
               prevent optimizations.
              cast a var to void*, and calling this,
              leaves the compiler unknown on what he can strip.
              (noipa) means the compiler doesn't know, what the function itself does.
              (the function does nothing, but don't tell that gcc, please..)
              therefore, everything used as parameter to this function,
              will be calculated, defined, and so on before.
              It's used for the globals, 
              shich are pushed within _start onto the stack.
              since _start itself only provides a global pointer,
              and initialitzes some of the globals,
              but doesn't use them again,
              this construction is needed.
              more funnily, the function will never be called.
              It's past the asm inline syscall to exit.
              But again, luckily gcc doesn't know.
              All other options, like having the globals volatile, 
              setting the optimization flag of _start to 0, 
              having a volatile asm call with the globals as param, and so on,
              have been useless. All after all, seems to me, ai has it's restrictions.

match          int match(const char *text, const char *re);
               (src/match.c: 10)
               simple regex engine.
              matches: * for every count of any char
              ? for 1 char
              backslash: escape *,?, and backslash itself.
             
              (memo) When the regex ist defined as C string,
              a backslash has to be defined as double backslash
              in the source code.

memfrob        void* memfrob(void* s, unsigned int len);
               (src/memfrob.c: 3)

mmap           static void* __attribute__((optimize("O0"))) mmap(void* addr,  size_t len,  int prot,  int flags,  int fd,  off_t off);
               (src/mmap.c: 8)
               mmap wrapper
              address length is rounded up to a multiple of pagesize (4096 Bytes here)
              for the description, please look up the according manpage
              errno is only set, when mini_errno is defined
              if not, on error the negative errno value is returned.
              (e.g. -22 for "invalid argument")

mremap         static void* volatile __attribute__((optimize("O0"))) mremap(void* addr, size_t old_len, size_t new_len, int flags, void* new_addr);
               (include/mremap.h: 4)

opendirp       static DIR *opendirp(const char *name, DIR *dir);
               Defines: dirbuf brk open close
               (src/dirent/opendir.c: 10)

posix_openpt   int posix_openpt(int flags);
               Defines: open
               (src/pty.c: 8)

print          #define print(str) write(STDOUT_FILENO,str,strlen(str))
               Defines: strlen write
               (include/prints.h: 38)
               write str to stdout. Needs strlen

printfs        #define printfs(fmt,...) fprintfs(stdout, fmt, __VA_ARGS__)
               Defines: write strlen fileno
               (include/prints.h: 84)
               write str to stdout. 
              only format %s is recognized

printl         #define printl() write(STDOUT_FILENO,"\n",1)
               Defines: write
               (include/prints.h: 63)
               write a newline to stdout

prints         #define prints(...) _mprints(__VA_ARGS__,0)
               Defines: 
               (include/prints.h: 11)
               print the string(s) supplied as arg(s) to stdout

printsl        #define printsl(...) _mprints(__VA_ARGS__,"\n",0)
               Defines: 
               (include/prints.h: 32)
               print the string(s) supplied as arg(s) and newline to stdout

ptsname        char *ptsname(int fd);
               Defines: uitodec ioctl open write
               (src/pty.c: 40)

ptsname_r      int ptsname_r(int fd, char *buf, size_t len);
               Defines: open write uitodec ioctl
               (src/pty.c: 27)

qsort_p        void qsort_p(void **base, int count, int(*cmp)(void**,void**)) ;
               (src/qsort_p.c: 29)
               sort an array of pointers,
              sort the pointers itself 

qsort_pp       void qsort_pp(void ***base, int count, int(*cmp)(void*,void*)) ;
               (src/qsort_pp.c: 29)
               sort an array of pointers to pointers,
              sort the pointers to the pointers 

sbrk           static void* sbrk(long incr);
               (src/brk.c: 57)
               Set the new brk, increment/decrement by incr bytes.
              return the old brk on success.
              conformant sbrk, when mini_errno is defined
              if no errno is available,
              returns the negative errno value on error

scandir_bufsize
               (src/dirent/scandir.c: 5)
               the increment of the buffer of scandir in bytes for memory allocations
              (default:4096)

sdbm_hash      unsigned long sdbm_hash(const unsigned char *str);
               (src/hashes.c: 21)

snprintf       int snprintf( char *buf, size_t size, const char *fmt, ... );
               Defines: write
               (src/sprintf.c: 220)

swap           static inline void swap(void* a, void* b,int size);
               (src/qsort.c: 21)
               swap a with b, with 'size' bytes
              swaps integers and longs at once, when size eq sizeof(int/long)

sys_brk        static long sys_brk(unsigned long addr);
               (src/brk.c: 6)
               the kernel syscall brk.

uitodec        int __attribute__((optimize("Os")))uitodec(unsigned int i, char *buf, int prec, char limiter );
               (src/itodec.c: 8)
               convert int to string.
              prec: precision, e.g. 4=> 0087 

ultodec        int ultodec(unsigned long ui, char *buf, int prec, char limiter );
               (src/ltodec.c: 6)

unlockpt       int unlockpt(int fd);
               Defines: ioctl
               (src/pty.c: 20)

verbose_errstr const char* verbose_errstr(int num);
               (include/errstr.h: 8)
               verbose error (errno) string. 
              this adds about 3.5kB to the compiled binary(!)

verbose_errstr2static const char* verbose_errstr2(int num);
               (include/errstr2.h: 11)
               verbose error (errno) string. 
              this adds about 3.5kB to the compiled binary(!)
              Trying to shrink that here.

vexec          int vexec( const char* path, char* const* argv, char* const* envp );
               (src/vexec.c: 4)
               execute a path, wait until the executed file exits.
              instead of system() an absolute pathname is taken.

vsnprintf      int vsnprintf(char *buf, size_t size, const char* fmt, va_list args );
               Defines: write
               (src/sprintf.c: 41)
               the function, translating the fmt of printf.
              warning - most possibly you'd like to define besides fprintf, or family,
              mini_itodec (%d conversion) 
              mini_atoi is needed for grouping numbers

writes         #define writes(str) write(STDOUT_FILENO,str,sizeof(str))
               Defines: write
               (include/prints.h: 48)
               write the constant str to stdout. Computes length with sizeof(str) at compile time.



==========
mini_syscalls
==========

sys__sysctl                      (include/syscalls_x64.h: 315)

sys_accept                       (include/syscalls_x64.h: 91)

sys_accept4                      (include/syscalls_x64.h: 551)

sys_access                       (include/syscalls_x64.h: 47)

sys_acct                         (include/syscalls_x64.h: 329)

sys_add_key                      (include/syscalls_x64.h: 471)

sys_adjtimex                     (include/syscalls_x64.h: 321)

sys_alarm                        (include/syscalls_x64.h: 79)

sys_arch_prctl                   (include/syscalls_x64.h: 319)

sys_bind                         (include/syscalls_x64.h: 103)

sys_capget                       (include/syscalls_x64.h: 255)

sys_capset                       (include/syscalls_x64.h: 257)

sys_chdir                        (include/syscalls_x64.h: 165)

sys_chmod                        (include/syscalls_x64.h: 185)

sys_chown                        (include/syscalls_x64.h: 189)

sys_chroot                       (include/syscalls_x64.h: 325)

sys_clock_adjtime                (include/syscalls_x64.h: 585)

sys_clock_getres                 (include/syscalls_x64.h: 435)

sys_clock_gettime                (include/syscalls_x64.h: 433)

sys_clock_nanosleep               (include/syscalls_x64.h: 437)

sys_clock_settime                (include/syscalls_x64.h: 431)

sys_clone                        (include/syscalls_x64.h: 117)

sys_close                        (include/syscalls_x64.h: 11)

sys_connect                      (include/syscalls_x64.h: 89)

sys_creat                        (include/syscalls_x64.h: 175)

sys_delete_module                (include/syscalls_x64.h: 353)

sys_dup                          (include/syscalls_x64.h: 69)

sys_dup2                         (include/syscalls_x64.h: 71)

sys_dup3                         (include/syscalls_x64.h: 559)

sys_epoll_create                 (include/syscalls_x64.h: 407)

sys_epoll_create1                (include/syscalls_x64.h: 557)

sys_epoll_ctl                    (include/syscalls_x64.h: 443)

sys_epoll_pwait                  (include/syscalls_x64.h: 537)

sys_epoll_wait                   (include/syscalls_x64.h: 441)

sys_eventfd                      (include/syscalls_x64.h: 543)

sys_eventfd2                     (include/syscalls_x64.h: 555)

sys_execve                       (include/syscalls_x64.h: 123)

sys_exit                         (include/syscalls_x64.h: 125)

sys_exit_group                   (include/syscalls_x64.h: 439)

sys_faccessat                    (include/syscalls_x64.h: 513)

sys_fadvise64                    (include/syscalls_x64.h: 419)

sys_fallocate                    (include/syscalls_x64.h: 545)

sys_fanotify_init                (include/syscalls_x64.h: 575)

sys_fanotify_mark                (include/syscalls_x64.h: 577)

sys_fchdir                       (include/syscalls_x64.h: 167)

sys_fchmod                       (include/syscalls_x64.h: 187)

sys_fchmodat                     (include/syscalls_x64.h: 511)

sys_fchown                       (include/syscalls_x64.h: 191)

sys_fchownat                     (include/syscalls_x64.h: 495)

sys_fcntl                        (include/syscalls_x64.h: 149)

sys_fdatasync                    (include/syscalls_x64.h: 155)

sys_fgetxattr                    (include/syscalls_x64.h: 371)

sys_finit_module                 (include/syscalls_x64.h: 601)

sys_flistxattr                   (include/syscalls_x64.h: 377)

sys_flock                        (include/syscalls_x64.h: 151)

sys_fork                         (include/syscalls_x64.h: 119)

sys_fremovexattr                 (include/syscalls_x64.h: 383)

sys_fsetxattr                    (include/syscalls_x64.h: 365)

sys_fstat                        (include/syscalls_x64.h: 15)

sys_fstatfs                      (include/syscalls_x64.h: 279)

sys_fsync                        (include/syscalls_x64.h: 153)

sys_ftruncate                    (include/syscalls_x64.h: 159)

sys_futex                        (include/syscalls_x64.h: 389)

sys_futimesat                    (include/syscalls_x64.h: 497)

sys_get_mempolicy                (include/syscalls_x64.h: 453)

sys_get_robust_list               (include/syscalls_x64.h: 523)

sys_getcpu                       (include/syscalls_x64.h: 593)

sys_getcwd                       (include/syscalls_x64.h: 163)

sys_getdents                     (include/syscalls_x64.h: 161)

sys_getdents64                   (include/syscalls_x64.h: 411)

sys_getegid                      (include/syscalls_x64.h: 221)

sys_geteuid                      (include/syscalls_x64.h: 219)

sys_getgid                       (include/syscalls_x64.h: 213)

sys_getgroups                    (include/syscalls_x64.h: 235)

sys_getitimer                    (include/syscalls_x64.h: 77)

sys_getpeername                  (include/syscalls_x64.h: 109)

sys_getpgid                      (include/syscalls_x64.h: 247)

sys_getpgrp                      (include/syscalls_x64.h: 227)

sys_getpid                       (include/syscalls_x64.h: 83)

sys_getppid                      (include/syscalls_x64.h: 225)

sys_getpriority                  (include/syscalls_x64.h: 283)

sys_getrandom                    (include/syscalls_x64.h: 611)

sys_getresgid                    (include/syscalls_x64.h: 245)

sys_getresuid                    (include/syscalls_x64.h: 241)

sys_getrlimit                    (include/syscalls_x64.h: 199)

sys_getrusage                    (include/syscalls_x64.h: 201)

sys_getsid                       (include/syscalls_x64.h: 253)

sys_getsockname                  (include/syscalls_x64.h: 107)

sys_getsockopt                   (include/syscalls_x64.h: 115)

sys_gettid                       (include/syscalls_x64.h: 357)

sys_gettimeofday                 (include/syscalls_x64.h: 197)

sys_getuid                       (include/syscalls_x64.h: 209)

sys_getxattr                     (include/syscalls_x64.h: 367)

sys_init_module                  (include/syscalls_x64.h: 351)

sys_inotify_add_watch               (include/syscalls_x64.h: 483)

sys_inotify_init                 (include/syscalls_x64.h: 481)

sys_inotify_init1                (include/syscalls_x64.h: 563)

sys_inotify_rm_watch               (include/syscalls_x64.h: 485)

sys_io_cancel                    (include/syscalls_x64.h: 403)

sys_io_destroy                   (include/syscalls_x64.h: 397)

sys_io_getevents                 (include/syscalls_x64.h: 399)

sys_io_setup                     (include/syscalls_x64.h: 395)

sys_io_submit                    (include/syscalls_x64.h: 401)

sys_ioctl                        (include/syscalls_x64.h: 37)

sys_ioperm                       (include/syscalls_x64.h: 349)

sys_iopl                         (include/syscalls_x64.h: 347)

sys_ioprio_get                   (include/syscalls_x64.h: 479)

sys_ioprio_set                   (include/syscalls_x64.h: 477)

sys_kcmp                         (include/syscalls_x64.h: 599)

sys_kexec_file_load               (include/syscalls_x64.h: 615)

sys_kexec_load                   (include/syscalls_x64.h: 467)

sys_keyctl                       (include/syscalls_x64.h: 475)

sys_kill                         (include/syscalls_x64.h: 129)

sys_lchown                       (include/syscalls_x64.h: 193)

sys_lgetxattr                    (include/syscalls_x64.h: 369)

sys_link                         (include/syscalls_x64.h: 177)

sys_linkat                       (include/syscalls_x64.h: 505)

sys_listen                       (include/syscalls_x64.h: 105)

sys_listxattr                    (include/syscalls_x64.h: 373)

sys_llistxattr                   (include/syscalls_x64.h: 375)

sys_lookup_dcookie               (include/syscalls_x64.h: 405)

sys_lremovexattr                 (include/syscalls_x64.h: 381)

sys_lseek                        (include/syscalls_x64.h: 21)

sys_lsetxattr                    (include/syscalls_x64.h: 363)

sys_lstat                        (include/syscalls_x64.h: 17)

sys_madvise                      (include/syscalls_x64.h: 61)

sys_mbind                        (include/syscalls_x64.h: 449)

sys_memfd_create                 (include/syscalls_x64.h: 613)

sys_migrate_pages                (include/syscalls_x64.h: 487)

sys_mincore                      (include/syscalls_x64.h: 59)

sys_mkdir                        (include/syscalls_x64.h: 171)

sys_mkdirat                      (include/syscalls_x64.h: 491)

sys_mknod                        (include/syscalls_x64.h: 271)

sys_mknodat                      (include/syscalls_x64.h: 493)

sys_mlock                        (include/syscalls_x64.h: 301)

sys_mlockall                     (include/syscalls_x64.h: 305)

sys_mmap                         (include/syscalls_x64.h: 23)

sys_modify_ldt                   (include/syscalls_x64.h: 311)

sys_mount                        (include/syscalls_x64.h: 333)

sys_move_pages                   (include/syscalls_x64.h: 533)

sys_mprotect                     (include/syscalls_x64.h: 25)

sys_mq_getsetattr                (include/syscalls_x64.h: 465)

sys_mq_notify                    (include/syscalls_x64.h: 463)

sys_mq_open                      (include/syscalls_x64.h: 455)

sys_mq_timedreceive               (include/syscalls_x64.h: 461)

sys_mq_timedsend                 (include/syscalls_x64.h: 459)

sys_mq_unlink                    (include/syscalls_x64.h: 457)

sys_mremap                       (include/syscalls_x64.h: 55)

sys_msgctl                       (include/syscalls_x64.h: 147)

sys_msgget                       (include/syscalls_x64.h: 141)

sys_msgrcv                       (include/syscalls_x64.h: 145)

sys_msgsnd                       (include/syscalls_x64.h: 143)

sys_msync                        (include/syscalls_x64.h: 57)

sys_munlock                      (include/syscalls_x64.h: 303)

sys_munlockall                   (include/syscalls_x64.h: 307)

sys_munmap                       (include/syscalls_x64.h: 27)

sys_name_to_handle_at               (include/syscalls_x64.h: 581)

sys_nanosleep                    (include/syscalls_x64.h: 75)

sys_newfstatat                   (include/syscalls_x64.h: 499)

sys_open                         (include/syscalls_x64.h: 9)

sys_open_by_handle_at               (include/syscalls_x64.h: 583)

sys_openat                       (include/syscalls_x64.h: 489)

sys_pause                        (include/syscalls_x64.h: 73)

sys_perf_event_open               (include/syscalls_x64.h: 571)

sys_personality                  (include/syscalls_x64.h: 273)

sys_pipe                         (include/syscalls_x64.h: 49)

sys_pipe2                        (include/syscalls_x64.h: 561)

sys_pivot_root                   (include/syscalls_x64.h: 313)

sys_poll                         (include/syscalls_x64.h: 19)

sys_ppoll                        (include/syscalls_x64.h: 517)

sys_prctl                        (include/syscalls_x64.h: 317)

sys_pread64                      (include/syscalls_x64.h: 39)

sys_preadv                       (include/syscalls_x64.h: 565)

sys_prlimit64                    (include/syscalls_x64.h: 579)

sys_process_vm_readv               (include/syscalls_x64.h: 595)

sys_process_vm_writev               (include/syscalls_x64.h: 597)

sys_pselect6                     (include/syscalls_x64.h: 515)

sys_ptrace                       (include/syscalls_x64.h: 207)

sys_pwrite64                     (include/syscalls_x64.h: 41)

sys_pwritev                      (include/syscalls_x64.h: 567)

sys_quotactl                     (include/syscalls_x64.h: 355)

sys_read                         (include/syscalls_x64.h: 5)

sys_readahead                    (include/syscalls_x64.h: 359)

sys_readlink                     (include/syscalls_x64.h: 183)

sys_readlinkat                   (include/syscalls_x64.h: 509)

sys_readv                        (include/syscalls_x64.h: 43)

sys_reboot                       (include/syscalls_x64.h: 341)

sys_recvfrom                     (include/syscalls_x64.h: 95)

sys_recvmmsg                     (include/syscalls_x64.h: 573)

sys_recvmsg                      (include/syscalls_x64.h: 99)

sys_remap_file_pages               (include/syscalls_x64.h: 409)

sys_removexattr                  (include/syscalls_x64.h: 379)

sys_rename                       (include/syscalls_x64.h: 169)

sys_renameat                     (include/syscalls_x64.h: 503)

sys_renameat2                    (include/syscalls_x64.h: 607)

sys_request_key                  (include/syscalls_x64.h: 473)

sys_restart_syscall               (include/syscalls_x64.h: 415)

sys_rmdir                        (include/syscalls_x64.h: 173)

sys_rt_sigaction                 (include/syscalls_x64.h: 31)

sys_rt_sigpending                (include/syscalls_x64.h: 259)

sys_rt_sigprocmask               (include/syscalls_x64.h: 33)

sys_rt_sigqueueinfo               (include/syscalls_x64.h: 263)

sys_rt_sigreturn                 (include/syscalls_x64.h: 35)

sys_rt_sigsuspend                (include/syscalls_x64.h: 265)

sys_rt_sigtimedwait               (include/syscalls_x64.h: 261)

sys_rt_tgsigqueueinfo               (include/syscalls_x64.h: 569)

sys_sched_get_priority_max               (include/syscalls_x64.h: 295)

sys_sched_get_priority_min               (include/syscalls_x64.h: 297)

sys_sched_getaffinity               (include/syscalls_x64.h: 393)

sys_sched_getattr                (include/syscalls_x64.h: 605)

sys_sched_getparam               (include/syscalls_x64.h: 289)

sys_sched_getscheduler               (include/syscalls_x64.h: 293)

sys_sched_rr_get_interval               (include/syscalls_x64.h: 299)

sys_sched_setaffinity               (include/syscalls_x64.h: 391)

sys_sched_setattr                (include/syscalls_x64.h: 603)

sys_sched_setparam               (include/syscalls_x64.h: 287)

sys_sched_setscheduler               (include/syscalls_x64.h: 291)

sys_sched_yield                  (include/syscalls_x64.h: 53)

sys_seccomp                      (include/syscalls_x64.h: 609)

sys_select                       (include/syscalls_x64.h: 51)

sys_semctl                       (include/syscalls_x64.h: 137)

sys_semget                       (include/syscalls_x64.h: 133)

sys_semop                        (include/syscalls_x64.h: 135)

sys_semtimedop                   (include/syscalls_x64.h: 417)

sys_sendfile                     (include/syscalls_x64.h: 85)

sys_sendmmsg                     (include/syscalls_x64.h: 589)

sys_sendmsg                      (include/syscalls_x64.h: 97)

sys_sendto                       (include/syscalls_x64.h: 93)

sys_set_mempolicy                (include/syscalls_x64.h: 451)

sys_set_robust_list               (include/syscalls_x64.h: 521)

sys_set_tid_address               (include/syscalls_x64.h: 413)

sys_setdomainname                (include/syscalls_x64.h: 345)

sys_setfsgid                     (include/syscalls_x64.h: 251)

sys_setfsuid                     (include/syscalls_x64.h: 249)

sys_setgid                       (include/syscalls_x64.h: 217)

sys_setgroups                    (include/syscalls_x64.h: 237)

sys_sethostname                  (include/syscalls_x64.h: 343)

sys_setitimer                    (include/syscalls_x64.h: 81)

sys_setns                        (include/syscalls_x64.h: 591)

sys_setpgid                      (include/syscalls_x64.h: 223)

sys_setpriority                  (include/syscalls_x64.h: 285)

sys_setregid                     (include/syscalls_x64.h: 233)

sys_setresgid                    (include/syscalls_x64.h: 243)

sys_setresuid                    (include/syscalls_x64.h: 239)

sys_setreuid                     (include/syscalls_x64.h: 231)

sys_setrlimit                    (include/syscalls_x64.h: 323)

sys_setsid                       (include/syscalls_x64.h: 229)

sys_setsockopt                   (include/syscalls_x64.h: 113)

sys_settimeofday                 (include/syscalls_x64.h: 331)

sys_setuid                       (include/syscalls_x64.h: 215)

sys_setxattr                     (include/syscalls_x64.h: 361)

sys_shmat                        (include/syscalls_x64.h: 65)

sys_shmctl                       (include/syscalls_x64.h: 67)

sys_shmdt                        (include/syscalls_x64.h: 139)

sys_shmget                       (include/syscalls_x64.h: 63)

sys_shutdown                     (include/syscalls_x64.h: 101)

sys_sigaltstack                  (include/syscalls_x64.h: 267)

sys_signalfd                     (include/syscalls_x64.h: 539)

sys_signalfd4                    (include/syscalls_x64.h: 553)

sys_socket                       (include/syscalls_x64.h: 87)

sys_socketpair                   (include/syscalls_x64.h: 111)

sys_splice                       (include/syscalls_x64.h: 525)

sys_stat                         (include/syscalls_x64.h: 13)

sys_statfs                       (include/syscalls_x64.h: 277)

sys_swapoff                      (include/syscalls_x64.h: 339)

sys_swapon                       (include/syscalls_x64.h: 337)

sys_symlink                      (include/syscalls_x64.h: 181)

sys_symlinkat                    (include/syscalls_x64.h: 507)

sys_sync                         (include/syscalls_x64.h: 327)

sys_sync_file_range               (include/syscalls_x64.h: 529)

sys_syncfs                       (include/syscalls_x64.h: 587)

sys_sysfs                        (include/syscalls_x64.h: 281)

sys_sysinfo                      (include/syscalls_x64.h: 203)

sys_syslog                       (include/syscalls_x64.h: 211)

sys_tee                          (include/syscalls_x64.h: 527)

sys_tgkill                       (include/syscalls_x64.h: 445)

sys_time                         (include/syscalls_x64.h: 387)

sys_timer_create                 (include/syscalls_x64.h: 421)

sys_timer_delete                 (include/syscalls_x64.h: 429)

sys_timer_getoverrun               (include/syscalls_x64.h: 427)

sys_timer_gettime                (include/syscalls_x64.h: 425)

sys_timer_settime                (include/syscalls_x64.h: 423)

sys_timerfd_create               (include/syscalls_x64.h: 541)

sys_timerfd_gettime               (include/syscalls_x64.h: 549)

sys_timerfd_settime               (include/syscalls_x64.h: 547)

sys_times                        (include/syscalls_x64.h: 205)

sys_tkill                        (include/syscalls_x64.h: 385)

sys_truncate                     (include/syscalls_x64.h: 157)

sys_umask                        (include/syscalls_x64.h: 195)

sys_umount2                      (include/syscalls_x64.h: 335)

sys_uname                        (include/syscalls_x64.h: 131)

sys_unlink                       (include/syscalls_x64.h: 179)

sys_unlinkat                     (include/syscalls_x64.h: 501)

sys_unshare                      (include/syscalls_x64.h: 519)

sys_ustat                        (include/syscalls_x64.h: 275)

sys_utime                        (include/syscalls_x64.h: 269)

sys_utimensat                    (include/syscalls_x64.h: 535)

sys_utimes                       (include/syscalls_x64.h: 447)

sys_vfork                        (include/syscalls_x64.h: 121)

sys_vhangup                      (include/syscalls_x64.h: 309)

sys_vmsplice                     (include/syscalls_x64.h: 531)

sys_wait4                        (include/syscalls_x64.h: 127)

sys_waitid                       (include/syscalls_x64.h: 469)

sys_write                        (include/syscalls_x64.h: 7)

sys_writev                       (include/syscalls_x64.h: 45)



==========
signal.h
==========

raise          static inline int raise(int signr);
               Defines: getpid
               (src/sigaction.c: 135)

sigaction      static int volatile sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
               Defines: memcpy
               (src/sigaction.c: 107)

sigaddset      int sigaddset(sigset_t *set, int sig);
               (src/sigaction.c: 34)

sigdelset      int sigdelset(sigset_t *set, int sig);
               (src/sigaction.c: 58)

sigemptyset    static int sigemptyset(sigset_t *set);
               (src/sigaction.c: 7)

sigfillset     static int sigfillset(sigset_t *set);
               (src/sigaction.c: 20)

sigismember    int sigismember(sigset_t *set, int sig);
               (src/sigaction.c: 75)

signal         sighandler_t signal(int sig, sighandler_t func );
               Defines: memcpy write
               (src/signal.c: 8)

sigprocmask    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
               (src/sigaction.c: 52)



==========
stdio.h
==========

_fopen         FILE *_fopen(int fd, const char* filename, const char* mode, FILE *f);
               Defines: close fileno open
               (src/fopen.c: 12)
               modes implemented: r, r+, w, w+, a, a+

_itohex        int _itohex(int i,char* buf,int padding, int capitals);
               (src/itohex.c: 6)

clearerr       static inline void clearerr(FILE *f);
               (include/mini_fstream.h: 198)

clearerror     static inline void clearerror(FILE *f);
               (include/mini_fstream.h: 203)

fclose         static inline int __attribute__((always_inline)) fclose( FILE* f );
               Defines: close
               (include/mini_fstream.h: 65)

fdopen         FILE *fdopen(int fd, const char* mode);
               Defines: close open fileno
               (src/fopen.c: 91)
               modes implemented: r, r+, w, w+, a, a+

feof           static inline int feof(FILE *f);
               (include/mini_fstream.h: 184)

ferror         static inline int ferror(FILE *f);
               (include/mini_fstream.h: 191)

fflush         static inline int __attribute__((always_inline)) fflush( FILE *F );
               (include/mini_fstream.h: 28)
               This does nothing, since minilib doesn't provide buffered streams yet.In order to sync data to disc, please use fsync

fgetc          static inline int fgetc(FILE *F);
               Defines: fileno read
               (include/fgetc.h: 11)

fgetpos        static inline void fgetpos(FILE *f, long *pos );
               Defines: lseek
               (include/mini_fstream.h: 127)

fgets          char* fgets(char *buf, int size, FILE* F);
               Defines: fileno read
               (src/fgets.c: 6)

fileno         static int fileno( FILE *f );
               (include/mini_fstream.h: 56)
               Return the fd nummber of stdin,-out,-err. 

fopen          FILE *fopen(const char* filename, const char* mode);
               Defines: close open fileno
               (src/fopen.c: 81)
               modes implemented: r, r+, w, w+, a, a+

fprint         #define fprint(...) fprintf(__VA_ARGS__)
               Defines: fileno write
               (include/mini_fstream.h: 95)

fprintf        #define fprintf(stream,...)	write(fileno(stream),mlgl->mbuf,sprintf(mlgl->mbuf,__VA_ARGS__))
               Defines: fileno write
               (src/sprintf.c: 245)

fputc          static inline int volatile fputc(int c, FILE* F);
               Defines: fileno write
               (include/fputc.h: 10)

fputs          static inline int volatile fputs(const char *c, FILE *F);
               Defines: fileno strlen write
               (include/fputs.h: 20)

fread          static inline size_t fread(void *ptr, size_t size, size_t nmemb, FILE *f);
               Defines: read
               (include/mini_fstream.h: 162)

freopen        FILE *freopen(const char* filename, const char* mode, FILE *F);
               Defines: close fileno open
               (src/fopen.c: 101)
               modes implemented: r, r+, w, w+, a, a+

fseek          static inline int fseek(FILE *f, long offset, int whence );
               Defines: lseek
               (include/mini_fstream.h: 146)

fsetpos        static inline int fsetpos(FILE *f, int pos );
               Defines: lseek
               (include/mini_fstream.h: 133)

ftell          static inline long ftell(FILE *f);
               Defines: lseek
               (include/mini_fstream.h: 121)

fwrite         static inline size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *f);
               Defines: write
               (include/mini_fstream.h: 106)

getc           #define getc(F) fgetc(F)
               Defines: read fileno
               (include/fgetc.h: 26)

getchar        #define getchar() fgetc(0)
               Defines: read fileno
               (include/fgetc.h: 29)

gets           #define gets(F) fgets(F,0xfffffff,stdin)
               Defines: read fileno
               (src/fgets.c: 29)

itoHEX         int itoHEX(int i,char* buf,int padding);
               Defines: 
               (src/itohex.c: 56)

itohex         int itohex(int i,char* buf,int padding);
               Defines: 
               (src/itohex.c: 49)

perror         void perror(const char *msg);
               Defines: strerror strlen errno fileno write
               (src/perror.c: 4)

printf         #define printf(...) fprintf(stdout,__VA_ARGS__)
               Defines: fileno write
               (include/mini_fstream.h: 91)

putc           #define putc(c,stream) fputc(c,stream)
               Defines: fileno write
               (include/fputc.h: 19)

putchar        #define putchar(c) fputc(c,stdout)
               Defines: write fileno
               (include/fputc.h: 16)

puts           #define puts(msg) ( print(msg) + printl() )
               Defines: strlen write
               (include/prints.h: 73)
               write msg to stdout, append a newline. Needs strlen.

rewind         static inline void rewind( FILE *f );
               Defines: lseek
               (include/mini_fstream.h: 156)

setbuf         static void setbuf(FILE *stream, char *buf);
               (include/mini_fstream.h: 211)
               dummy function.
              There is no buffering implemented for the streams yet.

setvbuf        static int setvbuf(FILE *stream, char *buf, int mode, size_t size);
               (include/mini_fstream.h: 216)
               dummy function

sprintf        #define sprintf(str,...) snprintf( str, 4096,  __VA_ARGS__)
               Defines: write
               (src/sprintf.c: 26)

ungetc         static int ungetc(int c, FILE *F);
               (include/fgetc.h: 35)
               pushes one char back to the stream.
              Overwrites a previously pushed char
              (conforming to the posix spec) 

vfprintf       #define vfprintf(...) fprintf(__VA_ARGS__)
               Defines: fileno write
               (include/mini_fstream.h: 100)



==========
stdlib.h
==========

abort          void abort();
               Defines: memcpy getpid write
               (src/abort.c: 3)

abs            static int abs(int i);
               (include/math.h: 25)

atexit         static int atexit( functionp* func );
               Defines: globals
               (src/atexit.c: 7)
               register functions, which are callen on exit in reverse order
              the switch mini_atexit takes a optional number,
              which defines the maximum numbers of functions to be registered.
              (defaults to 8)

atoi           int atoi(const char *c);
               (src/atoi.c: 6)

atol           long atol(const char *c);
               (src/atoi.c: 43)

div            static div_t div(int numerator, int denominator);
               (include/math.h: 8)

free           void free(void *p);
               Defines: getbrk brk
               (src/malloc.c: 134)

free_brk       int free_brk();
               (src/malloc.c: 229)
               free all memory,
              which has been allocated with malloc_brk.
              Returns 0, if memory has been freed;
              1, when there hasn't been any memory allocations with
              malloc_brk before.
              Then brk() gives an error, return the return value of brk

getenv         char* getenv(const char* name);
               Defines: environ
               (src/getenv.c: 8)

labs           static long int labs(long int i);
               (include/math.h: 30)

ldiv           static ldiv_t ldiv(long int numerator, long int denominator);
               (include/math.h: 16)

malloc         void* malloc(int size);
               Defines: brk
               (src/malloc.c: 114)
               0
              Here we go.. with the .. well. 
              Fastes and smallest malloc/free combi ever. 
              Not the smartest.
              Since it isn't exactly a memory allocation,
              instead it (mis)uses the minilib buf.
              ;) 1024 Bytes should be enough for everyone.
               Ok. If you really do need more memory - 
               rethink your design, increase mini_mbuf,
               or use a proper malloc implementation.
             
              Here we use mbuf from top to bottom as stack.
              64 Bytes are left at the bottom as reserve.
              Possibly we'd like to complain
              about the lack of memory, before we exit..
             
              ATM, the 'free' is really lazy. 
              It free's memory, but a real 'free' is only commited,
              when all memory below a freed area is also freed.
              Since the target of minilib atm are tiny tools, 
              this might be ok.
              ;) but, as I told before - 
              probably you should look out for a proper malloc implementation.
              It depends on your needs.
             
              I'm not sure yet, 
              whether another implementation of free would be useful at all.
              Overall, I'd really prefer keeping minilib tiny.
             
              Reusing sparse freed memory areas also leads 
              to a whole bunch of complications.
              cache misses, searching complexity,
              storage overhead, potentially page faults,
              just to name a few.
             
              I'm not sure whether it's worth it.
             
              And the existing malloc implementations 
              out there are countless.
             
              ;) It's sometimes smarter to stay special,
              although in this case this means the opposite.
              /misc
             
              The memory layout looks like this:
              mlgl->ibuf and mlgl->mbuf do point to the same address range.
              mlgl->ibuf is provided for alignment and faster access to the int values.
             
              flag prev free is the first bit in size. (0x8000, eq 1000 0000 0000 0000 binary when free), 
              (mbufsize)
                   size  data  size    mini_buf size
                   8008dataxxxx0004data8000|
                   ----========----====----|
             
              also, when free space is in between two areas
              
              8004data8008  free  0004data8000|
              ----====----________----====----|
             
              the free space is only freed, 
              when all areas below (left) have been free'd as well.
             
              Memory is allocated from right to left, 
              meaning from top to down.

malloc_brk     void* malloc_brk(int size);
               Defines: sbrk
               (src/malloc.c: 201)
               allocate via setting the brk
              free and realloc can be used normally.
              The intention of malloc_brk is for subsequent calls to realloc.
              The saved data has not to be copied,
              instead realloc just writes the new size and sets 
              the brk accordingly.
              if the break is saved before one or more calls to malloc_brk,
              the allocated memory can also be free'd by setting the brk to the saved value
              with brk(saved_brk)
              free_brk() free's all memory, which has been allocated with malloc_brk

qsort          static void qsort(void *base, int count, int size, int(*cmp)(const void*,const void*));
               Defines: swap
               (src/qsort.c: 108)
               qsort, implemented as recursive function
              there seems to be some trouble with gcc.
              Got segfaults, depending on the optimization flag.
              Going to file a bugreport,
              and leave this for now.
              The code might be correct. 
              But, sometimes it works, sometimes not. so.

rand           unsigned int rand();
               (src/rand.c: 15)

realloc        void* realloc(void *p, int size);
               Defines: getbrk brk
               (src/malloc.c: 247)

srand          void srand( unsigned int i );
               (src/rand.c: 7)

strtol         long int strtol(const char *c, const char **endp, int base);
               (src/strtol.c: 5)
               conversion
              doesn't check for overflow(!)

system         int system( const char* command );
               Defines: write environ execve vfork wait4
               (src/system.c: 4)

todo_putenv    int todo_putenv( char *s );
               Defines: environ
               (src/getenv.c: 22)



==========
string.h
==========

_strcasecmp    int _strcasecmp(const char*c1,const char*c2,int len);
               Defines: tolower
               (src/strcmp.c: 31)

_strcmp        int _strcmp(const char*c1,const char*c2,int len);
               (src/strcmp.c: 11)

memcmp         int memcmp(const void* c1,const void* c2,int len);
               Defines: 0
               (src/strcmp.c: 88)

memcpy         void *memcpy( void *d, const void *s, int n );
               (src/memcpy.c: 6)

memmove        void* memmove(void *dest, const void *src, int n);
               (src/memmove.c: 3)

memset         void *memset( void *s, int c, int n);
               (src/memset.c: 3)

strcasecmp     int strcasecmp(const char*c1,const char*c2);
               Defines: 
               (src/strcmp.c: 52)

strcat         char *strcat(char *dest, const char *src );
               Defines: strlen
               (src/strcat.c: 7)

strchr         char *strchr(const char *s, int c);
               Defines: strchrnul
               (src/strchr.c: 20)

strchrnul      char *strchrnul(const char *s, int c);
               (src/strchr.c: 7)

strcmp         int strcmp(const char*c1,const char*c2);
               Defines: 
               (src/strcmp.c: 71)

strcpy         char *strcpy(char *dest, const char *src);
               (src/memcpy.c: 17)

strdup         char *strdup(const char *source);
               Defines: brk strlen strcpy
               (src/strdup.c: 7)

strerror       static char* strerror( int errnum );
               (src/strerror.c: 7)

strlen         int strlen(const char*str);
               (src/strlen.c: 7)

strncasecmp    int strncasecmp(const char*c1,const char*c2,int len);
               Defines: 
               (src/strcmp.c: 60)

strncmp        int strncmp(const char*c1,const char*c2,int len);
               Defines: 
               (src/strcmp.c: 79)

strncpy        char *strncpy(char *dest, const char *src, int n);
               Defines: memcpy
               (src/memcpy.c: 27)

strrchr        char *strrchr(const char *s, int c);
               Defines: strchrnul
               (src/strchr.c: 36)

strstr         char* strstr(const char *big, const char *little);
               (src/strstr.c: 3)



==========
sys/wait.h
==========

wait           pid_t wait(int *wstatus);
               Defines: wait4
               (src/wait.c: 8)

waitpid        pid_t waitpid(pid_t pid, int *wstatus, int options);
               Defines: wait4
               (src/wait.c: 16)



==========
time.h
==========

time           time(unsigned int *a1 )
               (include/syscall_stubs.h: 206)



==========
unistd.h
==========

access         access( const char *filename, int mode)
               (include/syscall_stubs.h: 157)

chdir          chdir(const char* path)
               (include/syscall_stubs.h: 107)

chown          chown( const char *filename, uid_t user, gid_t group)
               (include/syscall_stubs.h: 188)

chroot         chroot( const char *filename)
               (include/syscall_stubs.h: 137)

close          close( int fd )
               (include/syscall_stubs.h: 96)

dup            dup(int fd)		
               (include/syscall_stubs.h: 112)

dup2           dup2(int oldfd, int newfd)		
               (include/syscall_stubs.h: 113)

execl          static int execl(const char *pathname, const char* arg0,... );
               Defines: execve environ
               (src/execl.c: 6)

execv          static inline int execv(const char *pathname, char *const argv[]);
               Defines: environ execve
               (src/execvp.c: 9)

execve         execve( const char *filename,  char* const* argv, char* const* envp)
               (include/syscall_stubs.h: 123)

execvp         static inline int execvp(const char *file, char *const argv[]);
               Defines: environ access execve
               (src/execvp.c: 58)

execvpe        static int execvpe(const char *file, char *const argv[], char *const envp[]);
               Defines: environ access execve
               (src/execvp.c: 18)
               When invoked with a filename, starting with "." or "/",
              interprets this as absolute path. (calls execve with the pathname)
              Looks for file in the PATH environment, othwerise.

fork           DEF_syscall(fork,0)
               (include/syscall_stubs.h: 127)

fsync          fsync(int a1 )
               (include/lseek.h: 22)

ftruncate      ftruncate(unsigned int a1, unsigned int a2 )
               (include/lseek.h: 21)

getgid         DEF_syscall(getgid,0)
               (include/syscall_stubs.h: 192)

getpgrp        DEF_syscall(getpgrp,0)
               (include/syscall_stubs.h: 193)

getpid         DEF_syscall(getpid,0 )
               (include/syscall_stubs.h: 141)

getuid         DEF_syscall(getuid,0)
               (include/syscall_stubs.h: 195)

isatty         int isatty(int fd);
               Defines: ioctl
               (src/isatty.c: 7)

link           link( const char *oldname, const char *newname)
               (include/syscall_stubs.h: 118)

lseek          lseek(unsigned int a1, int a2, int a3 )
               (include/lseek.h: 19)

mkdir          mkdir( const char *pathname, int mode)
               (include/syscall_stubs.h: 154)

open           int volatile open( const char *s, int flags, ... );
               (src/open.c: 19)
               open or create a file.
              warning: when using the flag O_CREAT,
              file permission flags have to be given
              as third argument. Otherwise file permission
              flags will be random. (I still do not know, what 
              the flag showing up as "-T" means..)

pipe           pipe( int *filedes)
               (include/syscall_stubs.h: 185)

read           read( int fd, void *buf, int len )
               (include/syscall_stubs.h: 97)

rename         rename( const char* oldpath, const char* newpath )
               (include/syscall_stubs.h: 102)

rmdir          rmdir( const char *pathname)
               (include/syscall_stubs.h: 155)

select         static int volatile __attribute__((optimize("O0"))) select(int fd, volatile fd_set* readfd, volatile fd_set *writefd, volatile fd_set *exceptfd, volatile struct timeval *wait);
               (include/select.h: 9)

setgid         setgid( gid_t gid)
               (include/syscall_stubs.h: 143)

setpgid        setpgid( pid_t pid, pid_t pgid)
               (include/syscall_stubs.h: 191)

setsid         DEF_syscall(setsid,0 )
               (include/syscall_stubs.h: 142)

setuid         setuid( uid_t uid)
               (include/syscall_stubs.h: 144)

sleep          unsigned int volatile sleep(unsigned int seconds);
               (src/sleep.c: 10)
               nonconformant sleep
              TODO: ignore blocked signals, sigchld

tcgetattr      static inline int __attribute__((always_inline)) tcgetattr(int fd, struct termios *io);
               Defines: ioctl
               (include/tcgetattr.h: 21)

tcsetattr      static inline int __attribute__((always_inline)) tcsetattr(int fd, int opt, const struct termios *io);
               Defines: ioctl
               (include/tcsetattr.h: 20)

unlink         unlink( const char* path)
               (include/syscall_stubs.h: 103)

usleep         unsigned int volatile usleep(unsigned int useconds);
               (src/sleep.c: 31)
               nonconformant usleep. 
              Sleep useconds.
              I just hope, noone relies on an exact sleep time.
              which isn't possible without a real time os, anyways.
              When for whatever reason you'd need nanoseconds exact times,
              best shot might be a spinloop, and looking for cpu ticks.
             
              TODO: ignore blocked signals, sigchld

write          write(int fd,const void *buf, int len )
               (include/syscall_stubs.h: 98)


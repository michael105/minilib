<!DOCTYPE html>
<html lang="en">
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.1.9">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="Martin Kompf" name="author">
<meta content="CORBA, C++, Cplusplus, Cplus, Objektorientiert, Programmieren, Programmierung, Tutorial" name="keywords">
<meta content="This is a short reference of the ANSI Standard C library." name="description">
<meta content="Martin Kompf" name="publisher">
<meta content="NEVER" name="expires">
<meta content="INDEX,FOLLOW" name="robots">
<title>Standard C Library Funktions</title>

<style media="all" type="text/css">
@import "/style/kompf.css";
</style>

<style media="print" type="text/css">
@import "/style/kompf-print.css";
</style>

<style media="only screen and (max-width: 480px)" type="text/css">
@import "/style/kompf-mobile.css";
</style>
<meta content="2018-05-13T16:28:47+02:00" name="date">
<meta content="initial-scale=1, minimum-scale=0.75, width=device-width" name="viewport">
<link href="https://www.mkompf.com/cplus/cliblist.html" rel="canonical">
<link href="//www.kompf.de/cplus/cliblist.html" hreflang="de" rel="alternate">
<link href="//www.mkompf.com/cplus/cliblist.html" hreflang="en" rel="alternate">
</head>
<body>
<div id="Header"><a href="//www.mkompf.com">Home</a> &gt; <a href="//www.mkompf.com/cplus">C/C++</a></div>
<div id="Content">
<div class="lang">en|<a href="//www.kompf.de/cplus/cliblist.html" title="Diese Seite in Deutsch">de</a></div>
<h1>Standard C Library Functions</h1>
<p>This is a very short reference of the ANSI Standard C library. Consult your operating system's man-pages for a detailed information about each function.</p>
<p>A short reference of the POSIX functions which are not part of the Standard C Library can be found <a href="posixlist.html">here</a>.</p>
<ul class="toc">
<li><a href="#diagnostics">Diagnostics</a></li>
<li><a href="#ctype.h">Character Class Tests</a></li>
<li><a href="#error_codes_reported_by__some__library_functions">Error Codes Reported by (Some) Library Functions</a></li>
<li><a href="#implementation_defined_floating_point_limits">Implementation-defined Floating-Point Limits</a></li>
<li><a href="#implementation_defined_limits">Implementation-defined Limits</a></li>
<li><a href="#locale_specific_information">Locale-specific Information</a></li>
<li><a href="#mathematical_functions">Mathematical Functions</a></li>
<li><a href="#non_local_jumps">Non-local Jumps</a></li>
<li><a href="#signals">Signals</a></li>
<li><a href="#variable_argument_lists">Variable Argument Lists</a></li>
<li><a href="#definitions_of_general_use">Definitions of General Use</a></li>
<li><a href="#input_and_output">Input and Output</a></li>
<li><a href="#utility_functions">Utility functions</a></li>
<li><a href="#string_functions">String functions</a></li>
<li><a href="#time_and_date_functions">Time and Date functions</a></li>
</ul>
<div>
<style scoped="scoped">
.ads-responsive { width: 320px; height: 50px; }
@media(min-width: 480px) { .ads-responsive { width: 468px; height: 60px; } }
@media(min-width: 800px) { .ads-responsive { width: 728px; height: 90px; } }
</style>
<script async="async" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
</script> <!-- ads_responsive_en -->
<ins class="adsbygoogle ads-responsive" data-ad-client="ca-pub-0341323781243867" data-ad-format="auto" data-ad-slot="3356484656" style="display:inline-block"></ins> 
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
<h2 id="diagnostics">Diagnostics</h2>
<p><code class="preprocessor">#include &lt;assert.h&gt;</code></p>
<dl>
<dt><code>void assert(int <var>expression</var>);</code></dt>
<dd><em>Macro</em> used for internal error detection. (Ignored if <code>NDEBUG</code> is defined where <code>&lt;assert.h&gt;</code> is included.) If <var>expression</var> equals zero, message printed on <code><a href="#stderr">stderr</a></code> and <a href="#abort">abort</a> called to terminate execution. Source filename and line number in message are from preprocessor macros <code>__FILE__</code> and <code>__LINE__</code>.</dd>
</dl>
<h2 id="ctype.h">Character Class Tests</h2>
<p><code class="preprocessor">#include &lt;ctype.h&gt;</code></p>
<dl>
<dt><code>int isalnum(int <var>c</var>);</code></dt>
<dd><code>isalpha(<var>c</var>)</code> or <code>isdigit(<var>c</var>)</code></dd>
<dt><code>int isalpha(int <var>c</var>);</code></dt>
<dd><code>isupper(<var>c</var>)</code> or <code>islower(<var>c</var>)</code></dd>
<dt><code>int iscntrl(int <var>c</var>);</code></dt>
<dd>is control character. In ASCII, control characters are <code>0x00</code> (<code>NUL</code>) to <code>0x1F</code> (<code>US</code>), and <code>0x7F</code> (<code>DEL</code>)</dd>
<dt><code>int isdigit(int <var>c</var>);</code></dt>
<dd>is decimal digit</dd>
<dt><code>int isgraph(int <var>c</var>);</code></dt>
<dd>is printing character other than space</dd>
<dt><code>int islower(int <var>c</var>);</code></dt>
<dd>is lower-case letter</dd>
<dt><code>int isprint(int <var>c</var>);</code></dt>
<dd>is printing character (including space). In ASCII, printing characters are <code>0x20</code> (<code>' '</code>) to <code>0x7E</code> (<code>'~'</code>)</dd>
<dt><code>int ispunct(int <var>c</var>);</code></dt>
<dd>is printing character other than space, letter, digit</dd>
<dt><code>int isspace(int <var>c</var>);</code></dt>
<dd>is space, formfeed, newline, carriage return, tab, vertical tab</dd>
<dt><code>int isupper(int <var>c</var>);</code></dt>
<dd>is upper-case letter</dd>
<dt><code>int isxdigit(int <var>c</var>);</code></dt>
<dd>is hexadecimal digit</dd>
<dt><code>int tolower(int <var>c</var>);</code></dt>
<dd>return lower-case equivalent</dd>
<dt><code>int toupper(int <var>c</var>);</code></dt>
<dd>return upper-case equivalent</dd>
</dl>
<h2 id="error_codes_reported_by__some__library_functions">Error Codes Reported by (Some) Library Functions</h2>
<p><code class="preprocessor">#include &lt;errno.h&gt;</code></p>
<dl>
<dt><code id="errno">errno</code></dt>
<dd>object to which <strong>certain</strong> library functions assign specific positive values on error</dd>
<dt><code id="EDOM">EDOM</code></dt>
<dd>code used for domain errors</dd>
<dt><code id="ERANGE">ERANGE</code></dt>
<dd>code used for range errors</dd>
</dl>
<p>Notes:</p>
<ul>
<li>other implementation-defined error values are permitted</li>
<li>to determine the value (if any) assigned to <a href="#errno">errno</a> by a library function, a program should assign zero to <a href="#errno">errno</a> immediately prior to the function call</li>
</ul>
<h2 id="implementation_defined_floating_point_limits">Implementation-defined Floating-Point Limits</h2>
<p><code class="preprocessor">#include &lt;float.h&gt;</code></p>
<dl>
<dt><code id="FLT_RADIX">FLT_RADIX</code></dt>
<dd>radix of floating-point representations</dd>
<dt><code>FLT_ROUNDS</code></dt>
<dd>floating-point rounding mode</dd>
</dl>
<p>Where the prefix "<code>FLT</code>" pertains to type <code>float</code>, "<code>DBL</code>" to type <code>double</code>, and "<code>LDBL</code>" to type <code>long double</code>:</p>
<dl>
<dt><code>FLT_DIG</code></dt>
<dt><code>DBL_DIG</code></dt>
<dt><code>LDBL_DIG</code></dt>
<dd>precision (in decimal digits)</dd>
<dt><code>FLT_EPSILON</code></dt>
<dt><code>DBL_EPSILON</code></dt>
<dt><code>LDBL_EPSILON</code></dt>
<dd>smallest number <var>x</var> such that <code>1.0 + <var>x</var> != 1.0</code></dd>
<dt><code>FLT_MANT_DIG</code></dt>
<dt><code>DBL_MANT_DIG</code></dt>
<dt><code>LDBL_MANT_DIG</code></dt>
<dd>number of digits, base <code><a href="#FLT_RADIX">FLT_RADIX</a></code>, in mantissa</dd>
<dt><code>FLT_MAX</code></dt>
<dt><code>DBL_MAX</code></dt>
<dt><code>LDBL_MAX</code></dt>
<dd>maximum number</dd>
<dt><code>FLT_MAX_EXP</code></dt>
<dt><code>DBL_MAX_EXP</code></dt>
<dt><code>LDBL_MAX_EXP</code></dt>
<dd>largest positive integer exponent to which <code><a href="#FLT_RADIX">FLT_RADIX</a></code> can be raised and remain representable</dd>
<dt><code>FLT_MIN</code></dt>
<dt><code>DBL_MIN</code></dt>
<dt><code>LDBL_MIN</code></dt>
<dd>minimum normalised number</dd>
<dt><code>FLT_MIN_EXP</code></dt>
<dt><code>DBL_MIN_EXP</code></dt>
<dt><code>LDBL_MIN_EXP</code></dt>
<dd>smallest negative integer exponent to which <code><a href="#FLT_RADIX">FLT_RADIX</a></code> can be raised and remain representable</dd>
</dl>
<h2 id="implementation_defined_limits">Implementation-defined Limits</h2>
<p><code class="preprocessor">#include &lt;limits.h&gt;</code></p>
<dl>
<dt><code>CHAR_BIT</code></dt>
<dd>number of bits in a <code>char</code></dd>
<dt><code>CHAR_MAX</code></dt>
<dd>maximum value of type <code>char</code></dd>
<dt><code>CHAR_MIN</code></dt>
<dd>minimum value of type <code>char</code></dd>
<dt><code>SCHAR_MAX</code></dt>
<dd>maximum value of type <code>signed char</code></dd>
<dt><code>SCHAR_MIN</code></dt>
<dd>minimum value of type <code>signed char</code></dd>
<dt><code>UCHAR_MAX</code></dt>
<dd>maximum value of type <code>unsigned char</code></dd>
<dt><code>SHRT_MAX</code></dt>
<dd>maximum value of type <code>short</code></dd>
<dt><code>SHRT_MIN</code></dt>
<dd>minimum value of type <code>short</code></dd>
<dt><code>USHRT_MAX</code></dt>
<dd>maximum value of type <code>unsigned short</code></dd>
<dt><code>INT_MAX</code></dt>
<dd>maximum value of type <code>int</code></dd>
<dt><code>INT_MIN</code></dt>
<dd>minimum value of type <code>int</code></dd>
<dt><code>UINT_MAX</code></dt>
<dd>maximum value of type <code>unsigned int</code></dd>
<dt><code id="LONG_MAX">LONG_MAX</code></dt>
<dd>maximum value of type <code>long</code></dd>
<dt><code id="LONG_MIN">LONG_MIN</code></dt>
<dd>minimum value of type <code>long</code></dd>
<dt><code id="ULONG_MAX">ULONG_MAX</code></dt>
<dd>maximum value of type <code>unsigned long</code></dd>
</dl>
<h2 id="locale_specific_information">Locale-specific Information</h2>
<p><code class="preprocessor">#include &lt;locale.h&gt;</code></p>
<dl>
<dt><code id="lconv">struct lconv</code></dt>
<dd>Describes formatting of monetary and other numeric values:
<dl>
<dt><code id="decimal_point">decimal_point;</code></dt>
<dd>decimal point for non-monetary values</dd>
<dt><code>char* grouping;</code></dt>
<dd>sizes of digit groups for non-monetary values</dd>
<dt><code>char* thousands_sep;</code></dt>
<dd>separator for digit groups for non-monetary values (left of "decimal point")</dd>
<dt><code>char* currency_symbol;</code></dt>
<dd>currency symbol</dd>
<dt><code>char* int_curr_symbol;</code></dt>
<dd>international currency symbol</dd>
<dt><code>char* mon_decimal_point;</code></dt>
<dd>decimal point for monetary values</dd>
<dt><code>char* mon_grouping;</code></dt>
<dd>sizes of digit groups for monetary values</dd>
<dt><code>char* mon_thousands_sep;</code></dt>
<dd>separator for digit groups for monetary values (left of "decimal point")</dd>
<dt><code>char* negative_sign;</code></dt>
<dd>negative sign for monetary values</dd>
<dt><code>char* positive_sign;</code></dt>
<dd>positive sign for monetary values</dd>
<dt><code>char frac_digits;</code></dt>
<dd>number of digits to be displayed to right of "decimal point" for monetary values</dd>
<dt><code>char int_frac_digits;</code></dt>
<dd>number of digits to be displayed to right of "decimal point" for international monetary values</dd>
<dt><code>char n_cs_precedes;</code></dt>
<dd>whether currency symbol precedes (<code>1</code>) or follows (<code>0</code>) negative monetary values</dd>
<dt><code>char n_sep_by_space;</code></dt>
<dd>whether currency symbol is (<code>1</code>) or is not (<code>0</code>) separated by space from negative monetary values</dd>
<dt><code id="n_sign_posn">char n_sign_posn;</code></dt>
<dd>format for negative monetary values:
<dl>
<dt><code>0</code></dt>
<dd>parentheses surround quantity and currency symbol</dd>
<dt><code>1</code></dt>
<dd>sign precedes quantity and currency symbol</dd>
<dt><code>2</code></dt>
<dd>sign follows quantity and currency symbol</dd>
<dt><code>3</code></dt>
<dd>sign immediately precedes currency symbol</dd>
<dt><code>4</code></dt>
<dd>sign immediately follows currency symbol</dd>
</dl>
</dd>
<dt><code>char p_cs_precedes;</code></dt>
<dd>whether currency symbol precedes (<code>1</code>) or follows (<code>0</code>) positive monetary values</dd>
<dt><code>char p_sep_by_space;</code></dt>
<dd>whether currency symbol is (<code>1</code>) or is not (<code>0</code>) separated by space from non-negative monetary values</dd>
<dt><code>char p_sign_posn;</code></dt>
<dd>format for non-negative monetary values, with values as for <code><a href="#n_sign_posn">n_sign_posn</a></code></dd>
</dl>
Implementations may change field order and include additional fields. <em>Standard C Library</em> functions use only <code><a href="#decimal_point">decimal_point</a></code>.</dd>
<dt><code><a href="#lconv">struct lconv</a>* localeconv(void);</code></dt>
<dd>returns pointer to formatting information for current locale</dd>
<dt><code>char* setlocale(int <var id="category">category</var>, const char* locale);</code></dt>
<dd>Sets components of locale according to specified <code><var><a href="#category">category</a></var></code> and <code><var>locale</var></code>. Returns string describing new locale or null on error. (Implementations are permitted to define values of <code><var><a href="#category">category</a></var></code> additional to those describe here.)</dd>
<dt><code>LC_ALL</code></dt>
<dd><code><var><a href="#category">category</a></var></code> argument for all categories</dd>
<dt><code>LC_NUMERIC</code></dt>
<dd><code><var><a href="#category">category</a></var></code> for numeric formatting information</dd>
<dt><code>LC_MONETARY</code></dt>
<dd><code><var><a href="#category">category</a></var></code> for monetary formatting information</dd>
<dt><code>LC_COLLATE</code></dt>
<dd><code><var><a href="#category">category</a></var></code> for information affecting collating functions</dd>
<dt><code>LC_CTYPE</code></dt>
<dd><code><var><a href="#category">category</a></var></code> for information affecting <a href="#ctype.h">character class tests</a> functions</dd>
<dt><code>LC_TIME</code></dt>
<dd><code><var><a href="#category">category</a></var></code> for information affecting time conversions functions</dd>
<dt><code>NULL</code></dt>
<dd>null pointer constant</dd>
</dl>
<h2 id="mathematical_functions">Mathematical Functions</h2>
<p><code class="preprocessor">#include &lt;math.h&gt;</code></p>
<p>On domain error, implementation-defined value returned and <code><a href="#errno">errno</a></code> set to <code><a href="#EDOM">EDOM</a></code>. On range error, <code><a href="#errno">errno</a></code> set to <code><a href="#ERANGE">ERANGE</a></code> and return value is <code><a href="#HUGE_VAL">HUGE_VAL</a></code> with correct sign for overflow, or zero for underflow. Angles are in radians.</p>
<dl>
<dt><code id="HUGE_VAL">HUGE_VAL</code></dt>
<dd>magnitude returned (with correct sign) on overflow error</dd>
<dt><code>double exp(double <var>x</var>);</code></dt>
<dd>exponential of <code><var>x</var></code></dd>
<dt><code>double log(double <var>x</var>);</code></dt>
<dd>natural logarithm of <code><var>x</var></code></dd>
<dt><code>double log10(double <var>x</var>);</code></dt>
<dd>base-10 logarithm of <code><var>x</var></code></dd>
<dt><code>double pow(double <var>x</var>, double <var>y</var>);</code></dt>
<dd><code><var>x</var></code> raised to power <code><var>y</var></code></dd>
<dt><code>double sqrt(double <var>x</var>);</code></dt>
<dd>square root of <code><var>x</var></code></dd>
<dt><code>double ceil(double <var>x</var>);</code></dt>
<dd>smallest integer not less than <code><var>x</var></code></dd>
<dt><code>double floor(double <var>x</var>);</code></dt>
<dd>largest integer not greater than <code><var>x</var></code></dd>
<dt><code>double fabs(double <var>x</var>);</code></dt>
<dd>absolute value of <code><var>x</var></code></dd>
<dt><code>double ldexp(double <var>x</var>, int <var>n</var>);</code></dt>
<dd><code><var>x</var></code> times 2 to the power <code><var>n</var></code></dd>
<dt><code>double frexp(double <var>x</var>, int* <var>exp</var>);</code></dt>
<dd>if <code><var>x</var></code> non-zero, returns value, with absolute value in interval [1/2, 1), and assigns to <code>*<var>exp</var></code> integer such that product of return value and 2 raised to the power <code>*<var>exp</var></code> equals <code><var>x</var></code>; if <code><var>x</var></code> zero, both return value and <code>*<var>exp</var></code> are zero</dd>
<dt><code>double modf(double <var>x</var>, double* <var>ip</var>);</code></dt>
<dd>returns fractional part and assigns to <code>*<var>ip</var></code> integral part of <code><var>x</var></code>, both with same sign as <code><var>x</var></code></dd>
<dt><code>double fmod(double <var>x</var>, double <var>y</var>);</code></dt>
<dd>if <code><var>y</var></code> non-zero, floating-point remainder of <code><var>x</var>/<var>y</var></code>, with same sign as <code><var>x</var></code>; if <code><var>y</var></code> zero, result is implementation-defined</dd>
<dt><code>double sin(double <var>x</var>);</code></dt>
<dd>sine of <code><var>x</var></code></dd>
<dt><code>double cos(double <var>x</var>);</code></dt>
<dd>cosine of <code><var>x</var></code></dd>
<dt><code>double tan(double <var>x</var>);</code></dt>
<dd>tangent of <code><var>x</var></code></dd>
<dt><code>double asin(double <var>x</var>);</code></dt>
<dd>arc-sine of <code><var>x</var></code></dd>
<dt><code>double acos(double <var>x</var>);</code></dt>
<dd>arc-cosine of <code><var>x</var></code></dd>
<dt><code>double atan(double <var>x</var>);</code></dt>
<dd>arc-tangent of <code><var>x</var></code></dd>
<dt><code>double atan2(double <var>y</var>, double <var>x</var>);</code></dt>
<dd>arc-tangent of <code><var>y</var>/<var>x</var></code></dd>
<dt><code>double sinh(double <var>x</var>);</code></dt>
<dd>hyperbolic sine of <code><var>x</var></code></dd>
<dt><code>double cosh(double <var>x</var>);</code></dt>
<dd>hyperbolic cosine of <code><var>x</var></code></dd>
<dt><code>double tanh(double <var>x</var>);</code></dt>
<dd>hyperbolic tangent of <code><var>x</var></code></dd>
</dl>
<h2 id="non_local_jumps">Non-local Jumps</h2>
<p><code class="preprocessor">#include &lt;setjmp.h&gt;</code></p>
<dl>
<dt><code id="jmp_buf">jmp_buf</code></dt>
<dd>type of object holding context information</dd>
<dt><code id="setjmp">int setjmp(<a href="#jmp_buf">jmp_buf</a> <var>env</var>);</code></dt>
<dd>Saves context information in <code><var>env</var></code> and returns zero. Subsequent call to <code><a href="#longjmp">longjmp</a></code> with same <var>env</var> returns non-zero.</dd>
<dt><code id="longjmp">void longjmp(<a href="#jmp_buf">jmp_buf</a> <var>env</var>, int <var>val</var>);</code></dt>
<dd>Restores context saved by most recent call to <code><a href="#setjmp">setjmp</a></code> with specified <code><var>env</var></code>. Execution resumes as a second return from <code><a href="#setjmp">setjmp</a></code>, with returned value <code><var>val</var></code> if specified value non-zero, or 1 otherwise.</dd>
</dl>
<h2 id="signals">Signals</h2>
<p><code class="preprocessor">#include &lt;signal.h&gt;</code></p>
<dl>
<dt><code id="sigabrt">SIGABRT</code></dt>
<dd>abnormal termination</dd>
<dt><code>SIGFPE</code></dt>
<dd>arithmetic error</dd>
<dt><code>SIGILL</code></dt>
<dd>invalid execution</dd>
<dt><code>SIGINT</code></dt>
<dd>(asynchronous) interactive attention</dd>
<dt><code>SIGSEGV</code></dt>
<dd>illegal storage access</dd>
<dt><code>SIGTERM</code></dt>
<dd>(asynchronous) termination request</dd>
<dt><code id="SIG_DFL">SIG_DFL</code></dt>
<dd>specifies default signal handling</dd>
<dt><code id="SIG_ERR">SIG_ERR</code></dt>
<dd>signal return value indicating error</dd>
<dt><code id="SIG_IGN">SIG_IGN</code></dt>
<dd>specifies that signal should be ignored</dd>
<dt><code id="signal">void (*signal(int <var>sig</var>, void (*<var>handler</var>)(int)))(int);</code></dt>
<dd>Install handler for subsequent signal <var>sig</var>. If <code><var>handler</var></code> is <code><a href="#SIG_DFL">SIG_DFL</a></code>, implementation-defined default behaviour will be used; if <code><a href="#SIG_IGN">SIG_IGN</a></code>, signal will be ignored; otherwise function pointed to by <code><var>handler</var></code> will be invoked with argument <var>sig</var>. In the last case, handling is <strong>restored to default behaviour</strong> before <code><var>handler</var></code> is called. If <code><var>handler</var></code> returns, execution resumes where signal occurred. <code><a href="#signal">signal</a></code> returns the previous handler or <code>SIG_ERR</code> on error. Initial state is implementation-defined. Implementations may may define signals additional to those listed here.</dd>
<dt><code id="raise">int raise(int <var>sig</var>);</code></dt>
<dd>Sends signal <code><var>sig</var></code>. Returns zero on success.</dd>
</dl>
<h2 id="variable_argument_lists">Variable Argument Lists</h2>
<p><code class="preprocessor">#include &lt;stdarg.h&gt;</code></p>
<dl>
<dt><code id="va_list">va_list</code></dt>
<dd>type of object holding context information</dd>
<dt><code id="va_start">void va_start(<a href="#va_list">va_list</a> <var>ap</var>, <var>lastarg</var>);</code></dt>
<dd>Initialisation macro which must be called once before any unnamed argument is accessed. Stores context information in <code><var>ap</var></code>. <code><var>lastarg</var></code> is the last named parameter of the function.</dd>
<dt><code id="va_arg"><var>type</var> va_arg(<a href="#va_list">va_list</a> <var>ap</var>, <var>type</var>);</code></dt>
<dd>Yields value of the type (<code><var>type</var></code>) and value of the next unnamed argument.</dd>
<dt><code id="va_end">void va_end(<a href="#va_list">va_list</a> <var>ap</var>);</code></dt>
<dd>Termination macro which must be called once after argument processing and before exit from function.</dd>
</dl>
<h2 id="definitions_of_general_use">Definitions of General Use</h2>
<p><code class="preprocessor">#include &lt;stddef.h&gt;</code></p>
<dl>
<dt><code>NULL</code></dt>
<dd>Null pointer constant.</dd>
<dt><code>offsetof(<var>stype</var>, <var>m</var>)</code></dt>
<dd>Offset (in bytes) of member <code><var>m</var></code> from start of structure type <code><var>stype</var></code>.</dd>
<dt><code>ptrdiff_t</code></dt>
<dd>Type for objects declared to store result of subtracting pointers.</dd>
<dt><code>size_t</code></dt>
<dd>Type for objects declared to store result of <code>sizeof</code> operator.</dd>
</dl>
<h2 id="input_and_output">Input and Output</h2>
<p><code class="preprocessor">#include &lt;stdio.h&gt;</code></p>
<dl>
<dt><code id="BUFSIZ">BUFSIZ</code></dt>
<dd>Size of buffer used by <code><a href="#setbuf">setbuf</a></code>.</dd>
<dt><code id="EOF">EOF</code></dt>
<dd>Value used to indicate end-of-stream or to report an error.</dd>
<dt><code>FILENAME_MAX</code></dt>
<dd>Maximum length required for array of characters to hold a filename.</dd>
<dt><code>FOPEN_MAX</code></dt>
<dd>Maximum number of files which may be open simultaneously.</dd>
<dt><code id="L_tmpnam">L_tmpnam</code></dt>
<dd>Number of characters required for temporary filename generated by <code><a href="#tmpnam">tmpnam</a></code>.</dd>
<dt><code id="stdio.NULL">NULL</code></dt>
<dd>Null pointer constant.</dd>
<dt><code id="SEEK_CUR">SEEK_CUR</code></dt>
<dd>Value for <code><var>origin</var></code> argument to <code><a href="#fseek">fseek</a></code> specifying current file position.</dd>
<dt><code id="SEEK_SET">SEEK_END</code></dt>
<dd>Value for <code><var>origin</var></code> argument to <code><a href="#fseek">fseek</a></code> specifying beginning of file.</dd>
<dt><code id="TMP_MAX">TMP_MAX</code></dt>
<dd>Minimum number of unique filenames generated by calls to <code><a href="#tmpnam">tmpnam</a></code>.</dd>
<dt><code id="_IOFBF">_IOFBF</code></dt>
<dd>Value for <code><var>mode</var></code> argument to <code><a href="#setvbuf">setvbuf</a></code> specifying full buffering.</dd>
<dt><code id="_IOLBF">_IOLBF</code></dt>
<dd>Value for <code><var>mode</var></code> argument to <code><a href="#setvbuf">setvbuf</a></code> specifying line buffering.</dd>
<dt><code id="_IONBF">_IONBF</code></dt>
<dd>Value for <code><var>mode</var></code> argument to <code><a href="#setvbuf">setvbuf</a></code> specifying no buffering.</dd>
<dt><code id="stdin">stdin</code></dt>
<dd>File pointer for standard input stream. Automatically opened when program execution begins.</dd>
<dt><code id="stdout">stdout</code></dt>
<dd>File pointer for standard output stream. Automatically opened when program execution begins.</dd>
<dt><code id="stderr">stderr</code></dt>
<dd>File pointer for standard error stream. Automatically opened when program execution begins.</dd>
<dt><code id="FILE">FILE</code></dt>
<dd>Type of object holding information necessary to control a stream.</dd>
<dt><code id="fpos_t">fpos_t</code></dt>
<dd>Type for objects declared to store file position information.</dd>
<dt><code id="stdio.size_t">size_t</code></dt>
<dd>Type for objects declared to store result of <code>sizeof</code> operator.</dd>
<dt><code id="fopen"><a href="#FILE">FILE</a>* fopen(const char* <var>filename</var>, const char* <var>mode</var>);</code></dt>
<dd>Opens file named <code><var>filename</var></code> and returns a stream, or <code><a href="#stdio.NULL">NULL</a></code> on failure. <code><var>mode</var></code> may be one of the following for text files:
<dl>
<dt><code>"r"</code></dt>
<dd>text reading</dd>
<dt><code>"w"</code></dt>
<dd>text writing</dd>
<dt><code>"a"</code></dt>
<dd>text append</dd>
<dt><code>"r+"</code></dt>
<dd>text update (reading and writing)</dd>
<dt><code>"w+"</code></dt>
<dd>text update, discarding previous content (if any)</dd>
<dt><code>"a+"</code></dt>
<dd>text append, reading, and writing at end</dd>
</dl>
or one of those strings with <code>b</code> included (after the first character), for binary files.</dd>
<dt><code><a href="#FILE">FILE</a>* freopen(const char* <var>filename</var>, const char* <var>mode</var>, <a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Closes file associated with <code><var>stream</var></code>, then opens file <code><var>filename</var></code> with specified mode and associates it with <code><var>stream</var></code>. Returns <code><var>stream</var></code> or <code><a href="#stdio.NULL">NULL</a></code> on error.</dd>
<dt><code>int <span id="fflush">fflush</span>(<a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Flushes stream <code><var>stream</var></code> and returns zero on success or <a href="#EOF">EOF</a> on error. Effect undefined for input stream. <code><a href="#fflush">fflush</a>(<a href="#stdio.NULL">NULL</a>)</code> flushes all output streams.</dd>
<dt><code>int <span id="fclose">fclose</span>(<a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Closes stream <var>stream</var> (after flushing, if output stream). Returns <code><a href="#EOF">EOF</a></code> on error, zero otherwise.</dd>
<dt><code>int <span id="remove">remove</span>(const char* <var>filename</var>);</code></dt>
<dd>Removes specified file. Returns non-zero on failure.</dd>
<dt><code>int <span id="rename">rename</span>(const char* <var>oldname</var>, const char* <var>newname</var>);</code></dt>
<dd>Changes name of file <code><var>oldname</var></code> to <code><var>newname</var></code>. Returns non-zero on failure.</dd>
<dt><code><a href="#FILE">FILE</a>* <span id="tmpfile">tmpfile</span>();</code></dt>
<dd>Creates temporary file (mode <code>"wb+"</code>) which will be removed when closed or on normal program termination. Returns stream or <code><a href="#stdio.NULL">NULL</a></code> on failure.</dd>
<dt><code>char* <span id="tmpname">tmpname</span>(char <var>s</var>[<a href="#L_tmpnam">L_tmpnam</a>]);</code></dt>
<dd>Assigns to <code><var>s</var></code> (if <code><var>s</var></code> non-null) and returns unique name for a temporary file. Unique name is returned for each of the first <code><a href="#TMP_MAX">TMP_MAX</a></code> invocations.</dd>
<dt><code>int <span id="setvbuf">setvbuf</span>(<a href="#FILE">FILE</a>* <var>stream</var>, char* <var>buf</var>, int <var>mode</var>, <a href="#stdio.size_t">size_t</a> <var>size</var>);</code></dt>
<dd>Controls buffering for stream <code><var>stream</var></code>. <code><var>mode</var></code> is <code><a href="#_IOFBF">_IOFBF</a></code> for full buffering, <code><a href="#_IOLBF">_IOLBF</a></code> for line buffering, <code><a href="#_IONBF">_IONBF</a></code> for no buffering. Non-null <code><var>buf</var></code> specifies buffer of size <code><var>size</var></code> to be used; otherwise, a buffer is allocated. Returns non-zero on error. Call must be before any other operation on stream.</dd>
<dt><code>void <span id="setbuf">setbuf</span>(<a href="#FILE">FILE</a>* <var>stream</var>, char* <var>buf</var>);</code></dt>
<dd>Controls buffering for stream <var>stream</var>. For null <code><var>buf</var></code>, turns off buffering, otherwise equivalent to <code>(void)<a href="#setvbuf">setvbuf</a>(<var>stream</var>,&nbsp;<var>buf</var>,&nbsp;<a href="#_IOFBF">_IOFBF</a>,&nbsp;<a href="#BUFSIZ">BUFSIZ</a>)</code>.</dd>
<dt><code>int <span id="fprintf">fprintf</span>(<a href="#FILE">FILE</a>* <var>stream</var>, const char* <var>format</var>, ...);</code></dt>
<dd>Converts (according to format <code><var>format</var></code>) and writes output to stream <code><var>stream</var></code>. Number of characters written, or negative value on error, is returned. Conversion specifications consist of:
<ul>
<li><code>%</code></li>
<li>(optional) flag:
<dl>
<dt><code>-</code></dt>
<dd>left adjust</dd>
<dt><code>+</code></dt>
<dd>always sign</dd>
<dt><em>space</em></dt>
<dd>space if no sign</dd>
<dt><code>0</code></dt>
<dd>zero pad</dd>
<dt><code>#</code></dt>
<dd>Alternate form: for conversion character <code>o</code>, first digit will be zero, for [<code>xX</code>], prefix <code>0x</code> or <code>0X</code> to non-zero value, for [<code>eEfgG</code>], always decimal point, for [<code>gG</code>] trailing zeros not removed.</dd>
</dl>
</li>
<li>(optional) minimum width: if specified as <code>*</code>, value taken from next argument (which must be <code>int</code>).</li>
<li>(optional) <code>.</code> (separating width from precision):</li>
<li>(optional) precision: for conversion character <code>s</code>, maximum characters to be printed from the string, for [<code>eEf</code>], digits after decimal point, for [<code>gG</code>], significant digits, for an integer, minimum number of digits to be printed. If specified as <code>*</code>, value taken from next argument (which must be <code>int</code>).</li>
<li>(optional) length modifier:
<dl>
<dt><code>h</code></dt>
<dd><code>short</code> or <code>unsigned short</code></dd>
<dt><code>l</code></dt>
<dd><code>long</code> or <code>unsigned long</code></dd>
<dt><code>L</code></dt>
<dd><code>long double</code></dd>
</dl>
</li>
<li>conversion character:
<dl>
<dt><code>d,i</code></dt>
<dd><code>int</code> argument, printed in signed decimal notation</dd>
<dt><code>o</code></dt>
<dd><code>int</code> argument, printed in unsigned octal notation</dd>
<dt><code>x,X</code></dt>
<dd><code>int</code> argument, printed in unsigned hexadecimal notation</dd>
<dt><code>u</code></dt>
<dd><code>int</code> argument, printed in unsigned decimal notation</dd>
<dt><code>c</code></dt>
<dd><code>int</code> argument, printed as single character</dd>
<dt><code>s</code></dt>
<dd><code>char*</code> argument</dd>
<dt><code>f</code></dt>
<dd><code>double</code> argument, printed with format [<code>-</code>]<var>mmm</var><code>.</code><var>ddd</var></dd>
<dt><code>e,E</code></dt>
<dd><code>double</code> argument, printed with format [<code>-</code>]<var>m</var><code>.</code><var>dddddd</var>(<code>e</code>|<code>E</code>)(<code>+</code>|<code>-</code>)<var>xx</var></dd>
<dt><code>g,G</code></dt>
<dd><code>double</code> argument</dd>
<dt><code>p</code></dt>
<dd><code>void*</code> argument, printed as pointer</dd>
<dt><code>n</code></dt>
<dd><code>int*</code> argument : the number of characters written to this point is written <em>into</em> argument</dd>
<dt><code>%</code></dt>
<dd>no argument; prints %</dd>
</dl>
</li>
</ul>
</dd>
<dt><code>int <span id="printf">printf</span>(const char* <var>format</var>, ...);</code></dt>
<dd><code><a href="#printf">printf</a>(f, ...)</code> is equivalent to <code><a href="#fprintf">fprintf</a>(<a href="#stdout">stdout</a>, f, ...)</code></dd>
<dt><code>int <span id="sprintf">sprintf</span>(char* <var>s</var>, const char* <var>format</var>, ...);</code></dt>
<dd>Like <a href="#fprintf">fprintf</a>, but output written into string <code><var>s</var></code>, which <strong>must be large enough to hold the output</strong>, rather than to a stream. Output is <code>NUL</code>-terminated. Returns length (excluding the terminating <code>NUL</code>).</dd>
<dt><code>int <span id="vfprintf">vfprintf</span>(<a href="#FILE">FILE</a>* <var>stream</var>, const char* <var>format</var>, <a href="#va_list">va_list</a> <var>arg</var>);</code></dt>
<dd>Equivalent to <code><a href="#fprintf">fprintf</a></code> with variable argument list replaced by <code><var>arg</var></code>, which must have been initialised by the <code><a href="#va_start">va_start</a></code> macro (and may have been used in calls to <code><a href="#va_arg">va_arg</a></code>).</dd>
<dt><code>int <span id="vprintf">vprintf</span>(const char* <var>format</var>, <a href="#va_list">va_list</a> <var>arg</var>);</code></dt>
<dd>Equivalent to <code><a href="#printf">printf</a></code> with variable argument list replaced by <code><var>arg</var></code>, which must have been initialised by the <code><a href="#va_start">va_start</a></code> macro (and may have been used in calls to <code><a href="#va_arg">va_arg</a></code>).</dd>
<dt><code>int vsprintf(char* <var>s</var>, const char* <var>format</var>, <a href="#va_list">va_list</a> <var>arg</var>);</code></dt>
<dd>Equivalent to <code><a href="#sprintf">sprintf</a></code> with variable argument list replaced by <code><var>arg</var></code>, which must have been initialised by the <code><a href="#va_start">va_start</a></code> macro (and may have been used in calls to <code><a href="#va_arg">va_arg</a></code>).</dd>
<dt><code>int <span id="fscanf">fscanf</span>(<a href="#FILE">FILE</a>* <var>stream</var>, const char* <var>format</var>, ...);</code></dt>
<dd>Performs formatted input conversion, reading from stream <code><var>stream</var></code> according to format <code><var>format</var></code>. The function returns when <code><var>format</var></code> is fully processed. Returns number of items converted and assigned, or <code><a href="#EOF">EOF</a></code> if end-of-file or error occurs before any conversion. Each of the arguments following <code><var>format</var></code> <strong>must be a pointer</strong>. Format string may contain:
<ul>
<li>blanks and tabs, which are ignored</li>
<li>ordinary characters, which are expected to match next non-white-space of input</li>
<li>conversion specifications, consisting of:
<ul>
<li><code>%</code></li>
<li>(optional) assignment suppression character "<code>*</code>"</li>
<li>(optional) maximum field width</li>
<li>(optional) target width indicator:
<dl>
<dt><code>h</code></dt>
<dd>argument is pointer to <code>short</code> rather than <code>int</code></dd>
<dt><code>l</code></dt>
<dd>argument is pointer to <code>long</code> rather than <code>int</code>, or <code>double</code> rather than <code>float</code></dd>
<dt><code>L</code></dt>
<dd>argument is pointer to <code>long double</code> rather than <code>float</code></dd>
</dl>
</li>
<li>conversion character:
<dl>
<dt><code>d</code></dt>
<dd>decimal integer; <code>int*</code> parameter required</dd>
<dt><code>i</code></dt>
<dd>integer; <code>int*</code> parameter required; decimal, octal or hex</dd>
<dt><code>o</code></dt>
<dd>octal integer; <code>int*</code> parameter required</dd>
<dt><code>u</code></dt>
<dd>unsigned decimal integer; <code>unsigned int*</code> parameter required</dd>
<dt><code>x</code></dt>
<dd>hexadecimal integer; <code>int*</code> parameter required</dd>
<dt><code>c</code></dt>
<dd>characters; <code>char*</code> parameter required; white-space is not skipped, and <code>NUL</code>-termination is not performed</dd>
<dt><code>s</code></dt>
<dd>string of non-white-space; <code>char*</code> parameter required; string is <code>NUL</code>-terminated</dd>
<dt><code>e,f,g</code></dt>
<dd>floating-point number; <code>float*</code> parameter required</dd>
<dt><code>p</code></dt>
<dd>pointer value; <code>void*</code> parameter required</dd>
<dt><code>n</code></dt>
<dd>chars read so far; <code>int*</code> parameter required</dd>
<dt><code>[<var>...</var>]</code></dt>
<dd>longest non-empty string from specified set; <code>char*</code> parameter required; string is <code>NUL</code>-terminated</dd>
<dt><code>[^<var>...</var>]</code></dt>
<dd>longest non-empty string not from specified set; <code>char*</code> parameter required; string is <code>NUL</code>-terminated</dd>
<dt><code>%</code></dt>
<dd>literal <code>%</code>; no assignment</dd>
</dl>
</li>
</ul>
</li>
</ul>
</dd>
<dt><code>int <span id="scanf">scanf</span>(const char* <var>format</var>, ...);</code></dt>
<dd><code><a href="#scanf">scanf</a>(f, ...)</code> is equivalent to <code><a href="#fscanf">fscanf</a>(<a href="#stdin">stdin</a>, f, ...)</code></dd>
<dt><code>int sscanf(char* <var>s</var>, const char* <var>format</var>, ...);</code></dt>
<dd>Like <code><a href="#fscanf">fscanf</a></code>, but input read from string <code><var>s</var></code>.</dd>
<dt><code>int <span id="fgetc">fgetc</span>(<a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Returns next character from (input) stream <code><var>stream</var></code>, or <code><a href="#EOF">EOF</a></code> on end-of-file or error.</dd>
<dt><code>char* <span id="fgets">fgets</span>(char* <var>s</var>, int <var>n</var>, <a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Copies characters from (input) stream <code><var>stream</var></code> to <code><var>s</var></code>, stopping when <code><var>n</var></code>-1 characters copied, newline copied, end-of-file reached or error occurs. If no error, <code><var>s</var></code> is <code>NUL</code>-terminated. Returns <code><a href="#stdio.NULL">NULL</a></code> on end-of-file or error, <code><var>s</var></code> otherwise.</dd>
<dt>int <code><span id="fputc">fputc</span>(int <var>c</var>, <a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Writes <code><var>c</var></code>, to stream <code><var>stream</var></code>. Returns <code><var>c</var></code>, or <code><a href="#EOF">EOF</a></code> on error.</dd>
<dt><code>char* <span id="fputs">fputs</span>(const char* <var>s</var>, <a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Writes <code><var>s</var></code>, to (output) stream stream. Returns non-negative on success or <code><a href="#EOF">EOF</a></code> on error.</dd>
<dt><code>int <span id="getc">getc</span>(<a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Equivalent to <code><a href="#fgetc">fgetc</a></code> except that it may be a macro.</dd>
<dt><code>int <span id="getchar">getchar</span>(void);</code></dt>
<dd>Equivalent to <code><a href="#getc">getc</a>(<a href="#stdin">stdin</a>)</code>.</dd>
<dt><code>char* <span id="gets">gets</span>(char* <var>s</var>);</code></dt>
<dd>Copies characters from <code><a href="#stdin">stdin</a></code> into <code><var>s</var></code> until newline encountered, end-of-file reached, or error occurs. Does not copy newline. <code>NUL</code>-terminates <code><var>s</var></code>. Returns <code><var>s</var></code>, or <code><a href="#stdio.NULL">NULL</a></code> on end-of-file or error. <strong>Should not be used because of the potential for buffer overflow.</strong></dd>
<dt><code>int <span id="putc">putc</span>(int <var>c</var>, <a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Equivalent to <code><a href="#fputc">fputc</a></code> except that it may be a macro.</dd>
<dt><code>int <span id="putchar">putchar</span>(int <var>c</var>);</code></dt>
<dd><code>putchar(<var>c</var>)</code> is equivalent to <code><a href="#putc">putc</a>(<var>c</var>, <a href="#stdout">stdout</a>)</code>.</dd>
<dt><code>int <span id="puts">puts</span>(const char* <var>s</var>);</code></dt>
<dd>Writes <code><var>s</var></code> (excluding terminating <code>NUL</code>) and a newline to <code><a href="#stdout">stdout</a></code>. Returns non-negative on success, <code><a href="#EOF">EOF</a></code> on error.</dd>
<dt><code>int <span id="ungetc">ungetc</span>(int <var>c</var>, <a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Pushes <code><var>c</var></code> (which must not be <code><a href="#EOF">EOF</a></code>), onto (input) stream <code><var>stream</var></code> such that it will be returned by the next read. Only one character of pushback is guaranteed (for each stream). Returns <code><var>c</var></code>, or <code><a href="#EOF">EOF</a></code> on error.</dd>
<dt><code><a href="#stdio.size_t">size_t</a> <span id="fread">fread</span>(void* <var>ptr</var>, <a href="#stdio.size_t">size_t</a> <var>size</var>, <a href="#stdio.size_t">size_t</a> <var>nobj</var>, <a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Reads (at most) <code><var>nobj</var></code> objects of size <code><var>size</var></code> from stream <code><var>stream</var></code> into <code><var>ptr</var></code> and returns number of objects read. (<code><a href="#feof">feof</a></code> and <code><a href="#ferror">ferror</a></code> can be used to check status.)</dd>
<dt><code>size_t <span id="fwrite">fwrite</span>(const void* <var>ptr</var>, <a href="#stdio.size_t">size_t</a> <var>size</var>, <a href="#stdio.size_t">size_t</a> <var>nobj</var>, <a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Writes to stream <code><var>stream</var></code>, <code><var>nobj</var></code> objects of size <code><var>size</var></code> from array <code><var>ptr</var></code>. Returns number of objects written.</dd>
<dt><code>int <span id="fseek">fseek</span>(<a href="#FILE">FILE</a>* <var>stream</var>, long <var>offset</var>, int <var>origin</var>);</code></dt>
<dd>Sets file position for stream <code><var>stream</var></code> and clears end-of-file indicator. For a binary stream, file position is set to <code><var>offset</var></code> bytes from the position indicated by <code><var>origin</var></code>: beginning of file for <code><a href="#SEEK_SET">SEEK_SET</a></code>, current position for <code><a href="#SEEK_CUR">SEEK_CUR</a></code>, or end of file for <code><a href="#SEEK_END">SEEK_END</a></code>. Behaviour is similar for a text stream, but <code><var>offset</var></code> must be zero or, for <code><a href="#SEEK_SET">SEEK_SET</a></code> only, a value returned by <code><a href="#ftell">ftell</a></code>. Returns non-zero on error.</dd>
<dt><code>long <span id="ftell">ftell</span>(<a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Returns current file position for stream <code><var>stream</var></code>, or <code>-1</code> on error.</dd>
<dt><code>void <span id="rewind">rewind</span>(<a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Equivalent to <code><a href="#fseek">fseek</a>(<var>stream</var>, 0L, SEEK_SET); <a href="#clearerr">clearerr</a>(<var>stream</var>)</code>.</dd>
<dt><code>int <span id="fgetpos">fgetpos</span>(<a href="#FILE">FILE</a>* <var>stream</var>, <a href="#fpos_t">fpos_t</a>* <var>ptr</var>);</code></dt>
<dd>Stores current file position for stream <code><var>stream</var></code> in <code>*<var>ptr</var></code>. Returns non-zero on error.</dd>
<dt><code>int <span id="fsetpos">fsetpos</span>(<a href="#FILE">FILE</a>* <var>stream</var>, const <a href="#fpos_t">fpos_t</a>* <var>ptr</var>);</code></dt>
<dd>Sets current position of stream <var>stream</var> to <code>*<var>ptr</var></code>. Returns non-zero on error.</dd>
<dt><code>void <span id="clearerr">clearerr</span>(<a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Clears end-of-file and error indicators for stream <code><var>stream</var></code>.</dd>
<dt><code>int <span id="feof">feof</span>(<a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Returns non-zero if end-of-file indicator is set for stream <code><var>stream</var></code>.</dd>
<dt><code>int <span id="ferror">ferror</span>(<a href="#FILE">FILE</a>* <var>stream</var>);</code></dt>
<dd>Returns non-zero if error indicator is set for stream <code><var>stream</var></code>.</dd>
<dt><code>void <span id="perror">perror</span>(const char* <var>s</var>);</code></dt>
<dd>Prints <code><var>s</var></code> (if non-null) and <code><a href="#strerror">strerror</a>(<a href="#errno">errno</a>)</code> to standard error as would:
<pre><a href="#fprintf">fprintf</a>(<a href="#stderr">stderr</a>, "%s: %s\n", (<var>s</var> != <a href="#stdio.NULL">NULL</a> ? <var>s</var> : ""), <a href="#strerror">strerror</a>(<a href="#errno">errno</a>))</pre></dd>
</dl>
<h2 id="utility_functions">Utility functions</h2>
<p><code class="preprocessor">#include &lt;stdlib.h&gt;</code></p>
<dl>
<dt><code id="EXIT_FAILURE">EXIT_FAILURE</code></dt>
<dd>Value for <code><var>status</var></code> argument to <code><a href="#exit">exit</a></code> indicating failure.</dd>
<dt><code id="EXIT_SUCCESS">EXIT_SUCCESS</code></dt>
<dd>Value for <code><var>status</var></code> argument to <code><a href="#exit">exit</a></code> indicating success.</dd>
<dt><code id="RAND_MAX">RAND_MAX</code></dt>
<dd>Maximum value returned by <code><a href="#rand">rand</a>()</code>.</dd>
<dt><code id="stdlib.NULL">NULL</code></dt>
<dd>Null pointer constant.</dd>
<dt><code id="div_t">div_t</code></dt>
<dd>Return type of <code><a href="#div">div</a>()</code>. Structure having members:
<dl>
<dt><code>int quot;</code></dt>
<dd>quotient</dd>
<dt><code>int rem;</code></dt>
<dd>remainder</dd>
</dl>
</dd>
<dt><code id="ldiv_t">ldiv_t</code></dt>
<dd>Return type of <code><a href="#ldiv">ldiv</a>()</code>. Structure having members:
<dl>
<dt><code>long quot;</code></dt>
<dd>quotient</dd>
<dt><code>long rem;</code></dt>
<dd>remainder</dd>
</dl>
</dd>
<dt><code id="stdlib.size_t">size_t</code></dt>
<dd>Type for objects declared to store result of <code>sizeof</code> operator.</dd>
<dt><code>int abs(int <var>n</var>);</code></dt>
<dt><code>long labs(long <var>n</var>);</code></dt>
<dd>Returns absolute value of <code><var>n</var></code>.</dd>
<dt><code><a href="#div_t">div_t</a> <span id="div">div</span>(int <var>num</var>, int <var>denom</var>);</code></dt>
<dt><code><a href="#ldiv_t">ldiv_t</a> <span id="ldiv">ldiv</span>(long <var>num</var>, long <var>denom</var>);</code></dt>
<dd>Returns quotient and remainder of <code><var>num</var>/<var>denom</var></code>.</dd>
<dt><code>double atof(const char* <var>s</var>);</code></dt>
<dd>Equivalent to <code><a href="#strtod">strtod</a>(<var>s</var>, (char**)<a href="#stdlib.NULL">NULL</a>)</code> except that <code><a href="#errno">errno</a></code> is not necessarily set on conversion error.</dd>
<dt><code>int atoi(const char* <var>s</var>);</code></dt>
<dd>Equivalent to <code>(int)<a href="#strtol">strtol</a>(<var>s</var>, (char**)<a href="#stdlib.NULL">NULL</a>, 10)</code> except that <code><a href="#errno">errno</a></code> is not necessarily set on conversion error.</dd>
<dt><code>long atol(const char* <var>s</var>);</code></dt>
<dd>Equivalent to <code><a href="#strtol">strtol</a>(<var>s</var>, (char**)<a href="#stdlib.NULL">NULL</a>, 10)</code> except that <code><a href="#errno">errno</a></code> is not necessarily set on conversion error.</dd>
<dt><code>double <span id="strtod">strtod</span>(const char* <var>s</var>, char** <var>endp</var>);</code></dt>
<dd>Converts initial characters (ignoring leading white space) of <code><var>s</var></code> to type <code>double</code>. If <code><var>endp</var></code> non-null, stores pointer to unconverted suffix in <code>*<var>endp</var></code>. On overflow, sets <code><a href="#errno">errno</a></code> to <code><a href="#ERANGE">ERANGE</a></code> and returns <code><a href="#HUGE_VAL">HUGE_VAL</a></code> with the appropriate sign; on underflow, sets <code><a href="#errno">errno</a></code> to <code><a href="#ERANGE">ERANGE</a></code> and returns zero; otherwise returns converted value.</dd>
<dt><code>long <span id="strtol">strtol</span>(const char* <var>s</var>, char** <var>endp</var>, int <var>base</var>);</code></dt>
<dd>Converts initial characters (ignoring leading white space) of <code><var>s</var></code> to type <code>long</code>. If <code><var>endp</var></code> non-nu ll, stores pointer to unconverted suffix in <code>*<var>endp</var></code>. If <code><var>base</var></code> between 2 and 36, that base used for conversion; if zero, leading (after any sign) <code>0X</code> or <code>0x</code> implies hexadecimal, leading <code>0</code> (after any sign) implies octal, otherwise decimal assumed. Leading <code>0X</code> or <code>0x</code> permitted for base hexadecimal. On overflow, sets <code><a href="#errno">errno</a></code> to <code><a href="#ERANGE">ERANGE</a></code> and returns <code><a href="#LONG_MAX">LONG_MAX</a></code> or <code><a href="#LONG_MIN">LONG_MIN</a></code> (as appropriate for sign); otherwise returns converted value.</dd>
<dt><code>unsigned long <span id="strtoul">strtoul</span>(const char* <var>s</var>, char** <var>endp</var>, int <var>base</var>);</code></dt>
<dd>As for <code><a href="#strtol">strtol</a></code> except result is <code>unsigned long</code> and value on overflow is <code><a href="#ULONG_MAX">ULONG_MAX</a></code>.</dd>
<dt><code>void* calloc(<a href="#stdlib.size_t">size_t</a> <var>nobj</var>, <a href="#stdlib.size_t">size_t</a> <var>size</var>);</code></dt>
<dd>Returns pointer to <em>zero-initialised</em> newly-allocated space for an array of <code><var>nobj</var></code> objects each of size <code><var>size</var></code>, or <code><a href="#stdlib.NULL">NULL</a></code> on error.</dd>
<dt><code>void* malloc(<a href="#stdlib.size_t">size_t</a> <var>size</var>);</code></dt>
<dd>Returns pointer to <em>uninitialised</em> newly-allocated space for an object of size <var>size</var>, or <code><a href="#stdlib.NULL">NULL</a></code> on error.</dd>
<dt><code>void* realloc(void* <var>p</var>, size_t <var>size</var>);</code></dt>
<dd>Returns pointer to newly-allocated space for an object of size <code><var>size</var></code>, initialised, to minimum of old and new sizes, to existing contents of <code><var>p</var></code> (if non-null), or <code><a href="#stdlib.NULL">NULL</a></code> on error. On success, old object deallocated, otherwise unchanged.</dd>
<dt><code>void free(void* <var>p</var>);</code></dt>
<dd>If <code><var>p</var></code> non-null, deallocates space to which it points.</dd>
<dt><code>void <span id="abort">abort</span>();</code></dt>
<dd>Terminates program abnormally, by calling <code><a href="#raise">raise</a>(<a href="#sigabrt">SIGABRT</a>)</code>.</dd>
<dt><code>void <span id="exit">exit</span>(int <var>status</var>);</code></dt>
<dd>Terminates program normally. Functions installed using <code><a href="#atexit">atexit</a></code> are called (in reverse order to that in which installed), open files are flushed, open streams are closed and control is returned to environment. <code><var>status</var></code> is returned to environment in implementation-dependent manner. Zero or <code><a href="#EXIT_SUCCESS">EXIT_SUCCESS</a></code> indicates successful termination and <code><a href="#EXIT_FAILURE">EXIT_FAILURE</a></code> indicates unsuccessful termination. Implementations may define other values.</dd>
<dt><code>int <span id="atexit">atexit</span>(void (*<var>fcm</var>)(void));</code></dt>
<dd>Registers <code><var>fcn</var></code> to be called when program terminates normally (or when <code>main</code> returns). Returns non-zero on failure.</dd>
<dt><code>int system(const char* <var>s</var>);</code></dt>
<dd>If <code><var>s</var></code> is not <code><a href="#stdlib.NULL">NULL</a></code>, passes <code><var>s</var></code> to environment for execution, and returns status reported by command processor; if <code><var>s</var></code> is <code><a href="#stdlib.NULL">NULL</a></code>, non-zero returned if environment has a command processor.</dd>
<dt><code>char* getenv(const char* <var>name</var>);</code></dt>
<dd>Returns string associated with name <code><var>name</var></code> from implementation's environment, or <code><a href="#stdlib.NULL">NULL</a></code> if no such string exists.</dd>
<dt><code>void* bsearch(const void* <var>key</var>, const void* <var>base</var>, <a href="#stdio.size_t">size_t</a> <var>n</var>, <a href="#stdio.size_t">size_t</a> <var>size</var>, int (*<var>cmp</var>)(const void* keyval, const void* datum));</code></dt>
<dd>Searches ordered array <code><var>base</var></code> (of <code><var>n</var></code> objects each of size <code><var>size</var></code>) for item matching <code><var>key</var></code> according to comparison function <code><var>cmp</var></code>. <code><var>cmp</var></code> must return negative value if first argument is less than second, zero if equal and positive if greater. Items of <code><var>base</var></code> are assumed to be in ascending order (according to <code><var>cmp</var></code>). Returns a pointer to an item matching <code><var>key</var></code>, or <code><a href="#stdlib.NULL">NULL</a></code> if none found.</dd>
<dt><code>void qsort(void* <var>base</var>, <a href="#stdio.size_t">size_t</a> <var>n</var>, <a href="#stdio.size_t">size_t</a> <var>size</var>, int (*<var>cmp</var>)(const void*, const void*));</code></dt>
<dd>Arranges into ascending order array <code><var>base</var></code> (of <code><var>n</var></code> objects each of size <code><var>size</var></code>) according to comparison function <code><var>cmp</var></code>. <code><var>cmp</var></code> must return negative value if first argument is less than second, zero if equal and positive if greater.</dd>
<dt><code>int <span id="rand">rand</span>(void);</code></dt>
<dd>Returns pseudo-random number in range <code>0</code> to <code><a href="#RAND_MAX">RAND_MAX</a></code>.</dd>
<dt><code>void srand(unsigned int <var>seed</var>);</code></dt>
<dd>Uses <code><var>seed</var></code> as seed for new sequence of pseudo-random numbers. Initial seed is <code>1</code>.</dd>
</dl>
<h2 id="string_functions">String functions</h2>
<pre>
<code class="preprocessor">#include &lt;string.h&gt;</code>
</pre>
<dl>
<dt><code id="string.NULL">NULL</code></dt>
<dd>Null pointer constant.</dd>
<dt><code id="string.size_t">size_t</code></dt>
<dd>Type for objects declared to store result of <code>sizeof</code> operator.</dd>
<dt><code>char* strcpy(char* <var>s</var>, const char* <var>ct</var>);</code></dt>
<dd>Copies <code><var>ct</var></code> to <code><var>s</var></code> including terminating <code>NUL</code> and returns <code><var>s</var></code>.</dd>
<dt><code>char* strncpy(char* <var>s</var>, const char* <var>ct</var>, <a href="#string.size_t">size_t</a> <var>n</var>);</code></dt>
<dd>Copies at most <code><var>n</var></code> characters of <code><var>ct</var></code> to <code><var>s</var></code>. Pads with <code>NUL</code> characters if <code><var>ct</var></code> is of length less than <code><var>n</var></code>. <strong>Note that this may leave <code><var>s</var></code> without <code>NUL</code>-termination.</strong> Return <code><var>s</var></code>.</dd>
<dt><code>char* strcat(char* <var>s</var>, const char* <var>ct</var>);</code></dt>
<dd>Concatenate <code><var>ct</var></code> to <code><var>s</var></code> and return <code><var>s</var></code>.</dd>
<dt><code>char* strncat(char* <var>s</var>, const char* <var>ct</var>, <a href="#string.size_t">size_t</a> <var>n</var>);</code></dt>
<dd>Concatenate at most <code><var>n</var></code> characters of <code><var>ct</var></code> to <code><var>s</var></code>. <code>NUL</code>-terminates <code><var>s</var></code> and return it.</dd>
<dt><code>int strcmp(const char* <var>cs</var>, const char* <var>ct</var>);</code></dt>
<dd>Compares <code><var>cs</var></code> with <code><var>ct</var></code>, returning negative value if <code><var>cs</var>&lt;<var>ct</var></code>, zero if <code><var>cs</var>==<var>ct</var></code>, positive value if <code><var>cs</var>&gt;<var>ct</var></code>.</dd>
<dt><code>int strncmp(const char* <var>cs</var>, const char* <var>ct</var>, <a href="#string.size_t">size_t</a> <var>n</var>);</code></dt>
<dd>Compares at most (the first) <code><var>n</var></code> characters of <code><var>cs</var></code> and <code><var>ct</var></code>, returning negative value if <code><var>cs</var>&lt;<var>ct</var></code>, zero if <code><var>cs</var>==<var>ct</var></code>, positive value if <code><var>cs</var>&gt;<var>ct</var></code>.</dd>
<dt><code>int strcoll(const char* <var>cs</var>, const char* <var>ct</var>);</code></dt>
<dd>Compares <code><var>cs</var></code> with <code><var>ct</var></code> according to locale, returning negative value if <code><var>cs</var>&lt;<var>ct</var></code>, zero if <code><var>cs</var>==<var>ct</var></code>, positive value if <code><var>cs</var>&gt;<var>ct</var></code>.</dd>
<dt><code>char* strchr(const char* <var>cs</var>, int <var>c</var>);</code></dt>
<dd>Returns pointer to first occurrence of <code><var>c</var></code> in <code><var>cs</var></code>, or <code><a href="#string.NULL">NULL</a></code> if not found.</dd>
<dt><code>char* strrchr(const char* <var>cs</var>, int <var>c</var>);</code></dt>
<dd>Returns pointer to last occurrence of <code><var>c</var></code> in <code><var>cs</var></code>, or <code><a href="#string.NULL">NULL</a></code> if not found.</dd>
<dt><code><a href="#string.size_t">size_t</a> strspn(const char* <var>cs</var>, const char* <var>ct</var>);</code></dt>
<dd>Returns length of prefix of <code><var>cs</var></code> which consists of characters which are in <code><var>ct</var></code>.</dd>
<dt><code><a href="#string.size_t">size_t</a> strcspn(const char* <var>cs</var>, const char* <var>ct</var>);</code></dt>
<dd>Returns length of prefix of <code><var>cs</var></code> which consists of characters which are <em>not</em> in <code><var>ct</var></code>.</dd>
<dt><code>char* strpbrk(const char* <var>cs</var>, const char* <var>ct</var>);</code></dt>
<dd>Returns pointer to first occurrence in <code><var>cs</var></code> of any character of <code><var>ct</var></code>, or <code><a href="#string.NULL">NULL</a></code> if none is found.</dd>
<dt><code>char* strstr(const char* <var>cs</var>, const char* <var>ct</var>);</code></dt>
<dd>Returns pointer to first occurrence of <code><var>ct</var></code> within <code><var>cs</var></code>, or <code><a href="#string.NULL">NULL</a></code> if none is found.</dd>
<dt><code><a href="#string.size_t">size_t</a> strlen(const char* <var>cs</var>);</code></dt>
<dd>Returns length of <code><var>cs</var></code>.</dd>
<dt><code id="strerror">char* strerror(int <var>n</var>);</code></dt>
<dd>Returns pointer to implementation-defined message string corresponding with error <code><var>n</var></code>.</dd>
<dt><code>char* strtok(char* <var>s</var>, const char* <var>t</var>);</code></dt>
<dd>Searches <code><var>s</var></code> for next token delimited by any character from <code><var>ct</var></code>. Non-<code><a href="#string.NULL">NULL</a></code> <code><var>s</var></code> indicates the first call of a sequence. If a token is found, it is <code>NUL</code>-terminated and returned, otherwise <code><a href="#string.NULL">NULL</a></code> is returned. <code><var>ct</var></code> need not be identical for each call in a sequence.</dd>
<dt><code><a href="#string.size_t">size_t</a> strxfrm(char* <var>s</var>, const char* <var>ct</var>, <a href="#string.size_t">size_t</a> <var>n</var>);</code></dt>
<dd>Stores in <code><var>s</var></code> no more than <code><var>n</var></code> characters (including terminating <code>NUL</code>) of a string produced from <code><var>ct</var></code> according to a locale-specific transformation. Returns length of <em>entire</em> transformed string.</dd>
<dt><code>void* <span id="memcpy">memcpy</span>(void* <var>s</var>, const void* <var>ct</var>, <a href="#string.size_t">size_t</a> <var>n</var>);</code></dt>
<dd>Copies <code><var>n</var></code> characters from <code><var>ct</var></code> to <code><var>s</var></code> and returns <code><var>s</var></code>. <strong><code><var>s</var></code> may be corrupted if objects overlap.</strong></dd>
<dt><code>void* memmove(void* <var>s</var>, const void* <var>ct</var>, <a href="#string.size_t">size_t</a> <var>n</var>);</code></dt>
<dd>Copies <code><var>n</var></code> characters from <code><var>ct</var></code> to <code><var>s</var></code> and returns <code><var>s</var></code>. <strong><code><var>s</var></code> will not be corrupted if objects overlap.</strong></dd>
<dt><code>int memcmp(const void* <var>cs</var>, const void* <var>ct</var>, <a href="#string.size_t">size_t</a> <var>n</var>);</code></dt>
<dd>Compares at most (the first) <code><var>n</var></code> characters of <code><var>cs</var></code> and <code><var>ct</var></code>, returning negative value if <code><var>cs</var>&lt;<var>ct</var></code>, zero if <code><var>cs</var>==<var>ct</var></code>, positive value if <code><var>cs</var>&gt;<var>ct</var></code>.</dd>
<dt><code>void* memchr(const void* <var>cs</var>, int <var>c</var>, <a href="#string.size_t">size_t</a> <var>n</var>);</code></dt>
<dd>Returns pointer to first occurrence of <code><var>c</var></code> in first <code><var>n</var></code> characters of <code><var>cs</var></code>, or <code><a href="#string.NULL">NULL</a></code> if not found.</dd>
<dt><code>void* memset(void* <var>s</var>, int <var>c</var>, <a href="#string.size_t">size_t</a> <var>n</var>);</code></dt>
<dd>Replaces each of the first <code><var>n</var></code> characters of <code><var>s</var></code> by <code><var>c</var></code> and returns <code><var>s</var></code>.</dd>
</dl>
<h2 id="time_and_date_functions">Time and Date functions</h2>
<p><code class="preprocessor">#include &lt;time.h&gt;</code></p>
<dl>
<dt><code>CLOCKS_PER_SEC</code></dt>
<dd>The number of <code><a href="#clock_t">clock_t</a></code> units per second.</dd>
<dt><code id="time.NULL">NULL</code></dt>
<dd>Null pointer constant.</dd>
<dt><code id="clock_t">clock_t</code></dt>
<dd>An arithmetic type elapsed processor representing time.</dd>
<dt><code id="time_t">time_t</code></dt>
<dd>An arithmetic type representing calendar time.</dd>
<dt><code id="tm">struct tm</code></dt>
<dd>Represents the components of calendar time:
<dl>
<dt><code>int tm_sec;</code></dt>
<dd>seconds after the minute</dd>
<dt><code>int tm_min;</code></dt>
<dd>minutes after the hour</dd>
<dt><code>int tm_hour;</code></dt>
<dd>hours since midnight</dd>
<dt><code>int tm_mday;</code></dt>
<dd>day of the month</dd>
<dt><code>int tm_mon;</code></dt>
<dd>months <strong>since</strong> January</dd>
<dt><code>int tm_year;</code></dt>
<dd>years since 1900</dd>
<dt><code>int tm_wday;</code></dt>
<dd>days since Sunday</dd>
<dt><code>int tm_yday;</code></dt>
<dd>days since January 1</dd>
<dt><code>int tm_isdst;</code></dt>
<dd>Daylight Saving Time flag : is positive if DST is in effect, zero if not in effect, negative if information not known.</dd>
</dl>
Implementations may change field order and include additional fields.</dd>
<dt><code><a href="#clock_t">clock_t</a> clock(void);</code></dt>
<dd>Returns elapsed processor time used by program or <code>-1</code> if not available.</dd>
<dt><code><a href="#time_t">time_t</a> time(<a href="#time_t">time_t</a>* <var>tp</var>);</code></dt>
<dd>Returns current calendar time or <code>-1</code> if not available. If <code><var>tp</var></code> is non-<code><a href="#time.NULL">NULL</a></code>, return value is also assigned to <code>*<var>tp</var></code>.</dd>
<dt><code>double difftime(<a href="#time_t">time_t</a> <var>time2</var>, <a href="#time_t">time_t</a> <var>time1</var>);</code></dt>
<dd>Returns the difference in seconds between <code><var>time2</var></code> and <code><var>time1</var></code>.</dd>
<dt><code><a href="#time_t">time_t</a> mktime(<a href="#tm">struct tm</a>* <var>tp</var>);</code></dt>
<dd>If necessary, adjusts fields of <code>*<var>tp</var></code> to fall withing normal ranges. Returns the corresponding calendar time, or <code>-1</code> if it cannot be represented.</dd>
<dt><code>char* <span id="asctime">asctime</span>(const <a href="#tm">struct tm</a>* <var>tp</var>);</code></dt>
<dd>Returns the given time as a string of the form: <code>Sun Jan 3 13:08:42 1988\n\0</code></dd>
<dt><code>char* ctime(const <a href="#time_t">time_t</a>* <var>tp</var>);</code></dt>
<dd>Returns string equivalent to calendar time <code><var>tp</var></code> converted to local time. Equivalent to: <code><a href="#asctime">asctime</a>(<a href="#localtime">localtime</a>(tp))</code></dd>
<dt><code><a href="#tm">struct tm</a>* gmtime(const <a href="#time_t">time_t</a>* <var>tp</var>);</code></dt>
<dd>Returns calendar time <code>*<var>tp</var></code> converted to Coordinated Universal Time, or <code><a href="#time.NULL">NULL</a></code> if not available.</dd>
<dt><code><a href="#tm">struct tm</a>* <span id="localtime">localtime</span>(const <a href="#time_t">time_t</a>* <var>tp</var>);</code></dt>
<dd>Returns calendar time <code>*<var>tp</var></code> converted into local time.</dd>
<dt><code>size_t strftime(char* <var>s</var>, size_t <var>smax</var>, const char* <var>fmt</var>, const <a href="#tm">struct tm</a>* <var>tp</var>);</code></dt>
<dd>Formats <code>*<var>tp</var></code> into <code><var>s</var></code> according to <code><var>fmt</var></code>. Places no more than <code><var>smax</var></code> characters into <code><var>s</var></code>, and returns number of characters produced (excluding terminating <code>NUL</code>), or <code>0</code> if greater than <code><var>smax</var></code>. Formatting conversions (<code>%<var>c</var></code>) are:
<dl>
<dt><code>A</code></dt>
<dd>name of weekday</dd>
<dt><code>a</code></dt>
<dd>abbreviated name of weekday</dd>
<dt><code>B</code></dt>
<dd>name of month</dd>
<dt><code>b</code></dt>
<dd>abbreviated name of month</dd>
<dt><code>c</code></dt>
<dd>local date and time representation</dd>
<dt><code>d</code></dt>
<dd>day of month [<code>01</code>-<code>31</code>]</dd>
<dt><code>H</code></dt>
<dd>hour (24-hour clock) [<code>00</code>-<code>23</code>]</dd>
<dt><code>I</code></dt>
<dd>hour (12-hour clock) [<code>01</code>-<code>12</code>]</dd>
<dt><code>j</code></dt>
<dd>day of year [<code>001</code>-<code>366</code>]</dd>
<dt><code>M</code></dt>
<dd>minute [<code>00</code>-<code>59</code>]</dd>
<dt><code>m</code></dt>
<dd>month [<code>01</code>-<code>12</code>]</dd>
<dt><code>p</code></dt>
<dd>local equivalent of "<code>AM</code>" or "<code>PM</code>"</dd>
<dt><code>S</code></dt>
<dd>second [<code>00</code>-<code>61</code>]</dd>
<dt><code>U</code></dt>
<dd>week number of year (Sunday as 1st day of week) [<code>00</code>-<code>53</code>]</dd>
<dt><code>W</code></dt>
<dd>week number of year (Monday as 1st day of week) [<code>00</code>-<code>53</code>]</dd>
<dt><code>w</code></dt>
<dd>weekday (Sunday as <code>0</code>) [<code>0</code>-<code>6</code>]</dd>
<dt><code>X</code></dt>
<dd>local time representation</dd>
<dt><code>x</code></dt>
<dd>local date representation</dd>
<dt><code>Y</code></dt>
<dd>year with century</dd>
<dt><code>y</code></dt>
<dd>year without century [<code>00</code>-<code>99</code>]</dd>
<dt><code>Z</code></dt>
<dd>name (if any) of time zone</dd>
<dt><code>%</code></dt>
<dd><code>%</code></dd>
</dl>
</dd>
</dl>
<p><em>Local</em> time may differ from <em>calendar</em> time because of time zone.</p>
<div>
<style scoped="scoped">
.ads-responsive { width: 320px; height: 50px; }
@media(min-width: 480px) { .ads-responsive { width: 468px; height: 60px; } }
@media(min-width: 800px) { .ads-responsive { width: 728px; height: 90px; } }
</style>
<script async="async" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
</script> <!-- ads_responsive_en -->
<ins class="adsbygoogle ads-responsive" data-ad-client="ca-pub-0341323781243867" data-ad-format="auto" data-ad-slot="3356484656" style="display:inline-block"></ins> 
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
</div>
<div id="Footer">
<div class="copyright">Copyright © 2018&nbsp;Martin Kompf. All rights reserved. <a href="/imprint.html">Imprint</a>&nbsp;<a href="/imprint.html">Privacy policy</a> 
<script type="text/javascript">
    window.cookieconsent_options = {"message":"This website uses cookies. You may however use this site with deactivated cookies as well. ","dismiss":"OK","learnMore":"Privacy Policy","link":"//www.mkompf.com/imprint.html","theme":"/cookieconsent2/light-bottom.css"};
</script> 
<script src="/cookieconsent2/cookieconsent.latest.min.js" type="text/javascript">
</script></div>
</div>
<div id="Menu">
<div xmlns="" class="menuLabel">Blog</div>
<div xmlns="" class="menuItem"><a href="index.html">Introduction</a></div>
<div xmlns="" class="menuItem"><a href="../search.html">Search</a></div>
<div xmlns="" class="menuItem"><a href="../imprint.html">Imprint</a></div>
<div xmlns="" class="menuLabel">Articles</div>
<div xmlns="" class="menuItem"><a href="artikel/index.html">Index</a></div>
<div xmlns="" class="menuLabel">Tutorials</div>
<div xmlns="" class="menuItem"><a href="emeocv.html">OpenCV practice</a></div>
<div xmlns="" class="menuLabel">Reference</div>
<div xmlns="" class="menuItem"><span class="menuSelected">ANSI C Library</span></div>
<div xmlns="" class="menuItem"><a href="posixlist.html">POSIX Library</a></div>
</div>
</body>
</html>


#conversions

f:_itobin|D:int _itobin(int i, char*buf, int prec, int groups );|c:conversions|x:|
f:_itohex|D:int _itohex(int i,char* buf,int padding, int capitals);|c:conversions|x:|
f:atoi|D:int atoi(const char *c);|c:conversions|x:convert a string to an integer|
f:atol|D:long atol(const char *c);|c:conversions|x:convert a string to a long integer|
f:dtodec|D:int dtodec(double d, char* buf, int precision);|c:conversions|x:|
f:itoHEX|D:int itoHEX(int i,char* buf,int padding);|c:conversions|x:|
f:itobin|D:#define itobin(A,B,...) _itobin(A,B,VARARG(SHIFT(__VA_ARGS__),0), VARARG(SHIFT(ARG( __VA_ARGS__ )),32) )|c:conversions|x:|
f:itodec|D:int itodec(int i, char *buf, int prec, char limiter );|c:conversions|x:|
f:itohex|D:int itohex(int i,char* buf,int padding);|c:conversions|x:|
f:ltodec|D:int ltodec(long i, char *buf, int prec, char limiter );|c:conversions|x:|
f:strtol|D:long int strtol(const char *c, const char **endp, int base);|c:conversions|x:convert a string to a long integer|
f:uitodec|D:int uitodec(unsigned int i, char *buf, int prec, char limiter );|c:conversions|x:|
f:ultodec|D:int ultodec(unsigned long ui, char *buf, int prec, char limiter );|c:conversions|x:|

#directories

f:basename|D:char *basename(char *path);|c:directories|x:return the last component of a pathname|
f:chdir|D:chdir(const char* path)|c:directories|x:change working directory|
f:dirfd|D:int dirfd(DIR *d);|c:directories|x:extract the file descriptor used by a DIR stream|
f:dirname|D:char *dirname(char *s);|c:directories|x:report the parent directory name of a file pathname|
f:fstat|D:fstat(int fd,struct stat* statbuf)|c:directories|x:get file status|
f:getcwd|D:getcwd( char *buf,  unsigned long size)|c:directories|x:get the pathname of the current working directory|
f:getdents|D:getdents( unsigned int fd, struct dirent *direntry, unsigned int count )|c:directories|x:get directory entries|
f:mkdir|D:mkdir( const char *pathname, int mode)|c:directories|x:make a directory relative to directory file descriptor|
f:opendir|D:DIR *opendir(const char *name);|c:directories|x:open directory associated with file descriptor|
f:readdir|D:struct dirent *readdir(DIR *dir);|c:directories|x:read a directory|
f:rewinddir|D:void rewinddir(DIR *dir);|c:directories|x:reset the position of a directory stream to the beginning|
f:rmdir|D:rmdir( const char *pathname)|c:directories|x:remove a directory|
f:seekdir|D:void seekdir(DIR *dir, long off);|c:directories|x:set the position of a directory stream|
f:telldir|D:long telldir(DIR *dir);|c:directories|x:current location of a named directory stream|

#errno

f:errno_str|D:const char *errno_str(int err);|c:errno|x:|
f:perror|D:void perror(const char *msg);|c:errno|x:write error messages to standard error|
f:strerror|D:char* strerror( int errnum );|c:errno|x:|
f:verbose_errstr|D:const char* verbose_errstr(int num);|c:errno|x:|

#files

f:_fopen|D:FILE *_fopen(int fd, const char* filename, const char* mode, FILE *f);|c:files|x:|
f:access|D:access( const char *filename, int mode)|c:files|x:determine accessibility of a file relative to directory file|
f:chmod|D:chmod( const char *filename, mode_t mode)|c:files|x:change mode of a file relative to directory file descriptor|
f:chown|D:chown( const char *filename, uid_t user, gid_t group)|c:files|x:change owner and group of a file relative to directory|
f:close|D:close( int fd )|c:files|x:close a file descriptor|
f:closedir|D:int closedir(DIR *dir);|c:files|x:close a directory stream|
f:creat|D:int volatile creat( const char *s, int mode );|c:files|x:create a new file or rewrite an existing one|
f:dup|D:dup(int fd)		|c:files|x:duplicate an open file descriptor|
f:dup2|D:dup2(int oldfd, int newfd)		|c:files|x:duplicate a file descriptor|
f:dup3|D:dup3(int oldfd, int newfd, int flags)		|c:files|x:duplicate a file descriptor|
f:fchmod|D:fchmod( unsigned int fd, mode_t mode)|c:files|x:change mode of a file|
f:fchown|D:fchown( unsigned int fd, uid_t user, gid_t group)|c:files|x:change owner and group of a file|
f:fcntl|D:fcntl( unsigned int fd, unsigned int cmd, unsigned long arg)|c:files|x:file control|
f:fsync|D:fsync(int a1 )|c:files|x:synchronize changes to a file|
f:ftruncate|D:ftruncate(unsigned int a1, unsigned int a2 )|c:files|x:truncate a file to a specified length|
f:link|D:link( const char *oldname, const char *newname)|c:files|x:link one file to another file relative to two directory|
f:lseek|D:lseek(unsigned int a1, int a2, int a3 )|c:files|x:move the read/write file offset|
f:open|D:int volatile open( const char *s, int flags, ... );|c:files|x:open file relative to directory file descriptor|
f:readahead|D:readahead( int fd,  loff_t offset,  size_t count)|c:files|x:initiate file readahead into page cache|
f:rename|D:rename( const char* oldpath, const char* newpath )|c:files|x:rename file relative to directory file descriptor|
f:select|D:static int volatile __attribute__((optimize("O0"))) select(int fd, volatile fd_set* readfd, volatile fd_set *writefd, volatile fd_set *exceptfd, volatile struct timeval *wait);|c:files|x:synchronous I/O multiplexing|
f:sendfile|D:sendfile( int out_fd,  int in_fd,  off_t *offset,  size_t count)|c:files|x:transfer data between file descriptors|
f:stat|D:stat(const char* filename,struct stat* statbuf)		|c:files|x:get file status|
f:symlink|D:symlink( const char *oldname,  const char *newname)|c:files|x:make a symbolic link relative to directory file descriptor|
f:umask|D:umask( int mask)|c:files|x:set and get the file mode creation mask|
f:unlink|D:unlink( const char* path)|c:files|x:remove a directory entry relative to directory file descriptor|

#input

f:fgetc|D:static inline int fgetc(FILE *F);|c:input|x:get a byte from a stream|
f:fgets|D:char* fgets(char *buf, int size, FILE* F);|c:input|x:get a string from a stream|
f:getc|D:#define getc(F) fgetc(F)|c:input|x:get a byte from a stream|
f:getchar|D:#define getchar() fgetc(0)|c:input|x:get a byte from a|
f:gets|D:#define gets(F) fgets(F,0xfffffff,stdin)|c:input|x:get a string from a|
f:read|D:read( int fd, void *buf, int len )|c:input|x:read from a file|
f:ungetc|D:static int ungetc(int c, FILE *F);|c:input|x:push byte back into input stream|

#ipc

f:kill|D:kill( pid_t pid,  int sig)|c:ipc|x:send a signal to a process or a group of processes|
f:mkfifo|D:static int mkfifo( const char* path, mode_t mode );|c:ipc|x:make a FIFO special file relative to directory file descriptor|
f:pipe|D:pipe( int *filedes)|c:ipc|x:create an interprocess channel|
f:raise|D:static inline int raise(int signr);|c:ipc|x:send a signal to the executing process|
f:rt_sigaction|D:rt_sigaction( int sig,  const struct sigaction *act,  struct sigaction *oact,  size_t sigsetsize)|c:ipc|x:examine and change a signal action|
f:rt_sigprocmask|D:rt_sigprocmask( int how,  sigset_t *nset,  sigset_t *oset,  size_t sigsetsize)|c:ipc|x:examine and change blocked signals|
f:rt_sigreturn|D:rt_sigreturn( unsigned long __unused)|c:ipc|x:return from signal handler and cleanup stack frame|
f:sigaction|D:static int volatile sigaction(int sig, const struct sigaction *act, struct sigaction *oact);|c:ipc|x:examine and change a signal action|
f:sigaddset|D:int sigaddset(sigset_t *set, int sig);|c:ipc|x:add a signal to a signal set|
f:sigdelset|D:int sigdelset(sigset_t *set, int sig);|c:ipc|x:delete a signal from a signal set|
f:sigemptyset|D:static int sigemptyset(sigset_t *set);|c:ipc|x:initialize and empty a signal set|
f:sigfillset|D:static int sigfillset(sigset_t *set);|c:ipc|x:initialize and fill a signal set|
f:sigismember|D:int sigismember(sigset_t *set, int sig);|c:ipc|x:test for a signal in a signal set|
f:signal|D:sighandler_t signal(int sig, sighandler_t func );|c:ipc|x:signal management|
f:sigprocmask|D:int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);|c:ipc|x:examine and change blocked signals|
f:wait|D:pid_t wait(int *wstatus);|c:ipc|x:wait for a child process to stop or terminate|
f:wait4|D:wait4( pid_t upid,  int *stat_addr,  int options,  struct rusage *ru)|c:ipc|x:wait for process to change state, BSD style|
f:waitpid|D:pid_t waitpid(pid_t pid, int *wstatus, int options);|c:ipc|x:wait for a child process to stop or terminate|

#math

f:abs|D:static int abs(int i);|c:math|x:return an integer absolute value|
f:div|D:static div_t div(int numerator, int denominator);|c:math|x:compute the quotient and remainder of an integer division|
f:djb2_hash|D:unsigned long djb2_hash(const unsigned char *str);|c:math|x:|
f:labs|D:static long int labs(long int i);|c:math|x:return a long integer absolute value|
f:ldiv|D:static ldiv_t ldiv(long int numerator, long int denominator);|c:math|x:compute quotient and remainder of a long division|
f:rand|D:unsigned int rand();|c:math|x:|
f:sdbm_hash|D:unsigned long sdbm_hash(const unsigned char *str);|c:math|x:|
f:srand|D:void srand( unsigned int i );|c:math|x:pseudo-random number generator|

#memory

f:brk|D:static int brk( const void* addr );|c:memory|x:change data segment size|
f:free|D:void volatile free(void* p);|c:memory|x:free allocated memory|
f:malloc|D:void* volatile malloc(int size);|c:memory|x:a memory allocator|
f:memcmp|D:int memcmp(const void* c1,const void* c2,int len);|c:memory|x:compare bytes in memory|
f:memcpy|D:void *memcpy( void *d, const void *s, int n );|c:memory|x:copy bytes in memory|
f:memfd_create|D:memfd_create( const char  *uname_ptr,  unsigned int flags)|c:memory|x:create an anonymous file|
f:memfrob|D:void* memfrob(void* s, unsigned int len);|c:memory|x:frobnicate (encrypt) a memory area|
f:memmove|D:void* memmove(void *dest, const void *src, int n);|c:memory|x:copy bytes in memory with overlapping areas|
f:memset|D:void *memset( void *s, int c, int n);|c:memory|x:set bytes in memory|
f:mmap|D:static void* __attribute__((optimize("O0"))) mmap(void* addr,  size_t len,  int prot,  int flags,  int fd,  off_t off);|c:memory|x:map pages of memory|
f:mprotect|D:mprotect( POINTER *a1, POINTER a2, int a3 )|c:memory|x:set protection of memory mapping|
f:mremap|D:static void* volatile __attribute__((optimize("O0"))) mremap(void* addr, size_t old_len, size_t new_len, int flags, void* new_addr);|c:memory|x:remap a virtual memory address|
f:munmap|D:munmap( unsigned long addr,  size_t len)|c:memory|x:unmap pages of memory|
f:realloc|D:void* realloc(void *p, int size);|c:memory|x:memory reallocator|
f:sbrk|D:static void* sbrk(int incr);|c:memory|x:change data segment size|
f:splice|D:splice( int fd_in,  loff_t *off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)|c:memory|x:splice data to/from a pipe|
f:sys_brk|D:static long sys_brk(unsigned long addr);|c:memory|x:|

#output

f:_mprints|D:#define _mprints(...) dprints(STDOUT_FILENO, __VA_ARGS__)|c:output|x:|
f:dprintf|D:int dprintf( int fd, const char *fmt, ... );|c:output|x:print formatted output|
f:eprint|D:#define eprint(str) write(STDERR_FILENO,str,strlen(str))|c:output|x:|
f:eprintfs|D:#define eprintfs(fmt,...) fprintfs(stderr, fmt, __VA_ARGS__)|c:output|x:|
f:eprintl|D:#define eprintl() write(STDERR_FILENO,"\n",1)|c:output|x:|
f:eputs|D:#define eputs(msg) ( eprint(msg) + eprintl() )|c:output|x:|
f:ewrites|D:#define ewrites(str) write(STDERR_FILENO,str,sizeof(str))|c:output|x:|
f:fprint|D:#define fprint(...) fprintf(__VA_ARGS__)|c:output|x:|
f:fprintf|D:#define fprintf(stream,...)	write(fileno(stream),mlgl->mbuf,sprintf(mlgl->mbuf,__VA_ARGS__))|c:output|x:|
f:fprintfs|D:int fprintfs( FILE* F, char *fmt, ...);|c:output|x:|
f:fprints|D:#define fprints(F,str) write(fileno(F),str,strlen(str))|c:output|x:|
f:fputc|D:static inline int volatile fputc(int c, FILE* F);|c:output|x:put a byte on a stream|
f:fwrite|D:static inline size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *f);|c:output|x:binary output|
f:fwrites|D:#define fwrites(fd,str) write(fd,str,sizeof(str))|c:output|x:|
f:print|D:#define print(str) write(STDOUT_FILENO,str,strlen(str))|c:output|x:|
f:printf|D:#define printf(...) fprintf(stdout,__VA_ARGS__)|c:output|x:print formatted output|
f:printfs|D:#define printfs(fmt,...) fprintfs(stdout, fmt, __VA_ARGS__)|c:output|x:|
f:printl|D:#define printl() write(STDOUT_FILENO,"\n",1)|c:output|x:|
f:prints|D:#define prints(...) _mprints(__VA_ARGS__,0)|c:output|x:|
f:printsl|D:#define printsl(...) _mprints(__VA_ARGS__,"\n",0)|c:output|x:|
f:putc|D:#define putc(c,stream) fputc(c,stream)|c:output|x:put a byte on a stream|
f:putchar|D:#define putchar(c) fputc(c,stdout)|c:output|x:put a byte on a stdout stream|
f:puts|D:#define puts(msg) ( print(msg) + printl() )|c:output|x:put a string on standard output|
f:snprintf|D:int snprintf( char *buf, size_t size, const char *fmt, ... );|c:output|x:print formatted output|
f:vfprintf|D:#define vfprintf(...) fprintf(__VA_ARGS__)|c:output|x:|
f:vsnprintf|D:int vsnprintf(char *buf, size_t size, const char* fmt, va_list args );|c:output|x:format output of a stdarg argument list|
f:write|D:write(int fd,const void *buf, int len )|c:output|x:write on a file|
f:writes|D:#define writes(str) write(STDOUT_FILENO,str,sizeof(str))|c:output|x:|

#process

f:execv|D:static inline int execv(const char *pathname, char *const argv[]);|c:process|x:execute a file|
f:execve|D:execve( const char *filename,  char* const* argv, char* const* envp)|c:process|x:execute program|
f:execveat|D:execveat( int dirfd, const char *filename,  char* const* argv, char* const* envp, int flags)|c:process|x:execute program relative to a directory file descriptor|
f:execvp|D:static inline int execvp(const char *file, char *const argv[]);|c:process|x:execute a file|
f:execvpe|D:static int execvpe(const char *file, char *const argv[], char *const envp[]);|c:process|x:execute a file|
f:fexecve|D:static inline int fexecve(int fd, char *const argv[], char *const envp[]);|c:process|x:execute a file|
f:fexecveat|D:static inline int fexecveat(int fd, char *const argv[], char *const envp[]);|c:process|x:|
f:fork|D:DEF_syscall(fork,0)|c:process|x:create a new process|
f:getenv|D:char* getenv(const char* name);|c:process|x:get value of an environment variable|
f:getpgrp|D:DEF_syscall(getpgrp,0)|c:process|x:get the process group ID of the calling process|
f:getpid|D:DEF_syscall(getpid,0 )|c:process|x:get the process ID|
f:getppid|D:DEF_syscall(getppid,0)|c:process|x:get the parent process ID|
f:setpgid|D:setpgid( pid_t pid, pid_t pgid)|c:process|x:set process group ID for job control|
f:setsid|D:DEF_syscall(setsid,0 )|c:process|x:create session and set process group ID|
f:system|D:int system( const char* command );|c:process|x:issue a command|
f:vfork|D:DEF_syscall(vfork,0)|c:process|x:create a child process and block parent|

#streams

f:clearerr|D:static inline void clearerr(FILE *f);|c:streams|x:clear indicators on a stream|
f:clearerror|D:static inline void clearerror(FILE *f);|c:streams|x:|
f:fclose|D:static inline int __attribute__((always_inline)) fclose( FILE* f );|c:streams|x:close a stream|
f:fdopen|D:FILE *fdopen(int fd, const char* mode);|c:streams|x:associate a stream with a file descriptor|
f:feof|D:static inline int feof(FILE *f);|c:streams|x:test end-of-file indicator on a stream|
f:ferror|D:static inline int ferror(FILE *f);|c:streams|x:test error indicator on a stream|
f:fflush|D:static inline int __attribute__((always_inline)) fflush( FILE *F );|c:streams|x:flush a stream|
f:fgetpos|D:static inline void fgetpos(FILE *f, long *pos );|c:streams|x:get current file position information|
f:fileno|D:static int fileno( FILE *f );|c:streams|x:map a stream pointer to a file descriptor|
f:fopen|D:FILE *fopen(const char* filename, const char* mode);|c:streams|x:open a stream|
f:fputs|D:static inline int volatile fputs(const char *c, FILE *F);|c:streams|x:put a string on a stream|
f:fread|D:static inline size_t fread(void *ptr, size_t size, size_t nmemb, FILE *f);|c:streams|x:binary input|
f:freopen|D:FILE *freopen(const char* filename, const char* mode, FILE *F);|c:streams|x:open a stream|
f:fseek|D:static inline int fseek(FILE *f, long offset, int whence );|c:streams|x:reposition a file-position indicator in a stream|
f:fsetpos|D:static inline int fsetpos(FILE *f, int pos );|c:streams|x:set current file position|
f:ftell|D:static inline long ftell(FILE *f);|c:streams|x:return a file offset in a stream|
f:rewind|D:static inline void rewind( FILE *f );|c:streams|x:reset the file position indicator in a stream|
f:setbuf|D:static void setbuf(FILE *stream, char *buf);|c:streams|x:assign buffering to a stream|
f:setvbuf|D:static int setvbuf(FILE *stream, char *buf, int mode, size_t size);|c:streams|x:assign buffering to a stream|

#strings

f:_strcasecmp|D:int _strcasecmp(const char*c1,const char*c2,int len);|c:strings|x:|
f:_strcmp|D:int _strcmp(const char*c1,const char*c2,int len);|c:strings|x:|
f:sprintf|D:#define sprintf(str,...) snprintf( str, 4096,  __VA_ARGS__)|c:strings|x:print formatted output|
f:strcasecmp|D:int strcasecmp(const char*c1,const char*c2);|c:strings|x:|
f:strcat|D:char *strcat(char *dest, const char *src );|c:strings|x:concatenate two strings|
f:strchr|D:char *strchr(const char *s, int c);|c:strings|x:string scanning operation|
f:strchrnul|D:char *strchrnul(const char *s, int c);|c:strings|x:locate character in string|
f:strcmp|D:int strcmp(const char*c1,const char*c2);|c:strings|x:compare two strings|
f:strcpy|D:char *strcpy(char *dest, const char *src);|c:strings|x:copy a string and return a pointer to the end of the result|
f:strdup|D:char *strdup(const char *source);|c:strings|x:duplicate a specific number of bytes from a string|
f:strlen|D:int strlen(const char*str);|c:strings|x:get length of fixed size string|
f:strncasecmp|D:int strncasecmp(const char*c1,const char*c2,int len);|c:strings|x:case-insensitive string comparisons|
f:strncmp|D:int strncmp(const char*c1,const char*c2,int len);|c:strings|x:compare part of two strings|
f:strncpy|D:char *strncpy(char *dest, const char *src, int n);|c:strings|x:copy fixed length string, returning a pointer to the array end|
f:strrchr|D:char *strrchr(const char *s, int c);|c:strings|x:string scanning operation|
f:strstr|D:char* strstr(const char *big, const char *little);|c:strings|x:find a substring|

#system

f:chroot|D:chroot( const char *filename)|c:system|x:change root directory|
f:getgid|D:DEF_syscall(getgid,0)|c:system|x:get the real group ID|
f:getuid|D:DEF_syscall(getuid,0)|c:system|x:get a real user ID|
f:ioctl|D:int volatile  __attribute__((optimize("O0"))) ioctl( int fd, unsigned long int request, ... );|c:system|x:control a STREAMS device (\fBSTREAMS\fP)|
f:mknod|D:mknod( const char *filename,  umode_t mode,  unsigned dev)|c:system|x:make directory, special file, or regular file|
f:mount|D:mount( char *dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)|c:system|x:mount filesystem|
f:pivot_root|D:pivot_root( const char *new_root,  const char *put_old)|c:system|x:change the root mount|
f:reboot|D:reboot( int magic1,  int magic2,  unsigned int cmd,  void *arg)|c:system|x:reboot or enable/disable Ctrl-Alt-Del|
f:setgid|D:setgid( gid_t gid)|c:system|x:set-group-ID|
f:setuid|D:setuid( uid_t uid)|c:system|x:set user ID|
f:sync|D:DEF_syscall(sync,0)|c:system|x:schedule file system updates|
f:umount2|D:umount2( const char *mountpoint, int flags) |c:system|x:unmount filesystem|
f:uname|D:uname(struct old_utsname *name )|c:system|x:get the name of the current system|

#terminal

f:grantpt|D:int grantpt(int fd);|c:terminal|x:grant access to the slave pseudo-terminal device|
f:isatty|D:int isatty(int fd);|c:terminal|x:test for a terminal device|
f:nanosleep|D:nanosleep( struct timespec *rqtp, struct timespec *rmtp)|c:terminal|x:high resolution sleep|
f:posix_openpt|D:int posix_openpt(int flags);|c:terminal|x:open a pseudo-terminal device|
f:ptsname|D:char *ptsname(int fd);|c:terminal|x:get name of the slave pseudo-terminal device|
f:ptsname_r|D:int ptsname_r(int fd, char *buf, size_t len);|c:terminal|x:get the name of the slave pseudoterminal|
f:tcgetattr|D:static inline int __attribute__((always_inline)) tcgetattr(int fd, struct termios *io);|c:terminal|x:get the parameters associated with the terminal|
f:tcsetattr|D:static inline int __attribute__((always_inline)) tcsetattr(int fd, int opt, const struct termios *io);|c:terminal|x:set the parameters associated with the terminal|
f:unlockpt|D:int unlockpt(int fd);|c:terminal|x:unlock a pseudo-terminal master/slave pair|
f:vhangup|D:DEF_syscall(vhangup,0 )|c:terminal|x:virtually hangup the current terminal|

#time

f:getitimer|D:getitimer( int which,  struct itimerval *value)|c:time|x:get and set value of interval timer|
f:gettimeofday|D:gettimeofday( struct timeval *a1, struct timezone *a2)|c:time|x:get the date and time|
f:setitimer|D:setitimer( int which,  struct itimerval *value,  struct itimerval *ovalue)|c:time|x:set the value of an interval timer|
f:sleep|D:unsigned int volatile sleep(unsigned int seconds);|c:time|x:suspend execution for an interval of time|
f:time|D:time(unsigned int *a1 )|c:time|x:get time|
f:usleep|D:unsigned int volatile usleep(unsigned int useconds);|c:time|x:suspend execution for microsecond intervals|
f:utime|D:utime( const char *filename, struct utimbuf *times)|c:time|x:set file access and modification times|

#u

f:def|D:#define SETOPT_short( opts, option ) (;|c:u|x:|
f:sys__sysctl|D:|c:u|x:read/write system parameters|
f:sys_accept|D:|c:u|x:accept a new connection on a socket|
f:sys_accept4|D:|c:u|x:accept a connection on a socket|
f:sys_access|D:|c:u|x:determine accessibility of a file relative to directory file|
f:sys_acct|D:|c:u|x:switch process accounting on or off|
f:sys_add_key|D:|c:u|x:add a key to the kernel's key management facility|
f:sys_adjtimex|D:|c:u|x:tune kernel clock|
f:sys_alarm|D:|c:u|x:schedule an alarm signal|
f:sys_arch_prctl|D:|c:u|x:set architecture-specific thread state|
f:sys_bind|D:|c:u|x:bind a name to a socket|
f:sys_brk|D:|c:u|x:change data segment size|
f:sys_capget|D:|c:u|x:set/get capabilities of thread(s)|
f:sys_capset|D:|c:u|x:set/get capabilities of thread(s)|
f:sys_chdir|D:|c:u|x:change working directory|
f:sys_chmod|D:|c:u|x:change mode of a file relative to directory file descriptor|
f:sys_chown|D:|c:u|x:change owner and group of a file relative to directory|
f:sys_chroot|D:|c:u|x:change root directory|
f:sys_clock_adjtime|D:|c:u|x:|
f:sys_clock_getres|D:|c:u|x:|
f:sys_clock_gettime|D:|c:u|x:clock and time functions|
f:sys_clock_nanosleep|D:|c:u|x:high resolution sleep with specifiable clock|
f:sys_clock_settime|D:|c:u|x:clock and timer functions|
f:sys_clone|D:|c:u|x:create a child process|
f:sys_close|D:|c:u|x:close a file descriptor|
f:sys_connect|D:|c:u|x:connect a socket|
f:sys_creat|D:|c:u|x:create a new file or rewrite an existing one|
f:sys_delete_module|D:|c:u|x:unload a kernel module|
f:sys_dup|D:|c:u|x:duplicate an open file descriptor|
f:sys_dup2|D:|c:u|x:duplicate a file descriptor|
f:sys_dup3|D:|c:u|x:duplicate a file descriptor|
f:sys_epoll_create|D:|c:u|x:open an epoll file descriptor|
f:sys_epoll_create1|D:|c:u|x:open an epoll file descriptor|
f:sys_epoll_ctl|D:|c:u|x:control interface for an epoll file descriptor|
f:sys_epoll_pwait|D:|c:u|x:wait for an I/O event on an epoll file descriptor|
f:sys_epoll_wait|D:|c:u|x:wait for an I/O event on an epoll file descriptor|
f:sys_eventfd|D:|c:u|x:create a file descriptor for event notification|
f:sys_eventfd2|D:|c:u|x:create a file descriptor for event notification|
f:sys_execve|D:|c:u|x:execute program|
f:sys_exit|D:|c:u|x:terminate a process|
f:sys_exit_group|D:|c:u|x:exit all threads in a process|
f:sys_faccessat|D:|c:u|x:determine accessibility of a file relative to directory file|
f:sys_fadvise64|D:|c:u|x:predeclare an access pattern for file data|
f:sys_fallocate|D:|c:u|x:manipulate file space|
f:sys_fanotify_init|D:|c:u|x:create and initialize fanotify group|
f:sys_fanotify_mark|D:|c:u|x:add, remove, or modify an fanotify mark on a filesystem|
f:sys_fchdir|D:|c:u|x:change working directory|
f:sys_fchmod|D:|c:u|x:change mode of a file|
f:sys_fchmodat|D:|c:u|x:change mode of a file relative to directory file descriptor|
f:sys_fchown|D:|c:u|x:change owner and group of a file|
f:sys_fchownat|D:|c:u|x:change owner and group of a file relative to directory|
f:sys_fcntl|D:|c:u|x:file control|
f:sys_fdatasync|D:|c:u|x:synchronize the data of a file|
f:sys_fgetxattr|D:|c:u|x:retrieve an extended attribute value|
f:sys_finit_module|D:|c:u|x:load a kernel module|
f:sys_flistxattr|D:|c:u|x:list extended attribute names|
f:sys_flock|D:|c:u|x:apply or remove an advisory lock on an open file|
f:sys_fork|D:|c:u|x:create a new process|
f:sys_fremovexattr|D:|c:u|x:remove an extended attribute|
f:sys_fsetxattr|D:|c:u|x:set an extended attribute value|
f:sys_fstat|D:|c:u|x:get file status|
f:sys_fstatfs|D:|c:u|x:get filesystem statistics|
f:sys_fsync|D:|c:u|x:synchronize changes to a file|
f:sys_ftruncate|D:|c:u|x:truncate a file to a specified length|
f:sys_futex|D:|c:u|x:fast user-space locking|
f:sys_futimesat|D:|c:u|x:change timestamps of a file relative to a directory file descriptor|
f:sys_get_mempolicy|D:|c:u|x:retrieve NUMA memory policy for a thread|
f:sys_get_robust_list|D:|c:u|x:get/set list of robust futexes|
f:sys_getcpu|D:|c:u|x:determine CPU and NUMA node on which the calling thread is running|
f:sys_getcwd|D:|c:u|x:get the pathname of the current working directory|
f:sys_getdents|D:|c:u|x:get directory entries|
f:sys_getdents64|D:|c:u|x:get directory entries|
f:sys_getegid|D:|c:u|x:get the effective group ID|
f:sys_geteuid|D:|c:u|x:get the effective user ID|
f:sys_getgid|D:|c:u|x:get the real group ID|
f:sys_getgroups|D:|c:u|x:get supplementary group IDs|
f:sys_getitimer|D:|c:u|x:get and set value of interval timer|
f:sys_getpeername|D:|c:u|x:get the name of the peer socket|
f:sys_getpgid|D:|c:u|x:get the process group ID for a process|
f:sys_getpgrp|D:|c:u|x:get the process group ID of the calling process|
f:sys_getpid|D:|c:u|x:get the process ID|
f:sys_getppid|D:|c:u|x:get the parent process ID|
f:sys_getpriority|D:|c:u|x:get and set the nice value|
f:sys_getrandom|D:|c:u|x:obtain a series of random bytes|
f:sys_getresgid|D:|c:u|x:get real, effective and saved user/group IDs|
f:sys_getresuid|D:|c:u|x:get real, effective and saved user/group IDs|
f:sys_getrlimit|D:|c:u|x:control maximum resource consumption|
f:sys_getrusage|D:|c:u|x:get information about resource utilization|
f:sys_getsid|D:|c:u|x:get the process group ID of a session leader|
f:sys_getsockname|D:|c:u|x:get the socket name|
f:sys_getsockopt|D:|c:u|x:get the socket options|
f:sys_gettid|D:|c:u|x:get thread identification|
f:sys_gettimeofday|D:|c:u|x:get the date and time|
f:sys_getuid|D:|c:u|x:get a real user ID|
f:sys_getxattr|D:|c:u|x:retrieve an extended attribute value|
f:sys_init_module|D:|c:u|x:load a kernel module|
f:sys_inotify_add_watch|D:|c:u|x:add a watch to an initialized inotify instance|
f:sys_inotify_init|D:|c:u|x:initialize an inotify instance|
f:sys_inotify_init1|D:|c:u|x:initialize an inotify instance|
f:sys_inotify_rm_watch|D:|c:u|x:remove an existing watch from an inotify instance|
f:sys_io_cancel|D:|c:u|x:cancel an outstanding asynchronous I/O operation|
f:sys_io_destroy|D:|c:u|x:destroy an asynchronous I/O context|
f:sys_io_getevents|D:|c:u|x:read asynchronous I/O events from the completion queue|
f:sys_io_setup|D:|c:u|x:create an asynchronous I/O context|
f:sys_io_submit|D:|c:u|x:submit asynchronous I/O blocks for processing|
f:sys_ioctl|D:|c:u|x:control a STREAMS device (\fBSTREAMS\fP)|
f:sys_ioperm|D:|c:u|x:set port input/output permissions|
f:sys_iopl|D:|c:u|x:change I/O privilege level|
f:sys_ioprio_get|D:|c:u|x:get/set I/O scheduling class and priority|
f:sys_ioprio_set|D:|c:u|x:get/set I/O scheduling class and priority|
f:sys_kcmp|D:|c:u|x:compare two processes to determine if they share a kernel resource|
f:sys_kexec_file_load|D:|c:u|x:load a new kernel for later execution|
f:sys_kexec_load|D:|c:u|x:load a new kernel for later execution|
f:sys_keyctl|D:|c:u|x:key management function wrappers|
f:sys_kill|D:|c:u|x:send a signal to a process or a group of processes|
f:sys_lchown|D:|c:u|x:change the owner and group of a symbolic link|
f:sys_lgetxattr|D:|c:u|x:retrieve an extended attribute value|
f:sys_link|D:|c:u|x:link one file to another file relative to two directory|
f:sys_linkat|D:|c:u|x:make a new name for a file|
f:sys_listen|D:|c:u|x:listen for socket connections and limit the queue of incoming|
f:sys_listxattr|D:|c:u|x:list extended attribute names|
f:sys_llistxattr|D:|c:u|x:list extended attribute names|
f:sys_lookup_dcookie|D:|c:u|x:return a directory entry's path|
f:sys_lremovexattr|D:|c:u|x:remove an extended attribute|
f:sys_lseek|D:|c:u|x:move the read/write file offset|
f:sys_lsetxattr|D:|c:u|x:set an extended attribute value|
f:sys_lstat|D:|c:u|x:get file status|
f:sys_madvise|D:|c:u|x:give advice about use of memory|
f:sys_mbind|D:|c:u|x:set memory policy for a memory range|
f:sys_memfd_create|D:|c:u|x:create an anonymous file|
f:sys_migrate_pages|D:|c:u|x:move all pages in a process to another set of nodes|
f:sys_mincore|D:|c:u|x:determine whether pages are resident in memory|
f:sys_mkdir|D:|c:u|x:make a directory relative to directory file descriptor|
f:sys_mkdirat|D:|c:u|x:create a directory|
f:sys_mknod|D:|c:u|x:make directory, special file, or regular file|
f:sys_mknodat|D:|c:u|x:create a special or ordinary file|
f:sys_mlock|D:|c:u|x:lock or unlock a range of process address space|
f:sys_mlockall|D:|c:u|x:lock/unlock the address space of a process|
f:sys_mmap|D:|c:u|x:map pages of memory|
f:sys_modify_ldt|D:|c:u|x:get or set a per-process LDT entry|
f:sys_mount|D:|c:u|x:mount filesystem|
f:sys_move_pages|D:|c:u|x:move individual pages of a process to another node|
f:sys_mprotect|D:|c:u|x:set protection of memory mapping|
f:sys_mq_getsetattr|D:|c:u|x:get/set message queue attributes|
f:sys_mq_notify|D:|c:u|x:notify process that a message is available|
f:sys_mq_open|D:|c:u|x:open a message queue|
f:sys_mq_timedreceive|D:|c:u|x:receive a message from a message queue|
f:sys_mq_timedsend|D:|c:u|x:send a message to a message queue|
f:sys_mq_unlink|D:|c:u|x:remove a message queue|
f:sys_mremap|D:|c:u|x:remap a virtual memory address|
f:sys_msgctl|D:|c:u|x:XSI message control operations|
f:sys_msgget|D:|c:u|x:get the XSI message queue identifier|
f:sys_msgrcv|D:|c:u|x:XSI message receive operation|
f:sys_msgsnd|D:|c:u|x:XSI message send operation|
f:sys_msync|D:|c:u|x:synchronize memory with physical storage|
f:sys_munlock|D:|c:u|x:unlock a range of process address space|
f:sys_munlockall|D:|c:u|x:unlock the address space of a process|
f:sys_munmap|D:|c:u|x:unmap pages of memory|
f:sys_name_to_handle_at|D:|c:u|x:obtain handle|
f:sys_nanosleep|D:|c:u|x:high resolution sleep|
f:sys_newfstatat|D:|c:u|x:get file status|
f:sys_open|D:|c:u|x:open file relative to directory file descriptor|
f:sys_open_by_handle_at|D:|c:u|x:obtain handle|
f:sys_openat|D:|c:u|x:open file relative to directory file descriptor|
f:sys_pause|D:|c:u|x:suspend the thread until a signal is received|
f:sys_perf_event_open|D:|c:u|x:set up performance monitoring|
f:sys_personality|D:|c:u|x:set the process execution domain|
f:sys_pipe|D:|c:u|x:create an interprocess channel|
f:sys_pipe2|D:|c:u|x:create pipe|
f:sys_pivot_root|D:|c:u|x:change the root mount|
f:sys_poll|D:|c:u|x:input/output multiplexing|
f:sys_ppoll|D:|c:u|x:wait for some event on a file descriptor|
f:sys_prctl|D:|c:u|x:operations on a process|
f:sys_pread64|D:|c:u|x:read from or write to a file descriptor at a given offset|
f:sys_preadv|D:|c:u|x:read or write data into multiple buffers|
f:sys_prlimit64|D:|c:u|x:get/set resource limits|
f:sys_process_vm_readv|D:|c:u|x:transfer data between process address spaces|
f:sys_process_vm_writev|D:|c:u|x:transfer data between process address spaces|
f:sys_pselect6|D:|c:u|x:select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO \-|
f:sys_ptrace|D:|c:u|x:process trace|
f:sys_pwrite64|D:|c:u|x:read from or write to a file descriptor at a given offset|
f:sys_pwritev|D:|c:u|x:read or write data into multiple buffers|
f:sys_quotactl|D:|c:u|x:manipulate disk quotas|
f:sys_read|D:|c:u|x:read from a file|
f:sys_readahead|D:|c:u|x:initiate file readahead into page cache|
f:sys_readlink|D:|c:u|x:read the contents of a symbolic link|
f:sys_readlinkat|D:|c:u|x:read value of a symbolic link|
f:sys_readv|D:|c:u|x:read a vector|
f:sys_reboot|D:|c:u|x:reboot or enable/disable Ctrl-Alt-Del|
f:sys_recvfrom|D:|c:u|x:receive a message from a socket|
f:sys_recvmmsg|D:|c:u|x:receive multiple messages on a socket|
f:sys_recvmsg|D:|c:u|x:receive a message from a socket|
f:sys_remap_file_pages|D:|c:u|x:create a nonlinear file mapping|
f:sys_removexattr|D:|c:u|x:remove an extended attribute|
f:sys_rename|D:|c:u|x:rename file relative to directory file descriptor|
f:sys_renameat|D:|c:u|x:change the name or location of a file|
f:sys_renameat2|D:|c:u|x:change the name or location of a file|
f:sys_request_key|D:|c:u|x:request a key from the kernel's key management facility|
f:sys_restart_syscall|D:|c:u|x:restart a system call after interruption by a stop signal|
f:sys_rmdir|D:|c:u|x:remove a directory|
f:sys_rt_sigaction|D:|c:u|x:examine and change a signal action|
f:sys_rt_sigpending|D:|c:u|x:examine pending signals|
f:sys_rt_sigprocmask|D:|c:u|x:examine and change blocked signals|
f:sys_rt_sigqueueinfo|D:|c:u|x:queue a signal and data|
f:sys_rt_sigreturn|D:|c:u|x:return from signal handler and cleanup stack frame|
f:sys_rt_sigsuspend|D:|c:u|x:wait for a signal|
f:sys_rt_sigtimedwait|D:|c:u|x:synchronously wait|
f:sys_rt_tgsigqueueinfo|D:|c:u|x:queue a signal and data|
f:sys_sched_get_priority_max|D:|c:u|x:get priority limits|
f:sys_sched_get_priority_min|D:|c:u|x:get static priority range|
f:sys_sched_getaffinity|D:|c:u|x:set and get a thread's CPU affinity mask|
f:sys_sched_getattr|D:|c:u|x:sched_setattr, sched_getattr \-|
f:sys_sched_getparam|D:|c:u|x:get scheduling parameters|
f:sys_sched_getscheduler|D:|c:u|x:get scheduling policy|
f:sys_sched_rr_get_interval|D:|c:u|x:get execution time limits|
f:sys_sched_setaffinity|D:|c:u|x:set and get a thread's CPU affinity mask|
f:sys_sched_setattr|D:|c:u|x:sched_setattr, sched_getattr \-|
f:sys_sched_setparam|D:|c:u|x:set scheduling parameters|
f:sys_sched_setscheduler|D:|c:u|x:set scheduling policy and parameters|
f:sys_sched_yield|D:|c:u|x:yield the processor|
f:sys_seccomp|D:|c:u|x:operate on Secure Computing state of the process|
f:sys_select|D:|c:u|x:synchronous I/O multiplexing|
f:sys_semctl|D:|c:u|x:XSI semaphore control operations|
f:sys_semget|D:|c:u|x:get set of XSI semaphores|
f:sys_semop|D:|c:u|x:XSI semaphore operations|
f:sys_semtimedop|D:|c:u|x:System V semaphore operations|
f:sys_sendfile|D:|c:u|x:transfer data between file descriptors|
f:sys_sendmmsg|D:|c:u|x:send multiple messages on a socket|
f:sys_sendmsg|D:|c:u|x:send a message on a socket using a message structure|
f:sys_sendto|D:|c:u|x:send a message on a socket|
f:sys_set_mempolicy|D:|c:u|x:set default NUMA memory policy for a thread and its children|
f:sys_set_robust_list|D:|c:u|x:get/set list of robust futexes|
f:sys_set_tid_address|D:|c:u|x:set pointer to thread ID|
f:sys_setdomainname|D:|c:u|x:get/set NIS domain name|
f:sys_setfsgid|D:|c:u|x:set group identity used for filesystem checks|
f:sys_setfsuid|D:|c:u|x:set user identity used for filesystem checks|
f:sys_setgid|D:|c:u|x:set-group-ID|
f:sys_setgroups|D:|c:u|x:get/set list of supplementary group IDs|
f:sys_sethostname|D:|c:u|x:get/set hostname|
f:sys_setitimer|D:|c:u|x:set the value of an interval timer|
f:sys_setns|D:|c:u|x:reassociate thread with a namespace|
f:sys_setpgid|D:|c:u|x:set process group ID for job control|
f:sys_setpriority|D:|c:u|x:set the nice value|
f:sys_setregid|D:|c:u|x:set real and effective group IDs|
f:sys_setresgid|D:|c:u|x:set real, effective and saved user or group ID|
f:sys_setresuid|D:|c:u|x:set real, effective and saved user or group ID|
f:sys_setreuid|D:|c:u|x:set real and effective user IDs|
f:sys_setrlimit|D:|c:u|x:control maximum resource consumption|
f:sys_setsid|D:|c:u|x:create session and set process group ID|
f:sys_setsockopt|D:|c:u|x:set the socket options|
f:sys_settimeofday|D:|c:u|x:get / set time|
f:sys_setuid|D:|c:u|x:set user ID|
f:sys_setxattr|D:|c:u|x:set an extended attribute value|
f:sys_shmat|D:|c:u|x:XSI shared memory attach operation|
f:sys_shmctl|D:|c:u|x:XSI shared memory control operations|
f:sys_shmdt|D:|c:u|x:XSI shared memory detach operation|
f:sys_shmget|D:|c:u|x:get an XSI shared memory segment|
f:sys_shutdown|D:|c:u|x:shut down socket send and receive operations|
f:sys_sigaltstack|D:|c:u|x:set and get signal alternate stack context|
f:sys_signalfd|D:|c:u|x:create a file descriptor for accepting signals|
f:sys_signalfd4|D:|c:u|x:create a file descriptor for accepting signals|
f:sys_socket|D:|c:u|x:create an endpoint for communication|
f:sys_socketpair|D:|c:u|x:create a pair of connected sockets|
f:sys_splice|D:|c:u|x:splice data to/from a pipe|
f:sys_stat|D:|c:u|x:get file status|
f:sys_statfs|D:|c:u|x:get filesystem statistics|
f:sys_swapoff|D:|c:u|x:start/stop swapping to file/device|
f:sys_swapon|D:|c:u|x:start/stop swapping to file/device|
f:sys_symlink|D:|c:u|x:make a symbolic link relative to directory file descriptor|
f:sys_symlinkat|D:|c:u|x:make a new name for a file|
f:sys_sync|D:|c:u|x:schedule file system updates|
f:sys_sync_file_range|D:|c:u|x:sync a file segment with disk|
f:sys_syncfs|D:|c:u|x:commit filesystem caches to disk|
f:sys_sysfs|D:|c:u|x:get filesystem type information|
f:sys_sysinfo|D:|c:u|x:return system information|
f:sys_syslog|D:|c:u|x:log a message|
f:sys_tee|D:|c:u|x:duplicating pipe content|
f:sys_tgkill|D:|c:u|x:send a signal to a thread|
f:sys_time|D:|c:u|x:get time|
f:sys_timer_create|D:|c:u|x:create a per-process timer|
f:sys_timer_delete|D:|c:u|x:delete a per-process timer|
f:sys_timer_getoverrun|D:|c:u|x:|
f:sys_timer_gettime|D:|c:u|x:arm/disarm and fetch|
f:sys_timer_settime|D:|c:u|x:arm/disarm and fetch|
f:sys_timerfd_create|D:|c:u|x:timerfd_create, timerfd_settime, timerfd_gettime \-|
f:sys_timerfd_gettime|D:|c:u|x:timerfd_create, timerfd_settime, timerfd_gettime \-|
f:sys_timerfd_settime|D:|c:u|x:timerfd_create, timerfd_settime, timerfd_gettime \-|
f:sys_times|D:|c:u|x:get process and waited-for child process times|
f:sys_tkill|D:|c:u|x:send a signal to a thread|
f:sys_truncate|D:|c:u|x:truncate a file to a specified length|
f:sys_umask|D:|c:u|x:set and get the file mode creation mask|
f:sys_umount2|D:|c:u|x:unmount filesystem|
f:sys_uname|D:|c:u|x:get the name of the current system|
f:sys_unlink|D:|c:u|x:remove a directory entry relative to directory file descriptor|
f:sys_unlinkat|D:|c:u|x:delete a name and possibly the file it refers to|
f:sys_unshare|D:|c:u|x:disassociate parts of the process execution context|
f:sys_ustat|D:|c:u|x:get filesystem statistics|
f:sys_utime|D:|c:u|x:set file access and modification times|
f:sys_utimensat|D:|c:u|x:set file access and modification times relative to directory|
f:sys_utimes|D:|c:u|x:change file last access and modification times|
f:sys_vfork|D:|c:u|x:create a child process and block parent|
f:sys_vhangup|D:|c:u|x:virtually hangup the current terminal|
f:sys_vmsplice|D:|c:u|x:splice user pages to/from a pipe|
f:sys_wait4|D:|c:u|x:wait for process to change state, BSD style|
f:sys_waitid|D:|c:u|x:wait for a child process to change state|
f:sys_write|D:|c:u|x:write on a file|
f:sys_writev|D:|c:u|x:write a vector|
f:macro|D:static void __attribute__((noipa)) optimization_fence(void*p){}|c:u|x:|
f:todo_abort|D:void todo_abort();|c:u|x:|
f:todo_putenv|D:int todo_putenv( char *s );|c:u|x:|

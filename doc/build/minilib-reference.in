f:chmod|k|D:int chmod( const char *filename, mode_t mode)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.184|m:manpages/sys/chmod.2.rst[chmod]||#
f:clone|k|D:int clone( int clone_flags,  unsigned long stack,  void *parent_tid,  void *child_tid)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.200||#
f:dup3|k|D:int dup3(int oldfd, int newfd, int flags)		|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.118|m:manpages/gen/dup3.3.rst[dup3]||#
f:execveat|k|D:int execveat( int dirfd, const char *filename,  char* const* argv, char* const* envp, int flags)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.157||#
f:fchmod|k|D:int fchmod( unsigned int fd, mode_t mode)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.114|m:manpages/sys/chmod.2.rst[fchmod]||#
f:fchown|k|D:int fchown( unsigned int fd, uid_t user, gid_t group)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.113|m:manpages/sys/chown.2.rst[fchown]||#
f:fcntl|k|D:int fcntl( unsigned int fd, unsigned int cmd, unsigned long arg)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.162|m:manpages/sys/fcntl.2.rst[fcntl]||#
f:fstat|k|D:int fstat(int fd,struct stat* statbuf)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.109|m:manpages/sys/stat.2.rst[fstat]||#
f:getcwd|k|D:int getcwd( char *buf,  unsigned long size)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.120|m:manpages/gen/getcwd.3.rst[getcwd]||#
f:getdents|k|D:int getdents( unsigned int fd, struct dirent *direntry, unsigned int count )|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.104|m:manpages/sys/getdirentries.2.rst[getdents]||#
f:getitimer|k|D:int getitimer( int which,  struct itimerval *value)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.216|m:manpages/sys/getitimer.2.rst[getitimer]||#
f:getppid|k|D:int DEF_syscall(getppid,0)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.187|m:manpages/sys/getpid.2.rst[getppid]||#
f:gettimeofday|k|D:int gettimeofday( struct timeval *a1, struct timezone *a2)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.136|m:manpages/sys/gettimeofday.2.rst[gettimeofday]||#
f:inotify_add_watch|k|D:int inotify_add_watch( int fd,  const char *pathname,  u32 mask)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.195||#
f:inotify_init|k|D:int DEF_syscall(inotify_init,0)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.194||#
f:inotify_init1|k|D:int inotify_init1( int flags)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.197||#
f:inotify_rm_watch|k|D:int inotify_rm_watch( int fd,  __s32 wd)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.196||#
f:kill|k|D:int kill( pid_t pid,  int sig)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.129|m:manpages/sys/kill.2.rst[kill]||#
f:memfd_create|k|D:int memfd_create( const char  *uname_ptr,  unsigned int flags)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.174||#
f:mknod|k|D:int mknod( const char *filename,  umode_t mode,  unsigned dev)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.211|m:manpages/sys/mknod.2.rst[mknod]||#
f:mount|k|D:int mount( char *dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.168|m:manpages/sys/mount.2.rst[mount]||#
f:mprotect|k|D:int mprotect( POINTER *a1, POINTER a2, int a3 )|R:*a1|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.206|m:manpages/sys/mprotect.2.rst[mprotect]||#
f:munmap|k|D:int munmap( void* addr,  size_t len)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.213|m:manpages/sys/munmap.2.rst[munmap]||#
f:nanosleep|k|D:int nanosleep( struct timespec *rqtp, struct timespec *rmtp)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.135|m:manpages/sys/nanosleep.2.rst[nanosleep]||#
f:pivot_root|k|D:int pivot_root( const char *new_root,  const char *put_old)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.142||#
f:readahead|k|D:int readahead( int fd,  loff_t offset,  size_t count)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.210||#
f:reboot|k|D:int reboot( int magic1,  int magic2,  unsigned int cmd,  void *arg)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.166|m:manpages/sys/reboot.2.rst[reboot]||#
f:rt_sigaction|k|D:int rt_sigaction( int sig,  const struct sigaction *act,  struct sigaction *oact,  size_t sigsetsize)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.138||#
f:rt_sigprocmask|k|D:int rt_sigprocmask( int how,  sigset_t *nset,  sigset_t *oset,  size_t sigsetsize)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.170||#
f:rt_sigreturn|k|D:int rt_sigreturn( unsigned long __unused)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.139||#
f:sendfile|k|D:int sendfile( int out_fd,  int in_fd,  off_t *offset,  size_t count)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.165|m:manpages/sys/sendfile.2.rst[sendfile]||#
f:setgroups|k|D:int setgroups( int gidsetsize,  gid_t *grouplist)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.182|m:manpages/sys/setgroups.2.rst[setgroups]||#
f:setitimer|k|D:int setitimer( int which,  struct itimerval *value,  struct itimerval *ovalue)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.215|m:manpages/sys/getitimer.2.rst[setitimer]||#
f:splice|k|D:int splice( int fd_in,  loff_t *off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.179||#
f:stat|k|D:int stat(const char* filename,struct stat* statbuf)		|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.110|m:manpages/sys/stat.2.rst[stat]||#
f:symlink|k|D:int symlink( const char *oldname,  const char *newname)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.123|m:manpages/sys/symlink.2.rst[symlink]||#
f:sync|k|D:int DEF_syscall(sync,0)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.124|m:manpages/sys/sync.2.rst[sync]||#
f:umask|k|D:int umask( int mask)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.209|m:manpages/sys/umask.2.rst[umask]||#
f:umount2|k|D:int umount2( const char *mountpoint, int flags) |l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.164||#
f:uname|k|D:int uname(struct old_utsname *name )|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.152|m:manpages/gen/uname.3.rst[uname]||#
f:utime|k|D:int utime( const char *filename, struct utimbuf *times)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.186|m:manpages/gen/utime.3.rst[utime]||#
f:vfork|k|D:int DEF_syscall(vfork,0)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.132|m:manpages/sys/vfork.2.rst[vfork]||#
f:vhangup|k|D:int DEF_syscall(vhangup,0 )|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.150||#
f:wait4|k|D:int wait4( pid_t upid,  int *stat_addr,  int options,  struct rusage *ru)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.160|m:manpages/sys/wait.2.rst[wait4]||#
f:closedir|D:int closedir(DIR *dir);|d:brk getbrk|l:../src/dirent/closedir.c[../src/dirent/closedir.c] l.6|m:manpages/gen/directory.3.rst[closedir]||#
f:opendir|D:static DIR *opendir(const char *name );|d:dirbuf open close 0 write|l:../src/dirent/opendir.c[../src/dirent/opendir.c] l.24|m:manpages/gen/directory.3.rst[opendir]||#
f:readdir|D:struct dirent *readdir(DIR *dir);|d:dirbuf getdents|l:../src/dirent/readdir.c[../src/dirent/readdir.c] l.10|m:manpages/gen/directory.3.rst[readdir]|o:read a directory.:+: return the next dirent, or 0, if the end is reached.:+: return 0 on error and set errno,:+: if mini_errno is not defined, return -errno on error||#
f:rewinddir|D:void rewinddir(DIR *dir);|l:../src/dirent/rewinddir.c[../src/dirent/rewinddir.c] l.2|m:manpages/gen/directory.3.rst[rewinddir]||#
f:scandir|D:int scandir(const char *path, struct dirent **listing[], int (*fp_select)(const struct dirent *),	int (*cmp)(const struct dirent **, const struct dirent **));|d:0 qsort seterrno getbrk sbrk write strlen brk memcpy dirbuf errno open|l:../src/dirent/scandir.c[../src/dirent/scandir.c] l.35|m:manpages/gen/scandir.3.rst[scandir]|o:list files and dirs in a directory:+::+: This implementation uses malloc_brk() for the dynamic allocation:+: of the listing, and tries to do as less copies as possible.:+: The dynamically allocated space for the result list (**listing[]):+: is guaranteed to be at one continuous memory location.:+::+: if the select callback is 0, meaning all entries should be returned,:+: There are no copies done at all, :+: besides the copying from kernelspace to userspace.:+::+: To free the space, allocated for the listing,:+: either call free_brk(),:+: when no other allocations via malloc_brk took place.:+::+: Or save the brk before you call scandir,:+: and restore it after the call.:+: (e.g.):+: long savebrk=getbrk();:+: int ret=scandir(...);:+: brk(savebrk);:+: Freeing single list entries might give unexpected results.:+::+: returns the number of the read entries,:+: or the negative errno on error.||#
f:seekdir|D:void seekdir(DIR *dir, long off);|l:../src/dirent/seekdir.c[../src/dirent/seekdir.c] l.2|m:manpages/gen/directory.3.rst[seekdir]||#
f:telldir|D:long telldir(DIR *dir);|l:../src/dirent/telldir.c[../src/dirent/telldir.c] l.2|m:manpages/gen/directory.3.rst[telldir]||#
f:creat|D:int volatile creat( const char *s, int mode );|d:open|l:../src/open.c[../src/open.c] l.36|m:manpages/compat-43/creat.2.rst[creat]||#
f:mkfifo|D:static int mkfifo( const char* path, mode_t mode );|l:../include/mkfifo.h[../include/mkfifo.h] l.4|m:manpages/sys/mkfifo.2.rst[mkfifo]||#
f:ioctl|D:int volatile  __attribute__((optimize("O0"))) ioctl( int fd, unsigned long int request, ... );|l:../src/ioctl.c[../src/ioctl.c] l.11|m:manpages/sys/ioctl.2.rst[ioctl]||#
f:OPTFENCE|D:static void __attribute__((noipa,cold,naked)) opt_fence(void*p,...);|l:../include/syscall.h[../include/syscall.h] l.65|o:prevent gcc to optimize away registers and variables:+: the macro OPTFENCE(...) can be invoked with any parameter.:+: The parameters will get calculated, even if gcc doesn't recognize:+: the use of the parameters, e.g. cause they are needed for an inlined asm syscall.:+::+: The macro translates to an asm jmp and a function call to the function :+: opt_fence, which is defined with the attribute "noipa" -:+: (the compiler "forgets" the function body, so gcc is forced:+: to generate all arguments for the function):+: The generated asm jump hops over the call to the function,:+: but this gcc doesn't recognize.:+::+: This generates some overhead, :+: (a few (never reached) bytes for setting up the function call, and the jmp):+: but I didn't find any other solution,:+: which gcc wouldn't cut for optimizations from time to time.:+: (volatile, volatile asm, optimize attributes, :+: andsoon have all shown up to be unreliable - sometimes(!)).:+::+: Had some fun debugging these bugs, which naturally showed up only sometimes.:+: (Many syscalls also work with scrambled arguments..):+: And, I believe it IS a compiler bug. :+: Volatile should be volatile for sure, not only sometimes.:+: I mean, why the heck do I write volatile?? ||#
f:OPTIMIZATIONS|D:|l:../include/config.h[../include/config.h] l.33|o:enable some optimizations,:+: with a slitghtly bigger memory footprint.:+: defaults to off:+: (yet only calloc is optimized. todo)||#
f:_itobin|D:int _itobin(int i, char*buf, int prec, int groups );|l:../src/itobin.c[../src/itobin.c] l.8||#
f:_mprints|D:#define _mprints(...) dprints(STDOUT_FILENO, __VA_ARGS__)|d:write|l:../include/prints.h[../include/prints.h] l.10||#
f:alphasort|D:int alphasort( const struct dirent** de1, const struct dirent** de2 );|d:|l:../src/dirent/alphasort.c[../src/dirent/alphasort.c] l.7|m:manpages/gen/scandir.3.rst[alphasort]|o:Sort dirents by name.:+: Deviating of the standard, :+: the asciitables is used for the comparison:+: (using strcmp)||#
f:ansicolors|D:|l:../include/ansicolors.h[../include/ansicolors.h] l.45|o:defines for ansicolors at the console, 16 color mode:+:the names are::+: AC_NORM ( white text on black background):+: AC_BLACK :+: AC_RED :+: AC_GREEN :+: AC_BROWN :+: AC_BLUE :+: AC_MAGENTA :+: AC_MARINE (= AC_CYAN):+: AC_LGREY :+: AC_WHITE :+: AC_GREY :+: AC_LRED :+: AC_LGREEN :+: AC_YELLOW :+: AC_LBLUE :+: AC_LMAGENTA :+: AC_LMARINE (= AC_LCYAN):+: AC_LWHITE :+: AC_BGBLACK :+: AC_BGRED :+: AC_BGGREEN :+: AC_BGBROWN :+: AC_BGBLUE :+: AC_BGMAGENTA :+: AC_BGMARINE :+: AC_BGLGREY :+: AC_BGWHITE :+::+: AC_BOLD:+: AC_FAINT:+: AC_CURSIVE:+: AC_UNDERLINE:+: AC_LIGHTBG:+: AC_BLINK:+: AC_INVERTED:+: AC_INVERSE:+::+: ( Faint to inverse are not available at every terminal )||#
f:basename|D:char *basename(char *path);|l:../src/basename.c[../src/basename.c] l.2|m:manpages/gen/basename.3.rst[basename]||#
f:brk|D:static int brk( const void* addr );|l:../src/brk.c[../src/brk.c] l.19|m:manpages/sys/brk.2.rst[brk]|o:set the brk to addr:+: return 0 on success.:+: conformant brk, when mini_errno is defined return -1 and set errno.:+: if errno isn't available,:+: returns the negative errno value on error||#
f:bsd_cksum|D:unsigned int bsd_cksum( const char* p, unsigned int len );|l:../src/cksum.c[../src/cksum.c] l.31|o:bsd checksum||#
f:bsd_cksumblock|D:unsigned int bsd_cksumblock( unsigned int hash, const char* p, unsigned int len );|l:../src/cksum.c[../src/cksum.c] l.20|o:bsd checksum, called by bsd_cksum,:+: with initial hash value||#
f:clone_t|D:int clone_t(int flags);|l:../src/clone.c[../src/clone.c] l.7||#
f:config|D:|l:../include/config.h[../include/config.h] l.6|o:configuration settings, to be compiled statically.:+: System specific paths, maximums, etc go here.:+: Other values are within globaldefs.h;:+: architecture specific values are within the folder headers.||#
f:def|D:#define SETOPT_short( opts, option ) (;|l:../macros/getoptm.h[../macros/getoptm.h] l.52|o:Set a option flag(s) (bit(s))  manually.:+:		param options: e.g. just a, or ( a+h+l) to check for several flags at once||#
f:dirbuf|D:|l:../include/dirent.h[../include/dirent.h] l.7|o:the switch for defining the dirbuf.:+: used internally||#
f:dirbufsize |D:#ifndef mini_dirbufsize|l:../include/dirent.h[../include/dirent.h] l.22|o:the dir stream bufsize:+: The size of the buffer can be changed by setting mini_dirbufsize:+: to it's size in Bytes. (default 2048):+: The buffer is allocated via malloc,:+: therefore mini_buf must be set to a value greater than dirbufsize||#
f:dirfd|D:int dirfd(DIR *d);|l:../src/dirent/dirfd.c[../src/dirent/dirfd.c] l.2|m:manpages/gen/directory.3.rst[dirfd]||#
f:dirname|D:char *dirname(char *s);|d:strlen|l:../src/dirname.c[../src/dirname.c] l.8|m:manpages/gen/dirname.3.rst[dirname]||#
f:djb2_hash|D:unsigned long djb2_hash(const unsigned char *str);|l:../src/hashes.c[../src/hashes.c] l.12|o:hashes, from d.j.Bernstein:+: (http://www.cse.yorku.ca/~oz/hash.html):+: I've tested djb2_hash, and it gives quite good results.:+: I'm sure, Bernstein did think and test his algorithm sincerely.:+: When combining djb2_hash and sdbm_hash, the probability of collisions:+: might tend to zero.:+: Me I'm going this way. I guess. I might check djb2_hash for collisions within a space of around 8 digits.:+: The hash functions compute the hashes of a c string with a 0 at the end.:+: The cksum functions do work with a pointer and a given len.||#
f:djb_cksum|D:unsigned int djb_cksum( const char* p, unsigned int len );|l:../src/cksum.c[../src/cksum.c] l.8|o:checksum algorithm by d.j.bernstein.:+: Didn't do any benchmarks, but the computation :+: might be quite performant. :+: It is a bitshift and two additions per byte.|c:hashes||#
f:dprintf|D:int dprintf( int fd, const char *fmt, ... );|d:write strlen|l:../src/dprintf.c[../src/dprintf.c] l.5|m:manpages/stdio/printf.3.rst[dprintf]||#
f:dprints|D:int dprints(int fd, const char *msg,...);|d:write|l:../src/prints.c[../src/prints.c] l.17||#
f:dtodec|D:int dtodec(double d, char* buf, int precision);|d:uitodec|l:../src/dtodec.c[../src/dtodec.c] l.10||#
f:endgrent|D:void endgrent();|l:../src/userdb/endgrent.c[../src/userdb/endgrent.c] l.3|m:manpages/gen/getgrent.3.rst[endgrent]|c:userdb||#
f:endpwent|D:void endpwent();|l:../src/userdb/endpwent.c[../src/userdb/endpwent.c] l.3|m:manpages/gen/getpwent.3.rst[endpwent]|c:userdb||#
f:eprint|D:#define eprint(str) write(STDERR_FILENO,str,strlen(str))|d:write strlen|l:../include/prints.h[../include/prints.h] l.59|o:write str to stderr. Needs strlen||#
f:eprintfs|D:#define eprintfs(fmt,...) fprintfs(stderr, fmt, __VA_ARGS__)|d:fileno strlen write|l:../include/prints.h[../include/prints.h] l.127|o:write fmt and arguments to stderr. :+: only format %s and %c are recognized||#
f:eprintl|D:#define eprintl() write(STDERR_FILENO,"\n",1)|d:write|l:../include/prints.h[../include/prints.h] l.68|o:write a newline to stderr||#
f:eprints|D:#define eprints(...) dprints(STDERR_FILENO,__VA_ARGS__,0)|d:write|l:../include/prints.h[../include/prints.h] l.26|o:print the string(s) supplied as arg(s) to stdout:+: this macro has an variable argument count.||#
f:eprintsl|D:#define eprintsl(...) dprints(STDERR_FILENO,__VA_ARGS__,"\n",0)|d:write|l:../include/prints.h[../include/prints.h] l.48|o:print the string(s) supplied as arg(s) and newline to stderr||#
f:eputs|D:#define eputs(msg) ( eprint(msg) + eprintl() )|d:write strlen|l:../include/prints.h[../include/prints.h] l.78|o:write msg to stderr, append a newline. Needs strlen.||#
f:errno_str|D:static char *errno_str(int err);|l:../src/errno_str.c[../src/errno_str.c] l.7|o:convert errno to str, with 3 chars length:+: ending the string (global) :+: with two \0\0, when errno<100:+: errnum must be <200.||#
f:ewrites|D:#define ewrites(str) write(STDERR_FILENO,str,sizeof(str))|d:write|l:../include/prints.h[../include/prints.h] l.89|o:write the constant str to stderr. Computes length with sizeof(str) at compile time.||#
f:ewritesl|D:#define ewritesl(str) write(STDERR_FILENO,str,sizeof(str));write(STDERR_FILENO,"\n",1)|d:write|l:../include/prints.h[../include/prints.h] l.101|o:write the constant str to stderr, followed by a newline. :+: Computes length with sizeof(str) at compile time.||#
f:exit_errno|D:void exit_errno( int errnum );|d:write errno_str execve exit|l:../src/exit_errno.c[../src/exit_errno.c] l.17|o:exit, and execute /bin/errno:+: this is intended to give a error message for the :+: given errno num.:+: Instead of having the error messages compiled :+: into each binary, they can stay within one executable, "errno":+: This spares about 4kB, but needs errno installed to /bin/errno:+: It's the drawback of not having a shared library,:+: where all executables would share the same errno messages:+: in memory.:+: On the other hand, a shared library would need to be installed:+: as well.:+: The supplied errno can be negative,:+: the absolute value is supplied to errno.||#
f:ext_match|D:int ext_match(char *text, const char *re, void(*p_match)(int number, char *pos,int len), int(*p_match_char)(int number, char *match_char), regex_match *st_match);|l:../src/ext_match.c[../src/ext_match.c] l.189|o:regex engine:+: This is somewhere between a fully fledged expression machine,:+: and a simplicistic solution.:+: The engine matches from left to right,:+: backtracking is done as less as possible.:+: Since the matching is nongreedy in general,:+: many tries can be spared. Opposed to another route,:+: where most patterns are per default greedy, and therfore:+: not the first matching next char is seeked for, but the first:+: solution while matching the most chars.:+: (I do not want to make this a hard statement, and it :+: depends onto each pattern. But it is the way, the solution:+: of the pattern is searched for, in most patterns.):+: This shows up in the logic of the patterns, which is more natural to me.:+::+: It is a compromise between performance, size:+: and capabilities.:+: The logic is different of a "regular" regular expression:+: machine, but has advantages (and disadvantages).:+: I'd say, the main advantage is the easiness of adding callbacks,:+: and defining your own matching/logic within these. :+: Performance might be better as well overall,:+: but this depends also on the expressions.:+::+: A few nonextensive benchmarks show,:+: this engine is a bit faster than perl's regular expression machine,:+: slower than gnu grep (around factor2), and has the same speed as sed.:+: This might however vary with each usecase.:+: In favor of codesize I'm not going to optimize ext_match,:+: but there would be several possibilities, if you'd need a faster engine.:+: (Albite I'd like to emphasise, sed (and ext_match), also perl, are quite fast.:+: About 10 times faster than most expression engines.):+::+: matches: :+: :+: * for every count of any char:+: + for 1 or more chars:+: ? for 1 char:+: # for space or end of text (0):+: $ match end of text:+::+: backslash: escape *,?,%,$,!,+,#,& and backslash itself.:+: !: invert the matching of the next character or character class:+: ,: separator. e.g. %,1 matches like ?*1. :+:   ( without the commata, the '1' would be part of the % match):+:  :+::+: predefined character classes::+: \d - digit:+: \D - nondigit:+: \s - space:+: \S - nonspace:+: \w - word character ( defined as ascii 32-126,160-255 ):+: \W - nonword character ( defined as ascii 0-31,127-159 ):+::+::+: [xyz]: character classes, here x,y or z :+:   the characters are matched literally, also \,*,?,+,..:+:   it is not possible to match the closing bracket (]):+:   within a character class:+::+: {nX}: counted match:+:  Match n times X.:+:  For X, all expressions are allowed.:+:  If you need to match a number at the first char of 'X',:+:  separate X by a commata. E.g. {5,0} matches 5 times '0'.:+::+: %[1]..%[9]: matches like a '+',:+:  and calls the callback supplied as 3rd argument (when not null).:+:  the number past the %, e.g. %1, is optional,:+:  p_match will be callen with this number:+:  as first parameter.:+:  When not supplied, p_matched will be callen with :+:  the parameter 'number' set to 0.:+::+:  The matching is 'nongreedy'.:+:  It is possible to rewrite the string to match:+:  from within the p_matched callback.:+:  This will not have an effect onto the current matching,:+:  even if text is e.g. deleted by writing 0's.:+:  The matched positions are called in reverse order.:+:  (The last matched % in the regex calls p_match first, :+:  the first % in the regex from the left will be callen last):+::+: supply 0 for p_matched, when you do not need to extract matches.:+: This will treat % in the regex like a *, :+: a following digit (0..9) in the regex is ignored.:+: if the 5th argument, a pointer to a regex_match struct, :+: is supplied, it will be filled with the first match.:+: (counting from left):+::+::+: &[1] .. &[9]:+:  "match" like a '?' and call p_match_char:+:  p_match_char has to return either RE_MATCH, RE_NOMATCH, RE_MATCHEND:+:  or a number of the count of chars, which have been matched.:+::+:  Therefore it is possible to e.g. rule your own:+:  character classes, defined at runtime, :+:  or do further tricks like changing the matched chars,:+:  match several chars, andsoon.:+:  When returning RE_NOMATCH,:+:  it is possible, the p_match and p_match_char callbacks are callen several times,:+:  but with different pos or len parameters.:+::+:  The matching works straight from left to right.:+:  So, a "*&*" will call the callback & for the first char.:+:  When returning RE_NOMATCH, the second char will be matched.:+:  Until either RE_MATCH is returned from the callback,:+:  or the last char has been matched.:+::+:  Matching several characters is also posssible from within the callback,:+:  the position within the text will be incremented by that number,:+:  you return from the callback.:+::+:  When returning RE_MATCHEND from the callback, :+:  the whole regular expression is aborted, and returns with matched;:+:  no matter, if there are chars left in the expression.:+::+::+:  The difference between % and & is the logic.:+:  % matches nongreedy, and has to check therefore the right side of the star:+:  for its matching.:+:  Possibly this has to be repeated, when following chars do not match.:+::+:  & is matched straight from left to right.:+:  Whatever number you return, the textpointer will be incremented by that value.:+:  However, a & isn't expanded on it's own. ( what a % is ).:+:  e.g. "x%x" will match 'aa' in xaax, x&x will match the whole expression:+:  only, when you return '2' from the callback.:+::+:  Performancewise, matching with & is faster,:+:  since the % has on its right side to be matched:+:  with recursing calls of ext_match.:+::+: When using closures for the callbacks, you will possibly have to:+: enable an executable stack for the trampoline code:+: of gcc. Here, gcc complains about that. :+: For setting this bit, have a look into the ldscripts in the folder:+: with the same name.:+::+: supply 0 for p_match_char, when you don't need it.:+: This will treat & in the regex like ?, :+: and match a following digit (0..9) in the text,:+: a following digit (0..9) in the regex is ignored.:+: :+: -----:+: In general, you have to somehow invert the logic of regular expressions:+: when using ext_match.:+: e.g. when matching the parameter 'runlevel=default' at the kernel's:+: commandline, a working regular expression would be:+: "runlevel=(\S*)". This could be written here as "*runlevel=%#".:+: For matching e.g. numbers, you'd most possibly best of:+: with writing your own & callback.:+::+: returns: 1 on match, 0 on no match:+: ( RE_MATCH / RE_NOMATCH ):+::+: if the pointer (argument 5) st_match is nonnull,:+: the supplied struct regex_match will be set to the first matching '%' location;:+: if there is no match, regex_match.len will be set to 0.:+: The struct is defined as: :+: typedef struct _regex_match { char* pos; int len; } regex_match;:+::+::+: (memo) When the regex ist defined within C/cpp source code,:+: a backslash has to be defined as double backslash.:+::+: (note) - be careful when negating a following *, or ?.:+:  somehow - it is logical, but seems to me I overshoot a bit,:+:  tragically hit my own foot, and stumbled into a logical paradox.:+::+:  Negating EVERYTHING translates to true.:+:  However, since truth is negated as well, there's a problem,:+:  cause it's now 'false', but 'false' is true. This is very close:+:  to proving 42 is the answer. What is the escape velocity:+:  in km/s out of the solar system, btw.:+::+:  (I'm not kidding here. Just don't do a regex with !* or !?..:+:  And, please, do not ask me what is going to happen when the impossible:+:  gets possibilized. I have to point at the according sentences of the BSD license;//  there is NO WARRANTY for CONSEQUENTIAL DAMAGE, LOSS OF PROFIT, etc pp.):+::+:  A "!+" will translate into nongreedy matching of any char, however;:+:  "%!+" will match with % everything but the last char;:+:  while "%+" matches with % only the first char.:+:  !+ basically sets the greedyness of the left * or % higher.||#
f:ext_match2|D:char* ext_match2(char *text, char *re, void(*p_match)(int number, char *pos,int len), int(*p_match_char)(int number, char *match_char), regex_match *st_match);|l:../src/ext_match2.c[../src/ext_match2.c] l.271|o:regex engine:+: WORK IN PROGRESS, please use ext_match:+::+: This is somewhere between a fully fledged expression machine,:+: and a simplicistic solution.:+: The engine matches from left to right,:+: backtracking is done as less as possible.:+: Since the matching is nongreedy in general,:+: many tries can be spared. Opposed to another route,:+: where most patterns are per default greedy, and therfore:+: not the first matching next char is seeked for, but the first:+: solution while matching the most chars.:+: (I do not want to make this a hard statement, and it :+: depends onto each pattern. But it is the way, the solution:+: of the pattern is searched for, in most patterns.):+: This shows up in the logic of the patterns, which is more natural to me.:+: Your mileage might vary.:+::+::+: It is a compromise between performance, size:+: and capabilities.:+: The logic is different of a "regular" regular expression:+: machine, but has advantages (and disadvantages).:+: I'd say, the main advantage is the easiness of adding callbacks,:+: and defining your own matching/logic within these. :+: Performance might be better as well overall,:+: but this depends on the expressions and usecases as well.:+::+: Yet I for myself have to get a grip of the possibilities of this engine.:+: However, I have the feeling, the logic is much more natural.:+: With regular regexes you always have to think kind of 'backwards',:+: e.g., match ".*" -> match "." (any char) x times. :+: gets to a simple "*":+: or, to match all group and user id's of /etc/passwd,:+: a regular expression would be: "(\d*):(\d*)":+: This is here: "*(\d*):(\d*)*":+: The content in the brackets looks the same,:+: but it's matched quite different.:+: The regular expression (the first) matches x times \d, for x>=0.:+: In the second expressin, the ext_match expression,:+: the first digit is matched, and then nongreedy any chars, until:+: the first occurence of ':'. :+: It is another logic. Whether it suits you, you have to decide.:+::+: The callbacks have shown up to be a mighty tool, while:+: at the same time having a good performance. :+: :+::+: A few nonextensive benchmarks show,:+: this engine is a bit faster than perl's regular expression machine,:+: slower than gnu grep (around factor2), and has the same speed as sed.:+: This might vary with each usecase, but the callbacks for extracting matches:+: have some advantage, as well as the strict left to right and nongreedy parsing.:+::+: In favor of codesize I'm not going to optimize ext_match,:+: but there would be several possibilities, if you'd need a faster engine.:+: (Albite I'd like to emphasise, sed (and ext_match), also perl, are quite fast.:+: About 5 to 10 times faster than most expression engines.):+::+: matches: :+: :+: * for every count of any char:+: + for 1 or more chars:+: ? for 1 char:+: # for space, end of text (\0), linebreak, tab:+: $ match end of text (\0) or linebreak:+::+: backslash: escape *,?,%,$,!,+,#,& and backslash itself.:+: !: invert the matching of the next character or character class:+: ,: separator. e.g. %,1 matches like ?*1. :+:   ( without the commata, the '1' would be part of the % match):+:  :+::+: predefined character classes::+: \d - digit:+: \D - nondigit:+: \s - space:+: \S - nonspace:+: \w - word character ( defined as ascii 32-126,160-255 ):+: \W - nonword character ( defined as ascii 0-31,127-159 ):+::+::+: [xyz]: character classes, here x,y or z :+:   the characters are matched literally, also \,*,?,+,..:+:   it is not possible to match the closing bracket (]):+:   within a character class:+::+: {nX}: counted match:+:  Match n times X.:+:  For X, all expressions are allowed.:+:  If you need to match a number at the first char of 'X',:+:  separate X by a commata. E.g. {5,0} matches 5 times '0'.:+::+: (X): match the subexpression X. atm, no nesting of round () and {} brackets allowed:+::+: %[1]..%[9]: matches like a '+',:+:  and calls the callback supplied as 3rd argument (when not null).:+:  the number past the %, e.g. %1, is optional,:+:  p_match will be callen with this number:+:  as first parameter.:+:  When not supplied, p_matched will be callen with :+:  the parameter 'number' set to 0.:+::+:  The matching is 'nongreedy'.:+:  It is possible to rewrite the string to match:+:  from within the p_matched callback.:+:  This will not have an effect onto the current matching,:+:  even if text is e.g. deleted by writing 0's.:+:  The matched positions are called in reverse order.:+:  (The last matched % in the regex calls p_match first, :+:  the first % in the regex from the left will be callen last):+:  / The regex is first matched; when the regex has matched,:+:  the %'s are filled/ the callbacks executed.:+:  (x) bracketed patterns are matched the same way.:+::+:  (Not like &, which callbacks are invoked, while matching):+::+: supply 0 for p_matched, when you do not need to extract matches.:+: This will treat % in the regex like a *, :+: a following digit (0..9) in the regex is ignored.:+: if the 5th argument, a pointer to a regex_match struct, :+: is supplied, it will be filled with the first match.:+: (counting from left):+::+::+: &[1] .. &[9]:+:  "match" like a '?' and call p_match_char:+:  p_match_char has to return either RE_MATCH, RE_NOMATCH, RE_MATCHEND:+:  or a number of the count of chars, which have been matched.:+::+:  Therefore it is possible to e.g. rule your own:+:  character classes, defined at runtime, :+:  or do further tricks like changing the matched chars,:+:  match several chars, andsoon.:+:  When returning RE_NOMATCH,:+:  it is possible, the p_match and p_match_char callbacks are callen several times,:+:  but with different pos or len parameters.:+::+:  The matching works straight from left to right.:+:  So, a "*&*" will call the callback & for the first char.:+:  When returning RE_NOMATCH, the second char will be tried to match.:+:  Until either RE_MATCH is returned from the callback,:+:  or the last char of the text has been tried to match.:+::+:  Matching several characters is also posssible from within the callback,:+:  the position within the text will be incremented by that number,:+:  you return from the callback.:+::+:  When returning RE_MATCHEND from the callback, :+:  the whole regular expression is aborted, and returns with matched;:+:  no matter, if there are chars left in the expression.:+::+::+:  The difference between % and & is the logic.:+:  % matches nongreedy, and has to check therefore the right side of the star:+:  for its matching.:+:  Possibly this has to be repeated, when following chars do not match.:+::+:  & is matched straight from left to right.:+:  Whatever number you return, the textpointer will be incremented by that value.:+:  However, a & isn't expanded on it's own. ( what a % is ).:+:  e.g. "x%x" will match 'aa' in xaax, x&x will match the whole expression:+:  only, when you return '2' from the callback.:+::+:  Performancewise, matching with & is faster,:+:  since the % has on its right side to be matched:+:  with recursing calls of ext_match.:+::+: When using closures for the callbacks, you will possibly have to:+: enable an executable stack for the trampoline code:+: of gcc. Here, gcc complains about that. :+: For setting this bit, please have a look into the ldscripts in the folder:+: with the same name.:+::+: supply 0 for p_match_char, when you don't need it.:+: This will treat & in the regex like ?, :+: and match a following digit (0..9) in the text,:+: a following digit (0..9) in the regex is ignored.:+: :+: -----:+: In general, you have to somehow invert the logic of regular expressions:+: when using ext_match.:+: e.g. when matching the parameter 'runlevel=default' at the kernel's:+: commandline, a working regular expression would be:+: "runlevel=(\S*)". This could be written here as "*runlevel=%#".:+: For matching e.g. numbers, you'd most possibly best of:+: with writing your own & callback.:+::+: returns: 1 on match, 0 on no match:+: ( RE_MATCH / RE_NOMATCH ):+::+: if the pointer (argument 5) st_match is nonnull,:+: the supplied struct regex_match will be set to the first matching '%' location;:+: if there is no match, regex_match.len will be set to 0.:+: The struct is defined as: :+: typedef struct _regex_match { char* pos; int len; } regex_match;:+::+::+: (memo) When the regex ist defined within C/cpp source code,:+: a backslash has to be defined as double backslash.:+::+: (note) - be careful when negating a following *, or ?.:+:  somehow - it is logical, but seems to me I overshoot a bit,:+:  tragically hit my own foot, and stumbled into a logical paradox.:+::+:  Negating EVERYTHING translates to true.:+:  However, since truth is negated as well, there's a problem,:+:  cause it's now 'false', but 'false' is true. This is very close:+:  to proving 42 is the answer. What is the escape velocity:+:  in km/s out of the solar system, btw.:+::+:  (I'm not kidding here. Just don't do a regex with !* or !?..:+:  And, please, do not ask me what is going to happen when the impossible:+:  gets possibilized. I have to point at the according sentences of the BSD license;//  there is NO WARRANTY for CONSEQUENTIAL DAMAGE, LOSS OF PROFIT, etc pp.):+::+:  A "!+" will translate into nongreedy matching of any char, however;:+:  "%!+" will match with % everything but the last char;:+:  while "%+" matches with % only the first char.:+:  !+ basically sets the greedyness of the left * or % higher.:+::+: (work in progress here) please use ext_match:+: return 0 for nomatch, the current textpos ( >0 ) for a match:+: With the exception of an empty text, matched by e.g. "*".:+: This will return 0, albite the regex formally matches, with 0 chars.:+::+: (todo):+: bracket matching () and {} needs debugging. (test/extmatch2 for testing):+: Add a callback for bracket matches, and add a matchlist:+: (linked list, allocated with malloc_brk):+: Trouble: e.g. *:(*) doesn't match, albite it should:+:  .. better. Now: # matches the end, after a bracket. Like it should:+:   $ doesn't. But should as well.:+: change '+' to greedy matching of any char:+: for {n,X} let n be * or + as well.:+:  (this would be closer to regular regulars again.?.):+::+::+: note. About a tokenizer::+: matching quoted string is really easy with the callback structure::+:  just match with &. When a quote is matched, look forward to the next quote,:+:  and return that many chars. Same time, the quoted string is matched.:+:  That's so easy, it is hard to believe.:+:  When using closures for that, it is same time easy to collect all tokens.:+::+:  It is even easier. just a "*("*")*" is enough.:+::+:  ->There is something needed for partial matching. Possibly spare the last *, and return,:+:  as soon the pattern is at it's end (and not the text?):+:  Already works this way. :+::+:  Should start to define the language for the init scripts.:+:  Or better, start thinking abut that, but follow my other obligations the next time.:+::+:  Have to think thouroughly about what points would make such a language useful.:+:  The reason to think about that is clear - performance squeezing, faster startup time.:+:  And writing the startup scripts in C is. Well. little bit painful.:+:  However, together with minilib, there is nearly no difference between having a C program compiled:+:  and run, or working with scripts. To not have the overhead of linking the external libraries in,:+:  is of quite some advance.:+:  The only difference, the compiled binaries are "cached".:+:  have just to sort something sensible out for the systematic.:+:  Implement an own loader? possibly easy. Since the loading address is fixed.:+:  This could possibly also be the solution for the yet unclear question of the line between parsing:+:  arguments and calling the main function of the small core tools, andsoon.:+:  :+:  gerad faellt mir "rings" ein. Ist ein idealer Aufreisser, als bootup animation.||#
f:fexecve|D:static inline int fexecve(int fd, char *const argv[], char *const envp[]);|l:../include/fexecve.h[../include/fexecve.h] l.3|m:manpages/sys/execve.2.rst[fexecve]||#
f:fexecveat|D:static inline int fexecveat(int fd, char *const argv[], char *const envp[]);|l:../include/fexecveat.h[../include/fexecveat.h] l.3||#
f:fprintfs|D:int fprintfs( FILE* F, char *fmt, ...);|d:strlen write fileno|l:../src/fprintfs.c[../src/fprintfs.c] l.10|o:prints formatted and unbuffered output to the stream F.:+: only %s and %c are recognized.:+: no mini_buf or globals are used, so using fprintfs instead of fprintf can save some sections / bytes.||#
f:fprints|D:#define fprints(F,...) dprints(fileno(F),__VA_ARGS__,0)|d:write strlen fileno|l:../include/prints.h[../include/prints.h] l.34|o:print the string(s) supplied as arg(s) to stream:+: this macro has an variable argument count.||#
f:free_brk|D:int free_brk();|l:../src/freebrk.c[../src/freebrk.c] l.9|o:free all memory,:+: which has been allocated with malloc_brk.:+: Returns 0, if memory has been freed;:+: 1, when there hasn't been any memory allocations with:+: malloc_brk before.:+: Then brk() gives an error, return the return value of brk||#
f:fwrites|D:#define fwrites(fd,str) write(fd,str,sizeof(str))|d:write|l:../include/prints.h[../include/prints.h] l.107|o:write the constant str to fd. Computes length with sizeof(str) at compile time.||#
f:fwritesl|D:#define fwritesl(fd,str) write(fd,str,sizeof(str));write(fd,"\n",1)|d:write|l:../include/prints.h[../include/prints.h] l.114|o:write the constant str to fd,followed by a newline. :+: Computes length with sizeof(str) at compile time.||#
f:getbrk|D:static long getbrk();|l:../src/brk.c[../src/brk.c] l.48|o:get the current brk:+: does either a syscall to brk,:+: or returns the globally saved var||#
f:getgrent|D:struct group* getgrent();|d:userdb open|l:../src/userdb/getgrent.c[../src/userdb/getgrent.c] l.4|m:manpages/gen/getgrent.3.rst[getgrent]|c:userdb||#
f:getgrgid|D:struct group *getgrgid(gid_t gid);|d:token_s mmap grent open globals userdb setgrent write token_i|l:../src/userdb/getgrgid.c[../src/userdb/getgrgid.c] l.7|m:manpages/gen/getgrent.3.rst[getgrgid]|o:get the group entry of the group "gid".:+: the last result is cached, multiple calls with the same:+: name will return the cached result.|c:userdb||#
f:getgrnam|D:struct group *getgrnam(const char* name);|d:grent open mmap token_s userdb globals write setgrent token_i|l:../src/userdb/getgrnam.c[../src/userdb/getgrnam.c] l.7|m:manpages/gen/getgrent.3.rst[getgrnam]|o:get the group entry of the group "name".:+: the last result is cached, multiple calls with the same:+: name will return the cached result.|c:userdb||#
f:getgrouplist|D:int getgrouplist(const char* user, gid_t group, gid_t *groups, int *ngroups);|d:token_i write setgrent setpwent passwdfile_open token_s open grent pwent mmap|l:../src/userdb/getgrouplist.c[../src/userdb/getgrouplist.c] l.5|m:manpages/gen/getgrouplist.3.rst[getgrouplist]|o:needs rewrite.:+: now nonstandard.||#
f:getpwent|D:struct passwd* getpwent();|d:open userdb|l:../src/userdb/getpwent.c[../src/userdb/getpwent.c] l.4|m:manpages/gen/getpwent.3.rst[getpwent]|c:userdb||#
f:getpwnam|D:struct passwd *getpwnam(const char* name);|d:write token_s mmap open pwent globals token_i|l:../src/userdb/getpwnam.c[../src/userdb/getpwnam.c] l.7|m:manpages/gen/getpwent.3.rst[getpwnam]|o:get the passwd entry of the user "name".:+: the last result is cached, multiple calls with the same:+: name will return the cached result.|c:userdb||#
f:getpwuid|D:struct passwd *getpwuid(uid_t uid);|d:token_i write setpwent passwdfile_open token_s pwent open mmap|l:../src/userdb/getpwuid.c[../src/userdb/getpwuid.c] l.7|m:manpages/gen/getpwent.3.rst[getpwuid]|o:get the passwd entry of the user with uid.:+: the last result is cached, multiple calls with the same:+: uid will return the cached result.|c:userdb||#
f:getusergroups|D:int getusergroups(const char* user, int maxgroups, int *list);|d:mmap grent pwent open token_s passwdfile_open setpwent setgrent write token_i|l:../src/userdb/getusergroups.c[../src/userdb/getusergroups.c] l.8|o:get the supplementary groups for the user uid.:+: does not necessarily contain the primary group,:+: which is given in the passwd entry.:+: This function calls internally setgrent() and getgrent();:+: therefore any iteration with getgrent will be resetted.||#
f:grantpt|D:int grantpt(int fd);|d:strlen write ioctl uitodec open fstat|l:../src/pty.c[../src/pty.c] l.49|m:manpages/stdlib/ptsname.3.rst[grantpt]||#
f:group_print|D:|d:write strlen fileno|l:../macros/defgroups.h[../macros/defgroups.h] l.13|o:enable print and related functions:+: This switch enables strlen;:+: but neither globals nor the mini_buf are used.||#
f:group_printf|D://|d:ltodec eprintf fileno write strlen uitodec|l:../macros/defgroups.h[../macros/defgroups.h] l.29|o:printf, eprintf, fprintf, itodec and ltodec (conversions %d %l), ||#
f:group_write|D:|d:ewrite write|l:../macros/defgroups.h[../macros/defgroups.h] l.23|o:write, and related functions:+: these functions do not depend on strlen, :+: or any globals.||#
f:initgroups|D:int initgroups(const char* user, gid_t group);|l:../src/userdb/initgroups.c[../src/userdb/initgroups.c] l.2|m:manpages/gen/initgroups.3.rst[initgroups]||#
f:itobin|D:#define itobin(A,B,...) _itobin(A,B,VARARG(SHIFT(__VA_ARGS__),0), VARARG(SHIFT(ARG( __VA_ARGS__ )),32) )|d:|l:../src/itobin.c[../src/itobin.c] l.46|o:convert a number to a binary representation.:+: the conversion assumes a size of 32bits for integers,:+: negative values are represented as they are stored internally.:+: ( -1 is 11111111111111111111111111111111,:+:   -2    11111111111111111111111111111110, ...)||#
f:itodec|D:int itodec(int i, char *buf, int prec, char limiter );|d:uitodec|l:../src/itodec.c[../src/itodec.c] l.118||#
f:itooct|D:int itooct(int i, char *buf);|l:../src/itooct.c[../src/itooct.c] l.4|o:convert int to octal:+: return the number of chars written.||#
f:ltodec|D:int ltodec(long i, char *buf, int prec, char limiter );|l:../src/ltodec.c[../src/ltodec.c] l.75||#
f:malloc_brk|D:void* malloc_brk(int size);|d:sbrk|l:../src/malloc_brk.c[../src/malloc_brk.c] l.16|o:allocate via setting the brk:+: free and realloc can be used normally.:+: The intention of malloc_brk is for subsequent calls to realloc.:+: The saved data has not to be copied,:+: instead realloc just writes the new size and sets :+: the brk accordingly.:+: if the break is saved before one or more calls to malloc_brk,:+: the allocated memory can also be free'd by setting the brk to the saved value:+: with brk(saved_brk):+: free_brk() free's all memory, which has been allocated with malloc_brk||#
f:map_protected|D:void* map_protected(int len);|d:mmap mprotect|l:../src/map_protected.c[../src/map_protected.c] l.19|o:allocate a buffer, which is surrounded by protected pages. :+: mprotect(PROT_NONE):+: When there is a buffer overflow,:+: neither the stack, nor other structures can be overwritten.:+: Instead the overflow (or underflow) touches the next protected page,:+: what results in a segfault.:+: The size is always a mutliple of the systems pagesize, 4kB here.:+: The len of the mapped memory area is rounded up to the next pagesize.:+: The mapped area can only be freed by call(s) to munmap,:+: neither realloc nor free are allowed.:+: There is one page before, and one page after the mapped area:+: protected with PROT_NONE, and len rounded up to the next:+: pagebreak. So this is the overhead. :+: If an error occures, errno is set (when defined), :+: and -1 returned, or the negative errno value, when errno isn't defined.|c:memory||#
f:match|D:int match(char *text, const char *re, regex_match *st_match);|l:../src/match.c[../src/match.c] l.59|o:regex engine:+: little bit simpler version than ext_match.:+: The engine matches nongreedy straight from left to right,:+: so backtracking is minimized.:+: It is a compromise between performance, size:+: and capabilities.:+::+: matches: :+: :+: * for every count of any char:+: + for 1 or more chars:+: ? for 1 char:+: # for space or end of text (0):+: $ match end of text:+::+: backslash: escape *,?,%,!,+,#,$ and backslash itself.:+: ! : invert the matching of the next character or character class:+:  :+: [xyz]: character classes, here x,y or z :+:   the characters are matched literally, also \,*,?,+,..:+:   it is not possible to match the closing bracket (]):+:   within a character class:+::+::+: % : matches like a '+', and fills in argument 3,:+: the regex_match struct, when the pointer is non null.:+: The matching is 'nongreedy'.:+::+::+: returns: 1 on match, 0 on no match:+: ( RE_MATCH / RE_NOMATCH ):+::+: if the pointer (argument 3) st_match is nonnull,:+: the supplied struct regex_match will be set to the first matching '%' location;:+: if there is no match, regex_match.len will be set to 0.:+: The struct is defined as: :+: typedef struct _regex_match { char* pos; int len; } regex_match;:+::+::+: (memo) When the regex ist defined within C/cpp source code,:+: a backslash has to be defined as double backslash.:+::+: (note) - be careful when negating a following *, or ?.:+:  somehow - it is logical, but seems to me I overshoot a bit,:+:  and tapped into a logical paradox.:+:  Negating EVERYTHING translates to true.:+:  However, since truth is negated as,... well, there's a problem.:+::+:  (I'm not kidding here. Just don't do a regex with !* or !?.,:+:  or you might experience the meaning of full featured. :+:  Maybe I should say, it's not allowed?):+::+:  A "!+" will translate into nongreedy matching of any char, however;:+:  "%!+" will match with % everything but the last char;:+:  while "%+" matches with % only the first char.:+:  !+ basically sets the greedyness of the left * or % higher.||#
f:max_groupmembers|D:#ifndef mini_max_groupmembers|l:../include/globaldefs.h[../include/globaldefs.h] l.82|o:The maximum number of users, :+: which are within a group.:+: used for the allocation of the array gr_mem.:+: default: 64|c:userdb||#
f:memfrob|D:void* memfrob(void* s, unsigned int len);|l:../src/memfrob.c[../src/memfrob.c] l.3||#
f:mmap|D:static void* __attribute__((optimize("O0"))) mmap(void* addr,  size_t len,  int prot,  int flags,  int fd,  off_t off);|l:../src/mmap.c[../src/mmap.c] l.8|m:manpages/sys/mmap.2.rst[mmap]|o:mmap wrapper:+: address length is rounded up to a multiple of pagesize (4096 Bytes here):+: for the description, please look up the according manpage:+: errno is only set, when mini_errno is defined:+: if not, on error the negative errno value is returned.:+: (e.g. -22 for "invalid argument")||#
f:mremap|D:static void* volatile __attribute__((optimize("O0"))) mremap(void* addr, size_t old_len, size_t new_len, int flags, void* new_addr);|l:../include/mremap.h[../include/mremap.h] l.4||#
f:opendirp|D:static DIR *opendirp(const char *name, DIR *dir);|d:dirbuf 0 open close|l:../src/dirent/opendir.c[../src/dirent/opendir.c] l.10||#
f:optimization_fence|D:static void __attribute__((noipa,cold)) optimization_fence(void*p);|l:../include/minilib_global.h[../include/minilib_global.h] l.151|o:prevent optimizations.:+: cast a var to void*, and calling this,:+: leaves the compiler unknown on what he can strip.:+: The function attribute noipa means,:+: the compiler doesn't know, what the function itself does.:+: (the function does nothing, but don't tell that gcc, please..):+: therefore, everything used as parameter to this function,:+: will be calculated, defined, and so on before.:+: It's used for the globals, :+: shich are pushed within _start onto the stack.:+: since _start itself only provides a global pointer,:+: and initialitzes some of the globals,:+: but doesn't use them again,:+: this construction is needed.:+: more funnily, the function will never be called.:+: It's past the asm inline syscall to exit.:+: But again, luckily gcc doesn't know.:+: All other options, like having the globals volatile, :+: setting the optimization flag of _start to 0, :+: having a volatile asm call with the globals as param, and so on,:+: have been useless. All after all, seems to me, ai has it's restrictions.:+::+: With less overhead the macro OPTFENCE(...) goes.:+: There the call to the "ipa" function is jumped over,:+: via asm inline instructions. ||#
f:posix_openpt|D:int posix_openpt(int flags);|d:open|l:../src/pty.c[../src/pty.c] l.8|m:manpages/sys/posix_openpt.2.rst[posix_openpt]||#
f:print|D:#define print(str) write(STDOUT_FILENO,str,strlen(str))|d:write strlen|l:../include/prints.h[../include/prints.h] l.55|o:write str to stdout. Needs strlen||#
f:printfs|D:#define printfs(fmt,...) fprintfs(stdout, fmt, __VA_ARGS__)|d:fileno strlen write|l:../include/prints.h[../include/prints.h] l.121|o:write fmt and arguments to stdout. :+: only format %s and %c are recognized||#
f:printl|D:#define printl() write(STDOUT_FILENO,"\n",1)|d:write|l:../include/prints.h[../include/prints.h] l.64|o:write a newline to stdout||#
f:prints|D:#define prints(...) _mprints(__VA_ARGS__,0)|d:write|l:../include/prints.h[../include/prints.h] l.18|o:print the string(s) supplied as arg(s) to stdout,:+: this macro has an variable argument count.||#
f:printsl|D:#define printsl(...) _mprints(__VA_ARGS__,"\n",0)|d:write|l:../include/prints.h[../include/prints.h] l.42|o:print the string(s) supplied as arg(s) and newline to stdout||#
f:ptsname|D:char *ptsname(int fd);|d:uitodec open write ioctl strlen|l:../src/pty.c[../src/pty.c] l.34|m:manpages/stdlib/ptsname.3.rst[ptsname]||#
f:ptsname_r|D:int ptsname_r(int fd, char *buf, size_t len);|d:uitodec open strlen ioctl write|l:../src/pty.c[../src/pty.c] l.21||#
f:putenv|D:int putenv( char *string );|d:environ ret_errno|l:../src/putenv.c[../src/putenv.c] l.10|m:manpages/stdlib/getenv.3.rst[putenv]|o:put a string into the environmental vars:+: the supplied string's pointer is put into the environmental array of pointers.:+: Subsequent changes of the string therefore will change the environment,:+: and the supplied string may not be deallocated.:+: Returns: :+: - 0 on success, :+: - EINVAL: string was 0, didn't contain a '=', some other error||#
f:pwent|D:|l:../include/globaldefs.h[../include/globaldefs.h] l.212||#
f:ret_errno|D:#ifdef mini_errno|l:../include/ret_errno.h[../include/ret_errno.h] l.5|o:This macro expands to a return, and:+: (when mini_errno is defined) returns -1 and sets errno,:+: or returns the negative errno value.||#
f:sbrk|D:static void* sbrk(long incr);|l:../src/brk.c[../src/brk.c] l.66|m:manpages/sys/brk.2.rst[sbrk]|o:Set the new brk, increment/decrement by incr bytes.:+: return the old brk on success.:+: conformant sbrk, when mini_errno is defined:+: if no errno is available,:+: returns the negative errno value on error||#
f:scandir_bufsize|D://#define mini_scandir_bufsize 4096|l:../src/dirent/scandir.c[../src/dirent/scandir.c] l.4|o:the increment of the buffer of scandir in bytes for memory allocations:+: (default:4096)||#
f:sdbm_hash|D:unsigned long sdbm_hash(const unsigned char *str);|l:../src/hashes.c[../src/hashes.c] l.23||#
f:setbrk|D:static int setbrk(long addr);|d:brk|l:../src/brk.c[../src/brk.c] l.39|o:set the current brk:+: wrapper for brk(), with type of brk changed to long||#
f:seterrno|D:#ifdef mini_errno|l:../include/seterrno.h[../include/seterrno.h] l.3|o:set errno, but only when errno is defined.||#
f:setgrent|D:void setgrent();|l:../src/userdb/setgrent.c[../src/userdb/setgrent.c] l.3|m:manpages/gen/getgrent.3.rst[setgrent]|c:userdb||#
f:setpwent|D:void setpwent();|l:../src/userdb/setpwent.c[../src/userdb/setpwent.c] l.3|m:manpages/gen/getpwent.3.rst[setpwent]|c:userdb||#
f:short_errstr|D:const char* short_errstr(int num);|l:../include/errstrshort.h[../include/errstrshort.h] l.10|o:verbose error (errno) string. :+: this adds about 3.5kB to the compiled binary(!)||#
f:shortcolornames|D:|l:../include/ansicolors.h[../include/ansicolors.h] l.103|o:short ansi color names:+: all colornames, without the praefix "AC_"||#
f:snprintf|D:int snprintf( char *buf, size_t size, const char *fmt, ... );|d:strlen write|l:../src/snprintf.c[../src/snprintf.c] l.5|m:manpages/stdio/printf.3.rst[snprintf]||#
f:strlcpy|D:char *strlcpy(char *dest, const char *src, int n);|l:../src/strlcpy.c[../src/strlcpy.c] l.5|m:manpages/string/strlcpy.3.rst[strlcpy]|o:copy max n chars from src to dest, :+: when src is longer than dest, :+: end dest[n-1] with '\0'.||#
f:swap|D:static inline void swap(void* a, void* b,int size);|l:../src/qsort.c[../src/qsort.c] l.31|o:swap a with b, with 'size' bytes:+: swaps integers and longs at once, when size eq sizeof(int/long)||#
f:sys_brk|D:static long sys_brk(unsigned long addr);|l:../src/brk.c[../src/brk.c] l.6|o:the kernel syscall brk.||#
f:term_width|D:int term_width();|d:environ|l:../src/term_width.c[../src/term_width.c] l.7|o:get the terminal width:+: reads the environmental var COLS,:+: if not present, returns 80.:+: Doesn't check for the existence of a terminal.||#
f:token_i|D:int token_i( userdb* udb, char **p );|l:../src/userdb/userdb.c[../src/userdb/userdb.c] l.33||#
f:token_s|D:char *token_s( userdb *udb, char **p );|l:../src/userdb/userdb.c[../src/userdb/userdb.c] l.19|o:tokenizer for the passwd/group files.:+: used by the group/user pwentry access functions.:+: performance of subsequent calls could be improved by replacing all ':' and '\n':+: by 0's when loading the db file.:+: it would be possible as well, testing not only single bytes, but:+: integers of longs at once. However, in most cases, e.g.:+: for big directories with many small files, in most cases :+: all files do have the same owner and group. Since the last result to calls:+: of the access functions is cached,:+: there wouldn't be an improvement by optimizing the tokenizing functions.:+: So I'm leaving this for now, as it is.:+: And most possibly it would be better to implement bsd's cached versions :+: of the user db access functions instead. ||#
f:uitodec|D:int __attribute__((optimize("Os")))uitodec(unsigned int i, char *buf, int prec, char limiter );|l:../src/itodec.c[../src/itodec.c] l.8|o:convert int to string.:+: prec: precision, e.g. 4=> 0087 ||#
f:ultodec|D:int ultodec(unsigned long ui, char *buf, int prec, char limiter );|l:../src/ltodec.c[../src/ltodec.c] l.6||#
f:unlockpt|D:int unlockpt(int fd);|d:ioctl|l:../src/pty.c[../src/pty.c] l.14|m:manpages/stdlib/ptsname.3.rst[unlockpt]||#
f:unmap_protected|D:int unmap_protected(void *p, int len);|d:mprotect munmap|l:../src/map_protected.c[../src/map_protected.c] l.41||#
f:userdb_open|D:int userdb_open(userdb *udb, const char* file);|d:globals write|l:../src/userdb/userdb_open.c[../src/userdb/userdb_open.c] l.3||#
f:verbose_errstr|D:const char* verbose_errstr(int num);|l:../include/errstr.h[../include/errstr.h] l.10|o:verbose error (errno) string. :+: this adds about 3.5kB to the compiled binary(!)||#
f:verbose_errstr2|D:static const char* verbose_errstr2(int num);|l:../include/errstr2.h[../include/errstr2.h] l.11|o:verbose error (errno) string. :+: this adds about 3.5kB to the compiled binary(!):+: Trying to shrink that here.||#
f:vexec|D:int vexec( const char* path, char* const* argv, char* const* envp );|d:wait4 seterrno|l:../src/vexec.c[../src/vexec.c] l.6|o:execute a path, wait until the executed file exits.:+: Deviating of system() an absolute pathname is taken.:+: sets errno on error.||#
f:vexec_q|D:int vexec_q( const char* path, char* const* argv, char* const* envp );|d:wait4 seterrno|l:../src/vexec.c[../src/vexec.c] l.30|o:execute a path, wait until the executed file exits, :+: do not write any output of the process. (close stdout):+: Deviating of system() an absolute pathname is taken.||#
f:vsnprintf|D:int vsnprintf(char *buf, size_t size, const char* fmt, va_list args );|d:write strlen|l:../src/sprintf.c[../src/sprintf.c] l.43|m:manpages/stdio/printf.3.rst[vsnprintf]|o:the function, translating the fmt of printf.:+: warning - most possibly you'd like to define besides fprintf, or family,:+: mini_itodec (%d conversion) :+: mini_atoi is needed for grouping numbers||#
f:writes|D:#define writes(str) write(STDOUT_FILENO,str,sizeof(str))|d:write|l:../include/prints.h[../include/prints.h] l.85|o:write the constant str to stdout. Computes length with sizeof(str) at compile time.||#
f:writesl|D:#define writesl(str) write(STDOUT_FILENO,str,sizeof(str));write(STDOUT_FILENO,"\n",1)|d:write|l:../include/prints.h[../include/prints.h] l.95|o:write the constant str to stdout, followed by a newline. :+: Computes length with sizeof(str) at compile time.||#
f:sys__sysctl|k|D:sys__sysctl( struct __sysctl_args *args)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.315||#
f:sys_accept|k|D:sys_accept( int fd,  struct sockaddr *upeersockaddr,  int *upeeraddrlen)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.91||#
f:sys_accept4|k|D:sys_accept4( int fd,  struct sockaddr *upeer_sockaddr,  int *upeer_addrlen,  int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.551||#
f:sys_access|k|D:sys_access( const char *filename,  int mode)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.47||#
f:sys_acct|k|D:sys_acct( const char *name)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.329||#
f:sys_add_key|k|D:sys_add_key( const char *_type,  const char *_description,  const void *_payload,  size_t plen)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.471||#
f:sys_adjtimex|k|D:sys_adjtimex( struct timex *txc_p)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.321||#
f:sys_alarm|k|D:sys_alarm( unsigned int seconds)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.79||#
f:sys_arch_prctl|k|D:sys_arch_prctl( struct task_struct *task,  int code,  unsigned long *addr)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.319||#
f:sys_bind|k|D:sys_bind( int fd,  struct sockaddr *umyaddr,  int addrlen)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.103||#
f:sys_capget|k|D:sys_capget( cap_user_header_t header,  cap_user_data_t dataptr)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.255||#
f:sys_capset|k|D:sys_capset( cap_user_header_t header,  const cap_user_data_t data)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.257||#
f:sys_chdir|k|D:sys_chdir( const char *filename)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.165||#
f:sys_chmod|k|D:sys_chmod( const char *filename,  mode_t mode)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.185||#
f:sys_chown|k|D:sys_chown( const char *filename,  uid_t user,  gid_t group)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.189||#
f:sys_chroot|k|D:sys_chroot( const char *filename)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.325||#
f:sys_clock_adjtime|k|D:sys_clock_adjtime( clockid_t which_clock,  struct timex *tx)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.585||#
f:sys_clock_getres|k|D:sys_clock_getres( const clockid_t which_clock,  struct timespec *tp)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.435||#
f:sys_clock_gettime|k|D:sys_clock_gettime( const clockid_t which_clock,  struct timespec *tp)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.433||#
f:sys_clock_nanosleep|k|D:sys_clock_nanosleep( const clockid_t which_clock,  int flags,  const struct timespec *rqtp,  struct timespec *rmtp)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.437||#
f:sys_clock_settime|k|D:sys_clock_settime( const clockid_t which_clock,  const struct timespec *tp)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.431||#
f:sys_clone|k|D:sys_clone( unsigned long clone_flags,  unsigned long newsp,  void *parent_tid,  void *child_tid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.117||#
f:sys_close|k|D:sys_close( unsigned int fd)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.11||#
f:sys_connect|k|D:sys_connect( int fd,  struct sockaddr *uservaddr,  int addrlen)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.89||#
f:sys_creat|k|D:sys_creat( const char *pathname,  int mode)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.175||#
f:sys_delete_module|k|D:sys_delete_module( const char *name_user,  unsigned int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.353||#
f:sys_dup|k|D:sys_dup( unsigned int fildes)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.69||#
f:sys_dup2|k|D:sys_dup2( unsigned int oldfd,  unsigned int newfd)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.71||#
f:sys_dup3|k|D:sys_dup3( unsigned int oldfd,  unsigned int newfd,  int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.559||#
f:sys_epoll_create|k|D:sys_epoll_create( int size)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.407||#
f:sys_epoll_create1|k|D:sys_epoll_create1( int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.557||#
f:sys_epoll_ctl|k|D:sys_epoll_ctl( int epfd,  int op,  int fd,  struct epoll_event *event)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.443||#
f:sys_epoll_pwait|k|D:sys_epoll_pwait( int epfd,  struct epoll_event *events,  int maxevents,  int timeout,  const sigset_t *sigmask,  size_t sigsetsize)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.537||#
f:sys_epoll_wait|k|D:sys_epoll_wait( int epfd,  struct epoll_event *events,  int maxevents,  int timeout)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.441||#
f:sys_eventfd|k|D:sys_eventfd( unsigned int count)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.543||#
f:sys_eventfd2|k|D:sys_eventfd2( unsigned int count,  int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.555||#
f:sys_execve|k|D:sys_execve( const char *filename,  const char *const argv[],  const char *const envp[])|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.123||#
f:sys_exit|k|D:sys_exit( int error_code)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.125|m:manpages/sys/_exit.2.rst[_exit]||#
f:sys_exit_group|k|D:sys_exit_group( int error_code)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.439||#
f:sys_faccessat|k|D:sys_faccessat( int dfd,  const char *filename,  int mode)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.513||#
f:sys_fadvise64|k|D:sys_fadvise64( int fd,  loff_t offset,  size_t len,  int advice)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.419||#
f:sys_fallocate|k|D:sys_fallocate( long fd,  long mode,  loff_t offset,  loff_t len)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.545||#
f:sys_fanotify_init|k|D:sys_fanotify_init( unsigned int flags,  unsigned int event_f_flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.575||#
f:sys_fanotify_mark|k|D:sys_fanotify_mark( long fanotify_fd,  long flags,  __u64 mask,  long dfd, long pathname)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.577||#
f:sys_fchdir|k|D:sys_fchdir( unsigned int fd)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.167||#
f:sys_fchmod|k|D:sys_fchmod( unsigned int fd,  mode_t mode)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.187||#
f:sys_fchmodat|k|D:sys_fchmodat( int dfd,  const char *filename,  mode_t mode)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.511||#
f:sys_fchown|k|D:sys_fchown( unsigned int fd,  uid_t user,  gid_t group)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.191||#
f:sys_fchownat|k|D:sys_fchownat( int dfd,  const char *filename,  uid_t user,  gid_t group,  int flag)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.495||#
f:sys_fcntl|k|D:sys_fcntl( unsigned int fd,  unsigned int cmd,  unsigned long arg)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.149||#
f:sys_fdatasync|k|D:sys_fdatasync( unsigned int fd)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.155||#
f:sys_fgetxattr|k|D:sys_fgetxattr( int fd,  const char *name,  void *value,  size_t size)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.371||#
f:sys_finit_module|k|D:sys_finit_module( int fd,  const char  *uargs,  int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.601||#
f:sys_flistxattr|k|D:sys_flistxattr( int fd,  char *list,  size_t size)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.377||#
f:sys_flock|k|D:sys_flock( unsigned int fd,  unsigned int cmd)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.151||#
f:sys_fork|k|D:sysSYSDEF_syscall(_fork,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.119||#
f:sys_fremovexattr|k|D:sys_fremovexattr( int fd,  const char *name)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.383||#
f:sys_fsetxattr|k|D:sys_fsetxattr( int fd,  const char *name,  const void *value,  size_t size, int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.365||#
f:sys_fstat|k|D:sys_fstat( unsigned int fd,  struct stat *statbuf)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.15||#
f:sys_fstatfs|k|D:sys_fstatfs( unsigned int fd,  struct statfs *buf)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.279||#
f:sys_fsync|k|D:sys_fsync( unsigned int fd)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.153||#
f:sys_ftruncate|k|D:sys_ftruncate( unsigned int fd,  unsigned long length)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.159||#
f:sys_futex|k|D:sys_futex( u32 *uaddr,  int op,  u32 val,  struct timespec *utime,  u32 *uaddr2,  u32 val3)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.389||#
f:sys_futimesat|k|D:sys_futimesat( int dfd,  const char *filename,  struct timeval *utimes)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.497||#
f:sys_get_mempolicy|k|D:sys_get_mempolicy( int *policy,  unsigned long *nmask,  unsigned long maxnode,  unsigned long addr,  unsigned long flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.453||#
f:sys_get_robust_list|k|D:sys_get_robust_list( int pid,  struct robust_list_head **head_ptr,  size_t *len_ptr)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.523||#
f:sys_getcpu|k|D:sys_getcpu( unsigned *cpup,  unsigned *nodep,  struct getcpu_cache *unused)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.593||#
f:sys_getcwd|k|D:sys_getcwd( char *buf,  unsigned long size)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.163||#
f:sys_getdents|k|D:sys_getdents( unsigned int fd,  struct linux_dirent *dirent,  unsigned int count)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.161||#
f:sys_getdents64|k|D:sys_getdents64( unsigned int fd,  struct linux_dirent64 *dirent,  unsigned int count)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.411||#
f:sys_getegid|k|D:sysSYSDEF_syscall(_getegid,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.221||#
f:sys_geteuid|k|D:sysSYSDEF_syscall(_geteuid,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.219||#
f:sys_getgid|k|D:sysSYSDEF_syscall(_getgid,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.213||#
f:sys_getgroups|k|D:sys_getgroups( int gidsetsize,  gid_t *grouplist)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.235||#
f:sys_getitimer|k|D:sys_getitimer( int which,  struct itimerval *value)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.77||#
f:sys_getpeername|k|D:sys_getpeername( int fd,  struct sockaddr *usockaddr,  int *usockaddr_len)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.109||#
f:sys_getpgid|k|D:sys_getpgid( pid_t pid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.247||#
f:sys_getpgrp|k|D:sysSYSDEF_syscall(_getpgrp,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.227||#
f:sys_getpid|k|D:sysSYSDEF_syscall(_getpid,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.83||#
f:sys_getppid|k|D:sysSYSDEF_syscall(_getppid,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.225||#
f:sys_getpriority|k|D:sys_getpriority( int which,  int who)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.283||#
f:sys_getrandom|k|D:sys_getrandom( char  *buf,  size_t count,  unsigned int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.611||#
f:sys_getresgid|k|D:sys_getresgid( gid_t *rgid,  gid_t *egid,  gid_t *sgid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.245||#
f:sys_getresuid|k|D:sys_getresuid( uid_t *ruid,  uid_t *euid,  uid_t *suid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.241||#
f:sys_getrlimit|k|D:sys_getrlimit( unsigned int resource,  struct rlimit *rlim)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.199||#
f:sys_getrusage|k|D:sys_getrusage( int who,  struct rusage *ru)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.201||#
f:sys_getsid|k|D:sys_getsid( pid_t pid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.253||#
f:sys_getsockname|k|D:sys_getsockname( int fd,  struct sockaddr *usockaddr,  int *usockaddr_len)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.107||#
f:sys_getsockopt|k|D:sys_getsockopt( int fd,  int level,  int optname,  char *optval,  int *optlen)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.115||#
f:sys_gettid|k|D:sysSYSDEF_syscall(_gettid,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.357||#
f:sys_gettimeofday|k|D:sys_gettimeofday( struct timeval *tv,  struct timezone *tz)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.197||#
f:sys_getuid|k|D:sysSYSDEF_syscall(_getuid,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.209||#
f:sys_getxattr|k|D:sys_getxattr( const char *pathname,  const char *name,  void *value,  size_t size)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.367||#
f:sys_init_module|k|D:sys_init_module( void *umod,  unsigned long len,  const char *uargs)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.351||#
f:sys_inotify_add_watch|k|D:sys_inotify_add_watch( int fd,  const char *pathname,  u32 mask)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.483||#
f:sys_inotify_init|k|D:sysSYSDEF_syscall(_inotify_init,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.481||#
f:sys_inotify_init1|k|D:sys_inotify_init1( int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.563||#
f:sys_inotify_rm_watch|k|D:sys_inotify_rm_watch( int fd,  __s32 wd)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.485||#
f:sys_io_cancel|k|D:sys_io_cancel( aio_context_t ctx_id,  struct iocb *iocb,  struct io_event *result)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.403||#
f:sys_io_destroy|k|D:sys_io_destroy( aio_context_t ctx)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.397||#
f:sys_io_getevents|k|D:sys_io_getevents( aio_context_t ctx_id,  long min_nr,  long nr,  struct io_event *events)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.399||#
f:sys_io_setup|k|D:sys_io_setup( unsigned nr_events,  aio_context_t *ctxp)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.395||#
f:sys_io_submit|k|D:sys_io_submit( aio_context_t ctx_id,  long nr,  struct iocb **iocbpp)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.401||#
f:sys_ioctl|k|D:sys_ioctl( unsigned int fd,  unsigned int cmd,  unsigned long arg)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.37||#
f:sys_ioperm|k|D:sys_ioperm( unsigned long from,  unsigned long num,  int turn_on)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.349||#
f:sys_iopl|k|D:sys_iopl( unsigned int level,  struct pt_regs *regs)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.347||#
f:sys_ioprio_get|k|D:sys_ioprio_get( int which,  int who)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.479||#
f:sys_ioprio_set|k|D:sys_ioprio_set( int which,  int who,  int ioprio)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.477||#
f:sys_kcmp|k|D:sys_kcmp( pid_t pid1,  pid_t pid2,  int type,  unsigned long idx1,  unsigned long idx2)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.599||#
f:sys_kexec_file_load|k|D:sys_kexec_file_load( int kernel_fd,  int initrd_fd,  unsigned long cmdline_len,  const char  *cmdline_ptr,  unsigned long flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.615||#
f:sys_kexec_load|k|D:sys_kexec_load( unsigned long entry,  unsigned long nr_segments,  struct kexec_segment *segments,  unsigned long flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.467||#
f:sys_keyctl|k|D:sys_keyctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.475||#
f:sys_kill|k|D:sys_kill( pid_t pid,  int sig)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.129||#
f:sys_lchown|k|D:sys_lchown( const char *filename,  uid_t user,  gid_t group)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.193||#
f:sys_lgetxattr|k|D:sys_lgetxattr( const char *pathname,  const char *name,  void *value,  size_t size)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.369||#
f:sys_link|k|D:sys_link( const char *oldname,  const char *newname)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.177||#
f:sys_linkat|k|D:sys_linkat( int oldfd,  const char *oldname,  int newfd,  const char *newname,  int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.505||#
f:sys_listen|k|D:sys_listen( int fd,  int backlog)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.105||#
f:sys_listxattr|k|D:sys_listxattr( const char *pathname,  char *list,  size_t size)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.373||#
f:sys_llistxattr|k|D:sys_llistxattr( const char *pathname,  char *list,  size_t size)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.375||#
f:sys_lookup_dcookie|k|D:sys_lookup_dcookie( u64 cookie64,  long buf,  long len)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.405||#
f:sys_lremovexattr|k|D:sys_lremovexattr( const char *pathname,  const char *name)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.381||#
f:sys_lseek|k|D:sys_lseek( unsigned int fd,  off_t offset,  unsigned int origin)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.21||#
f:sys_lsetxattr|k|D:sys_lsetxattr( const char *pathname,  const char *name,  const void *value, size_t size,  int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.363||#
f:sys_lstat|k|D:sys_lstat( const char *filename,  struct stat *statbuf)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.17||#
f:sys_madvise|k|D:sys_madvise( unsigned long start,  size_t len_in,  int behavior)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.61||#
f:sys_mbind|k|D:sys_mbind( unsigned long start,  unsigned long len,  unsigned long mode,  unsigned long *nmask,  unsigned long maxnode,  unsigned flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.449||#
f:sys_memfd_create|k|D:sys_memfd_create( const char  *uname_ptr,  unsigned int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.613||#
f:sys_migrate_pages|k|D:sys_migrate_pages( pid_t pid,  unsigned long maxnode,  const unsigned long *old_nodes,  const unsigned long *new_nodes)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.487||#
f:sys_mincore|k|D:sys_mincore( unsigned long start,  size_t len,  unsigned char *vec)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.59||#
f:sys_mkdir|k|D:sys_mkdir( const char *pathname,  int mode)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.171||#
f:sys_mkdirat|k|D:sys_mkdirat( int dfd,  const char *pathname,  int mode)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.491||#
f:sys_mknod|k|D:sys_mknod( const char *filename,  umode_t mode,  unsigned dev)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.271||#
f:sys_mknodat|k|D:sys_mknodat( int dfd,  const char *filename,  int mode,  unsigned dev)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.493||#
f:sys_mlock|k|D:sys_mlock( unsigned long start,  size_t len)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.301||#
f:sys_mlockall|k|D:sys_mlockall( int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.305||#
f:sys_mmap|k|D:sys_mmap( unsigned long addr,  unsigned long len,  unsigned long prot,  unsigned long flags,  unsigned long fd,  unsigned long off)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.23||#
f:sys_modify_ldt|k|D:sys_modify_ldt( int func,  void *ptr,  unsigned long bytecount)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.311||#
f:sys_mount|k|D:sys_mount( char *dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.333||#
f:sys_move_pages|k|D:sys_move_pages( pid_t pid,  unsigned long nr_pages,  const void *pages[], const int *nodes,  int *status,  int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.533||#
f:sys_mprotect|k|D:sys_mprotect( unsigned long start,  size_t len,  unsigned long prot)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.25||#
f:sys_mq_getsetattr|k|D:sys_mq_getsetattr( mqd_t mqdes,  const struct mq_attr *u_mqstat,  struct mq_attr *u_omqstat)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.465||#
f:sys_mq_notify|k|D:sys_mq_notify( mqd_t mqdes,  const struct sigevent *u_notification)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.463||#
f:sys_mq_open|k|D:sys_mq_open( const char *u_name,  int oflag,  mode_t mode,  struct mq_attr *u_attr)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.455||#
f:sys_mq_timedreceive|k|D:sys_mq_timedreceive( mqd_t mqdes,  char *u_msg_ptr,  size_t msg_len,  unsigned int *u_msg_prio,  const struct timespec *u_abs_timeout)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.461||#
f:sys_mq_timedsend|k|D:sys_mq_timedsend( mqd_t mqdes,  const char *u_msg_ptr,  size_t msg_len,  unsigned int msg_prio,  const struct timespec *u_abs_timeout)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.459||#
f:sys_mq_unlink|k|D:sys_mq_unlink( const char *u_name)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.457||#
f:sys_mremap|k|D:sys_mremap( unsigned long addr,  unsigned long old_len,  unsigned long new_len,  unsigned long flags,  unsigned long new_addr)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.55||#
f:sys_msgctl|k|D:sys_msgctl( int msqid,  int cmd,  struct msqid_ds *buf)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.147||#
f:sys_msgget|k|D:sys_msgget( key_t key,  int msgflg)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.141||#
f:sys_msgrcv|k|D:sys_msgrcv( int msqid,  struct msgbuf *msgp,  size_t msgsz,  long msgtyp,  int msgflg)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.145||#
f:sys_msgsnd|k|D:sys_msgsnd( int msqid,  struct msgbuf *msgp,  size_t msgsz,  int msgflg)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.143||#
f:sys_msync|k|D:sys_msync( unsigned long start,  size_t len,  int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.57||#
f:sys_munlock|k|D:sys_munlock( unsigned long start,  size_t len)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.303||#
f:sys_munlockall|k|D:sysSYSDEF_syscall(_munlockall,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.307||#
f:sys_munmap|k|D:sys_munmap( unsigned long addr,  size_t len)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.27||#
f:sys_name_to_handle_at|k|D:sys_name_to_handle_at( int dfd,  const char *name,  struct file_handle *handle,  int *mnt_id,  int flag)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.581||#
f:sys_nanosleep|k|D:sys_nanosleep( struct timespec *rqtp,  struct timespec *rmtp)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.75||#
f:sys_newfstatat|k|D:sys_newfstatat( int dfd,  const char *filename,  struct stat *statbuf,  int flag)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.499||#
f:sys_open|k|D:sys_open( const char *filename,  int flags,  int mode)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.9||#
f:sys_open_by_handle_at|k|D:sys_open_by_handle_at( int dfd,  const char *name,  struct file_handle *handle,  int *mnt_id,  int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.583||#
f:sys_openat|k|D:sys_openat( int dfd,  const char *filename,  int flags,  int mode)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.489||#
f:sys_pause|k|D:sysSYSDEF_syscall(_pause,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.73||#
f:sys_perf_event_open|k|D:sys_perf_event_open( struct perf_event_attr *attr_uptr,  pid_t pid,  int cpu,  int group_fd,  unsigned long flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.571||#
f:sys_personality|k|D:sys_personality( unsigned int personality)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.273||#
f:sys_pipe|k|D:sys_pipe( int *filedes)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.49||#
f:sys_pipe2|k|D:sys_pipe2( int *filedes,  int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.561||#
f:sys_pivot_root|k|D:sys_pivot_root( const char *new_root,  const char *put_old)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.313||#
f:sys_poll|k|D:sys_poll( struct poll_fd *ufds,  unsigned int nfds,  long timeout_msecs)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.19||#
f:sys_ppoll|k|D:sys_ppoll( struct pollfd *ufds,  unsigned int nfds,  struct timespec *tsp,  const sigset_t *sigmask,  size_t sigsetsize)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.517||#
f:sys_prctl|k|D:sys_prctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.317||#
f:sys_pread64|k|D:sys_pread64( unsigned long fd,  char *buf,  size_t count,  loff_t pos)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.39||#
f:sys_preadv|k|D:sys_preadv( unsigned long fd,  const struct iovec *vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.565||#
f:sys_prlimit64|k|D:sys_prlimit64( pid_t pid,  unsigned int resource,  const struct rlimit64 *new_rlim,  struct rlimit64 *old_rlim)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.579||#
f:sys_process_vm_readv|k|D:sys_process_vm_readv( pid_t pid,  const struct iovec *lvec,  unsigned long liovcnt,  const struct iovec *rvec,  unsigned long riovcnt,  unsigned long flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.595||#
f:sys_process_vm_writev|k|D:sys_process_vm_writev( pid_t pid,  const struct iovec *lvec,  unsigned long liovcnt,  const struct iovcc *rvec,  unsigned long riovcnt,  unsigned long flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.597||#
f:sys_pselect6|k|D:sys_pselect6( int n,  fd_set *inp,  fd_set *outp,  fd_set *exp,  struct timespec *tsp,  void *sig)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.515||#
f:sys_ptrace|k|D:sys_ptrace( long request,  long pid,  unsigned long addr,  unsigned long data)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.207||#
f:sys_pwrite64|k|D:sys_pwrite64( unsigned int fd,  const char *buf,  size_t count,  loff_t pos)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.41||#
f:sys_pwritev|k|D:sys_pwritev( unsigned long fd,  const struct iovec *vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.567||#
f:sys_quotactl|k|D:sys_quotactl( unsigned int cmd,  const char *special,  qid_t id,  void *addr)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.355||#
f:sys_read|k|D:sys_read( unsigned int fd,  char *buf,  size_t count)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.5||#
f:sys_readahead|k|D:sys_readahead( int fd,  loff_t offset,  size_t count)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.359||#
f:sys_readlink|k|D:sys_readlink( const char *path,  char *buf,  int bufsiz)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.183||#
f:sys_readlinkat|k|D:sys_readlinkat( int dfd,  const char *pathname,  char *buf,  int bufsiz)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.509||#
f:sys_readv|k|D:sys_readv( unsigned long fd,  const struct iovec *vec,  unsigned long vlen)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.43||#
f:sys_reboot|k|D:sys_reboot( int magic1,  int magic2,  unsigned int cmd,  void *arg)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.341||#
f:sys_recvfrom|k|D:sys_recvfrom( int fd,  void *ubuf,  size_t size,  unsigned flags,  struct sockaddr *addr,  int *addr_len)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.95||#
f:sys_recvmmsg|k|D:sys_recvmmsg( int fd,  struct msghdr *mmsg,  unsigned int vlen,  unsigned int flags,  struct timespec *timeout)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.573||#
f:sys_recvmsg|k|D:sys_recvmsg( int fd,  struct msghdr *msg,  unsigned int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.99||#
f:sys_remap_file_pages|k|D:sys_remap_file_pages( unsigned long start,  unsigned long size,  unsigned long prot,  unsigned long pgoff,  unsigned long flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.409||#
f:sys_removexattr|k|D:sys_removexattr( const char *pathname,  const char *name)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.379||#
f:sys_rename|k|D:sys_rename( const char *oldname,  const char *newname)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.169||#
f:sys_renameat|k|D:sys_renameat( int oldfd,  const char *oldname,  int newfd,  const char *newname)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.503||#
f:sys_renameat2|k|D:sys_renameat2( int olddfd,  const char  *oldname,  int newdfd,  const char  *newname,  unsigned int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.607||#
f:sys_request_key|k|D:sys_request_key( const char *_type,  const char *_description,  const char *_callout_info,  key_serial_t destringid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.473||#
f:sys_restart_syscall|k|D:sysSYSDEF_syscall(_restart_syscall,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.415||#
f:sys_rmdir|k|D:sys_rmdir( const char *pathname)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.173||#
f:sys_rt_sigaction|k|D:sys_rt_sigaction( int sig,  const struct sigaction *act,  struct sigaction *oact,  size_t sigsetsize)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.31||#
f:sys_rt_sigpending|k|D:sys_rt_sigpending( sigset_t *set,  size_t sigsetsize)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.259||#
f:sys_rt_sigprocmask|k|D:sys_rt_sigprocmask( int how,  sigset_t *nset,  sigset_t *oset,  size_t sigsetsize)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.33||#
f:sys_rt_sigqueueinfo|k|D:sys_rt_sigqueueinfo( pid_t pid,  int sig,  siginfo_t *uinfo)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.263||#
f:sys_rt_sigreturn|k|D:sys_rt_sigreturn( unsigned long __unused)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.35||#
f:sys_rt_sigsuspend|k|D:sys_rt_sigsuspend( sigset_t *unewset,  size_t sigsetsize)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.265||#
f:sys_rt_sigtimedwait|k|D:sys_rt_sigtimedwait( const sigset_t *uthese,  siginfo_t *uinfo,  const struct timespec *uts,  size_t sigsetsize)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.261||#
f:sys_rt_tgsigqueueinfo|k|D:sys_rt_tgsigqueueinfo( pid_t tgid,  pid_t pid,  int sig,  siginfo_t *uinfo)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.569||#
f:sys_sched_get_priority_max|k|D:sys_sched_get_priority_max( int policy)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.295||#
f:sys_sched_get_priority_min|k|D:sys_sched_get_priority_min( int policy)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.297||#
f:sys_sched_getaffinity|k|D:sys_sched_getaffinity( pid_t pid,  unsigned int len,  unsigned long *user_mask_ptr)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.393||#
f:sys_sched_getattr|k|D:sys_sched_getattr( pid_t pid,  struct sched_attr  *attr,  unsigned int size,  unsigned int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.605||#
f:sys_sched_getparam|k|D:sys_sched_getparam( pid_t pid,  struct sched_param *param)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.289||#
f:sys_sched_getscheduler|k|D:sys_sched_getscheduler( pid_t pid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.293||#
f:sys_sched_rr_get_interval|k|D:sys_sched_rr_get_interval( pid_t pid,  struct timespec *interval)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.299||#
f:sys_sched_setaffinity|k|D:sys_sched_setaffinity( pid_t pid,  unsigned int len,  unsigned long *user_mask_ptr)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.391||#
f:sys_sched_setattr|k|D:sys_sched_setattr( pid_t pid,  struct sched_attr  *attr,  unsigned int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.603||#
f:sys_sched_setparam|k|D:sys_sched_setparam( pid_t pid,  struct sched_param *param)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.287||#
f:sys_sched_setscheduler|k|D:sys_sched_setscheduler( pid_t pid,  int policy,  struct sched_param *param)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.291||#
f:sys_sched_yield|k|D:sysSYSDEF_syscall(_sched_yield,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.53||#
f:sys_seccomp|k|D:sys_seccomp( unsigned int op,  unsigned int flags,  const char  *uargs)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.609||#
f:sys_select|k|D:sys_select( int n,  fd_set *inp,  fd_set *outp,  fd_set *exp,  struct timeval *tvp)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.51||#
f:sys_semctl|k|D:sys_semctl( int semid,  int semnum,  int cmd,  semun_u arg)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.137||#
f:sys_semget|k|D:sys_semget( key_t key,  int nsems,  int semflg)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.133||#
f:sys_semop|k|D:sys_semop( int semid,  struct sembuf *tsops,  unsigned nsops)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.135||#
f:sys_semtimedop|k|D:sys_semtimedop( int semid,  struct sembuf *tsops,  unsigned nsops,  const struct timespec *timeout)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.417||#
f:sys_sendfile|k|D:sys_sendfile( int out_fd,  int in_fd,  off_t *offset,  size_t count)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.85||#
f:sys_sendmmsg|k|D:sys_sendmmsg( int fd,  struct mmsghdr *mmsg,  unsigned int vlen,  unsigned int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.589||#
f:sys_sendmsg|k|D:sys_sendmsg( int fd,  struct msghdr *msg,  unsigned flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.97||#
f:sys_sendto|k|D:sys_sendto( int fd,  void *buff,  size_t len,  unsigned flags,  struct sockaddr *addr,  int addr_len)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.93||#
f:sys_set_mempolicy|k|D:sys_set_mempolicy( int mode,  unsigned long *nmask,  unsigned long maxnode)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.451||#
f:sys_set_robust_list|k|D:sys_set_robust_list( struct robust_list_head *head,  size_t len)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.521||#
f:sys_set_tid_address|k|D:sys_set_tid_address( int *tidptr)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.413||#
f:sys_setdomainname|k|D:sys_setdomainname( char *name,  int len)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.345||#
f:sys_setfsgid|k|D:sys_setfsgid( gid_t gid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.251||#
f:sys_setfsuid|k|D:sys_setfsuid( uid_t uid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.249||#
f:sys_setgid|k|D:sys_setgid( gid_t gid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.217||#
f:sys_setgroups|k|D:sys_setgroups( int gidsetsize,  gid_t *grouplist)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.237||#
f:sys_sethostname|k|D:sys_sethostname( char *name,  int len)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.343||#
f:sys_setitimer|k|D:sys_setitimer( int which,  struct itimerval *value,  struct itimerval *ovalue)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.81||#
f:sys_setns|k|D:sys_setns( int fd,  int nstype)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.591||#
f:sys_setpgid|k|D:sys_setpgid( pid_t pid,  pid_t pgid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.223||#
f:sys_setpriority|k|D:sys_setpriority( int which,  int who,  int niceval)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.285||#
f:sys_setregid|k|D:sys_setregid( gid_t rgid,  gid_t egid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.233||#
f:sys_setresgid|k|D:sys_setresgid( gid_t rgid,  gid_t egid,  gid_t sgid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.243||#
f:sys_setresuid|k|D:sys_setresuid( uid_t *ruid,  uid_t *euid,  uid_t *suid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.239||#
f:sys_setreuid|k|D:sys_setreuid( uid_t ruid,  uid_t euid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.231||#
f:sys_setrlimit|k|D:sys_setrlimit( unsigned int resource,  struct rlimit *rlim)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.323||#
f:sys_setsid|k|D:sysSYSDEF_syscall(_setsid,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.229||#
f:sys_setsockopt|k|D:sys_setsockopt( int fd,  int level,  int optname,  char *optval,  int optlen)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.113||#
f:sys_settimeofday|k|D:sys_settimeofday( struct timeval *tv,  struct timezone *tz)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.331||#
f:sys_setuid|k|D:sys_setuid( uid_t uid)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.215||#
f:sys_setxattr|k|D:sys_setxattr( const char *pathname,  const char *name,  const void *value, size_t size,  int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.361||#
f:sys_shmat|k|D:sys_shmat( int shmid,  char *shmaddr,  int shmflg)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.65||#
f:sys_shmctl|k|D:sys_shmctl( int shmid,  int cmd,  struct shmid_ds *buf)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.67||#
f:sys_shmdt|k|D:sys_shmdt( char *shmaddr)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.139||#
f:sys_shmget|k|D:sys_shmget( key_t key,  size_t size,  int shmflg)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.63||#
f:sys_shutdown|k|D:sys_shutdown( int fd,  int how)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.101||#
f:sys_sigaltstack|k|D:sys_sigaltstack( const stack_t *uss,  stack_t *uoss)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.267||#
f:sys_signalfd|k|D:sys_signalfd( int ufd,  sigset_t *user_mask,  size_t sizemask)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.539||#
f:sys_signalfd4|k|D:sys_signalfd4( int ufd,  sigset_t *user_mask,  size_t sizemask,  int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.553||#
f:sys_socket|k|D:sys_socket( int family,  int type,  int protocol)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.87||#
f:sys_socketpair|k|D:sys_socketpair( int family,  int type,  int protocol,  int *usockvec)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.111||#
f:sys_splice|k|D:sys_splice( int fd_in,  loff_t *off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.525||#
f:sys_stat|k|D:sys_stat( const char *filename,  struct stat *statbuf)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.13||#
f:sys_statfs|k|D:sys_statfs( const char *pathname,  struct statfs *buf)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.277||#
f:sys_swapoff|k|D:sys_swapoff( const char *specialfile)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.339||#
f:sys_swapon|k|D:sys_swapon( const char *specialfile,  int swap_flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.337||#
f:sys_symlink|k|D:sys_symlink( const char *oldname,  const char *newname)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.181||#
f:sys_symlinkat|k|D:sys_symlinkat( const char *oldname,  int newfd,  const char *newname)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.507||#
f:sys_sync|k|D:sysSYSDEF_syscall(_sync,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.327||#
f:sys_sync_file_range|k|D:sys_sync_file_range( long fd,  loff_t offset,  loff_t bytes,  long flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.529||#
f:sys_syncfs|k|D:sys_syncfs( int fd)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.587||#
f:sys_sysfs|k|D:sys_sysfs( int option,  unsigned long arg1,  unsigned long arg2)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.281||#
f:sys_sysinfo|k|D:sys_sysinfo( struct sysinfo *info)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.203||#
f:sys_syslog|k|D:sys_syslog( int type,  char *buf,  int len)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.211||#
f:sys_tee|k|D:sys_tee( int fdin,  int fdout,  size_t len,  unsigned int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.527||#
f:sys_tgkill|k|D:sys_tgkill( pid_t tgid,  pid_t pid,  int sig)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.445||#
f:sys_time|k|D:sys_time( time_t *tloc)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.387||#
f:sys_timer_create|k|D:sys_timer_create( const clockid_t which_clock,  struct sigevent *timer_event_spec,  timer_t *created_timer_id)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.421||#
f:sys_timer_delete|k|D:sys_timer_delete( timer_t timer_id)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.429||#
f:sys_timer_getoverrun|k|D:sys_timer_getoverrun( timer_t timer_id)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.427||#
f:sys_timer_gettime|k|D:sys_timer_gettime( timer_t timer_id,  struct itimerspec *setting)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.425||#
f:sys_timer_settime|k|D:sys_timer_settime( timer_t timer_id,  int flags,  const struct itimerspec *new_setting,  struct itimerspec *old_setting)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.423||#
f:sys_timerfd_create|k|D:sys_timerfd_create( int clockid,  int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.541||#
f:sys_timerfd_gettime|k|D:sys_timerfd_gettime( int ufd,  struct itimerspec *otmr)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.549||#
f:sys_timerfd_settime|k|D:sys_timerfd_settime( int ufd,  int flags,  const struct itimerspec *utmr,  struct itimerspec *otmr)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.547||#
f:sys_times|k|D:sys_times( struct sysinfo *info)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.205||#
f:sys_tkill|k|D:sys_tkill( pid_t pid,  int sig)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.385||#
f:sys_truncate|k|D:sys_truncate( const char *path,  long length)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.157||#
f:sys_umask|k|D:sys_umask( int mask)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.195||#
f:sys_umount2|k|D:sys_umount2( const char *target,  int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.335||#
f:sys_uname|k|D:sys_uname( struct old_utsname *name)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.131||#
f:sys_unlink|k|D:sys_unlink( const char *pathname)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.179||#
f:sys_unlinkat|k|D:sys_unlinkat( int dfd,  const char *pathname,  int flag)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.501||#
f:sys_unshare|k|D:sys_unshare( unsigned long unshare_flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.519||#
f:sys_ustat|k|D:sys_ustat( unsigned dev,  struct ustat *ubuf)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.275||#
f:sys_utime|k|D:sys_utime( char *filename,  struct utimbuf *times)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.269||#
f:sys_utimensat|k|D:sys_utimensat( int dfd,  const char *filename,  struct timespec *utimes, int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.535||#
f:sys_utimes|k|D:sys_utimes( char *filename,  struct timeval *utimes)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.447||#
f:sys_vfork|k|D:sysSYSDEF_syscall(_vfork,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.121||#
f:sys_vhangup|k|D:sysSYSDEF_syscall(_vhangup,0)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.309||#
f:sys_vmsplice|k|D:sys_vmsplice( int fd,  const struct iovec *iov,  unsigned long nr_segs, unsigned int flags)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.531||#
f:sys_wait4|k|D:sys_wait4( pid_t upid,  int *stat_addr,  int options,  struct rusage *ru)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.127||#
f:sys_waitid|k|D:sys_waitid( int which,  pid_t upid,  struct siginfo *infop,  int options,  struct rusage *ru)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.469||#
f:sys_write|k|D:sys_write( unsigned int fd,  const char *buf,  size_t count)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.7||#
f:sys_writev|k|D:sys_writev( unsigned long fd,  const struct iovec *vec,  unsigned long vlen)|l:../include/syscalls_x64.h[../include/syscalls_x64.h] l.45||#
f:raise|D:static inline int raise(int signr);|d:getpid|l:../src/sigaction.c[../src/sigaction.c] l.135|m:manpages/gen/raise.3.rst[raise]||#
f:sigaction|D:static int volatile sigaction(int sig, const struct sigaction *act, struct sigaction *oact);|d:memcpy|l:../src/sigaction.c[../src/sigaction.c] l.107|m:manpages/sys/sigaction.2.rst[sigaction]||#
f:sigaddset|D:int sigaddset(sigset_t *set, int sig);|l:../src/sigaction.c[../src/sigaction.c] l.34|m:manpages/gen/sigsetops.3.rst[sigaddset]||#
f:sigdelset|D:int sigdelset(sigset_t *set, int sig);|l:../src/sigaction.c[../src/sigaction.c] l.58|m:manpages/gen/sigsetops.3.rst[sigdelset]||#
f:sigemptyset|D:static int sigemptyset(sigset_t *set);|l:../src/sigaction.c[../src/sigaction.c] l.7|m:manpages/gen/sigsetops.3.rst[sigemptyset]||#
f:sigfillset|D:static int sigfillset(sigset_t *set);|l:../src/sigaction.c[../src/sigaction.c] l.20|m:manpages/gen/sigsetops.3.rst[sigfillset]||#
f:sigismember|D:int sigismember(sigset_t *set, int sig);|l:../src/sigaction.c[../src/sigaction.c] l.75|m:manpages/gen/sigsetops.3.rst[sigismember]||#
f:signal|D:sighandler_t signal(int sig, sighandler_t func );|d:memcpy write|l:../src/signal.c[../src/signal.c] l.5|m:manpages/gen/signal.3.rst[signal]||#
f:sigprocmask|D:int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);|l:../src/sigaction.c[../src/sigaction.c] l.52|m:manpages/sys/sigprocmask.2.rst[sigprocmask]||#
f:_fopen|D:FILE *_fopen(int fd, const char* filename, const char* mode, FILE *f);|d:close open fileno|l:../src/_fopen.c[../src/_fopen.c] l.12|o:modes implemented: r, r+, w, w+, a, a+||#
f:_itohex|D:int _itohex(int i,char* buf,int padding, int capitals);|l:../src/itohex.c[../src/itohex.c] l.6||#
f:clearerr|D:static inline void clearerr(FILE *f);|l:../include/mini_fstream.h[../include/mini_fstream.h] l.184|m:manpages/stdio/ferror.3.rst[clearerr]||#
f:clearerror|D:static inline void clearerror(FILE *f);|l:../include/mini_fstream.h[../include/mini_fstream.h] l.189||#
f:fclose|D:static inline int __attribute__((always_inline)) fclose( FILE* f );|d:close|l:../include/mini_fstream.h[../include/mini_fstream.h] l.65|m:manpages/stdio/fclose.3.rst[fclose]||#
f:fdopen|D:FILE *fdopen(int fd, const char* mode);|d:fileno close open|l:../src/fopen.c[../src/fopen.c] l.20|m:manpages/stdio/fopen.3.rst[fdopen]|o:modes implemented: r, r+, w, w+, a, a+||#
f:feof|D:static inline int feof(FILE *f);|l:../include/mini_fstream.h[../include/mini_fstream.h] l.170|m:manpages/stdio/ferror.3.rst[feof]||#
f:ferror|D:static inline int ferror(FILE *f);|l:../include/mini_fstream.h[../include/mini_fstream.h] l.177|m:manpages/stdio/ferror.3.rst[ferror]||#
f:fflush|D:static inline int __attribute__((always_inline)) fflush( FILE *F );|l:../include/mini_fstream.h[../include/mini_fstream.h] l.28|m:manpages/stdio/fflush.3.rst[fflush]|o:This does nothing, since minilib doesn't provide buffered streams yet.In order to sync data to disc, please use fsync||#
f:fgetc|D:static inline int fgetc(FILE *F);|d:read fileno|l:../include/fgetc.h[../include/fgetc.h] l.11|m:manpages/stdio/getc.3.rst[fgetc]||#
f:fgetpos|D:static inline void fgetpos(FILE *f, long *pos );|d:lseek|l:../include/mini_fstream.h[../include/mini_fstream.h] l.113|m:manpages/stdio/fseek.3.rst[fgetpos]||#
f:fgets|D:char* fgets(char *buf, int size, FILE* F);|d:fileno read|l:../src/fgets.c[../src/fgets.c] l.4|m:manpages/stdio/fgets.3.rst[fgets]||#
f:fileno|D:static int fileno( FILE *f );|l:../include/mini_fstream.h[../include/mini_fstream.h] l.56|m:manpages/stdio/ferror.3.rst[fileno]|o:Return the fd nummber of stdin,-out,-err. ||#
f:fopen|D:FILE *fopen(const char* filename, const char* mode);|d:close open fileno|l:../src/fopen.c[../src/fopen.c] l.10|m:manpages/stdio/fopen.3.rst[fopen]|o:modes implemented: r, r+, w, w+, a, a+||#
f:fprint|D:#define fprint(...) fprintf(__VA_ARGS__)|d:fileno write strlen|l:../include/mini_fstream.h[../include/mini_fstream.h] l.81||#
f:fprintf|D:#define fprintf(stream,...)	write(fileno(stream),mlgl->mbuf,sprintf(mlgl->mbuf,__VA_ARGS__))|d:fileno write strlen|l:../src/sprintf.c[../src/sprintf.c] l.268|m:manpages/stdio/printf.3.rst[fprintf]|o:fprintf, formatted output:+: conversions implemented::+: %d: signed int (mini_itodec):+: %u: unsigned int (mini_uitodec):+: %f: double (max precision 8 digits, highest possible number: 2^31:+: %l (modify a following d,u to long) (mini_ltodec,mini_ultodec):+: %s: string:+: %c: char:+: binary and hex output print the numbers, :+: as they are internally stored(!).:+: Negative numbers are represented with the first sign bit set.:+: (e.g. -1 = 0xFFFFFFFF at x64):+: %b : binary output  (mini_itobin):+: %o : octal output (mini_itooct):+: %x/X : hex output (small/big capitals) (mini_itohex,mini_itoHEX:+: %(: grouping (mini_atoi):+::+: warning - most possibly you'd like to define besides fprintf, or family,:+: mini_itodec (%d conversion) :+: :+: For squeezing a few more bytes, and saving some checking;:+: writes(constant string) and print (variable string), :+: prints (formatted output of one or several strings) are provided.:+::+: ||#
f:fputc|D:static inline int volatile fputc(int c, FILE* F);|d:fileno write|l:../include/fputc.h[../include/fputc.h] l.10|m:manpages/stdio/putc.3.rst[fputc]||#
f:fputs|D:static inline int volatile fputs(const char *c, FILE *F);|d:fileno write strlen|l:../include/fputs.h[../include/fputs.h] l.20|m:manpages/stdio/fputs.3.rst[fputs]||#
f:fread|D:static inline size_t fread(void *ptr, size_t size, size_t nmemb, FILE *f);|d:read|l:../include/mini_fstream.h[../include/mini_fstream.h] l.148|m:manpages/stdio/fread.3.rst[fread]||#
f:freopen|D:FILE *freopen(const char* filename, const char* mode, FILE *F);|d:fileno open close|l:../src/fopen.c[../src/fopen.c] l.30|m:manpages/stdio/fopen.3.rst[freopen]|o:modes implemented: r, r+, w, w+, a, a+||#
f:fseek|D:static inline int fseek(FILE *f, long offset, int whence );|d:lseek|l:../include/mini_fstream.h[../include/mini_fstream.h] l.132|m:manpages/stdio/fseek.3.rst[fseek]||#
f:fsetpos|D:static inline int fsetpos(FILE *f, int pos );|d:lseek|l:../include/mini_fstream.h[../include/mini_fstream.h] l.119|m:manpages/stdio/fseek.3.rst[fsetpos]||#
f:ftell|D:static inline long ftell(FILE *f);|d:lseek|l:../include/mini_fstream.h[../include/mini_fstream.h] l.107|m:manpages/stdio/fseek.3.rst[ftell]||#
f:fwrite|D:static inline size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *f);|d:write|l:../include/mini_fstream.h[../include/mini_fstream.h] l.92|m:manpages/stdio/fread.3.rst[fwrite]||#
f:getc|D:#define getc(F) fgetc(F)|d:read fileno|l:../include/fgetc.h[../include/fgetc.h] l.26|m:manpages/stdio/getc.3.rst[getc]||#
f:getchar|D:#define getchar() fgetc(0)|d:fileno read|l:../include/fgetc.h[../include/fgetc.h] l.29|m:manpages/stdio/getc.3.rst[getchar]||#
f:gets|D:#define gets(F) fgets(F,0xfffffff,stdin)|d:read fileno|l:../src/fgets.c[../src/fgets.c] l.27|m:manpages/stdio/fgets.3.rst[gets]||#
f:itoHEX|D:int itoHEX(int i,char* buf,int padding);|d:|l:../src/itohex.c[../src/itohex.c] l.65|o:convert a number to hexadecimal representation with big capitals.:+: the conversion assumes a size of 32bits for integers,:+: negative values are represented as they are stored internally.:+: ( -1 is 0xFFFFFFFF, -2 0xFFFFFFFE, ... )||#
f:itohex|D:int itohex(int i,char* buf,int padding);|d:|l:../src/itohex.c[../src/itohex.c] l.53|o:convert a number to hexadecimal representation.:+: the conversion assumes a size of 32bits for integers,:+: negative values are represented as they are stored internally.:+: ( -1 is 0xffffffff, -2 0xfffffffe, ... )||#
f:perror|D:void perror(const char *msg);|d:write errno strlen strerror fileno|l:../src/perror.c[../src/perror.c] l.4|m:manpages/string/strerror.3.rst[perror]||#
f:printf|D:#define printf(...) fprintf(stdout,__VA_ARGS__)|d:fileno write strlen|l:../include/mini_fstream.h[../include/mini_fstream.h] l.77|m:manpages/stdio/printf.3.rst[printf]||#
f:putc|D:#define putc(c,stream) fputc(c,stream)|d:fileno write|l:../include/fputc.h[../include/fputc.h] l.19|m:manpages/stdio/putc.3.rst[putc]||#
f:putchar|D:#define putchar(c) fputc(c,stdout)|d:fileno write|l:../include/fputc.h[../include/fputc.h] l.16|m:manpages/stdio/putc.3.rst[putchar]||#
f:puts|D:#define puts(msg) ( print(msg) + printl() )|d:strlen write|l:../include/prints.h[../include/prints.h] l.74|m:manpages/stdio/fputs.3.rst[puts]|o:write msg to stdout, append a newline. Needs strlen.||#
f:rewind|D:static inline void rewind( FILE *f );|d:lseek|l:../include/mini_fstream.h[../include/mini_fstream.h] l.142|m:manpages/stdio/fseek.3.rst[rewind]||#
f:setbuf|D:static void setbuf(FILE *stream, char *buf);|l:../include/mini_fstream.h[../include/mini_fstream.h] l.197|m:manpages/stdio/setbuf.3.rst[setbuf]|o:dummy function.:+: There is no buffering implemented for the streams yet.||#
f:setvbuf|D:static int setvbuf(FILE *stream, char *buf, int mode, size_t size);|l:../include/mini_fstream.h[../include/mini_fstream.h] l.202|m:manpages/stdio/setbuf.3.rst[setvbuf]|o:dummy function||#
f:sprintf|D:#define sprintf(str,...) snprintf( str, 4096,  __VA_ARGS__)|d:write strlen|l:../src/sprintf.c[../src/sprintf.c] l.26|m:manpages/stdio/printf.3.rst[sprintf]||#
f:ungetc|D:static int ungetc(int c, FILE *F);|l:../include/fgetc.h[../include/fgetc.h] l.35|m:manpages/stdio/ungetc.3.rst[ungetc]|o:pushes one char back to the stream.:+: Overwrites a previously pushed char:+: (conforming to the posix spec) ||#
f:vfprintf|D:#define vfprintf(...) fprintf(__VA_ARGS__)|d:fileno write strlen|l:../include/mini_fstream.h[../include/mini_fstream.h] l.86|m:manpages/stdio/printf.3.rst[vfprintf]||#
f:vsprintf|D:int vsprintf( char *buf, const char *fmt, ... );|d:0|l:../src/vsprintf.c[../src/vsprintf.c] l.9|m:manpages/stdio/printf.3.rst[vsprintf]|o:write fmt and arguments into buf:+: calls vsnprintf, :+: the size is limited to 4096 by default.||#
f:abort|D:void abort();|d:memcpy getpid write|l:../src/abort.c[../src/abort.c] l.3|m:manpages/stdlib/abort.3.rst[abort]||#
f:abs|D:static int abs(int i);|l:../include/math.h[../include/math.h] l.25|m:manpages/stdlib/abs.3.rst[abs]||#
f:atexit|D:static int atexit( functionp* func );|d:globals|l:../src/atexit.c[../src/atexit.c] l.7|m:manpages/stdlib/atexit.3.rst[atexit]|o:register functions, which are callen on exit in reverse order:+: the switch mini_atexit takes a optional number,:+: which defines the maximum numbers of functions to be registered.:+: (defaults to 8)||#
f:atoi|D:int atoi(const char *c);|l:../src/atoi.c[../src/atoi.c] l.3|m:manpages/stdlib/atoi.3.rst[atoi]||#
f:atol|D:long atol(const char *c);|l:../src/atol.c[../src/atol.c] l.3|m:manpages/stdlib/atol.3.rst[atol]||#
f:calloc|D:void* calloc(int size);|l:../src/calloc.c[../src/calloc.c] l.2|m:manpages/stdlib/memory.3.rst[calloc]||#
f:div|D:static div_t div(int numerator, int denominator);|l:../include/math.h[../include/math.h] l.8|m:manpages/stdlib/div.3.rst[div]||#
f:free|D:void free(void *p);|d:brk getbrk|l:../src/malloc.c[../src/malloc.c] l.146|m:manpages/stdlib/memory.3.rst[free]||#
f:getenv|D:char* getenv(const char* name);|d:environ|l:../src/getenv.c[../src/getenv.c] l.5|m:manpages/stdlib/getenv.3.rst[getenv]||#
f:labs|D:static long int labs(long int i);|l:../include/math.h[../include/math.h] l.30|m:manpages/stdlib/labs.3.rst[labs]||#
f:ldiv|D:static ldiv_t ldiv(long int numerator, long int denominator);|l:../include/math.h[../include/math.h] l.16|m:manpages/stdlib/ldiv.3.rst[ldiv]||#
f:malloc|D:void* malloc(int size);|d:0|l:../src/malloc.c[../src/malloc.c] l.126|m:manpages/stdlib/memory.3.rst[malloc]|o:0:+: Here we go.. with the .. well. :+: Fastes and smallest malloc/free combi ever. :+: Not the smartest.:+: Since it isn't exactly a memory allocation,:+: instead it (mis)uses the minilib buf.:+: Which is allocated by the kernel, and uses:+: either the bss section, or is allocated on the stack.:+: (option "globals_on_stack"):+::+: This is basically a linked list,:+: optimized for fast access, allocation of new elements, :+: and small memory overhead.:+: Albite the list structure might be hard to recognize.:+: It is not the right malloc, if you expect:+: many de- or reallocations.:+: And it obviously is not the right choose, when:+: expecting medium to big sized allocations. (> 1 page, here 4kB, as medium sized):+: :+: Here we use mbuf from top to bottom as stack.:+: 64 Bytes are left at the bottom as reserve.:+: Possibly we'd like to complain:+: about the lack of memory, before we exit.:+::+: ATM, the 'free' is really lazy. :+: It free's memory, but a real 'free' is only commited,:+: when all memory below a freed area is also freed.:+: Since the target of minilib atm are tiny tools, :+: this might be ok.:+: ;) but, as I told before - :+: probably you should look out for a proper malloc implementation.:+: It depends on your needs.:+::+: I'm not sure yet, :+: whether another implementation of free would be useful at all.:+: Overall, I'd really prefer keeping minilib tiny.:+::+: Reusing sparse freed memory areas also leads :+: to a whole bunch of complications.:+: cache misses, searching complexity,:+: storage overhead, potentially page faults,:+: just to name a few.:+::+: I'm not sure whether it's worth it.:+::+: And the existing malloc implementations :+: out there are countless.:+::+: ;) It's sometimes smarter to stay special,:+: albite in this case this means the opposite.:+: /misc:+::+: The memory layout looks like this::+: mlgl->ibuf and mlgl->mbuf do point to the same address range.:+: mlgl->ibuf is provided for alignment and faster access to the int values.:+::+: flag prev free is the first bit in size. (0x8000, eq 1000 0000 0000 0000 binary when free), :+: (mbufsize):+: ```:+:      size  data  size    mini_buf size:+:      8008dataxxxx0004data8000|:+:      ----========----====----|:+::+: also, when free space is in between two areas:+: :+: 8004data8008  free  0004data8000|:+: ----====----________----====----|:+::+: ```:+: the free space is only freed, :+: when all areas below (left) have been free'd as well.:+::+: Memory is allocated from right to left, :+: meaning from top to down.||#
f:qsort|D:void qsort(void  *base,	size_t nel,	size_t width,	int (*comp)(const void *, const void *));|l:../src/qsort.c[../src/qsort.c] l.59|m:manpages/stdlib/qsort.3.rst[qsort]|o:(quick) shell sort routine:+: following the tradition, this isn't exactly a quicksort algorithm,:+: albite named quicksort.:+: It is a shell sort implementation, originally done by Ray Gardner, 5/90;:+: which in turn I did find within musl.||#
f:rand|D:unsigned int rand();|l:../src/rand.c[../src/rand.c] l.15|m:manpages/stdlib/rand.3.rst[rand]||#
f:realloc|D:void* realloc(void *p, int size);|d:brk 0 getbrk|l:../src/malloc.c[../src/malloc.c] l.210|m:manpages/stdlib/memory.3.rst[realloc]||#
f:srand|D:void srand( unsigned int i );|l:../src/rand.c[../src/rand.c] l.7|m:manpages/stdlib/rand.3.rst[srand]||#
f:strtol|D:long int strtol(const char *c, const char **endp, int base);|l:../src/strtol.c[../src/strtol.c] l.5|m:manpages/stdlib/strtol.3.rst[strtol]|o:conversion:+: doesn't check for overflow(!)||#
f:system|D:int system( const char* command );|d:wait4 execve vfork write environ|l:../src/system.c[../src/system.c] l.4|m:manpages/stdlib/system.3.rst[system]||#
f:_strcasecmp|D:int _strcasecmp(const char*c1,const char*c2,int len);|d:tolower|l:../src/strcmp.c[../src/strcmp.c] l.27||#
f:_strcmp|D:int _strcmp(const char*c1,const char*c2,int len);|l:../src/strcmp.c[../src/strcmp.c] l.10||#
f:memcmp|D:int memcmp(const void* c1,const void* c2,int len);|d:0|l:../src/strcmp.c[../src/strcmp.c] l.84|m:manpages/string/memcmp.3.rst[memcmp]||#
f:memcpy|D:void *memcpy( void *d, const void *s, int n );|l:../src/memcpy.c[../src/memcpy.c] l.4|m:manpages/string/memcpy.3.rst[memcpy]||#
f:memmove|D:void* memmove(void *dest, const void *src, int n);|l:../src/memmove.c[../src/memmove.c] l.3|m:manpages/string/memmove.3.rst[memmove]||#
f:memset|D:void *memset( void *s, int c, int n);|l:../src/memset.c[../src/memset.c] l.3|m:manpages/string/memset.3.rst[memset]||#
f:strcasecmp|D:int strcasecmp(const char*c1,const char*c2);|d:|l:../src/strcmp.c[../src/strcmp.c] l.48|m:manpages/string/string.3.rst[strcasecmp]||#
f:strcat|D:char *strcat(char *dest, const char *src );|d:strlen|l:../src/strcat.c[../src/strcat.c] l.5|m:manpages/string/string.3.rst[strcat]||#
f:strchr|D:char *strchr(const char *s, int c);|d:strchrnul|l:../src/strchr.c[../src/strchr.c] l.20|m:manpages/string/string.3.rst[strchr]||#
f:strchrnul|D:char *strchrnul(const char *s, int c);|l:../src/strchr.c[../src/strchr.c] l.7|m:manpages/string/strchr.3.rst[strchrnul]||#
f:strcmp|D:int strcmp(const char*c1,const char*c2);|d:|l:../src/strcmp.c[../src/strcmp.c] l.67|m:manpages/string/string.3.rst[strcmp]||#
f:strcpy|D:char *strcpy(char *dest, const char *src);|l:../src/strcpy.c[../src/strcpy.c] l.3|m:manpages/string/string.3.rst[strcpy]||#
f:strdup|D:char *strdup(const char *source);|d:strcpy 0 strlen|l:../src/strdup.c[../src/strdup.c] l.7|m:manpages/string/strdup.3.rst[strdup]||#
f:strerror|D:static char* strerror( int errnum );|l:../src/strerror.c[../src/strerror.c] l.7|m:manpages/string/string.3.rst[strerror]||#
f:strlen|D:int strlen(const char*str);|l:../src/strlen.c[../src/strlen.c] l.4|m:manpages/string/strlen.3.rst[strlen]||#
f:strncasecmp|D:int strncasecmp(const char*c1,const char*c2,int len);|d:|l:../src/strcmp.c[../src/strcmp.c] l.56|m:manpages/string/string.3.rst[strncasecmp]||#
f:strncmp|D:int strncmp(const char*c1,const char*c2,int len);|d:|l:../src/strcmp.c[../src/strcmp.c] l.75|m:manpages/string/string.3.rst[strncmp]||#
f:strncpy|D:char *strncpy(char *dest, const char *src, int n);|l:../src/strncpy.c[../src/strncpy.c] l.7|m:manpages/string/string.3.rst[strncpy]|o:copy max n chars from src to dest, :+: write 0's up to src[n] when len of dest < n:+: Please note strlcpy (borrowed from freebsd), :+: which does the same,:+: but doesn't pad src with 0's.||#
f:strrchr|D:char *strrchr(const char *s, int c);|d:strchrnul|l:../src/strchr.c[../src/strchr.c] l.36|m:manpages/string/string.3.rst[strrchr]||#
f:strstr|D:char* strstr(const char *big, const char *little);|l:../src/strstr.c[../src/strstr.c] l.3|m:manpages/string/strstr.3.rst[strstr]||#
f:wait|D:pid_t wait(int *wstatus);|d:wait4|l:../src/wait.c[../src/wait.c] l.8|m:manpages/sys/wait.2.rst[wait]||#
f:waitpid|D:pid_t waitpid(pid_t pid, int *wstatus, int options);|d:wait4|l:../src/wait.c[../src/wait.c] l.16|m:manpages/sys/wait.2.rst[waitpid]||#
f:time|k|D:int time(unsigned int *a1 )|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.221|m:manpages/gen/time.3.rst[time]||#
f:access|k|D:int access( const char *filename, int mode)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.161|m:manpages/sys/access.2.rst[access]||#
f:chdir|k|D:int chdir(const char* path)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.111|m:manpages/sys/chdir.2.rst[chdir]||#
f:chown|k|D:int chown( const char *filename, uid_t user, gid_t group)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.185|m:manpages/sys/chown.2.rst[chown]||#
f:chroot|k|D:int chroot( const char *filename)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.141|m:manpages/sys/chroot.2.rst[chroot]||#
f:close|k|D:int close( int fd )|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.100|m:manpages/sys/close.2.rst[close]||#
f:dup|k|D:int dup(int fd)		|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.116|m:manpages/sys/dup.2.rst[dup]||#
f:dup2|k|D:int dup2(int oldfd, int newfd)		|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.117|m:manpages/sys/dup.2.rst[dup2]||#
f:execl|D:static int execl(const char *pathname, const char* arg0,... );|d:execve environ|l:../src/execl.c[../src/execl.c] l.6|m:manpages/gen/exec.3.rst[execl]||#
f:execv|D:static inline int execv(const char *pathname, char *const argv[]);|d:execve environ|l:../src/execvp.c[../src/execvp.c] l.9|m:manpages/gen/exec.3.rst[execv]||#
f:execve|k|D:int execve( const char *filename,  char* const* argv, char* const* envp)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.127|m:manpages/sys/execve.2.rst[execve]||#
f:execvp|D:static inline int execvp(const char *file, char *const argv[]);|d:execve environ access|l:../src/execvp.c[../src/execvp.c] l.58|m:manpages/gen/exec.3.rst[execvp]||#
f:execvpe|D:static int execvpe(const char *file, char *const argv[], char *const envp[]);|d:execve access environ|l:../src/execvp.c[../src/execvp.c] l.18|o:When invoked with a filename, starting with "." or "/",:+: interprets this as absolute path. (calls execve with the pathname):+: Looks for file in the PATH environment, othwerise.||#
f:fork|k|D:int DEF_syscall(fork,0)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.131|m:manpages/sys/fork.2.rst[fork]||#
f:fsync|k|D:int fsync(int a1 )|l:../include/lseek.h[../include/lseek.h] l.22|m:manpages/sys/fsync.2.rst[fsync]||#
f:ftruncate|k|D:int ftruncate(unsigned int a1, unsigned int a2 )|l:../include/lseek.h[../include/lseek.h] l.21|m:manpages/sys/truncate.2.rst[ftruncate]||#
f:getgid|k|D:int DEF_syscall(getgid,0)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.189|m:manpages/sys/getgid.2.rst[getgid]||#
f:getgroups|D:int getgroups(int maxgroups, int *list);|d:passwdfile_open token_s grent pwent open mmap setpwent setgrent write token_i|l:../src/userdb/getgroups.c[../src/userdb/getgroups.c] l.8|m:manpages/sys/getgroups.2.rst[getgroups]|o:get the groups of the calling process:+: does not necessarily contain the primary group,:+: which is given in the passwd entry.:+: This function calls internally setgrent() and getgrent();:+: therefore any iteration with getgrent will be resetted.||#
f:getpgrp|k|D:int DEF_syscall(getpgrp,0)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.190|m:manpages/sys/getpgrp.2.rst[getpgrp]||#
f:getpid|k|D:int DEF_syscall(getpid,0 )|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.145|m:manpages/sys/getpid.2.rst[getpid]||#
f:getuid|k|D:int DEF_syscall(getuid,0)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.191|m:manpages/sys/getuid.2.rst[getuid]||#
f:isatty|D:int isatty(int fd);|d:ioctl|l:../src/isatty.c[../src/isatty.c] l.5|m:manpages/gen/ttyname.3.rst[isatty]||#
f:link|k|D:int link( const char *oldname, const char *newname)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.122|m:manpages/sys/link.2.rst[link]||#
f:lseek|k|D:int lseek(unsigned int a1, int a2, int a3 )|l:../include/lseek.h[../include/lseek.h] l.19|m:manpages/sys/lseek.2.rst[lseek]||#
f:mkdir|k|D:int mkdir( const char *pathname, int mode)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.158|m:manpages/sys/mkdir.2.rst[mkdir]||#
f:open|D:int volatile open( const char *s, int flags, ... );|l:../src/open.c[../src/open.c] l.19|m:manpages/sys/open.2.rst[open]|o:open or create a file.:+: warning: when using the flag O_CREAT,:+: file permission flags have to be given:+: as third argument. Otherwise file permission:+: flags will be random. (I still do not know, what :+: the flag showing up as "-T" means..)||#
f:pipe|k|D:int pipe( int *filedes)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.208|m:manpages/sys/pipe.2.rst[pipe]||#
f:read|k|D:int read( int fd, void *buf, int len )|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.101|m:manpages/sys/read.2.rst[read]||#
f:rename|k|D:int rename( const char* oldpath, const char* newpath )|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.106|m:manpages/sys/rename.2.rst[rename]||#
f:rmdir|k|D:int rmdir( const char *pathname)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.159|m:manpages/sys/rmdir.2.rst[rmdir]||#
f:select|D:static int volatile __attribute__((optimize("O0"))) select(int fd, volatile fd_set* readfd, volatile fd_set *writefd, volatile fd_set *exceptfd, volatile struct timeval *wait);|l:../include/select.h[../include/select.h] l.9|m:manpages/sys/select.2.rst[select]||#
f:setgid|k|D:int setgid( gid_t gid)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.147|m:manpages/sys/setuid.2.rst[setgid]||#
f:setpgid|k|D:int setpgid( pid_t pid, pid_t pgid)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.188|m:manpages/sys/setpgid.2.rst[setpgid]||#
f:setsid|k|D:int DEF_syscall(setsid,0 )|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.146|m:manpages/sys/setsid.2.rst[setsid]||#
f:setuid|k|D:int setuid( uid_t uid)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.148|m:manpages/sys/setuid.2.rst[setuid]||#
f:sleep|D:unsigned int volatile sleep(unsigned int seconds);|l:../src/sleep.c[../src/sleep.c] l.10|m:manpages/gen/sleep.3.rst[sleep]|o:nonconformant sleep:+: TODO: ignore blocked signals, sigchld||#
f:tcgetattr|D:static inline int __attribute__((always_inline)) tcgetattr(int fd, struct termios *io);|d:ioctl|l:../include/tcgetattr.h[../include/tcgetattr.h] l.21|m:manpages/gen/tcsetattr.3.rst[tcgetattr]||#
f:tcsetattr|D:static inline int __attribute__((always_inline)) tcsetattr(int fd, int opt, const struct termios *io);|d:ioctl|l:../include/tcsetattr.h[../include/tcsetattr.h] l.20|m:manpages/gen/tcsetattr.3.rst[tcsetattr]||#
f:unlink|k|D:int unlink( const char* path)|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.107|m:manpages/sys/unlink.2.rst[unlink]||#
f:usleep|D:unsigned int volatile usleep(unsigned int useconds);|l:../src/sleep.c[../src/sleep.c] l.31|m:manpages/gen/usleep.3.rst[usleep]|o:nonconformant usleep. :+: Sleep useconds.:+: I just hope, noone relies on an exact sleep time.:+: which isn't possible without a real time os, anyways.:+: When for whatever reason you'd need nanoseconds exact times,:+: best shot might be a spinloop, and looking for cpu ticks.:+::+: TODO: ignore blocked signals, sigchld||#
f:write|k|D:int write(int fd,const void *buf, int len )|l:../include/syscall_stubs.h[../include/syscall_stubs.h] l.102|m:manpages/sys/write.2.rst[write]||#

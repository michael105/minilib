Seems, intuitively I got some things right, from the beginning.

I should possibly point out,
although I'm quite firm and experienced with programming,
I still have to learn about memory layout and executable loading.
So your remarks are welcome, just open an issue, please.

Anyways, I'm trying to pin here, why I think the concept of minilib is good.

(As well as where problems might be)

* Executable stack.

  Minilib doesn't need an executable stack.
	I'm still fiddling around, there are some traps hidden in the linking process.
	But, according to several sources, the lack of the (executable) stack is a good thing,
	in the matter of security. 


* No dynamic bindings

  No libinjection possible.


* Small footprint

  - It's not only about performance.
	  Although the gain is big here. 
		Cache misses and page faults can be avoided by the property of small tools,
		being loaded at once and having all executable code in the same memory region

	- You can read through the minilib, as well as through the created binaries.
		That's quite a good point, also for security.
		You can be sure, where doesn't something hide,
		either in the huge binary of e.g. even an hello world (static linked with gcc 500kB),
		or within any of the dynamically loaded libraries

	  TODO: Disassembly is not with every tool possible. 
		( Due to the lack of elf section headers )
		Pointing out, how I got the binaries disassembled 


* BSD License

  I got some headache about the different Licenses.
	Finally I decided to go with the 3 clause BSD-License, 
	with the addition, that the file "NOTICE" has to be included in distributions.
	The BSD License is short, easy to read and allows e.g. static linking and distributing
	of the binaries, without the need to open the source of the whole binary.


 implemented functions
=======================

short ref, links to source files.

Only functions defined are going to be built.

To define them, either do (for, e.g. puts) `#define mini_puts`
before you include minilib.h

Or, use the config script.: `mini_puts`

Some functions define other functions, these will be listed in the line,
starting with `Define:`


An example, using the scripting config, is given below:
(miniputs.c)
----
#if 0
mini_start
mini_puts

LDSCRIPT text_and_bss
INCLUDESRC
shrinkelf

return
#endif

int main(){
  puts("Hello, world!");
  return(0);
}
----

compile with ./mini-gcc --config miniputs.c -o miniputs miniputs.c

(what compiles to an annoying size of 251 Bytes here. Something again bloats.
replacing the puts with writes, there still are 208 Bytes. This used to
be 151 Bytes. Have to sort this out.)

:toc:






 declarations.h
----------------

chmod::

  chmod( const char *filename, mode_t mode)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.187) manpage: link:manpages/sys/chmod.2.rst[chmod] +


dup3::

  dup3(int oldfd, int newfd, int flags)		
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.114) manpage: link:manpages/gen/dup3.3.rst[dup3] +


execveat::

  execveat( int dirfd, const char *filename,  char* const* argv, char* const* envp, int flags)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.153)  +


fchmod::

  fchmod( unsigned int fd, mode_t mode)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.110) manpage: link:manpages/sys/chmod.2.rst[fchmod] +


fchown::

  fchown( unsigned int fd, uid_t user, gid_t group)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.109) manpage: link:manpages/sys/chown.2.rst[fchown] +


fcntl::

  fcntl( unsigned int fd, unsigned int cmd, unsigned long arg)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.158) manpage: link:manpages/sys/fcntl.2.rst[fcntl] +


fstat::

  fstat(int fd,struct stat* statbuf)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.105) manpage: link:manpages/sys/stat.2.rst[fstat] +


getcwd::

  getcwd( char *buf,  unsigned long size)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.116) manpage: link:manpages/gen/getcwd.3.rst[getcwd] +


getdents::

  getdents( unsigned int fd, struct dirent *direntry, unsigned int count )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.100) manpage: link:manpages/sys/getdirentries.2.rst[getdents] +


getitimer::

  getitimer( int which,  struct itimerval *value)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.201) manpage: link:manpages/sys/getitimer.2.rst[getitimer] +


getppid::

  DEF_syscall(getppid,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.190) manpage: link:manpages/sys/getpid.2.rst[getppid] +


gettimeofday::

  gettimeofday( struct timeval *a1, struct timezone *a2)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.132) manpage: link:manpages/sys/gettimeofday.2.rst[gettimeofday] +


kill::

  kill( pid_t pid,  int sig)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.125) manpage: link:manpages/sys/kill.2.rst[kill] +


memfd_create::

  memfd_create( const char  *uname_ptr,  unsigned int flags)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.170)  +


mknod::

  mknod( const char *filename,  umode_t mode,  unsigned dev)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.196) manpage: link:manpages/sys/mknod.2.rst[mknod] +


mount::

  mount( char *dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.164) manpage: link:manpages/sys/mount.2.rst[mount] +


mprotect::

  mprotect( POINTER *a1, POINTER a2, int a3 )
 +
 Returns: *a1 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.183) manpage: link:manpages/sys/mprotect.2.rst[mprotect] +


munmap::

  munmap( unsigned long addr,  size_t len)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.198) manpage: link:manpages/sys/munmap.2.rst[munmap] +


nanosleep::

  nanosleep( struct timespec *rqtp, struct timespec *rmtp)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.131) manpage: link:manpages/sys/nanosleep.2.rst[nanosleep] +


pivot_root::

  pivot_root( const char *new_root,  const char *put_old)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.138)  +


readahead::

  readahead( int fd,  loff_t offset,  size_t count)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.194)  +


reboot::

  reboot( int magic1,  int magic2,  unsigned int cmd,  void *arg)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.162) manpage: link:manpages/sys/reboot.2.rst[reboot] +


rt_sigaction::

  rt_sigaction( int sig,  const struct sigaction *act,  struct sigaction *oact,  size_t sigsetsize)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.134)  +


rt_sigprocmask::

  rt_sigprocmask( int how,  sigset_t *nset,  sigset_t *oset,  size_t sigsetsize)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.166)  +


rt_sigreturn::

  rt_sigreturn( unsigned long __unused)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.135)  +


sendfile::

  sendfile( int out_fd,  int in_fd,  off_t *offset,  size_t count)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.161) manpage: link:manpages/sys/sendfile.2.rst[sendfile] +


setgroups::

  setgroups( int gidsetsize,  gid_t *grouplist)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.178) manpage: link:manpages/sys/setgroups.2.rst[setgroups] +


setitimer::

  setitimer( int which,  struct itimerval *value,  struct itimerval *ovalue)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.200) manpage: link:manpages/sys/getitimer.2.rst[setitimer] +


splice::

  splice( int fd_in,  loff_t *off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.175)  +


stat::

  stat(const char* filename,struct stat* statbuf)		
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.106) manpage: link:manpages/sys/stat.2.rst[stat] +


symlink::

  symlink( const char *oldname,  const char *newname)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.119) manpage: link:manpages/sys/symlink.2.rst[symlink] +


sync::

  DEF_syscall(sync,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.120) manpage: link:manpages/sys/sync.2.rst[sync] +


umask::

  umask( int mask)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.186) manpage: link:manpages/sys/umask.2.rst[umask] +


umount2::

  umount2( const char *mountpoint, int flags) 
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.160)  +


uname::

  uname(struct old_utsname *name )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.148) manpage: link:manpages/gen/uname.3.rst[uname] +


utime::

  utime( const char *filename, struct utimbuf *times)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.189) manpage: link:manpages/gen/utime.3.rst[utime] +


vfork::

  DEF_syscall(vfork,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.128) manpage: link:manpages/sys/vfork.2.rst[vfork] +


vhangup::

  DEF_syscall(vhangup,0 )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.146)  +


wait4::

  wait4( pid_t upid,  int *stat_addr,  int options,  struct rusage *ru)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.156) manpage: link:manpages/sys/wait.2.rst[wait4] +




 dirent.h
----------

closedir::

  int closedir(DIR *dir);
 +
  Defines: getbrk brk +
 (link:../src/dirent/closedir.c[../src/dirent/closedir.c] l.6) manpage: link:manpages/gen/directory.3.rst[closedir] +


opendir::

  static DIR *opendir(const char *name );
 +
  Defines: open brk close dirbuf write +
 (link:../src/dirent/opendir.c[../src/dirent/opendir.c] l.24) manpage: link:manpages/gen/directory.3.rst[opendir] +


readdir::

  struct dirent *readdir(DIR *dir);
 +
  Defines: getdents dirbuf +
 (link:../src/dirent/readdir.c[../src/dirent/readdir.c] l.10) manpage: link:manpages/gen/directory.3.rst[readdir] +
read a directory. +
  return the next dirent, or 0, if the end is reached. +
  return 0 on error and set errno, +
  if mini_errno is not defined, return -errno on error +
 

rewinddir::

  void rewinddir(DIR *dir);
 +
  (link:../src/dirent/rewinddir.c[../src/dirent/rewinddir.c] l.2) manpage: link:manpages/gen/directory.3.rst[rewinddir] +


scandir::

  int scandir(const char *path, struct dirent **listing[], int (*fp_select)(const struct dirent *),	int (*cmp)(const struct dirent **, const struct dirent **));
 +
  Defines: sbrk write getbrk errno memcpy dirbuf brk seterrno qsort open +
 (link:../src/dirent/scandir.c[../src/dirent/scandir.c] l.35) manpage: link:manpages/gen/scandir.3.rst[scandir] +
list files and dirs in a directory +
  +
  This implementation uses malloc_brk() for the dynamic allocation +
  of the listing, and tries to do as less copies as possible. +
  The dynamically allocated space for the result list (**listing[]) +
  is guaranteed to be at one continuous memory location. +
  +
  if the select callback is 0, meaning all entries should be returned, +
  There are no copies done at all,  +
  besides the copying from kernelspace to userspace. +
  +
  To free the space, allocated for the listing, +
  either call free_brk(), +
  when no other allocations via malloc_brk took place. +
  +
  Or save the brk before you call scandir, +
  and restore it after the call. +
  (e.g.) +
  long savebrk=getbrk(); +
  int ret=scandir(...); +
  brk(savebrk); +
  Freeing single list entries might give unexpected results. +
  +
  returns the number of the read entries, +
  or the negative errno on error. +
 

seekdir::

  void seekdir(DIR *dir, long off);
 +
  (link:../src/dirent/seekdir.c[../src/dirent/seekdir.c] l.2) manpage: link:manpages/gen/directory.3.rst[seekdir] +


telldir::

  long telldir(DIR *dir);
 +
  (link:../src/dirent/telldir.c[../src/dirent/telldir.c] l.2) manpage: link:manpages/gen/directory.3.rst[telldir] +




 fcntl.h
---------

creat::

  int volatile creat( const char *s, int mode );
 +
  Defines: open +
 (link:../src/open.c[../src/open.c] l.36) manpage: link:manpages/compat-43/creat.2.rst[creat] +


mkfifo::

  static int mkfifo( const char* path, mode_t mode );
 +
  (link:../include/mkfifo.h[../include/mkfifo.h] l.4) manpage: link:manpages/sys/mkfifo.2.rst[mkfifo] +




 ioctl.h
---------

ioctl::

  int volatile  __attribute__((optimize("O0"))) ioctl( int fd, unsigned long int request, ... );
 +
  (link:../src/ioctl.c[../src/ioctl.c] l.11) manpage: link:manpages/sys/ioctl.2.rst[ioctl] +




 mini_addons.h
---------------

_itobin::

  int _itobin(int i, char*buf, int prec, int groups );
 +
  (link:../src/itobin.c[../src/itobin.c] l.8)  +


_mprints::

  #define _mprints(...) dprints(STDOUT_FILENO, __VA_ARGS__)
 +
  Defines: write +
 (link:../src/prints.c[../src/prints.c] l.69)  +


basename::

  char *basename(char *path);
 +
  Defines: strlen +
 (link:../src/basename.c[../src/basename.c] l.29) manpage: link:manpages/gen/basename.3.rst[basename] +


brk::

  static int brk( const void* addr );
 +
  (link:../src/brk.c[../src/brk.c] l.19) manpage: link:manpages/sys/brk.2.rst[brk] +
set the brk to addr +
  return 0 on success. +
  conformant brk, when mini_errno is defined return -1 and set errno. +
  if errno isn't available, +
  returns the negative errno value on error +
 

def::

  #define SETOPT_short( opts, option ) (;
 +
  (link:../macros/getoptm.h[../macros/getoptm.h] l.52)  +
Set a option flag(s) (bit(s))  manually. +
 		param options: e.g. just a, or ( a+h+l) to check for several flags at once +
 

dirbuf::

  
 +
  (link:../include/dirent.h[../include/dirent.h] l.7)  +
the switch for defining the dirbuf. +
  used internally +
 

dirbufsize ::

  #ifndef mini_dirbufsize
 +
  (link:../include/dirent.h[../include/dirent.h] l.22)  +
the dir stream bufsize +
  The size of the buffer can be changed by setting mini_dirbufsize +
  to it's size in Bytes. (default 2048) +
  The buffer is allocated via malloc, +
  therefore mini_buf must be set to a value greater than dirbufsize +
 

dirfd::

  int dirfd(DIR *d);
 +
  (link:../src/dirent/dirfd.c[../src/dirent/dirfd.c] l.2) manpage: link:manpages/gen/directory.3.rst[dirfd] +


dirname::

  char *dirname(char *s);
 +
  Defines: strlen +
 (link:../src/dirname.c[../src/dirname.c] l.8) manpage: link:manpages/gen/dirname.3.rst[dirname] +


djb2_hash::

  unsigned long djb2_hash(const unsigned char *str);
 +
  (link:../src/hashes.c[../src/hashes.c] l.10)  +
hashes, from d.j.Bernstein +
  (http://www.cse.yorku.ca/~oz/hash.html) +
  I've tested djb2_hash, and it gives quite good results. +
  But I'm sure, Bernstein did think and test his algorithm sincerely. +
  When combining djb2_hash and sdbm_hash, the probability of collisions +
  might tend to zero. +
  Me I'm going this way. I guess. I might check djb2_hash for collisions within a space of around 8 digits. +
 

dprintf::

  int dprintf( int fd, const char *fmt, ... );
 +
  Defines: write +
 (link:../src/dprintf.c[../src/dprintf.c] l.5) manpage: link:manpages/stdio/printf.3.rst[dprintf] +


dprints::

  int dprints(int fd, const char *msg,...);
 +
  Defines: write +
 (link:../src/prints.c[../src/prints.c] l.48)  +


dtodec::

  int dtodec(double d, char* buf, int precision);
 +
  Defines: uitodec +
 (link:../src/dtodec.c[../src/dtodec.c] l.10)  +


eprint::

  #define eprint(str) write(STDERR_FILENO,str,strlen(str))
 +
  Defines: write strlen +
 (link:../include/prints.h[../include/prints.h] l.42)  +
write str to stderr. Needs strlen +
 

eprintfs::

  #define eprintfs(fmt,...) fprintfs(stderr, fmt, __VA_ARGS__)
 +
  Defines: write strlen fileno +
 (link:../include/prints.h[../include/prints.h] l.90)  +
write str to stderr.  +
  only format %s is recognized +
 

eprintl::

  #define eprintl() write(STDERR_FILENO,"\n",1)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.67)  +
write a newline to stderr +
 

eprints::

  #define eprints(...) dprints(STDERR_FILENO,__VA_ARGS__,0)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.17)  +
print the string(s) supplied as arg(s) to stdout +
 

eputs::

  #define eputs(msg) ( eprint(msg) + eprintl() )
 +
  Defines: strlen write +
 (link:../include/prints.h[../include/prints.h] l.77)  +
write msg to stderr, append a newline. Needs strlen. +
 

errno_str::

  static char *errno_str(int err);
 +
  (link:../src/errno_str.c[../src/errno_str.c] l.7)  +
convert errno to str, with 3 chars length +
  ending the string (global)  +
  with two \0\0, when errno<100 +
  errnum must be <200. +
 

ewrites::

  #define ewrites(str) write(STDERR_FILENO,str,sizeof(str))
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.52)  +
write the constant str to stderr. Computes length with sizeof(str) at compile time. +
 

exit_errno::

  void exit_errno( int errnum );
 +
  Defines: execve exit write errno_str +
 (link:../src/exit_errno.c[../src/exit_errno.c] l.17)  +
exit, and execute /bin/errno +
  this is intended to give a error message for the  +
  given errno num. +
  Instead of having the error messages compiled  +
  into each binary, they can stay within one executable, "errno" +
  This spares about 4kB, but needs errno installed to /bin/errno +
  It's the drawback of not having a shared library, +
  where all executables would share the same errno messages +
  in memory. +
  On the other hand, a shared library would need to be installed +
  as well. +
  The supplied errno can be negative, +
  the absolute value is supplied to errno. +
 

ext_match::

  int ext_match(const char *text, const char *re);
 +
  (link:../src/ext_match.c[../src/ext_match.c] l.16)  +
simple regex engine. +
  matches: * for every count of any char +
  ? for 1 char +
  backslash: escape *,?, and backslash itself. +
  \d - digit +
  \D - nondigit +
  \s - space +
  \S - nonspace +
  \w - word character ( defined as ascii 32-126,160-255 ) +
  \W - nonword character ( defined as ascii 0-31,127-159 ) +
  +
  (memo) When the regex ist defined as C string, +
  a backslash has to be defined as double backslash +
  in the source code. +
 

fexecve::

  static inline int fexecve(int fd, char *const argv[], char *const envp[]);
 +
  (link:../include/fexecve.h[../include/fexecve.h] l.3) manpage: link:manpages/sys/execve.2.rst[fexecve] +


fexecveat::

  static inline int fexecveat(int fd, char *const argv[], char *const envp[]);
 +
  (link:../include/fexecveat.h[../include/fexecveat.h] l.3)  +


fprintfs::

  int fprintfs( FILE* F, char *fmt, ...);
 +
  Defines: strlen write fileno +
 (link:../src/fprintfs.c[../src/fprintfs.c] l.10)  +
prints formatted to the stream F.only %s and %c are recognized.no mini_buf needed, so using fprintfs instead of fprintf can save some sections / bytes. +
 

fprints::

  #define fprints(F,str) write(fileno(F),str,strlen(str))
 +
  Defines: fileno strlen write +
 (link:../include/prints.h[../include/prints.h] l.24)  +
print the string(s) supplied as arg(s) to stream +
 

fwrites::

  #define fwrites(fd,str) write(fd,str,sizeof(str))
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.58)  +
write the constant str to fd. Computes length with sizeof(str) at compile time. +
 

getbrk::

  static long getbrk();
 +
  (link:../src/brk.c[../src/brk.c] l.39)  +
get the current brk +
  does either a syscall to brk, +
  or returns the globally saved var +
 

grantpt::

  int grantpt(int fd);
 +
  (link:../src/pty.c[../src/pty.c] l.13) manpage: link:manpages/stdlib/ptsname.3.rst[grantpt] +


itobin::

  #define itobin(A,B,...) _itobin(A,B,VARARG(SHIFT(__VA_ARGS__),0), VARARG(SHIFT(ARG( __VA_ARGS__ )),32) )
 +
  Defines:  +
 (link:../src/itobin.c[../src/itobin.c] l.41)  +


itodec::

  int itodec(int i, char *buf, int prec, char limiter );
 +
  Defines: uitodec +
 (link:../src/itodec.c[../src/itodec.c] l.116)  +


itooct::

  int itooct(int i, char *buf);
 +
  (link:../src/itooct.c[../src/itooct.c] l.4)  +
convert int to octal +
  return the number of chars written. +
 

ltodec::

  int ltodec(long i, char *buf, int prec, char limiter );
 +
  (link:../src/ltodec.c[../src/ltodec.c] l.75)  +


macro::

  static void __attribute__((noipa,cold)) optimization_fence(void*p){}
 +
  (link:../include/minilib_global.h[../include/minilib_global.h] l.90)  +
prevent optimizations. +
  cast a var to void*, and calling this, +
  leaves the compiler unknown on what he can strip. +
  (noipa) means the compiler doesn't know, what the function itself does. +
  (the function does nothing, but don't tell that gcc, please..) +
  therefore, everything used as parameter to this function, +
  will be calculated, defined, and so on before. +
  It's used for the globals,  +
  shich are pushed within _start onto the stack. +
  since _start itself only provides a global pointer, +
  and initialitzes some of the globals, +
  but doesn't use them again, +
  this construction is needed. +
  more funnily, the function will never be called. +
  It's past the asm inline syscall to exit. +
  But again, luckily gcc doesn't know. +
  All other options, like having the globals volatile,  +
  setting the optimization flag of _start to 0,  +
  having a volatile asm call with the globals as param, and so on, +
  have been useless. All after all, seems to me, ai has it's restrictions. +
 

match::

  int match(const char *text, const char *re);
 +
  (link:../src/match.c[../src/match.c] l.10)  +
simple regex engine. +
  matches: * for every count of any char +
  ? for 1 char +
  backslash: escape *,?, and backslash itself. +
  +
  (memo) When the regex ist defined as C string, +
  a backslash has to be defined as double backslash +
  in the source code. +
 

memfrob::

  void* memfrob(void* s, unsigned int len);
 +
  (link:../src/memfrob.c[../src/memfrob.c] l.3)  +


mmap::

  static void* __attribute__((optimize("O0"))) mmap(void* addr,  size_t len,  int prot,  int flags,  int fd,  off_t off);
 +
  (link:../src/mmap.c[../src/mmap.c] l.8) manpage: link:manpages/sys/mmap.2.rst[mmap] +
mmap wrapper +
  address length is rounded up to a multiple of pagesize (4096 Bytes here) +
  for the description, please look up the according manpage +
  errno is only set, when mini_errno is defined +
  if not, on error the negative errno value is returned. +
  (e.g. -22 for "invalid argument") +
 

mremap::

  static void* volatile __attribute__((optimize("O0"))) mremap(void* addr, size_t old_len, size_t new_len, int flags, void* new_addr);
 +
  (link:../include/mremap.h[../include/mremap.h] l.4)  +


opendirp::

  static DIR *opendirp(const char *name, DIR *dir);
 +
  Defines: close brk dirbuf open +
 (link:../src/dirent/opendir.c[../src/dirent/opendir.c] l.10)  +


posix_openpt::

  int posix_openpt(int flags);
 +
  Defines: open +
 (link:../src/pty.c[../src/pty.c] l.8) manpage: link:manpages/sys/posix_openpt.2.rst[posix_openpt] +


print::

  #define print(str) write(STDOUT_FILENO,str,strlen(str))
 +
  Defines: strlen write +
 (link:../include/prints.h[../include/prints.h] l.38)  +
write str to stdout. Needs strlen +
 

printfs::

  #define printfs(fmt,...) fprintfs(stdout, fmt, __VA_ARGS__)
 +
  Defines: fileno strlen write +
 (link:../include/prints.h[../include/prints.h] l.84)  +
write str to stdout.  +
  only format %s is recognized +
 

printl::

  #define printl() write(STDOUT_FILENO,"\n",1)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.63)  +
write a newline to stdout +
 

prints::

  #define prints(...) _mprints(__VA_ARGS__,0)
 +
  Defines:  +
 (link:../include/prints.h[../include/prints.h] l.11)  +
print the string(s) supplied as arg(s) to stdout +
 

printsl::

  #define printsl(...) _mprints(__VA_ARGS__,"\n",0)
 +
  Defines:  +
 (link:../include/prints.h[../include/prints.h] l.32)  +
print the string(s) supplied as arg(s) and newline to stdout +
 

ptsname::

  char *ptsname(int fd);
 +
  Defines: write ioctl open uitodec +
 (link:../src/pty.c[../src/pty.c] l.40) manpage: link:manpages/stdlib/ptsname.3.rst[ptsname] +


ptsname_r::

  int ptsname_r(int fd, char *buf, size_t len);
 +
  Defines: ioctl write uitodec open +
 (link:../src/pty.c[../src/pty.c] l.27)  +


putenv::

  int putenv( char *string );
 +
  Defines: ret_errno environ +
 (link:../src/putenv.c[../src/putenv.c] l.10) manpage: link:manpages/stdlib/getenv.3.rst[putenv] +
put a string into the environmental vars +
  the supplied string's pointer is put into the environmental array of pointers. +
  Subsequent changes of the string therefore will change the environment, +
  and the supplied string may not be deallocated. +
  Returns:  +
  - 0 on success,  +
  - EINVAL: string was 0, didn't contain a '=', some other error +
 

ret_errno::

  #ifdef mini_errno
 +
  (link:../include/ret_errno.h[../include/ret_errno.h] l.5)  +
This macro expands to a return, and +
  (when mini_errno is defined) returns -1 and sets errno, +
  or returns the negative errno value. +
 

sbrk::

  static void* sbrk(long incr);
 +
  (link:../src/brk.c[../src/brk.c] l.57) manpage: link:manpages/sys/brk.2.rst[sbrk] +
Set the new brk, increment/decrement by incr bytes. +
  return the old brk on success. +
  conformant sbrk, when mini_errno is defined +
  if no errno is available, +
  returns the negative errno value on error +
 

scandir_bufsize::

  //#define mini_scandir_bufsize 4096
 +
  (link:../src/dirent/scandir.c[../src/dirent/scandir.c] l.4)  +
the increment of the buffer of scandir in bytes for memory allocations +
  (default:4096) +
 

sdbm_hash::

  unsigned long sdbm_hash(const unsigned char *str);
 +
  (link:../src/hashes.c[../src/hashes.c] l.21)  +


seterrno::

  #ifdef mini_errno
 +
  (link:../include/seterrno.h[../include/seterrno.h] l.3)  +
set errno, but only when errno is defined. +
 

snprintf::

  int snprintf( char *buf, size_t size, const char *fmt, ... );
 +
  Defines: write +
 (link:../src/snprintf.c[../src/snprintf.c] l.5) manpage: link:manpages/stdio/printf.3.rst[snprintf] +


swap::

  static inline void swap(void* a, void* b,int size);
 +
  (link:../src/qsort.c[../src/qsort.c] l.31)  +
swap a with b, with 'size' bytes +
  swaps integers and longs at once, when size eq sizeof(int/long) +
 

sys_brk::

  static long sys_brk(unsigned long addr);
 +
  (link:../src/brk.c[../src/brk.c] l.6)  +
the kernel syscall brk. +
 

uitodec::

  int __attribute__((optimize("Os")))uitodec(unsigned int i, char *buf, int prec, char limiter );
 +
  (link:../src/itodec.c[../src/itodec.c] l.8)  +
convert int to string. +
  prec: precision, e.g. 4=> 0087  +
 

ultodec::

  int ultodec(unsigned long ui, char *buf, int prec, char limiter );
 +
  (link:../src/ltodec.c[../src/ltodec.c] l.6)  +


unlockpt::

  int unlockpt(int fd);
 +
  Defines: ioctl +
 (link:../src/pty.c[../src/pty.c] l.20) manpage: link:manpages/stdlib/ptsname.3.rst[unlockpt] +


verbose_errstr::

  const char* verbose_errstr(int num);
 +
  (link:../include/errstr.h[../include/errstr.h] l.8)  +
verbose error (errno) string.  +
  this adds about 3.5kB to the compiled binary(!) +
 

verbose_errstr2::

  static const char* verbose_errstr2(int num);
 +
  (link:../include/errstr2.h[../include/errstr2.h] l.11)  +
verbose error (errno) string.  +
  this adds about 3.5kB to the compiled binary(!) +
  Trying to shrink that here. +
 

vexec::

  int vexec( const char* path, char* const* argv, char* const* envp );
 +
  (link:../src/vexec.c[../src/vexec.c] l.4)  +
execute a path, wait until the executed file exits. +
  Deviating of system() an absolute pathname is taken. +
 

vexec_q::

  int vexec_q( const char* path, char* const* argv, char* const* envp );
 +
  (link:../src/vexec.c[../src/vexec.c] l.26)  +
execute a path, wait until the executed file exits,  +
  do not write any output of the process. (close stdout) +
  Deviating of system() an absolute pathname is taken. +
 

vsnprintf::

  int vsnprintf(char *buf, size_t size, const char* fmt, va_list args );
 +
  Defines: write +
 (link:../src/sprintf.c[../src/sprintf.c] l.41) manpage: link:manpages/stdio/printf.3.rst[vsnprintf] +
the function, translating the fmt of printf. +
  warning - most possibly you'd like to define besides fprintf, or family, +
  mini_itodec (%d conversion)  +
  mini_atoi is needed for grouping numbers +
 

writes::

  #define writes(str) write(STDOUT_FILENO,str,sizeof(str))
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.48)  +
write the constant str to stdout. Computes length with sizeof(str) at compile time. +
 



 mini_syscalls
---------------

sys__sysctl::

  sys__sysctl( struct __sysctl_args *args)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.315)  +


sys_accept::

  sys_accept( int fd,  struct sockaddr *upeersockaddr,  int *upeeraddrlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.91)  +


sys_accept4::

  sys_accept4( int fd,  struct sockaddr *upeer_sockaddr,  int *upeer_addrlen,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.551)  +


sys_access::

  sys_access( const char *filename,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.47)  +


sys_acct::

  sys_acct( const char *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.329)  +


sys_add_key::

  sys_add_key( const char *_type,  const char *_description,  const void *_payload,  size_t plen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.471)  +


sys_adjtimex::

  sys_adjtimex( struct timex *txc_p)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.321)  +


sys_alarm::

  sys_alarm( unsigned int seconds)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.79)  +


sys_arch_prctl::

  sys_arch_prctl( struct task_struct *task,  int code,  unsigned long *addr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.319)  +


sys_bind::

  sys_bind( int fd,  struct sockaddr *umyaddr,  int addrlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.103)  +


sys_capget::

  sys_capget( cap_user_header_t header,  cap_user_data_t dataptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.255)  +


sys_capset::

  sys_capset( cap_user_header_t header,  const cap_user_data_t data)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.257)  +


sys_chdir::

  sys_chdir( const char *filename)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.165)  +


sys_chmod::

  sys_chmod( const char *filename,  mode_t mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.185)  +


sys_chown::

  sys_chown( const char *filename,  uid_t user,  gid_t group)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.189)  +


sys_chroot::

  sys_chroot( const char *filename)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.325)  +


sys_clock_adjtime::

  sys_clock_adjtime( clockid_t which_clock,  struct timex *tx)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.585)  +


sys_clock_getres::

  sys_clock_getres( const clockid_t which_clock,  struct timespec *tp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.435)  +


sys_clock_gettime::

  sys_clock_gettime( const clockid_t which_clock,  struct timespec *tp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.433)  +


sys_clock_nanosleep::

  sys_clock_nanosleep( const clockid_t which_clock,  int flags,  const struct timespec *rqtp,  struct timespec *rmtp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.437)  +


sys_clock_settime::

  sys_clock_settime( const clockid_t which_clock,  const struct timespec *tp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.431)  +


sys_clone::

  sys_clone( unsigned long clone_flags,  unsigned long newsp,  void *parent_tid,  void *child_tid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.117)  +


sys_close::

  sys_close( unsigned int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.11)  +


sys_connect::

  sys_connect( int fd,  struct sockaddr *uservaddr,  int addrlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.89)  +


sys_creat::

  sys_creat( const char *pathname,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.175)  +


sys_delete_module::

  sys_delete_module( const char *name_user,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.353)  +


sys_dup::

  sys_dup( unsigned int fildes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.69)  +


sys_dup2::

  sys_dup2( unsigned int oldfd,  unsigned int newfd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.71)  +


sys_dup3::

  sys_dup3( unsigned int oldfd,  unsigned int newfd,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.559)  +


sys_epoll_create::

  sys_epoll_create( int size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.407)  +


sys_epoll_create1::

  sys_epoll_create1( int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.557)  +


sys_epoll_ctl::

  sys_epoll_ctl( int epfd,  int op,  int fd,  struct epoll_event *event)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.443)  +


sys_epoll_pwait::

  sys_epoll_pwait( int epfd,  struct epoll_event *events,  int maxevents,  int timeout,  const sigset_t *sigmask,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.537)  +


sys_epoll_wait::

  sys_epoll_wait( int epfd,  struct epoll_event *events,  int maxevents,  int timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.441)  +


sys_eventfd::

  sys_eventfd( unsigned int count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.543)  +


sys_eventfd2::

  sys_eventfd2( unsigned int count,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.555)  +


sys_execve::

  sys_execve( const char *filename,  const char *const argv[],  const char *const envp[])
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.123)  +


sys_exit::

  sys_exit( int error_code)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.125) manpage: link:manpages/sys/_exit.2.rst[_exit] +


sys_exit_group::

  sys_exit_group( int error_code)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.439)  +


sys_faccessat::

  sys_faccessat( int dfd,  const char *filename,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.513)  +


sys_fadvise64::

  sys_fadvise64( int fd,  loff_t offset,  size_t len,  int advice)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.419)  +


sys_fallocate::

  sys_fallocate( long fd,  long mode,  loff_t offset,  loff_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.545)  +


sys_fanotify_init::

  sys_fanotify_init( unsigned int flags,  unsigned int event_f_flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.575)  +


sys_fanotify_mark::

  sys_fanotify_mark( long fanotify_fd,  long flags,  __u64 mask,  long dfd, long pathname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.577)  +


sys_fchdir::

  sys_fchdir( unsigned int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.167)  +


sys_fchmod::

  sys_fchmod( unsigned int fd,  mode_t mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.187)  +


sys_fchmodat::

  sys_fchmodat( int dfd,  const char *filename,  mode_t mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.511)  +


sys_fchown::

  sys_fchown( unsigned int fd,  uid_t user,  gid_t group)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.191)  +


sys_fchownat::

  sys_fchownat( int dfd,  const char *filename,  uid_t user,  gid_t group,  int flag)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.495)  +


sys_fcntl::

  sys_fcntl( unsigned int fd,  unsigned int cmd,  unsigned long arg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.149)  +


sys_fdatasync::

  sys_fdatasync( unsigned int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.155)  +


sys_fgetxattr::

  sys_fgetxattr( int fd,  const char *name,  void *value,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.371)  +


sys_finit_module::

  sys_finit_module( int fd,  const char  *uargs,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.601)  +


sys_flistxattr::

  sys_flistxattr( int fd,  char *list,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.377)  +


sys_flock::

  sys_flock( unsigned int fd,  unsigned int cmd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.151)  +


sys_fork::

  sysSYSDEF_syscall(_fork,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.119)  +


sys_fremovexattr::

  sys_fremovexattr( int fd,  const char *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.383)  +


sys_fsetxattr::

  sys_fsetxattr( int fd,  const char *name,  const void *value,  size_t size, int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.365)  +


sys_fstat::

  sys_fstat( unsigned int fd,  struct stat *statbuf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.15)  +


sys_fstatfs::

  sys_fstatfs( unsigned int fd,  struct statfs *buf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.279)  +


sys_fsync::

  sys_fsync( unsigned int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.153)  +


sys_ftruncate::

  sys_ftruncate( unsigned int fd,  unsigned long length)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.159)  +


sys_futex::

  sys_futex( u32 *uaddr,  int op,  u32 val,  struct timespec *utime,  u32 *uaddr2,  u32 val3)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.389)  +


sys_futimesat::

  sys_futimesat( int dfd,  const char *filename,  struct timeval *utimes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.497)  +


sys_get_mempolicy::

  sys_get_mempolicy( int *policy,  unsigned long *nmask,  unsigned long maxnode,  unsigned long addr,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.453)  +


sys_get_robust_list::

  sys_get_robust_list( int pid,  struct robust_list_head **head_ptr,  size_t *len_ptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.523)  +


sys_getcpu::

  sys_getcpu( unsigned *cpup,  unsigned *nodep,  struct getcpu_cache *unused)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.593)  +


sys_getcwd::

  sys_getcwd( char *buf,  unsigned long size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.163)  +


sys_getdents::

  sys_getdents( unsigned int fd,  struct linux_dirent *dirent,  unsigned int count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.161)  +


sys_getdents64::

  sys_getdents64( unsigned int fd,  struct linux_dirent64 *dirent,  unsigned int count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.411)  +


sys_getegid::

  sysSYSDEF_syscall(_getegid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.221)  +


sys_geteuid::

  sysSYSDEF_syscall(_geteuid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.219)  +


sys_getgid::

  sysSYSDEF_syscall(_getgid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.213)  +


sys_getgroups::

  sys_getgroups( int gidsetsize,  gid_t *grouplist)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.235)  +


sys_getitimer::

  sys_getitimer( int which,  struct itimerval *value)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.77)  +


sys_getpeername::

  sys_getpeername( int fd,  struct sockaddr *usockaddr,  int *usockaddr_len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.109)  +


sys_getpgid::

  sys_getpgid( pid_t pid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.247)  +


sys_getpgrp::

  sysSYSDEF_syscall(_getpgrp,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.227)  +


sys_getpid::

  sysSYSDEF_syscall(_getpid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.83)  +


sys_getppid::

  sysSYSDEF_syscall(_getppid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.225)  +


sys_getpriority::

  sys_getpriority( int which,  int who)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.283)  +


sys_getrandom::

  sys_getrandom( char  *buf,  size_t count,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.611)  +


sys_getresgid::

  sys_getresgid( gid_t *rgid,  gid_t *egid,  gid_t *sgid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.245)  +


sys_getresuid::

  sys_getresuid( uid_t *ruid,  uid_t *euid,  uid_t *suid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.241)  +


sys_getrlimit::

  sys_getrlimit( unsigned int resource,  struct rlimit *rlim)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.199)  +


sys_getrusage::

  sys_getrusage( int who,  struct rusage *ru)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.201)  +


sys_getsid::

  sys_getsid( pid_t pid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.253)  +


sys_getsockname::

  sys_getsockname( int fd,  struct sockaddr *usockaddr,  int *usockaddr_len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.107)  +


sys_getsockopt::

  sys_getsockopt( int fd,  int level,  int optname,  char *optval,  int *optlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.115)  +


sys_gettid::

  sysSYSDEF_syscall(_gettid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.357)  +


sys_gettimeofday::

  sys_gettimeofday( struct timeval *tv,  struct timezone *tz)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.197)  +


sys_getuid::

  sysSYSDEF_syscall(_getuid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.209)  +


sys_getxattr::

  sys_getxattr( const char *pathname,  const char *name,  void *value,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.367)  +


sys_init_module::

  sys_init_module( void *umod,  unsigned long len,  const char *uargs)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.351)  +


sys_inotify_add_watch::

  sys_inotify_add_watch( int fd,  const char *pathname,  u32 mask)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.483)  +


sys_inotify_init::

  sysSYSDEF_syscall(_inotify_init,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.481)  +


sys_inotify_init1::

  sys_inotify_init1( int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.563)  +


sys_inotify_rm_watch::

  sys_inotify_rm_watch( int fd,  __s32 wd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.485)  +


sys_io_cancel::

  sys_io_cancel( aio_context_t ctx_id,  struct iocb *iocb,  struct io_event *result)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.403)  +


sys_io_destroy::

  sys_io_destroy( aio_context_t ctx)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.397)  +


sys_io_getevents::

  sys_io_getevents( aio_context_t ctx_id,  long min_nr,  long nr,  struct io_event *events)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.399)  +


sys_io_setup::

  sys_io_setup( unsigned nr_events,  aio_context_t *ctxp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.395)  +


sys_io_submit::

  sys_io_submit( aio_context_t ctx_id,  long nr,  struct iocb **iocbpp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.401)  +


sys_ioctl::

  sys_ioctl( unsigned int fd,  unsigned int cmd,  unsigned long arg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.37)  +


sys_ioperm::

  sys_ioperm( unsigned long from,  unsigned long num,  int turn_on)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.349)  +


sys_iopl::

  sys_iopl( unsigned int level,  struct pt_regs *regs)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.347)  +


sys_ioprio_get::

  sys_ioprio_get( int which,  int who)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.479)  +


sys_ioprio_set::

  sys_ioprio_set( int which,  int who,  int ioprio)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.477)  +


sys_kcmp::

  sys_kcmp( pid_t pid1,  pid_t pid2,  int type,  unsigned long idx1,  unsigned long idx2)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.599)  +


sys_kexec_file_load::

  sys_kexec_file_load( int kernel_fd,  int initrd_fd,  unsigned long cmdline_len,  const char  *cmdline_ptr,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.615)  +


sys_kexec_load::

  sys_kexec_load( unsigned long entry,  unsigned long nr_segments,  struct kexec_segment *segments,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.467)  +


sys_keyctl::

  sys_keyctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.475)  +


sys_kill::

  sys_kill( pid_t pid,  int sig)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.129)  +


sys_lchown::

  sys_lchown( const char *filename,  uid_t user,  gid_t group)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.193)  +


sys_lgetxattr::

  sys_lgetxattr( const char *pathname,  const char *name,  void *value,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.369)  +


sys_link::

  sys_link( const char *oldname,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.177)  +


sys_linkat::

  sys_linkat( int oldfd,  const char *oldname,  int newfd,  const char *newname,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.505)  +


sys_listen::

  sys_listen( int fd,  int backlog)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.105)  +


sys_listxattr::

  sys_listxattr( const char *pathname,  char *list,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.373)  +


sys_llistxattr::

  sys_llistxattr( const char *pathname,  char *list,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.375)  +


sys_lookup_dcookie::

  sys_lookup_dcookie( u64 cookie64,  long buf,  long len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.405)  +


sys_lremovexattr::

  sys_lremovexattr( const char *pathname,  const char *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.381)  +


sys_lseek::

  sys_lseek( unsigned int fd,  off_t offset,  unsigned int origin)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.21)  +


sys_lsetxattr::

  sys_lsetxattr( const char *pathname,  const char *name,  const void *value, size_t size,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.363)  +


sys_lstat::

  sys_lstat( const char *filename,  struct stat *statbuf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.17)  +


sys_madvise::

  sys_madvise( unsigned long start,  size_t len_in,  int behavior)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.61)  +


sys_mbind::

  sys_mbind( unsigned long start,  unsigned long len,  unsigned long mode,  unsigned long *nmask,  unsigned long maxnode,  unsigned flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.449)  +


sys_memfd_create::

  sys_memfd_create( const char  *uname_ptr,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.613)  +


sys_migrate_pages::

  sys_migrate_pages( pid_t pid,  unsigned long maxnode,  const unsigned long *old_nodes,  const unsigned long *new_nodes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.487)  +


sys_mincore::

  sys_mincore( unsigned long start,  size_t len,  unsigned char *vec)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.59)  +


sys_mkdir::

  sys_mkdir( const char *pathname,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.171)  +


sys_mkdirat::

  sys_mkdirat( int dfd,  const char *pathname,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.491)  +


sys_mknod::

  sys_mknod( const char *filename,  umode_t mode,  unsigned dev)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.271)  +


sys_mknodat::

  sys_mknodat( int dfd,  const char *filename,  int mode,  unsigned dev)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.493)  +


sys_mlock::

  sys_mlock( unsigned long start,  size_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.301)  +


sys_mlockall::

  sys_mlockall( int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.305)  +


sys_mmap::

  sys_mmap( unsigned long addr,  unsigned long len,  unsigned long prot,  unsigned long flags,  unsigned long fd,  unsigned long off)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.23)  +


sys_modify_ldt::

  sys_modify_ldt( int func,  void *ptr,  unsigned long bytecount)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.311)  +


sys_mount::

  sys_mount( char *dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.333)  +


sys_move_pages::

  sys_move_pages( pid_t pid,  unsigned long nr_pages,  const void *pages[], const int *nodes,  int *status,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.533)  +


sys_mprotect::

  sys_mprotect( unsigned long start,  size_t len,  unsigned long prot)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.25)  +


sys_mq_getsetattr::

  sys_mq_getsetattr( mqd_t mqdes,  const struct mq_attr *u_mqstat,  struct mq_attr *u_omqstat)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.465)  +


sys_mq_notify::

  sys_mq_notify( mqd_t mqdes,  const struct sigevent *u_notification)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.463)  +


sys_mq_open::

  sys_mq_open( const char *u_name,  int oflag,  mode_t mode,  struct mq_attr *u_attr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.455)  +


sys_mq_timedreceive::

  sys_mq_timedreceive( mqd_t mqdes,  char *u_msg_ptr,  size_t msg_len,  unsigned int *u_msg_prio,  const struct timespec *u_abs_timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.461)  +


sys_mq_timedsend::

  sys_mq_timedsend( mqd_t mqdes,  const char *u_msg_ptr,  size_t msg_len,  unsigned int msg_prio,  const struct timespec *u_abs_timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.459)  +


sys_mq_unlink::

  sys_mq_unlink( const char *u_name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.457)  +


sys_mremap::

  sys_mremap( unsigned long addr,  unsigned long old_len,  unsigned long new_len,  unsigned long flags,  unsigned long new_addr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.55)  +


sys_msgctl::

  sys_msgctl( int msqid,  int cmd,  struct msqid_ds *buf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.147)  +


sys_msgget::

  sys_msgget( key_t key,  int msgflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.141)  +


sys_msgrcv::

  sys_msgrcv( int msqid,  struct msgbuf *msgp,  size_t msgsz,  long msgtyp,  int msgflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.145)  +


sys_msgsnd::

  sys_msgsnd( int msqid,  struct msgbuf *msgp,  size_t msgsz,  int msgflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.143)  +


sys_msync::

  sys_msync( unsigned long start,  size_t len,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.57)  +


sys_munlock::

  sys_munlock( unsigned long start,  size_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.303)  +


sys_munlockall::

  sysSYSDEF_syscall(_munlockall,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.307)  +


sys_munmap::

  sys_munmap( unsigned long addr,  size_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.27)  +


sys_name_to_handle_at::

  sys_name_to_handle_at( int dfd,  const char *name,  struct file_handle *handle,  int *mnt_id,  int flag)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.581)  +


sys_nanosleep::

  sys_nanosleep( struct timespec *rqtp,  struct timespec *rmtp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.75)  +


sys_newfstatat::

  sys_newfstatat( int dfd,  const char *filename,  struct stat *statbuf,  int flag)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.499)  +


sys_open::

  sys_open( const char *filename,  int flags,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.9)  +


sys_open_by_handle_at::

  sys_open_by_handle_at( int dfd,  const char *name,  struct file_handle *handle,  int *mnt_id,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.583)  +


sys_openat::

  sys_openat( int dfd,  const char *filename,  int flags,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.489)  +


sys_pause::

  sysSYSDEF_syscall(_pause,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.73)  +


sys_perf_event_open::

  sys_perf_event_open( struct perf_event_attr *attr_uptr,  pid_t pid,  int cpu,  int group_fd,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.571)  +


sys_personality::

  sys_personality( unsigned int personality)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.273)  +


sys_pipe::

  sys_pipe( int *filedes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.49)  +


sys_pipe2::

  sys_pipe2( int *filedes,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.561)  +


sys_pivot_root::

  sys_pivot_root( const char *new_root,  const char *put_old)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.313)  +


sys_poll::

  sys_poll( struct poll_fd *ufds,  unsigned int nfds,  long timeout_msecs)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.19)  +


sys_ppoll::

  sys_ppoll( struct pollfd *ufds,  unsigned int nfds,  struct timespec *tsp,  const sigset_t *sigmask,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.517)  +


sys_prctl::

  sys_prctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.317)  +


sys_pread64::

  sys_pread64( unsigned long fd,  char *buf,  size_t count,  loff_t pos)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.39)  +


sys_preadv::

  sys_preadv( unsigned long fd,  const struct iovec *vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.565)  +


sys_prlimit64::

  sys_prlimit64( pid_t pid,  unsigned int resource,  const struct rlimit64 *new_rlim,  struct rlimit64 *old_rlim)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.579)  +


sys_process_vm_readv::

  sys_process_vm_readv( pid_t pid,  const struct iovec *lvec,  unsigned long liovcnt,  const struct iovec *rvec,  unsigned long riovcnt,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.595)  +


sys_process_vm_writev::

  sys_process_vm_writev( pid_t pid,  const struct iovec *lvec,  unsigned long liovcnt,  const struct iovcc *rvec,  unsigned long riovcnt,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.597)  +


sys_pselect6::

  sys_pselect6( int n,  fd_set *inp,  fd_set *outp,  fd_set *exp,  struct timespec *tsp,  void *sig)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.515)  +


sys_ptrace::

  sys_ptrace( long request,  long pid,  unsigned long addr,  unsigned long data)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.207)  +


sys_pwrite64::

  sys_pwrite64( unsigned int fd,  const char *buf,  size_t count,  loff_t pos)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.41)  +


sys_pwritev::

  sys_pwritev( unsigned long fd,  const struct iovec *vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.567)  +


sys_quotactl::

  sys_quotactl( unsigned int cmd,  const char *special,  qid_t id,  void *addr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.355)  +


sys_read::

  sys_read( unsigned int fd,  char *buf,  size_t count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.5)  +


sys_readahead::

  sys_readahead( int fd,  loff_t offset,  size_t count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.359)  +


sys_readlink::

  sys_readlink( const char *path,  char *buf,  int bufsiz)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.183)  +


sys_readlinkat::

  sys_readlinkat( int dfd,  const char *pathname,  char *buf,  int bufsiz)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.509)  +


sys_readv::

  sys_readv( unsigned long fd,  const struct iovec *vec,  unsigned long vlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.43)  +


sys_reboot::

  sys_reboot( int magic1,  int magic2,  unsigned int cmd,  void *arg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.341)  +


sys_recvfrom::

  sys_recvfrom( int fd,  void *ubuf,  size_t size,  unsigned flags,  struct sockaddr *addr,  int *addr_len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.95)  +


sys_recvmmsg::

  sys_recvmmsg( int fd,  struct msghdr *mmsg,  unsigned int vlen,  unsigned int flags,  struct timespec *timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.573)  +


sys_recvmsg::

  sys_recvmsg( int fd,  struct msghdr *msg,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.99)  +


sys_remap_file_pages::

  sys_remap_file_pages( unsigned long start,  unsigned long size,  unsigned long prot,  unsigned long pgoff,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.409)  +


sys_removexattr::

  sys_removexattr( const char *pathname,  const char *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.379)  +


sys_rename::

  sys_rename( const char *oldname,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.169)  +


sys_renameat::

  sys_renameat( int oldfd,  const char *oldname,  int newfd,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.503)  +


sys_renameat2::

  sys_renameat2( int olddfd,  const char  *oldname,  int newdfd,  const char  *newname,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.607)  +


sys_request_key::

  sys_request_key( const char *_type,  const char *_description,  const char *_callout_info,  key_serial_t destringid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.473)  +


sys_restart_syscall::

  sysSYSDEF_syscall(_restart_syscall,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.415)  +


sys_rmdir::

  sys_rmdir( const char *pathname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.173)  +


sys_rt_sigaction::

  sys_rt_sigaction( int sig,  const struct sigaction *act,  struct sigaction *oact,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.31)  +


sys_rt_sigpending::

  sys_rt_sigpending( sigset_t *set,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.259)  +


sys_rt_sigprocmask::

  sys_rt_sigprocmask( int how,  sigset_t *nset,  sigset_t *oset,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.33)  +


sys_rt_sigqueueinfo::

  sys_rt_sigqueueinfo( pid_t pid,  int sig,  siginfo_t *uinfo)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.263)  +


sys_rt_sigreturn::

  sys_rt_sigreturn( unsigned long __unused)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.35)  +


sys_rt_sigsuspend::

  sys_rt_sigsuspend( sigset_t *unewset,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.265)  +


sys_rt_sigtimedwait::

  sys_rt_sigtimedwait( const sigset_t *uthese,  siginfo_t *uinfo,  const struct timespec *uts,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.261)  +


sys_rt_tgsigqueueinfo::

  sys_rt_tgsigqueueinfo( pid_t tgid,  pid_t pid,  int sig,  siginfo_t *uinfo)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.569)  +


sys_sched_get_priority_max::

  sys_sched_get_priority_max( int policy)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.295)  +


sys_sched_get_priority_min::

  sys_sched_get_priority_min( int policy)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.297)  +


sys_sched_getaffinity::

  sys_sched_getaffinity( pid_t pid,  unsigned int len,  unsigned long *user_mask_ptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.393)  +


sys_sched_getattr::

  sys_sched_getattr( pid_t pid,  struct sched_attr  *attr,  unsigned int size,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.605)  +


sys_sched_getparam::

  sys_sched_getparam( pid_t pid,  struct sched_param *param)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.289)  +


sys_sched_getscheduler::

  sys_sched_getscheduler( pid_t pid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.293)  +


sys_sched_rr_get_interval::

  sys_sched_rr_get_interval( pid_t pid,  struct timespec *interval)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.299)  +


sys_sched_setaffinity::

  sys_sched_setaffinity( pid_t pid,  unsigned int len,  unsigned long *user_mask_ptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.391)  +


sys_sched_setattr::

  sys_sched_setattr( pid_t pid,  struct sched_attr  *attr,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.603)  +


sys_sched_setparam::

  sys_sched_setparam( pid_t pid,  struct sched_param *param)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.287)  +


sys_sched_setscheduler::

  sys_sched_setscheduler( pid_t pid,  int policy,  struct sched_param *param)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.291)  +


sys_sched_yield::

  sysSYSDEF_syscall(_sched_yield,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.53)  +


sys_seccomp::

  sys_seccomp( unsigned int op,  unsigned int flags,  const char  *uargs)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.609)  +


sys_select::

  sys_select( int n,  fd_set *inp,  fd_set *outp,  fd_set *exp,  struct timeval *tvp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.51)  +


sys_semctl::

  sys_semctl( int semid,  int semnum,  int cmd,  semun_u arg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.137)  +


sys_semget::

  sys_semget( key_t key,  int nsems,  int semflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.133)  +


sys_semop::

  sys_semop( int semid,  struct sembuf *tsops,  unsigned nsops)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.135)  +


sys_semtimedop::

  sys_semtimedop( int semid,  struct sembuf *tsops,  unsigned nsops,  const struct timespec *timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.417)  +


sys_sendfile::

  sys_sendfile( int out_fd,  int in_fd,  off_t *offset,  size_t count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.85)  +


sys_sendmmsg::

  sys_sendmmsg( int fd,  struct mmsghdr *mmsg,  unsigned int vlen,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.589)  +


sys_sendmsg::

  sys_sendmsg( int fd,  struct msghdr *msg,  unsigned flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.97)  +


sys_sendto::

  sys_sendto( int fd,  void *buff,  size_t len,  unsigned flags,  struct sockaddr *addr,  int addr_len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.93)  +


sys_set_mempolicy::

  sys_set_mempolicy( int mode,  unsigned long *nmask,  unsigned long maxnode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.451)  +


sys_set_robust_list::

  sys_set_robust_list( struct robust_list_head *head,  size_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.521)  +


sys_set_tid_address::

  sys_set_tid_address( int *tidptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.413)  +


sys_setdomainname::

  sys_setdomainname( char *name,  int len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.345)  +


sys_setfsgid::

  sys_setfsgid( gid_t gid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.251)  +


sys_setfsuid::

  sys_setfsuid( uid_t uid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.249)  +


sys_setgid::

  sys_setgid( gid_t gid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.217)  +


sys_setgroups::

  sys_setgroups( int gidsetsize,  gid_t *grouplist)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.237)  +


sys_sethostname::

  sys_sethostname( char *name,  int len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.343)  +


sys_setitimer::

  sys_setitimer( int which,  struct itimerval *value,  struct itimerval *ovalue)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.81)  +


sys_setns::

  sys_setns( int fd,  int nstype)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.591)  +


sys_setpgid::

  sys_setpgid( pid_t pid,  pid_t pgid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.223)  +


sys_setpriority::

  sys_setpriority( int which,  int who,  int niceval)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.285)  +


sys_setregid::

  sys_setregid( gid_t rgid,  gid_t egid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.233)  +


sys_setresgid::

  sys_setresgid( gid_t rgid,  gid_t egid,  gid_t sgid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.243)  +


sys_setresuid::

  sys_setresuid( uid_t *ruid,  uid_t *euid,  uid_t *suid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.239)  +


sys_setreuid::

  sys_setreuid( uid_t ruid,  uid_t euid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.231)  +


sys_setrlimit::

  sys_setrlimit( unsigned int resource,  struct rlimit *rlim)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.323)  +


sys_setsid::

  sysSYSDEF_syscall(_setsid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.229)  +


sys_setsockopt::

  sys_setsockopt( int fd,  int level,  int optname,  char *optval,  int optlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.113)  +


sys_settimeofday::

  sys_settimeofday( struct timeval *tv,  struct timezone *tz)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.331)  +


sys_setuid::

  sys_setuid( uid_t uid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.215)  +


sys_setxattr::

  sys_setxattr( const char *pathname,  const char *name,  const void *value, size_t size,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.361)  +


sys_shmat::

  sys_shmat( int shmid,  char *shmaddr,  int shmflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.65)  +


sys_shmctl::

  sys_shmctl( int shmid,  int cmd,  struct shmid_ds *buf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.67)  +


sys_shmdt::

  sys_shmdt( char *shmaddr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.139)  +


sys_shmget::

  sys_shmget( key_t key,  size_t size,  int shmflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.63)  +


sys_shutdown::

  sys_shutdown( int fd,  int how)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.101)  +


sys_sigaltstack::

  sys_sigaltstack( const stack_t *uss,  stack_t *uoss)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.267)  +


sys_signalfd::

  sys_signalfd( int ufd,  sigset_t *user_mask,  size_t sizemask)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.539)  +


sys_signalfd4::

  sys_signalfd4( int ufd,  sigset_t *user_mask,  size_t sizemask,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.553)  +


sys_socket::

  sys_socket( int family,  int type,  int protocol)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.87)  +


sys_socketpair::

  sys_socketpair( int family,  int type,  int protocol,  int *usockvec)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.111)  +


sys_splice::

  sys_splice( int fd_in,  loff_t *off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.525)  +


sys_stat::

  sys_stat( const char *filename,  struct stat *statbuf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.13)  +


sys_statfs::

  sys_statfs( const char *pathname,  struct statfs *buf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.277)  +


sys_swapoff::

  sys_swapoff( const char *specialfile)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.339)  +


sys_swapon::

  sys_swapon( const char *specialfile,  int swap_flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.337)  +


sys_symlink::

  sys_symlink( const char *oldname,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.181)  +


sys_symlinkat::

  sys_symlinkat( const char *oldname,  int newfd,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.507)  +


sys_sync::

  sysSYSDEF_syscall(_sync,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.327)  +


sys_sync_file_range::

  sys_sync_file_range( long fd,  loff_t offset,  loff_t bytes,  long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.529)  +


sys_syncfs::

  sys_syncfs( int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.587)  +


sys_sysfs::

  sys_sysfs( int option,  unsigned long arg1,  unsigned long arg2)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.281)  +


sys_sysinfo::

  sys_sysinfo( struct sysinfo *info)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.203)  +


sys_syslog::

  sys_syslog( int type,  char *buf,  int len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.211)  +


sys_tee::

  sys_tee( int fdin,  int fdout,  size_t len,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.527)  +


sys_tgkill::

  sys_tgkill( pid_t tgid,  pid_t pid,  int sig)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.445)  +


sys_time::

  sys_time( time_t *tloc)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.387)  +


sys_timer_create::

  sys_timer_create( const clockid_t which_clock,  struct sigevent *timer_event_spec,  timer_t *created_timer_id)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.421)  +


sys_timer_delete::

  sys_timer_delete( timer_t timer_id)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.429)  +


sys_timer_getoverrun::

  sys_timer_getoverrun( timer_t timer_id)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.427)  +


sys_timer_gettime::

  sys_timer_gettime( timer_t timer_id,  struct itimerspec *setting)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.425)  +


sys_timer_settime::

  sys_timer_settime( timer_t timer_id,  int flags,  const struct itimerspec *new_setting,  struct itimerspec *old_setting)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.423)  +


sys_timerfd_create::

  sys_timerfd_create( int clockid,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.541)  +


sys_timerfd_gettime::

  sys_timerfd_gettime( int ufd,  struct itimerspec *otmr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.549)  +


sys_timerfd_settime::

  sys_timerfd_settime( int ufd,  int flags,  const struct itimerspec *utmr,  struct itimerspec *otmr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.547)  +


sys_times::

  sys_times( struct sysinfo *info)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.205)  +


sys_tkill::

  sys_tkill( pid_t pid,  int sig)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.385)  +


sys_truncate::

  sys_truncate( const char *path,  long length)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.157)  +


sys_umask::

  sys_umask( int mask)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.195)  +


sys_umount2::

  sys_umount2( const char *target,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.335)  +


sys_uname::

  sys_uname( struct old_utsname *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.131)  +


sys_unlink::

  sys_unlink( const char *pathname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.179)  +


sys_unlinkat::

  sys_unlinkat( int dfd,  const char *pathname,  int flag)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.501)  +


sys_unshare::

  sys_unshare( unsigned long unshare_flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.519)  +


sys_ustat::

  sys_ustat( unsigned dev,  struct ustat *ubuf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.275)  +


sys_utime::

  sys_utime( char *filename,  struct utimbuf *times)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.269)  +


sys_utimensat::

  sys_utimensat( int dfd,  const char *filename,  struct timespec *utimes, int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.535)  +


sys_utimes::

  sys_utimes( char *filename,  struct timeval *utimes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.447)  +


sys_vfork::

  sysSYSDEF_syscall(_vfork,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.121)  +


sys_vhangup::

  sysSYSDEF_syscall(_vhangup,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.309)  +


sys_vmsplice::

  sys_vmsplice( int fd,  const struct iovec *iov,  unsigned long nr_segs, unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.531)  +


sys_wait4::

  sys_wait4( pid_t upid,  int *stat_addr,  int options,  struct rusage *ru)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.127)  +


sys_waitid::

  sys_waitid( int which,  pid_t upid,  struct siginfo *infop,  int options,  struct rusage *ru)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.469)  +


sys_write::

  sys_write( unsigned int fd,  const char *buf,  size_t count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.7)  +


sys_writev::

  sys_writev( unsigned long fd,  const struct iovec *vec,  unsigned long vlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.45)  +




 signal.h
----------

raise::

  static inline int raise(int signr);
 +
  Defines: getpid +
 (link:../src/sigaction.c[../src/sigaction.c] l.135) manpage: link:manpages/gen/raise.3.rst[raise] +


sigaction::

  static int volatile sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
 +
  Defines: memcpy +
 (link:../src/sigaction.c[../src/sigaction.c] l.107) manpage: link:manpages/sys/sigaction.2.rst[sigaction] +


sigaddset::

  int sigaddset(sigset_t *set, int sig);
 +
  (link:../src/sigaction.c[../src/sigaction.c] l.34) manpage: link:manpages/gen/sigsetops.3.rst[sigaddset] +


sigdelset::

  int sigdelset(sigset_t *set, int sig);
 +
  (link:../src/sigaction.c[../src/sigaction.c] l.58) manpage: link:manpages/gen/sigsetops.3.rst[sigdelset] +


sigemptyset::

  static int sigemptyset(sigset_t *set);
 +
  (link:../src/sigaction.c[../src/sigaction.c] l.7) manpage: link:manpages/gen/sigsetops.3.rst[sigemptyset] +


sigfillset::

  static int sigfillset(sigset_t *set);
 +
  (link:../src/sigaction.c[../src/sigaction.c] l.20) manpage: link:manpages/gen/sigsetops.3.rst[sigfillset] +


sigismember::

  int sigismember(sigset_t *set, int sig);
 +
  (link:../src/sigaction.c[../src/sigaction.c] l.75) manpage: link:manpages/gen/sigsetops.3.rst[sigismember] +


signal::

  sighandler_t signal(int sig, sighandler_t func );
 +
  Defines: memcpy write +
 (link:../src/signal.c[../src/signal.c] l.8) manpage: link:manpages/gen/signal.3.rst[signal] +


sigprocmask::

  int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
 +
  (link:../src/sigaction.c[../src/sigaction.c] l.52) manpage: link:manpages/sys/sigprocmask.2.rst[sigprocmask] +




 stdio.h
---------

_fopen::

  FILE *_fopen(int fd, const char* filename, const char* mode, FILE *f);
 +
  Defines: fileno open close +
 (link:../src/fopen.c[../src/fopen.c] l.12)  +
modes implemented: r, r+, w, w+, a, a+ +
 

_itohex::

  int _itohex(int i,char* buf,int padding, int capitals);
 +
  (link:../src/itohex.c[../src/itohex.c] l.6)  +


clearerr::

  static inline void clearerr(FILE *f);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.198) manpage: link:manpages/stdio/ferror.3.rst[clearerr] +


clearerror::

  static inline void clearerror(FILE *f);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.203)  +


fclose::

  static inline int __attribute__((always_inline)) fclose( FILE* f );
 +
  Defines: close +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.65) manpage: link:manpages/stdio/fclose.3.rst[fclose] +


fdopen::

  FILE *fdopen(int fd, const char* mode);
 +
  Defines: open fileno close +
 (link:../src/fopen.c[../src/fopen.c] l.91) manpage: link:manpages/stdio/fopen.3.rst[fdopen] +
modes implemented: r, r+, w, w+, a, a+ +
 

feof::

  static inline int feof(FILE *f);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.184) manpage: link:manpages/stdio/ferror.3.rst[feof] +


ferror::

  static inline int ferror(FILE *f);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.191) manpage: link:manpages/stdio/ferror.3.rst[ferror] +


fflush::

  static inline int __attribute__((always_inline)) fflush( FILE *F );
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.28) manpage: link:manpages/stdio/fflush.3.rst[fflush] +
This does nothing, since minilib doesn't provide buffered streams yet.In order to sync data to disc, please use fsync +
 

fgetc::

  static inline int fgetc(FILE *F);
 +
  Defines: read fileno +
 (link:../include/fgetc.h[../include/fgetc.h] l.11) manpage: link:manpages/stdio/getc.3.rst[fgetc] +


fgetpos::

  static inline void fgetpos(FILE *f, long *pos );
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.127) manpage: link:manpages/stdio/fseek.3.rst[fgetpos] +


fgets::

  char* fgets(char *buf, int size, FILE* F);
 +
  Defines: read fileno +
 (link:../src/fgets.c[../src/fgets.c] l.6) manpage: link:manpages/stdio/fgets.3.rst[fgets] +


fileno::

  static int fileno( FILE *f );
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.56) manpage: link:manpages/stdio/ferror.3.rst[fileno] +
Return the fd nummber of stdin,-out,-err.  +
 

fopen::

  FILE *fopen(const char* filename, const char* mode);
 +
  Defines: close open fileno +
 (link:../src/fopen.c[../src/fopen.c] l.81) manpage: link:manpages/stdio/fopen.3.rst[fopen] +
modes implemented: r, r+, w, w+, a, a+ +
 

fprint::

  #define fprint(...) fprintf(__VA_ARGS__)
 +
  Defines: write fileno +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.95)  +


fprintf::

  #define fprintf(stream,...)	write(fileno(stream),mlgl->mbuf,sprintf(mlgl->mbuf,__VA_ARGS__))
 +
  Defines: write fileno +
 (link:../src/sprintf.c[../src/sprintf.c] l.224) manpage: link:manpages/stdio/printf.3.rst[fprintf] +


fputc::

  static inline int volatile fputc(int c, FILE* F);
 +
  Defines: write fileno +
 (link:../include/fputc.h[../include/fputc.h] l.10) manpage: link:manpages/stdio/putc.3.rst[fputc] +


fputs::

  static inline int volatile fputs(const char *c, FILE *F);
 +
  Defines: fileno write strlen +
 (link:../include/fputs.h[../include/fputs.h] l.20) manpage: link:manpages/stdio/fputs.3.rst[fputs] +


fread::

  static inline size_t fread(void *ptr, size_t size, size_t nmemb, FILE *f);
 +
  Defines: read +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.162) manpage: link:manpages/stdio/fread.3.rst[fread] +


freopen::

  FILE *freopen(const char* filename, const char* mode, FILE *F);
 +
  Defines: fileno open close +
 (link:../src/fopen.c[../src/fopen.c] l.101) manpage: link:manpages/stdio/fopen.3.rst[freopen] +
modes implemented: r, r+, w, w+, a, a+ +
 

fseek::

  static inline int fseek(FILE *f, long offset, int whence );
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.146) manpage: link:manpages/stdio/fseek.3.rst[fseek] +


fsetpos::

  static inline int fsetpos(FILE *f, int pos );
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.133) manpage: link:manpages/stdio/fseek.3.rst[fsetpos] +


ftell::

  static inline long ftell(FILE *f);
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.121) manpage: link:manpages/stdio/fseek.3.rst[ftell] +


fwrite::

  static inline size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *f);
 +
  Defines: write +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.106) manpage: link:manpages/stdio/fread.3.rst[fwrite] +


getc::

  #define getc(F) fgetc(F)
 +
  Defines: read fileno +
 (link:../include/fgetc.h[../include/fgetc.h] l.26) manpage: link:manpages/stdio/getc.3.rst[getc] +


getchar::

  #define getchar() fgetc(0)
 +
  Defines: fileno read +
 (link:../include/fgetc.h[../include/fgetc.h] l.29) manpage: link:manpages/stdio/getc.3.rst[getchar] +


gets::

  #define gets(F) fgets(F,0xfffffff,stdin)
 +
  Defines: fileno read +
 (link:../src/fgets.c[../src/fgets.c] l.29) manpage: link:manpages/stdio/fgets.3.rst[gets] +


itoHEX::

  int itoHEX(int i,char* buf,int padding);
 +
  Defines:  +
 (link:../src/itohex.c[../src/itohex.c] l.56)  +


itohex::

  int itohex(int i,char* buf,int padding);
 +
  Defines:  +
 (link:../src/itohex.c[../src/itohex.c] l.49)  +


perror::

  void perror(const char *msg);
 +
  Defines: strlen write fileno strerror errno +
 (link:../src/perror.c[../src/perror.c] l.4) manpage: link:manpages/string/strerror.3.rst[perror] +


printf::

  #define printf(...) fprintf(stdout,__VA_ARGS__)
 +
  Defines: write fileno +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.91) manpage: link:manpages/stdio/printf.3.rst[printf] +


putc::

  #define putc(c,stream) fputc(c,stream)
 +
  Defines: fileno write +
 (link:../include/fputc.h[../include/fputc.h] l.19) manpage: link:manpages/stdio/putc.3.rst[putc] +


putchar::

  #define putchar(c) fputc(c,stdout)
 +
  Defines: write fileno +
 (link:../include/fputc.h[../include/fputc.h] l.16) manpage: link:manpages/stdio/putc.3.rst[putchar] +


puts::

  #define puts(msg) ( print(msg) + printl() )
 +
  Defines: strlen write +
 (link:../include/prints.h[../include/prints.h] l.73) manpage: link:manpages/stdio/fputs.3.rst[puts] +
write msg to stdout, append a newline. Needs strlen. +
 

rewind::

  static inline void rewind( FILE *f );
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.156) manpage: link:manpages/stdio/fseek.3.rst[rewind] +


setbuf::

  static void setbuf(FILE *stream, char *buf);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.211) manpage: link:manpages/stdio/setbuf.3.rst[setbuf] +
dummy function. +
  There is no buffering implemented for the streams yet. +
 

setvbuf::

  static int setvbuf(FILE *stream, char *buf, int mode, size_t size);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.216) manpage: link:manpages/stdio/setbuf.3.rst[setvbuf] +
dummy function +
 

sprintf::

  #define sprintf(str,...) snprintf( str, 4096,  __VA_ARGS__)
 +
  Defines: write +
 (link:../src/sprintf.c[../src/sprintf.c] l.26) manpage: link:manpages/stdio/printf.3.rst[sprintf] +


ungetc::

  static int ungetc(int c, FILE *F);
 +
  (link:../include/fgetc.h[../include/fgetc.h] l.35) manpage: link:manpages/stdio/ungetc.3.rst[ungetc] +
pushes one char back to the stream. +
  Overwrites a previously pushed char +
  (conforming to the posix spec)  +
 

vfprintf::

  #define vfprintf(...) fprintf(__VA_ARGS__)
 +
  Defines: fileno write +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.100) manpage: link:manpages/stdio/printf.3.rst[vfprintf] +


vsprintf::

  int vsprintf( char *buf, const char *fmt, ... );
 +
  Defines: 0 +
 (link:../src/vsprintf.c[../src/vsprintf.c] l.9) manpage: link:manpages/stdio/printf.3.rst[vsprintf] +
write fmt and arguments into buf +
  calls vsnprintf,  +
  the size is limited to 4096 by default. +
 



 stdlib.h
----------

abort::

  void abort();
 +
  Defines: getpid memcpy write +
 (link:../src/abort.c[../src/abort.c] l.3) manpage: link:manpages/stdlib/abort.3.rst[abort] +


abs::

  static int abs(int i);
 +
  (link:../include/math.h[../include/math.h] l.25) manpage: link:manpages/stdlib/abs.3.rst[abs] +


atexit::

  static int atexit( functionp* func );
 +
  Defines: globals +
 (link:../src/atexit.c[../src/atexit.c] l.7) manpage: link:manpages/stdlib/atexit.3.rst[atexit] +
register functions, which are callen on exit in reverse order +
  the switch mini_atexit takes a optional number, +
  which defines the maximum numbers of functions to be registered. +
  (defaults to 8) +
 

atoi::

  int atoi(const char *c);
 +
  (link:../src/atoi.c[../src/atoi.c] l.6) manpage: link:manpages/stdlib/atoi.3.rst[atoi] +


atol::

  long atol(const char *c);
 +
  (link:../src/atoi.c[../src/atoi.c] l.43) manpage: link:manpages/stdlib/atol.3.rst[atol] +


div::

  static div_t div(int numerator, int denominator);
 +
  (link:../include/math.h[../include/math.h] l.8) manpage: link:manpages/stdlib/div.3.rst[div] +


free::

  void free(void *p);
 +
  Defines: getbrk brk +
 (link:../src/malloc.c[../src/malloc.c] l.139) manpage: link:manpages/stdlib/memory.3.rst[free] +


free_brk::

  int free_brk();
 +
  (link:../src/malloc.c[../src/malloc.c] l.234)  +
free all memory, +
  which has been allocated with malloc_brk. +
  Returns 0, if memory has been freed; +
  1, when there hasn't been any memory allocations with +
  malloc_brk before. +
  Then brk() gives an error, return the return value of brk +
 

getenv::

  char* getenv(const char* name);
 +
  Defines: environ +
 (link:../src/getenv.c[../src/getenv.c] l.8) manpage: link:manpages/stdlib/getenv.3.rst[getenv] +


labs::

  static long int labs(long int i);
 +
  (link:../include/math.h[../include/math.h] l.30) manpage: link:manpages/stdlib/labs.3.rst[labs] +


ldiv::

  static ldiv_t ldiv(long int numerator, long int denominator);
 +
  (link:../include/math.h[../include/math.h] l.16) manpage: link:manpages/stdlib/ldiv.3.rst[ldiv] +


malloc::

  void* malloc(int size);
 +
  Defines: brk +
 (link:../src/malloc.c[../src/malloc.c] l.119) manpage: link:manpages/stdlib/memory.3.rst[malloc] +
0 +
  Here we go.. with the .. well.  +
  Fastes and smallest malloc/free combi ever.  +
  Not the smartest. +
  Since it isn't exactly a memory allocation, +
  instead it (mis)uses the minilib buf. +
  ;) 1024 Bytes should be enough for everyone. +
   Ok. If you really do need more memory -  +
   rethink your design, increase mini_mbuf, +
   or use a proper malloc implementation. +
  +
  Here we use mbuf from top to bottom as stack. +
  64 Bytes are left at the bottom as reserve. +
  Possibly we'd like to complain +
  about the lack of memory, before we exit.. +
  +
  ATM, the 'free' is really lazy.  +
  It free's memory, but a real 'free' is only commited, +
  when all memory below a freed area is also freed. +
  Since the target of minilib atm are tiny tools,  +
  this might be ok. +
  ;) but, as I told before -  +
  probably you should look out for a proper malloc implementation. +
  It depends on your needs. +
  +
  I'm not sure yet,  +
  whether another implementation of free would be useful at all. +
  Overall, I'd really prefer keeping minilib tiny. +
  +
  Reusing sparse freed memory areas also leads  +
  to a whole bunch of complications. +
  cache misses, searching complexity, +
  storage overhead, potentially page faults, +
  just to name a few. +
  +
  I'm not sure whether it's worth it. +
  +
  And the existing malloc implementations  +
  out there are countless. +
  +
  ;) It's sometimes smarter to stay special, +
  although in this case this means the opposite. +
  /misc +
  +
  The memory layout looks like this: +
  mlgl->ibuf and mlgl->mbuf do point to the same address range. +
  mlgl->ibuf is provided for alignment and faster access to the int values. +
  +
  flag prev free is the first bit in size. (0x8000, eq 1000 0000 0000 0000 binary when free),  +
  (mbufsize) +
  ``` +
       size  data  size    mini_buf size +
       8008dataxxxx0004data8000| +
       ----========----====----| +
  +
  also, when free space is in between two areas +
   +
  8004data8008  free  0004data8000| +
  ----====----________----====----| +
  +
  ``` +
  the free space is only freed,  +
  when all areas below (left) have been free'd as well. +
  +
  Memory is allocated from right to left,  +
  meaning from top to down. +
 

malloc_brk::

  void* malloc_brk(int size);
 +
  Defines: sbrk +
 (link:../src/malloc.c[../src/malloc.c] l.206)  +
allocate via setting the brk +
  free and realloc can be used normally. +
  The intention of malloc_brk is for subsequent calls to realloc. +
  The saved data has not to be copied, +
  instead realloc just writes the new size and sets  +
  the brk accordingly. +
  if the break is saved before one or more calls to malloc_brk, +
  the allocated memory can also be free'd by setting the brk to the saved value +
  with brk(saved_brk) +
  free_brk() free's all memory, which has been allocated with malloc_brk +
 

qsort::

  void qsort(void  *base,	size_t nel,	size_t width,	int (*comp)(const void *, const void *));
 +
  (link:../src/qsort.c[../src/qsort.c] l.56) manpage: link:manpages/stdlib/qsort.3.rst[qsort] +
(quick) shell sort routine +
  following the tradition, this isn't exactly a quicksort algorithm, +
  albite named quicksort. +
  It is a shell sort implementation, originally done by Ray Gardner, 5/90. +
 

rand::

  unsigned int rand();
 +
  (link:../src/rand.c[../src/rand.c] l.15) manpage: link:manpages/stdlib/rand.3.rst[rand] +


realloc::

  void* realloc(void *p, int size);
 +
  Defines: getbrk brk +
 (link:../src/malloc.c[../src/malloc.c] l.252) manpage: link:manpages/stdlib/memory.3.rst[realloc] +


srand::

  void srand( unsigned int i );
 +
  (link:../src/rand.c[../src/rand.c] l.7) manpage: link:manpages/stdlib/rand.3.rst[srand] +


strtol::

  long int strtol(const char *c, const char **endp, int base);
 +
  (link:../src/strtol.c[../src/strtol.c] l.5) manpage: link:manpages/stdlib/strtol.3.rst[strtol] +
conversion +
  doesn't check for overflow(!) +
 

system::

  int system( const char* command );
 +
  Defines: wait4 environ write vfork execve +
 (link:../src/system.c[../src/system.c] l.4) manpage: link:manpages/stdlib/system.3.rst[system] +




 string.h
----------

_strcasecmp::

  int _strcasecmp(const char*c1,const char*c2,int len);
 +
  Defines: tolower +
 (link:../src/strcmp.c[../src/strcmp.c] l.27)  +


_strcmp::

  int _strcmp(const char*c1,const char*c2,int len);
 +
  (link:../src/strcmp.c[../src/strcmp.c] l.10)  +


memcmp::

  int memcmp(const void* c1,const void* c2,int len);
 +
  Defines: 0 +
 (link:../src/strcmp.c[../src/strcmp.c] l.84) manpage: link:manpages/string/memcmp.3.rst[memcmp] +


memcpy::

  void *memcpy( void *d, const void *s, int n );
 +
  (link:../src/memcpy.c[../src/memcpy.c] l.6) manpage: link:manpages/string/memcpy.3.rst[memcpy] +


memmove::

  void* memmove(void *dest, const void *src, int n);
 +
  (link:../src/memmove.c[../src/memmove.c] l.3) manpage: link:manpages/string/memmove.3.rst[memmove] +


memset::

  void *memset( void *s, int c, int n);
 +
  (link:../src/memset.c[../src/memset.c] l.3) manpage: link:manpages/string/memset.3.rst[memset] +


strcasecmp::

  int strcasecmp(const char*c1,const char*c2);
 +
  Defines:  +
 (link:../src/strcmp.c[../src/strcmp.c] l.48) manpage: link:manpages/string/string.3.rst[strcasecmp] +


strcat::

  char *strcat(char *dest, const char *src );
 +
  Defines: strlen +
 (link:../src/strcat.c[../src/strcat.c] l.7) manpage: link:manpages/string/string.3.rst[strcat] +


strchr::

  char *strchr(const char *s, int c);
 +
  Defines: strchrnul +
 (link:../src/strchr.c[../src/strchr.c] l.20) manpage: link:manpages/string/string.3.rst[strchr] +


strchrnul::

  char *strchrnul(const char *s, int c);
 +
  (link:../src/strchr.c[../src/strchr.c] l.7) manpage: link:manpages/string/strchr.3.rst[strchrnul] +


strcmp::

  int strcmp(const char*c1,const char*c2);
 +
  Defines:  +
 (link:../src/strcmp.c[../src/strcmp.c] l.67) manpage: link:manpages/string/string.3.rst[strcmp] +


strcpy::

  char *strcpy(char *dest, const char *src);
 +
  (link:../src/memcpy.c[../src/memcpy.c] l.17) manpage: link:manpages/string/string.3.rst[strcpy] +


strdup::

  char *strdup(const char *source);
 +
  Defines: strlen brk strcpy +
 (link:../src/strdup.c[../src/strdup.c] l.7) manpage: link:manpages/string/strdup.3.rst[strdup] +


strerror::

  static char* strerror( int errnum );
 +
  (link:../src/strerror.c[../src/strerror.c] l.7) manpage: link:manpages/string/string.3.rst[strerror] +


strlen::

  int strlen(const char*str);
 +
  (link:../src/strlen.c[../src/strlen.c] l.7) manpage: link:manpages/string/strlen.3.rst[strlen] +


strncasecmp::

  int strncasecmp(const char*c1,const char*c2,int len);
 +
  Defines:  +
 (link:../src/strcmp.c[../src/strcmp.c] l.56) manpage: link:manpages/string/string.3.rst[strncasecmp] +


strncmp::

  int strncmp(const char*c1,const char*c2,int len);
 +
  Defines:  +
 (link:../src/strcmp.c[../src/strcmp.c] l.75) manpage: link:manpages/string/string.3.rst[strncmp] +


strncpy::

  char *strncpy(char *dest, const char *src, int n);
 +
  Defines: memcpy +
 (link:../src/memcpy.c[../src/memcpy.c] l.27) manpage: link:manpages/string/string.3.rst[strncpy] +


strrchr::

  char *strrchr(const char *s, int c);
 +
  Defines: strchrnul +
 (link:../src/strchr.c[../src/strchr.c] l.36) manpage: link:manpages/string/string.3.rst[strrchr] +


strstr::

  char* strstr(const char *big, const char *little);
 +
  (link:../src/strstr.c[../src/strstr.c] l.3) manpage: link:manpages/string/strstr.3.rst[strstr] +




 sys/wait.h
------------

wait::

  pid_t wait(int *wstatus);
 +
  Defines: wait4 +
 (link:../src/wait.c[../src/wait.c] l.8) manpage: link:manpages/sys/wait.2.rst[wait] +


waitpid::

  pid_t waitpid(pid_t pid, int *wstatus, int options);
 +
  Defines: wait4 +
 (link:../src/wait.c[../src/wait.c] l.16) manpage: link:manpages/sys/wait.2.rst[waitpid] +




 time.h
--------

time::

  time(unsigned int *a1 )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.206) manpage: link:manpages/gen/time.3.rst[time] +




 unistd.h
----------

access::

  access( const char *filename, int mode)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.157) manpage: link:manpages/sys/access.2.rst[access] +


chdir::

  chdir(const char* path)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.107) manpage: link:manpages/sys/chdir.2.rst[chdir] +


chown::

  chown( const char *filename, uid_t user, gid_t group)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.188) manpage: link:manpages/sys/chown.2.rst[chown] +


chroot::

  chroot( const char *filename)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.137) manpage: link:manpages/sys/chroot.2.rst[chroot] +


close::

  close( int fd )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.96) manpage: link:manpages/sys/close.2.rst[close] +


dup::

  dup(int fd)		
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.112) manpage: link:manpages/sys/dup.2.rst[dup] +


dup2::

  dup2(int oldfd, int newfd)		
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.113) manpage: link:manpages/sys/dup.2.rst[dup2] +


execl::

  static int execl(const char *pathname, const char* arg0,... );
 +
  Defines: execve environ +
 (link:../src/execl.c[../src/execl.c] l.6) manpage: link:manpages/gen/exec.3.rst[execl] +


execv::

  static inline int execv(const char *pathname, char *const argv[]);
 +
  Defines: execve environ +
 (link:../src/execvp.c[../src/execvp.c] l.9) manpage: link:manpages/gen/exec.3.rst[execv] +


execve::

  execve( const char *filename,  char* const* argv, char* const* envp)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.123) manpage: link:manpages/sys/execve.2.rst[execve] +


execvp::

  static inline int execvp(const char *file, char *const argv[]);
 +
  Defines: access environ execve +
 (link:../src/execvp.c[../src/execvp.c] l.58) manpage: link:manpages/gen/exec.3.rst[execvp] +


execvpe::

  static int execvpe(const char *file, char *const argv[], char *const envp[]);
 +
  Defines: environ access execve +
 (link:../src/execvp.c[../src/execvp.c] l.18)  +
When invoked with a filename, starting with "." or "/", +
  interprets this as absolute path. (calls execve with the pathname) +
  Looks for file in the PATH environment, othwerise. +
 

fork::

  DEF_syscall(fork,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.127) manpage: link:manpages/sys/fork.2.rst[fork] +


fsync::

  fsync(int a1 )
 +
 (link:../include/lseek.h[../include/lseek.h] l.22) manpage: link:manpages/sys/fsync.2.rst[fsync] +


ftruncate::

  ftruncate(unsigned int a1, unsigned int a2 )
 +
 (link:../include/lseek.h[../include/lseek.h] l.21) manpage: link:manpages/sys/truncate.2.rst[ftruncate] +


getgid::

  DEF_syscall(getgid,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.192) manpage: link:manpages/sys/getgid.2.rst[getgid] +


getpgrp::

  DEF_syscall(getpgrp,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.193) manpage: link:manpages/sys/getpgrp.2.rst[getpgrp] +


getpid::

  DEF_syscall(getpid,0 )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.141) manpage: link:manpages/sys/getpid.2.rst[getpid] +


getuid::

  DEF_syscall(getuid,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.195) manpage: link:manpages/sys/getuid.2.rst[getuid] +


isatty::

  int isatty(int fd);
 +
  Defines: ioctl +
 (link:../src/isatty.c[../src/isatty.c] l.7) manpage: link:manpages/gen/ttyname.3.rst[isatty] +


link::

  link( const char *oldname, const char *newname)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.118) manpage: link:manpages/sys/link.2.rst[link] +


lseek::

  lseek(unsigned int a1, int a2, int a3 )
 +
 (link:../include/lseek.h[../include/lseek.h] l.19) manpage: link:manpages/sys/lseek.2.rst[lseek] +


mkdir::

  mkdir( const char *pathname, int mode)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.154) manpage: link:manpages/sys/mkdir.2.rst[mkdir] +


open::

  int volatile open( const char *s, int flags, ... );
 +
  (link:../src/open.c[../src/open.c] l.19) manpage: link:manpages/sys/open.2.rst[open] +
open or create a file. +
  warning: when using the flag O_CREAT, +
  file permission flags have to be given +
  as third argument. Otherwise file permission +
  flags will be random. (I still do not know, what  +
  the flag showing up as "-T" means..) +
 

pipe::

  pipe( int *filedes)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.185) manpage: link:manpages/sys/pipe.2.rst[pipe] +


read::

  read( int fd, void *buf, int len )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.97) manpage: link:manpages/sys/read.2.rst[read] +


rename::

  rename( const char* oldpath, const char* newpath )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.102) manpage: link:manpages/sys/rename.2.rst[rename] +


rmdir::

  rmdir( const char *pathname)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.155) manpage: link:manpages/sys/rmdir.2.rst[rmdir] +


select::

  static int volatile __attribute__((optimize("O0"))) select(int fd, volatile fd_set* readfd, volatile fd_set *writefd, volatile fd_set *exceptfd, volatile struct timeval *wait);
 +
  (link:../include/select.h[../include/select.h] l.9) manpage: link:manpages/sys/select.2.rst[select] +


setgid::

  setgid( gid_t gid)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.143) manpage: link:manpages/sys/setuid.2.rst[setgid] +


setpgid::

  setpgid( pid_t pid, pid_t pgid)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.191) manpage: link:manpages/sys/setpgid.2.rst[setpgid] +


setsid::

  DEF_syscall(setsid,0 )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.142) manpage: link:manpages/sys/setsid.2.rst[setsid] +


setuid::

  setuid( uid_t uid)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.144) manpage: link:manpages/sys/setuid.2.rst[setuid] +


sleep::

  unsigned int volatile sleep(unsigned int seconds);
 +
  (link:../src/sleep.c[../src/sleep.c] l.10) manpage: link:manpages/gen/sleep.3.rst[sleep] +
nonconformant sleep +
  TODO: ignore blocked signals, sigchld +
 

tcgetattr::

  static inline int __attribute__((always_inline)) tcgetattr(int fd, struct termios *io);
 +
  Defines: ioctl +
 (link:../include/tcgetattr.h[../include/tcgetattr.h] l.21) manpage: link:manpages/gen/tcsetattr.3.rst[tcgetattr] +


tcsetattr::

  static inline int __attribute__((always_inline)) tcsetattr(int fd, int opt, const struct termios *io);
 +
  Defines: ioctl +
 (link:../include/tcsetattr.h[../include/tcsetattr.h] l.20) manpage: link:manpages/gen/tcsetattr.3.rst[tcsetattr] +


unlink::

  unlink( const char* path)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.103) manpage: link:manpages/sys/unlink.2.rst[unlink] +


usleep::

  unsigned int volatile usleep(unsigned int useconds);
 +
  (link:../src/sleep.c[../src/sleep.c] l.31) manpage: link:manpages/gen/usleep.3.rst[usleep] +
nonconformant usleep.  +
  Sleep useconds. +
  I just hope, noone relies on an exact sleep time. +
  which isn't possible without a real time os, anyways. +
  When for whatever reason you'd need nanoseconds exact times, +
  best shot might be a spinloop, and looking for cpu ticks. +
  +
  TODO: ignore blocked signals, sigchld +
 

write::

  write(int fd,const void *buf, int len )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.98) manpage: link:manpages/sys/write.2.rst[write] +



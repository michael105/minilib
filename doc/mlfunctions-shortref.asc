 implemented functions
=======================

short ref, links to source files.

Only functions defined are going to be built.

To define them, either do (for, e.g. puts) `#define mini_puts`
before you include minilib.h

Or, use the config script.: `mini_puts`

Some functions define other functions, these will be listed in the line,
starting with `Define:`


An example, using the scripting config, is given below:
(miniputs.c)
----
#if 0
mini_start
mini_puts

LDSCRIPT text_and_bss
INCLUDESRC
shrinkelf

return
#endif

int main(){
  puts("Hello, world!");
  return(0);
}
----

compile with ./mini-gcc --config miniputs.c -o miniputs miniputs.c

(what compiles to an annoying size of 251 Bytes here. Something again bloats.
replacing the puts with writes, there still are 208 Bytes. This used to
be 151 Bytes. Have to sort this out.)

:toc:






 declarations.h
----------------

bind::

  bind( int fd,  struct sockaddr *umyaddr,  int addrlen)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.223) manpage: link:manpages/sys/bind.2.rst[bind] +


chmod::

  chmod( const char *filename, mode_t mode)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.192) manpage: link:manpages/sys/chmod.2.rst[chmod] +


clone::

  clone( int clone_flags,  unsigned long stack,  void *parent_tid,  void *child_tid)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.211)  +


dup3::

  dup3(int oldfd, int newfd, int flags)		
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.121) manpage: link:manpages/gen/dup3.3.rst[dup3] +


execveat::

  execveat( int dirfd, const char *filename,  char* const* argv, char* const* envp, int flags)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.164)  +


fchmod::

  fchmod( unsigned int fd, mode_t mode)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.117) manpage: link:manpages/sys/chmod.2.rst[fchmod] +


fchown::

  fchown( unsigned int fd, uid_t user, gid_t group)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.116) manpage: link:manpages/sys/chown.2.rst[fchown] +


fcntl::

  fcntl( unsigned int fd, unsigned int cmd, unsigned long arg)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.169) manpage: link:manpages/sys/fcntl.2.rst[fcntl] +


flock::

  flock( unsigned int fd,  unsigned int cmd)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.129) manpage: link:manpages/sys/flock.2.rst[flock] +


fstat::

  fstat(int fd,struct stat* statbuf)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.111) manpage: link:manpages/sys/stat.2.rst[fstat] +


getcwd::

  getcwd( char *buf,  unsigned long size)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.123) manpage: link:manpages/gen/getcwd.3.rst[getcwd] +


getdents::

  getdents( unsigned int fd, struct dirent *direntry, unsigned int count )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.106) manpage: link:manpages/sys/getdirentries.2.rst[getdents] +


getitimer::

  getitimer( int which,  struct itimerval *value)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.245) manpage: link:manpages/sys/getitimer.2.rst[getitimer] +


getppid::

  DEF_syscall(getppid,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.195) manpage: link:manpages/sys/getpid.2.rst[getppid] +


getresuid::

  getresuid( uid_t *ruid,  uid_t *euid,  uid_t *suid)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.201) manpage: link:manpages/sys/setresuid.2.rst[getresuid] +


getsockopt::

  getsockopt( int fd,  int level,  int optname,  char *optval,  int *optlen)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.227) manpage: link:manpages/sys/getsockopt.2.rst[getsockopt] +


gettimeofday::

  gettimeofday( struct timeval *a1, struct timezone *a2)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.142) manpage: link:manpages/sys/gettimeofday.2.rst[gettimeofday] +


inotify_add_watch::

  inotify_add_watch( int fd,  const char *pathname,  u32 mask)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.206)  +


inotify_init::

  DEF_syscall(inotify_init,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.205)  +


inotify_init1::

  inotify_init1( int flags)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.208)  +


inotify_rm_watch::

  inotify_rm_watch( int fd,  __s32 wd)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.207)  +


kill::

  kill( pid_t pid,  int sig)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.135) manpage: link:manpages/sys/kill.2.rst[kill] +


lstat::

  lstat(const char* filename,struct stat* statbuf)		
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.113) manpage: link:manpages/sys/stat.2.rst[lstat] +


memfd_create::

  memfd_create( const char  *uname_ptr,  unsigned int flags)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.182)  +


mknod::

  mknod( const char *filename,  umode_t mode,  unsigned dev)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.239) manpage: link:manpages/sys/mknod.2.rst[mknod] +


mount::

  mount( char *dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.175) manpage: link:manpages/sys/mount.2.rst[mount] +


mprotect::

  mprotect( POINTER *a1, POINTER a2, int a3 )
 +
 Returns: *a1 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.234) manpage: link:manpages/sys/mprotect.2.rst[mprotect] +


msync::

  msync( void* addr,  size_t len, int flags)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.242) manpage: link:manpages/sys/msync.2.rst[msync] +


munmap::

  munmap( void* addr,  size_t len)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.241) manpage: link:manpages/sys/munmap.2.rst[munmap] +


nanosleep::

  nanosleep( struct timespec *rqtp, struct timespec *rmtp)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.141) manpage: link:manpages/sys/nanosleep.2.rst[nanosleep] +


pivot_root::

  pivot_root( const char *new_root,  const char *put_old)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.148)  +


prctl::

  prctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.254)  +


readahead::

  readahead( int fd,  loff_t offset,  size_t count)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.238)  +


reboot::

  reboot( int magic1,  int magic2,  unsigned int cmd,  void *arg)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.173) manpage: link:manpages/sys/reboot.2.rst[reboot] +


recvfrom::

  recvfrom( int fd,  void *ubuf,  size_t size,  unsigned flags,  struct sockaddr *addr,  unsigned int *addr_len)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.219) manpage: link:manpages/sys/recv.2.rst[recvfrom] +


rt_sigaction::

  rt_sigaction( int sig,  const struct sigaction *act,  struct sigaction *oact,  size_t sigsetsize)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.144)  +


rt_sigprocmask::

  rt_sigprocmask( int how,  sigset_t *nset,  sigset_t *oset,  size_t sigsetsize)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.177)  +


rt_sigreturn::

  rt_sigreturn( unsigned long __unused)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.145)  +


rt_sigsuspend::

  rt_sigsuspend( const sigset_t *mask, size_t sigsetsize);
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.179)  +


sendfile::

  sendfile( int out_fd,  int in_fd,  off_t *offset,  size_t count)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.172) manpage: link:manpages/sys/sendfile.2.rst[sendfile] +


sendto::

  sendto( int fd,  void *buff,  size_t len,  unsigned flags,  struct sockaddr *addr,  int addr_len)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.221) manpage: link:manpages/sys/send.2.rst[sendto] +


setgroups::

  setgroups( int gidsetsize,  gid_t *grouplist)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.190) manpage: link:manpages/sys/setgroups.2.rst[setgroups] +


setitimer::

  setitimer( int which,  struct itimerval *value,  struct itimerval *ovalue)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.244) manpage: link:manpages/sys/getitimer.2.rst[setitimer] +


setresuid::

  setresuid( uid_t *ruid,  uid_t *euid,  uid_t *suid)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.202) manpage: link:manpages/sys/setresuid.2.rst[setresuid] +


setreuid::

  setreuid( uid_t ruid,  uid_t euid)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.155) manpage: link:manpages/sys/setreuid.2.rst[setreuid] +


setsockopt::

  setsockopt( int fd,  int level,  int optname,  const void *optval,  int optlen)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.225) manpage: link:manpages/sys/getsockopt.2.rst[setsockopt] +


socket::

  socket( int family,  int type,  int protocol)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.215) manpage: link:manpages/sys/socket.2.rst[socket] +


splice::

  splice( int fd_in,  loff_t *off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.187)  +


stat::

  stat(const char* filename,struct stat* statbuf)		
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.112) manpage: link:manpages/sys/stat.2.rst[stat] +


symlink::

  symlink( const char *oldname,  const char *newname)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.126) manpage: link:manpages/sys/symlink.2.rst[symlink] +


sync::

  DEF_syscall(sync,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.127) manpage: link:manpages/sys/sync.2.rst[sync] +


timerfd_create::

  timerfd_create( int clockid,  int flags)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.248)  +


timerfd_gettime::

  timerfd_gettime( int ufd,  struct itimerspec *otmr)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.252)  +


timerfd_settime::

  timerfd_settime( int ufd,  int flags,  const struct itimerspec *utmr,  struct itimerspec *otmr)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.250)  +


umask::

  umask( int mask)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.237) manpage: link:manpages/sys/umask.2.rst[umask] +


umount2::

  umount2( const char *mountpoint, int flags) 
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.171)  +


uname::

  uname(struct new_utsname *name )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.159) manpage: link:manpages/gen/uname.3.rst[uname] +


utime::

  utime( const char *filename, struct utimbuf *times)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.194) manpage: link:manpages/gen/utime.3.rst[utime] +


vfork::

  DEF_syscall(vfork,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.138) manpage: link:manpages/sys/vfork.2.rst[vfork] +


vhangup::

  DEF_syscall(vhangup,0 )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.157)  +


wait4::

  wait4( pid_t upid,  int *stat_addr,  int options,  struct rusage *ru)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.167) manpage: link:manpages/sys/wait.2.rst[wait4] +




 dirent.h
----------

closedir::

  int closedir(DIR *dir);
 +
  Defines: getbrk brk +
 (link:../src/directories/closedir.c[../src/directories/closedir.c] l.6) manpage: link:manpages/gen/directory.3.rst[closedir] +


opendir::

  static DIR *opendir(const char *name );
 +
  Defines: 0 close getbrk brk write dirbuf open +
 (link:../src/directories/opendir.c[../src/directories/opendir.c] l.10) manpage: link:manpages/gen/directory.3.rst[opendir] +


readdir::

  struct dirent *readdir(DIR *dir);
 +
  Defines: dirbuf getdents +
 (link:../src/directories/readdir.c[../src/directories/readdir.c] l.10) manpage: link:manpages/gen/directory.3.rst[readdir] +
read a directory. +
  return the next dirent, or 0, if the end is reached. +
  return 0 on error and set errno, +
  if mini_errno is not defined, return -errno on error +
 

rewinddir::

  void rewinddir(DIR *dir);
 +
  (link:../src/directories/rewinddir.c[../src/directories/rewinddir.c] l.2) manpage: link:manpages/gen/directory.3.rst[rewinddir] +


scandir::

  int scandir(const char *path, struct dirent **listing[], int (*fp_select)(const struct dirent *),	int (*cmp)(const struct dirent **, const struct dirent **));
 +
  Defines: qsort strlen memcpy 0 getbrk brk sbrk dirbuf open errno seterrno write +
 (link:../src/directories/scandir.c[../src/directories/scandir.c] l.35) manpage: link:manpages/gen/scandir.3.rst[scandir] +
list files and dirs in a directory +
  +
  This implementation uses malloc_brk() for the dynamic allocation +
  of the listing, and tries to do as less copies as possible. +
  The dynamically allocated space for the result list (**listing[]) +
  is guaranteed to be at one continuous memory location. +
  +
  if the select callback is 0, meaning all entries should be returned, +
  There are no copies done at all,  +
  besides the copying from kernelspace to userspace. +
  +
  To free the space, allocated for the listing, +
  either call free_brk(), +
  when no other allocations via malloc_brk took place. +
  +
  Or save the brk before you call scandir, +
  and restore it after the call. +
  (e.g.) +
  long savebrk=getbrk(); +
  int ret=scandir(...); +
  brk(savebrk); +
  Freeing single list entries might give unexpected results. +
  +
  returns the number of the read entries, +
  or the negative errno on error. +
 

seekdir::

  void seekdir(DIR *dir, long off);
 +
  (link:../src/directories/seekdir.c[../src/directories/seekdir.c] l.2) manpage: link:manpages/gen/directory.3.rst[seekdir] +


telldir::

  long telldir(DIR *dir);
 +
  (link:../src/directories/telldir.c[../src/directories/telldir.c] l.2) manpage: link:manpages/gen/directory.3.rst[telldir] +




 fcntl.h
---------

creat::

  int volatile creat( const char *s, int mode );
 +
  Defines: open +
 (link:../src/file/open.c[../src/file/open.c] l.36) manpage: link:manpages/compat-43/creat.2.rst[creat] +


mkfifo::

  static int mkfifo( const char* path, mode_t mode );
 +
  (link:../include/mkfifo.h[../include/mkfifo.h] l.4) manpage: link:manpages/sys/mkfifo.2.rst[mkfifo] +




 ioctl.h
---------

ioctl::

  int volatile  __attribute__((optimize("O0"))) ioctl( int fd, unsigned long int request, ... );
 +
  (link:../src/system/ioctl.c[../src/system/ioctl.c] l.9) manpage: link:manpages/sys/ioctl.2.rst[ioctl] +




 mini_addons.h
---------------

ALIGN::

  
 +
  (link:../macros/alignment.h[../macros/alignment.h] l.9)  +
macros for alignment. +
  They take a number or pointer, and align upwards to 2,4,8,..256 +
  There are the macros ALIGN_2 ALIGN_4 ALIGN_8 ..., +
  and ALIGN_P, which aligns to the size of a pointer. (8 for amd64) +
 

OPTFENCE::

  static void __attribute__((noipa,cold,naked)) opt_fence(void*p,...);
 +
  (link:../include/syscall.h[../include/syscall.h] l.65)  +
prevent gcc to optimize away registers and variables +
  the macro OPTFENCE(...) can be invoked with any parameter. +
  The parameters will get calculated, even if gcc doesn't recognize +
  the use of the parameters, e.g. cause they are needed for an inlined asm syscall. +
  +
  The macro translates to an asm jmp and a function call to the function  +
  opt_fence, which is defined with the attribute "noipa" - +
  (the compiler "forgets" the function body, so gcc is forced +
  to generate all arguments for the function) +
  The generated asm jump hops over the call to the function, +
  but this gcc doesn't recognize. +
  +
  This generates some overhead,  +
  (a few (never reached) bytes for setting up the function call, and the jmp) +
  but I didn't find any other solution, +
  which gcc wouldn't cut for optimizations from time to time. +
  (volatile, volatile asm, optimize attributes,  +
  andsoon have all shown up to be unreliable - sometimes(!)). +
  +
  Had some fun debugging these bugs, which naturally showed up only sometimes. +
  (Many syscalls also work with scrambled arguments..) +
  And, I believe it IS a compiler bug.  +
  Volatile should be volatile for sure, not only sometimes. +
  I mean, why the heck do I write volatile??  +
 

OPTIMIZATIONS::

  
 +
  (link:../include/config.h[../include/config.h] l.33)  +
enable some optimizations, +
  with a slitghtly bigger memory footprint. +
  defaults to off +
  (yet only calloc is optimized. todo) +
 

_die::

  void _die();
 +
  (link:../src/process/die.c[../src/process/die.c] l.36)  +
internal implementation of die +
 

_itobin::

  int _itobin(int i, char*buf, int prec, int groups );
 +
  (link:../src/conversions/itobin.c[../src/conversions/itobin.c] l.8)  +


_match::

  int _match(char *text, const char *re, text_match *st_match);
 +
  (link:../src/match/match.c[../src/match/match.c] l.96)  +


_match_ext2::

  char* _match_ext2(char *text, char *re, void(*p_matched_cb)(int number, char *pos,int len), int(*p_wildcard_cb)(int number, char *match_char), text_match *st_match);
 +
  (link:../src/match/match_ext2.c[../src/match/match_ext2.c] l.326)  +
internal implementation of match_ext +
 

_mprints::

  #define _mprints(...) dprints(STDOUT_FILENO, __VA_ARGS__)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.10)  +


alphasort::

  int alphasort( const struct dirent** de1, const struct dirent** de2 );
 +
  Defines:  +
 (link:../src/directories/alphasort.c[../src/directories/alphasort.c] l.7) manpage: link:manpages/gen/scandir.3.rst[alphasort] +
Sort dirents by name. +
  Deviating of the standard,  +
  the asciitables is used for the comparison +
  (using strcmp) +
 

ansicolors::

  
 +
  (link:../include/ansicolors.h[../include/ansicolors.h] l.45)  +
defines for ansicolors at the console, 16 color mode +
 the names are: +
  AC_NORM ( white text on black background) +
  AC_BLACK  +
  AC_RED  +
  AC_GREEN  +
  AC_BROWN  +
  AC_BLUE  +
  AC_MAGENTA  +
  AC_MARINE (= AC_CYAN) +
  AC_LGREY  +
  AC_WHITE  +
  AC_GREY  +
  AC_LRED  +
  AC_LGREEN  +
  AC_YELLOW  +
  AC_LBLUE  +
  AC_LMAGENTA  +
  AC_LMARINE (= AC_LCYAN) +
  AC_LWHITE  +
  AC_BGBLACK  +
  AC_BGRED  +
  AC_BGGREEN  +
  AC_BGBROWN  +
  AC_BGBLUE  +
  AC_BGMAGENTA  +
  AC_BGMARINE  +
  AC_BGLGREY  +
  AC_BGWHITE  +
  +
  AC_BOLD +
  AC_FAINT +
  AC_CURSIVE +
  AC_UNDERLINE +
  AC_LIGHTBG +
  AC_BLINK +
  AC_INVERTED +
  AC_INVERSE +
  +
  ( Faint to inverse are not available at every terminal ) +
 

basename::

  char *basename(char *path);
 +
  (link:../src/directories/basename.c[../src/directories/basename.c] l.2) manpage: link:manpages/gen/basename.3.rst[basename] +


brk::

  static int brk( const void* addr );
 +
  (link:../src/memory/brk.c[../src/memory/brk.c] l.19) manpage: link:manpages/sys/brk.2.rst[brk] +
set the brk to addr +
  return 0 on success. +
  conformant brk, when mini_errno is defined return -1 and set errno. +
  if errno isn't available, +
  returns the negative errno value on error +
 

bsd_cksum::

  unsigned int bsd_cksum( const char* p, unsigned int len );
 +
  (link:../src/file/cksum.c[../src/file/cksum.c] l.31)  +
bsd checksum +
 

bsd_cksumblock::

  unsigned int bsd_cksumblock( unsigned int hash, const char* p, unsigned int len );
 +
  (link:../src/file/cksum.c[../src/file/cksum.c] l.20)  +
bsd checksum, called by bsd_cksum, +
  with initial hash value +
 

cfmakeraw::

  void cfmakeraw(struct termios *tp);
 +
  Defines: termio +
 (link:../src/termios/cfmakeraw.c[../src/termios/cfmakeraw.c] l.3) manpage: link:manpages/gen/tcsetattr.3.rst[cfmakeraw] +


clone_t::

  int clone_t(int flags);
 +
  (link:../src/process/clone.c[../src/process/clone.c] l.7)  +


config::

  
 +
  (link:../include/config.h[../include/config.h] l.6)  +
configuration settings, to be compiled statically. +
  System specific paths, maximums, etc go here. +
  Other values are within globaldefs.h; +
  architecture specific values are within the folder headers. +
 

def::

  #define SETOPT_short( opts, option ) (;
 +
  (link:../macros/getoptm.h[../macros/getoptm.h] l.52)  +
Set a option flag(s) (bit(s))  manually. +
 		param options: e.g. just a, or ( a+h+l) to check for several flags at once +
 

die::

  #define die(errnum,msg) {ewritesl(msg);exit_errno(errnum);}
 +
  Defines: write exit execve errno_str +
 (link:../src/process/die.c[../src/process/die.c] l.11)  +
write msg to stderr and exit with failure +
  if errno is defined and set, /bin/errno is executed to give a verbose error  +
  message +
  if errno is either not defined or not set, +
  exit with -1 +
   +
 

die_if::

  #define die_if( when, errnum, msg ) if( when ) die( errnum, msg )
 +
  Defines: execve exit write errno_str +
 (link:../src/process/die.c[../src/process/die.c] l.59)  +
when arg1 is true, write msg to stderr and exit with failure +
  if errno is defined and set, /bin/errno is executed to give a verbose error  +
  message +
  if errno is either not defined or not set, +
  exit with -1 +
   +
 

dief::

  #define dief(errnum,fmt,...) {fprintf(stderr,fmt,__VA_ARGS__);exit_errno(errnum);}
 +
  Defines: strlen exit execve errno_str fileno write +
 (link:../src/process/die.c[../src/process/die.c] l.20)  +
write fmt andargs via fprintf to stderr and exit with failure +
  if errno is defined and set, /bin/errno is executed to give a verbose error  +
  message +
  if errno is either not defined or not set, +
  exit with -1 +
   +
 

dief_if::

  #define dief_if( when, errnum, fmt,... ) if( when ) dief( errnum, fmt, __VA_ARGS__ )
 +
  Defines: errno_str exit write execve +
 (link:../src/process/die.c[../src/process/die.c] l.69)  +
when arg1 is true, vall dief(errnum,fmt) +
  if errno is defined and set, /bin/errno is executed to give a verbose error  +
  message +
  if errno is either not defined or not set, +
  exit with -1 +
   +
 

dies::

  #define dies(errnum,...) {eprintsl(__VA_ARGS__);exit_errno(errnum);}
 +
  Defines: errno_str exit write execve +
 (link:../src/process/die.c[../src/process/die.c] l.30)  +
write variable string list to stderr and exit with failure +
  if errno is defined and set, /bin/errno is executed to give a verbose error  +
  message +
  if errno is either not defined or not set, +
  exit with -1 +
   +
 

dies_if::

  #define dies_if( when, errnum, ... ) if( when ) dies( errnum, __VA_ARGS__ )
 +
  Defines: errno_str execve write exit +
 (link:../src/process/die.c[../src/process/die.c] l.80)  +
when arg1 is true, vall dies(errnum, ... ) +
  if errno is defined and set, /bin/errno is executed to give a verbose error  +
  message +
  if errno is either not defined or not set, +
  exit with -1 +
   +
 

dirbuf::

  
 +
  (link:../include/dirent.h[../include/dirent.h] l.7)  +
the switch for defining the dirbuf. +
  used internally +
 

dirbuf_malloc::

  #ifndef mini_dirbuf_malloc
 +
  (link:../include/dirent.h[../include/dirent.h] l.31)  +
which malloc to use for allocating the dir handles +
  malloc : use malloc, therefore the minibuf +
  malloc_brk : use malloc_brk  +
  defaults to malloc +
 

dirbufsize ::

  #ifndef mini_dirbufsize
 +
  (link:../include/dirent.h[../include/dirent.h] l.22)  +
the dir stream bufsize +
  The size of the buffer can be changed by setting mini_dirbufsize +
  to it's size in Bytes. (default 2048) +
  The buffer is allocated via malloc, +
  therefore mini_buf must be set to a value greater than dirbufsize +
 

dirfd::

  int dirfd(DIR *d);
 +
  (link:../src/directories/dirfd.c[../src/directories/dirfd.c] l.2) manpage: link:manpages/gen/directory.3.rst[dirfd] +


dirname::

  char *dirname(char *s);
 +
  Defines: strlen +
 (link:../src/directories/dirname.c[../src/directories/dirname.c] l.8) manpage: link:manpages/gen/dirname.3.rst[dirname] +


djb2_hash::

  unsigned long djb2_hash(const unsigned char *str);
 +
  (link:../src/math/hashes.c[../src/math/hashes.c] l.12)  +
hashes, from d.j.Bernstein +
  (http://www.cse.yorku.ca/~oz/hash.html) +
  I've tested djb2_hash, and it gives quite good results. +
  I'm sure, Bernstein did think and test his algorithm sincerely. +
  When combining djb2_hash and sdbm_hash, the probability of collisions +
  might tend to zero. +
  Me I'm going this way. I guess. I might check djb2_hash for collisions within a space of around 8 digits. +
  The hash functions compute the hashes of a c string with a 0 at the end. +
  The cksum functions do work with a pointer and a given len. +
 

djb_cksum::

  unsigned int djb_cksum( const char* p, unsigned int len );
 +
  (link:../src/file/cksum.c[../src/file/cksum.c] l.8)  +
checksum algorithm by d.j.bernstein. +
  Didn't do any benchmarks, but the computation  +
  might be quite performant.  +
  It is a bitshift and two additions per byte. +
 

dprintf::

  int dprintf( int fd, const char *fmt, ... );
 +
  Defines: strlen write +
 (link:../src/output/dprintf.c[../src/output/dprintf.c] l.5) manpage: link:manpages/stdio/printf.3.rst[dprintf] +


dprints::

  int dprints(int fd, const char *msg,...);
 +
  Defines: write +
 (link:../src/output/prints.c[../src/output/prints.c] l.14)  +


dtodec::

  int dtodec(double d, char* buf, int precision);
 +
  Defines: uitodec +
 (link:../src/conversions/dtodec.c[../src/conversions/dtodec.c] l.10)  +


endgrent::

  void endgrent();
 +
  Defines: munmap pwent +
 (link:../src/userdb/endgrent.c[../src/userdb/endgrent.c] l.4) manpage: link:manpages/gen/getgrent.3.rst[endgrent] +


endpwent::

  void endpwent();
 +
  Defines: munmap pwent +
 (link:../src/userdb/endpwent.c[../src/userdb/endpwent.c] l.4) manpage: link:manpages/gen/getpwent.3.rst[endpwent] +


eprint::

  #define eprint(str) write(STDERR_FILENO,str,strlen(str))
 +
  Defines: write strlen +
 (link:../include/prints.h[../include/prints.h] l.57)  +
write str to stderr. Needs strlen +
 

eprintf::

  #define eprintf(fmt,...) fprintf(stderr, fmt, __VA_ARGS__)
 +
  Defines: write fileno strlen +
 (link:../include/prints.h[../include/prints.h] l.133)  +
write fmt and arguments to stderr.  +
 

eprintfs::

  #define eprintfs(fmt,...) fprintfs(stderr, fmt, __VA_ARGS__)
 +
  Defines: strlen fileno write +
 (link:../include/prints.h[../include/prints.h] l.128)  +
write fmt and arguments to stderr.  +
  only format %s and %c are recognized +
 

eprintl::

  #define eprintl() write(STDERR_FILENO,"\n",1)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.66)  +
write a newline to stderr +
 

eprints::

  #define eprints(...) dprints(STDERR_FILENO,__VA_ARGS__,0)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.26)  +
print the string(s) supplied as arg(s) to stdout +
  this macro has an variable argument count. +
 

eprintsl::

  #define eprintsl(...) dprints(STDERR_FILENO,__VA_ARGS__,"\n",0)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.48)  +
print the string(s) supplied as arg(s) and newline to stderr +
 

eputs::

  #define eputs(msg) ( eprint(msg) + eprintl() )
 +
  Defines: strlen write +
 (link:../include/prints.h[../include/prints.h] l.76)  +
write msg to stderr, append a newline. Needs strlen. +
 

err::

  #define err( status, fmt ... ) { fprintf(stderr,fmt ); fprints(stderr,":",strerror(errno)); exit(status); }
 +
  Defines: fileno write exit strerror errno strlen +
 (link:../src/process/error.c[../src/process/error.c] l.20) manpage: link:manpages/gen/err.3.rst[err] +
print an error message to stderr, +
  print an error message dependend on errno ( strerror(errno) ), +
  exit with status +
 

errno_str::

  static char *errno_str(int err);
 +
  (link:../src/process/errno_str.c[../src/process/errno_str.c] l.7)  +
convert errno to str, with 3 chars length +
  ending the string (global)  +
  with two \0\0, when errno<100 +
  errnum must be <200. +
 

error::

  #define error( status, errnum, fmt ... ) { fprintf(stderr,fmt ); if (errnum) fprints(stderr,":",strerror(errnum)); if ( status ) exit(status); }
 +
  Defines: fileno write exit strlen strerror +
 (link:../src/process/error.c[../src/process/error.c] l.13)  +
print an error message to stderr +
  when errnum is not 0, print either the number, +
   or a verbose error message (with strerror),  +
   when mini_verbose_errstr is defined. +
   (verbose error messages add aboyut 4kB) +
  +
  when status is non null, terminate with status +
 

errx::

  #define errx( status, fmt ... ) { fprintf(stderr,fmt); exit(status); }
 +
  Defines: strlen write fileno exit +
 (link:../src/process/error.c[../src/process/error.c] l.27) manpage: link:manpages/gen/err.3.rst[errx] +
print an error message to stderr, +
  exit with status +
 

ewrites::

  #define ewrites(str) write(STDERR_FILENO,str,sizeof(str))
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.87)  +
write the constant str to stderr. Computes length with sizeof(str) at compile time. +
 

ewritesl::

  #define ewritesl(str) write(STDERR_FILENO,str"\n",sizeof(str)+1)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.100)  +
write the constant str to stderr, followed by a newline.  +
  Computes length with sizeof(str) at compile time. +
 

exit_errno::

  void exit_errno( int errnum );
 +
  Defines: errno_str write exit execve +
 (link:../src/process/exit_errno.c[../src/process/exit_errno.c] l.17)  +
exit, and execute /bin/errno +
  this is intended to give a error message for the  +
  given errno num. +
  Instead of having the error messages compiled  +
  into each binary, they can stay within one executable, "errno" +
  This spares about 4kB, but needs errno installed to /bin/errno +
  It's the drawback of not having a shared library, +
  where all executables would share the same errno messages +
  in memory. +
  On the other hand, a shared library would need to be installed +
  as well. +
  The supplied errno can be negative, +
  the absolute value is supplied to errno. +
 

fexecve::

  static inline int fexecve(int fd, char *const argv[], char *const envp[]);
 +
  (link:../include/fexecve.h[../include/fexecve.h] l.3) manpage: link:manpages/sys/execve.2.rst[fexecve] +


fexecveat::

  static inline int fexecveat(int fd, char *const argv[], char *const envp[]);
 +
  (link:../include/fexecveat.h[../include/fexecveat.h] l.3)  +


fgetsn::

  int fgetsn(char *buf, int size, FILE* F);
 +
  Defines: fileno read +
 (link:../src/streams/fgetsn.c[../src/streams/fgetsn.c] l.4)  +
get a line like fgets, but return the len of the read string. +
 

fgetsp::

  char* fgetsp(char *buf, int size, FILE* F);
 +
  Defines: fileno read +
 (link:../src/streams/fgetsp.c[../src/streams/fgetsp.c] l.7)  +
read a line from F into buf with max chars size. +
  Return a pointer to the terminating '0' byte. +
  A terminating linebreak is not written to buf. +
 

fgetud::

  unsigned int fgetud(FILE* F);
 +
  Defines: fileno read +
 (link:../src/streams/fgetud.c[../src/streams/fgetud.c] l.5)  +
read an unsigned integer from the stream F +
  reads all digits until a nondigit is read. +
 

fgetul::

  unsigned long int fgetul(FILE* F);
 +
  Defines: fileno read +
 (link:../src/streams/fgetul.c[../src/streams/fgetul.c] l.5)  +
read an unsigned long integer from the stream F +
  reads all digits until a nondigit is read. +
 

fprintfs::

  int fprintfs( FILE* F, char *fmt, ...);
 +
  Defines: strlen write fileno +
 (link:../src/output/fprintfs.c[../src/output/fprintfs.c] l.8)  +
prints formatted and unbuffered output to the stream F. +
  only %s and %c are recognized. +
  no mini_buf or globals are used, so using fprintfs instead of fprintf can save some sections / bytes. +
 

fprints::

  #define fprints(F,...) dprints(fileno(F),__VA_ARGS__,0)
 +
  Defines: strlen fileno write +
 (link:../include/prints.h[../include/prints.h] l.34)  +
print the string(s) supplied as arg(s) to stream +
  this macro has an variable argument count. +
 

free_brk::

  int free_brk();
 +
  (link:../src/memory/freebrk.c[../src/memory/freebrk.c] l.9)  +
free all memory, +
  which has been allocated with malloc_brk. +
  Returns 0, if memory has been freed; +
  1, when there hasn't been any memory allocations with +
  malloc_brk before. +
  Then brk() gives an error, return the return value of brk +
 

fwrites::

  #define fwrites(fd,str) write(fd,str,sizeof(str))
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.107)  +
write the constant str to fd. Computes length with sizeof(str) at compile time. +
 

fwritesl::

  #define fwritesl(fd,str) write(fd,str"\n",sizeof(str)+1)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.114)  +
write the constant str to fd,followed by a newline.  +
  Computes length with sizeof(str) at compile time. +
 

getbrk::

  static long getbrk();
 +
  (link:../src/memory/brk.c[../src/memory/brk.c] l.48)  +
get the current brk +
  does either a syscall to brk, +
  or returns the globally saved var +
 

getgrent::

  struct group* getgrent();
 +
  Defines: open pwent userdb +
 (link:../src/userdb/getgrent.c[../src/userdb/getgrent.c] l.4) manpage: link:manpages/gen/getgrent.3.rst[getgrent] +


getgrgid::

  struct group *getgrgid(gid_t gid);
 +
  Defines: token_s mmap token_i close fstat globals userdb setgrent pwent write grent open +
 (link:../src/userdb/getgrgid.c[../src/userdb/getgrgid.c] l.7) manpage: link:manpages/gen/getgrent.3.rst[getgrgid] +
get the group entry of the group "gid". +
  the last result is cached, multiple calls with the same +
  name will return the cached result. +
 

getgrnam::

  struct group *getgrnam(const char* name);
 +
  Defines: mmap token_s close fstat token_i setgrent pwent globals userdb open write grent +
 (link:../src/userdb/getgrnam.c[../src/userdb/getgrnam.c] l.7) manpage: link:manpages/gen/getgrent.3.rst[getgrnam] +
get the group entry of the group "name". +
  the last result is cached, multiple calls with the same +
  name will return the cached result. +
 

getgrouplist::

  int getgrouplist(const char* user, gid_t group, gid_t *groups, int *ngroups);
 +
  Defines: setpwent open write grent setgrent pwent passwdfile_open token_i mmap token_s +
 (link:../src/userdb/getgrouplist.c[../src/userdb/getgrouplist.c] l.5) manpage: link:manpages/gen/getgrouplist.3.rst[getgrouplist] +
needs rewrite. +
  now nonstandard. +
 

getpwent::

  struct passwd* getpwent();
 +
  Defines: userdb open +
 (link:../src/userdb/getpwent.c[../src/userdb/getpwent.c] l.4) manpage: link:manpages/gen/getpwent.3.rst[getpwent] +


getpwnam::

  struct passwd *getpwnam(const char* name);
 +
  Defines: globals pwent write open token_s mmap token_i fstat close +
 (link:../src/userdb/getpwnam.c[../src/userdb/getpwnam.c] l.7) manpage: link:manpages/gen/getpwent.3.rst[getpwnam] +
get the passwd entry of the user "name". +
  the last result is cached, multiple calls with the same +
  name will return the cached result. +
 

getpwuid::

  struct passwd *getpwuid(uid_t uid);
 +
  Defines: write setpwent open pwent token_i passwdfile_open token_s mmap +
 (link:../src/userdb/getpwuid.c[../src/userdb/getpwuid.c] l.7) manpage: link:manpages/gen/getpwent.3.rst[getpwuid] +
get the passwd entry of the user with uid. +
  the last result is cached, multiple calls with the same +
  uid will return the cached result. +
 

getusergroups::

  int getusergroups(const char* user, int maxgroups, int *list);
 +
  Defines: token_i passwdfile_open token_s mmap write grent setpwent open setgrent pwent +
 (link:../src/userdb/getusergroups.c[../src/userdb/getusergroups.c] l.8)  +
get the supplementary groups for the user uid. +
  does not necessarily contain the primary group, +
  which is given in the passwd entry. +
  This function calls internally setgrent() and getgrent(); +
  therefore any iteration with getgrent will be resetted. +
 

grantpt::

  int grantpt(int fd);
 +
  Defines: strlen uitodec fstat termio open ioctl write +
 (link:../src/termios/pty.c[../src/termios/pty.c] l.49) manpage: link:manpages/stdlib/ptsname.3.rst[grantpt] +


group_print::

  
 +
  Defines: strlen write fileno +
 (link:../macros/defgroups.h[../macros/defgroups.h] l.13)  +
enable print and related functions +
  This switch enables strlen; +
  but neither globals nor the mini_buf are used. +
 

group_printf::

  //
 +
  Defines: uitohex strlen uitodec fileno write ltodec uitoHEX atoi itooct globals +
 (link:../macros/defgroups.h[../macros/defgroups.h] l.29)  +
printf, eprintf, fprintf, itodec, ltodec, itohex, anprintf, sprintf (conversions %d %l %x %ud %ul %ux ),  +
 

group_write::

  
 +
  Defines: ewrite write +
 (link:../macros/defgroups.h[../macros/defgroups.h] l.23)  +
write, and related functions +
  these functions do not depend on strlen,  +
  or any globals. +
 

htonl::

  static uint32_t htonl(uint32_t i);
 +
  Defines: network +
 (link:../src/network/byteorder.c[../src/network/byteorder.c] l.19) manpage: link:manpages/net/byteorder.3.rst[htonl] +


htons::

  static uint16_t htons(uint16_t i);
 +
  Defines: network +
 (link:../src/network/byteorder.c[../src/network/byteorder.c] l.7) manpage: link:manpages/net/byteorder.3.rst[htons] +


inet_aton::

  int inet_aton(const char* s, struct in_addr *addr);
 +
  Defines: network +
 (link:../src/network/inet_aton.c[../src/network/inet_aton.c] l.3) manpage: link:manpages/net/inet.3.rst[inet_aton] +


inet_ntoa::

  char* inet_ntoa( struct in_addr in);
 +
  Defines: network +
 (link:../src/network/inet_ntoa.c[../src/network/inet_ntoa.c] l.7) manpage: link:manpages/net/inet.3.rst[inet_ntoa] +
convert a address +
  This returns a pointer to a string in the globals, +
  therefore the routine isn't reentrant. +
  (whoever thought this might be a good idea..) +
 

initgroups::

  int initgroups(const char* user, gid_t group);
 +
  (link:../src/userdb/initgroups.c[../src/userdb/initgroups.c] l.2) manpage: link:manpages/gen/initgroups.3.rst[initgroups] +


itobin::

  #define itobin(A,B,...) _itobin(A,B,VARARG(SHIFT(__VA_ARGS__),0), VARARG(SHIFT(ARG( __VA_ARGS__ )),32) )
 +
  Defines:  +
 (link:../src/conversions/itobin.c[../src/conversions/itobin.c] l.46)  +
convert a number to a binary representation. +
  the conversion assumes a size of 32bits for integers, +
  negative values are represented as they are stored internally. +
  ( -1 is 11111111111111111111111111111111, +
    -2    11111111111111111111111111111110, ...) +
 

itodec::

  int itodec(int i, char *buf, int prec, char limiter, char pad );
 +
  Defines: uitodec +
 (link:../src/conversions/itodec.c[../src/conversions/itodec.c] l.123)  +


itooct::

  int itooct(int i, char *buf);
 +
  (link:../src/conversions/itooct.c[../src/conversions/itooct.c] l.4)  +
convert int to octal +
  return the number of chars written. +
 

ltodec::

  int ltodec(long i, char *buf, int prec, char limiter );
 +
  (link:../src/conversions/ltodec.c[../src/conversions/ltodec.c] l.75)  +


malloc_brk::

  void* malloc_brk(int size);
 +
  Defines: sbrk +
 (link:../src/memory/malloc_brk.c[../src/memory/malloc_brk.c] l.16)  +
allocate via setting the brk +
  free and realloc can be used normally. +
  The intention of malloc_brk is for subsequent calls to realloc. +
  The saved data has not to be copied, +
  instead realloc just writes the new size and sets  +
  the brk accordingly. +
  if the break is saved before one or more calls to malloc_brk, +
  the allocated memory can also be free'd by setting the brk to the saved value +
  with brk(saved_brk) +
  free_brk() free's all memory, which has been allocated with malloc_brk +
 

map_protected::

  void* map_protected(int len);
 +
  Defines: mprotect mmap +
 (link:../src/memory/map_protected.c[../src/memory/map_protected.c] l.19)  +
allocate a buffer, which is surrounded by protected pages.  +
  mprotect(PROT_NONE) +
  When there is a buffer overflow, +
  neither the stack, nor other structures can be overwritten. +
  Instead the overflow (or underflow) touches the next protected page, +
  what results in a segfault. +
  The size is always a mutliple of the systems pagesize, 4kB here. +
  The len of the mapped memory area is rounded up to the next pagesize. +
  The mapped area can only be freed by call(s) to munmap, +
  neither realloc nor free are allowed. +
  There is one page before, and one page after the mapped area +
  protected with PROT_NONE, and len rounded up to the next +
  pagebreak. So this is the overhead.  +
  If an error occures, errno is set (when defined),  +
  and -1 returned, or the negative errno value, when errno isn't defined. +
 

match::

  int match(char *text, const char *re, text_match *st_match);
 +
  Defines:  +
 (link:../src/match/match.c[../src/match/match.c] l.83)  +
text matching engine +
  +
  little bit simpler version than match_ext. +
  Consciusly named 'text matching', since the inherent logic +
  is quite different to a regular expression machine. +
  +
  The engine matches nongreedy straight from left to right, +
  so backtracking is minimized. +
  It is a compromise between performance, size +
  and capabilities. +
  +
  +
  matches:  +
   +
  * for every count of any char (nongreedy(!)) +
  + for 1 or more chars +
  % for 1 or more chars, and fills in arg 3 (text_match) +
  ? for 1 char +
  @ matches the beginning of the text or endofline (\n)  +
    -> beginning of a line +
  # for space, endofline, \t, \n, \f, \r, \v  or end of text (0) +
  $ match end of text +
  backslash: escape *,?,%,!,+,#,$ and backslash itself. +
  ! : invert the matching of the next character or character class +
    +
  [xyz]: character classes, here x,y or z  +
    the characters are matched literally, also \,*,?,+,.. +
    it is not possible to match the closing bracket (]) +
    within a character class +
  +
  +
  % : matches like a '+', and fills in argument 3, +
  the text_match struct, when the pointer is non null. +
  The matching is 'nongreedy'. +
  +
  +
  returns: 1 on match, 0 on no match +
  ( RE_MATCH / RE_NOMATCH ) +
  +
  if the pointer (argument 3) st_match is nonnull, +
  the supplied struct text_match will be set to the first matching '%' location; +
  if there is no match, text_match.len will be set to 0. +
  +
  The struct is defined as:  +
  typedef struct _text_match { char* pos; int len; } text_match; +
  +
  examples:  +
  "*word*"  matches "words are true" or "true words are rare" +
  "word*"   matches "words are true" and not "true words are rare" +
  "word"    matches none of the above two texts (!) +
  "*words%" extracts with % " are true" and " are rare" +
            into text_match +
   +
  "Some\ntext\nwith\nlinebreaks\n\n" +
  "*@%#*" matches with % "Some" +
  "*@line%#*" matches % = "breaks" +
  "*text\n%"  % = "with linebreaks\n\n" +
  +
  +
  (memo) When the regex ist defined within C/cpp source code, +
  a backslash has to be defined as double backslash. +
  +
  (note) - be careful when negating a following *, or ?. +
   somehow - it is logical, but seems to me I overshoot a bit, +
   and tapped into a logical paradox. +
   Negating EVERYTHING translates to true. +
   However, since truth is negated as,... well, there's a problem. +
  +
   (I'm not kidding here. Just don't do a regex with !* or !?., +
   or you might experience the meaning of full featured.  +
   Maybe I should say, it's not allowed?) +
  +
   A "!+" will translate into nongreedy matching of any char, however; +
   "%!+" will match with % everything but the last char; +
   while "%+" matches with % only the first char. +
   !+ basically sets the greedyness of the left * or % higher. +
 

match_ext::

  int match_ext(char *text, const char *re, void(*p_match)(int number, char *pos,int len, void *userdata), int(*p_match_char)(int number, char *match_char, void *userdata), tmatch_ext *st_match, void *userdata);
 +
  (link:../src/match/match_ext.c[../src/match/match_ext.c] l.193)  +
text matching engine +
  +
  This is somewhere between a fully fledged expression machine, +
  and a simplicistic solution. +
  Consciusly named 'text matching', since the inherent logic +
  is quite different to a regular expression machine. +
  +
  The engine matches from left to right, +
  backtracking is done as less as possible. +
  Since the matching is nongreedy in general, +
  many tries can be spared. Opposed to another route, +
  where most patterns are per default greedy, and therfore +
  not the first matching next char is seeked for, but the first +
  solution while matching the most chars. +
  (I do not want to make this a hard statement, and it  +
  depends onto each pattern. But it is the way, the solution +
  of the pattern is searched for, in most patterns.) +
  This shows up in the logic of the patterns, which is more natural to me. +
  +
  It is a compromise between performance, size +
  and capabilities. +
  The logic is different of a "regular" regular expression +
  machine, but has advantages (and disadvantages). +
  I'd say, the main advantage is the easiness of adding callbacks, +
  and defining your own matching/logic within these.  +
  Performance might be better as well overall, +
  but this depends also on the expressions. +
  +
  A few nonextensive benchmarks show, +
  this engine is a bit faster than perl's regular expression machine, +
  slower than gnu grep (around factor2), and has the same speed as sed. +
  This might however vary with each usecase. +
  In favor of codesize I'm not going to optimize match_ext, +
  but there would be several possibilities, if you'd need a faster engine. +
  (Albite I'd like to emphasise, sed (and match_ext), also perl, are quite fast. +
  About 10 times faster than most expression engines.) +
  +
  matches:  +
   +
  * for every count of any char +
  + for 1 or more chars +
  ? for 1 char +
  # for space or end of text (0) +
  $ match end of text +
  +
  backslash: escape *,?,%,$,!,+,#,& and backslash itself. +
  !: invert the matching of the next character or character class +
  ,: separator. e.g. %,1 matches like ?*1.  +
    ( without the commata, the '1' would be part of the % match) +
    +
  +
  predefined character classes: +
  \d - digit +
  \D - nondigit +
  \s - space +
  \S - nonspace +
  \w - word character ( defined as ascii 32-126,160-255 ) +
  \W - nonword character ( defined as ascii 0-31,127-159 ) +
  +
  +
  [xyz]: character classes, here x,y or z  +
    the characters are matched literally, also \,*,?,+,.. +
    it is not possible to match the closing bracket (]) +
    within a character class +
  +
  {nX}: counted match +
   Match n times X. +
   For X, all expressions are allowed. +
   If you need to match a number at the first char of 'X', +
   separate X by a commata. E.g. {5,0} matches 5 times '0'. +
  +
  %[1]..%[9]: matches like a '+', +
   and calls the callback supplied as 3rd argument (when not null). +
   the number past the %, e.g. %1, is optional, +
   p_match will be callen with this number +
   as first parameter. +
   When not supplied, p_matched will be callen with  +
   the parameter 'number' set to 0. +
  +
   The matching is 'nongreedy'. +
   It is possible to rewrite the string to match +
   from within the p_matched callback. +
   This will not have an effect onto the current matching, +
   even if text is e.g. deleted by writing 0's. +
   The matched positions are called in reverse order. +
   (The last matched % in the regex calls p_match first,  +
   the first % in the regex from the left will be callen last) +
  +
  supply 0 for p_matched, when you do not need to extract matches. +
  This will treat % in the regex like a *,  +
  a following digit (0..9) in the regex is ignored. +
  if the 5th argument, a pointer to a tmatch_ext struct,  +
  is supplied, it will be filled with the first match. +
  (counting from left) +
  +
  +
  &[1] .. &[9] +
   "match" like a '?' and call p_match_char +
   p_match_char has to return either RE_MATCH, RE_NOMATCH, RE_MATCHEND +
   or a number of the count of chars, which have been matched. +
  +
   Therefore it is possible to e.g. rule your own +
   character classes, defined at runtime,  +
   or do further tricks like changing the matched chars, +
   match several chars, andsoon. +
   When returning RE_NOMATCH, +
   it is possible, the p_match and p_match_char callbacks are callen several times, +
   but with different pos or len parameters. +
  +
   The matching works straight from left to right. +
   So, a "*&*" will call the callback & for the first char. +
   When returning RE_NOMATCH, the second char will be matched. +
   Until either RE_MATCH is returned from the callback, +
   or the last char has been matched. +
  +
   Matching several characters is also posssible from within the callback, +
   the position within the text will be incremented by that number, +
   you return from the callback. +
  +
   When returning RE_MATCHEND from the callback,  +
   the whole regular expression is aborted, and returns with matched; +
   no matter, if there are chars left in the expression. +
  +
  +
   The difference between % and & is the logic. +
   % matches nongreedy, and has to check therefore the right side of the star +
   for its matching. +
   Possibly this has to be repeated, when following chars do not match. +
  +
   & is matched straight from left to right. +
   Whatever number you return, the textpointer will be incremented by that value. +
   However, a & isn't expanded on it's own. ( what a % is ). +
   e.g. "x%x" will match 'aa' in xaax, x&x will match the whole expression +
   only, when you return '2' from the callback. +
  +
   Performancewise, matching with & is faster, +
   since the % has on its right side to be matched +
   with recursing calls of match_ext. +
  +
  When using closures for the callbacks, you will possibly have to +
  enable an executable stack for the trampoline code +
  of gcc. Here, gcc complains about that.  +
  For setting this bit, have a look into the ldscripts in the folder +
  with the same name. +
  +
  supply 0 for p_match_char, when you don't need it. +
  This will treat & in the regex like ?,  +
  and match a following digit (0..9) in the text, +
  a following digit (0..9) in the regex is ignored. +
   +
  ----- +
  In general, you have to somehow invert the logic of regular expressions +
  when using match_ext. +
  e.g. when matching the parameter 'runlevel=default' at the kernel's +
  commandline, a working regular expression would be +
  "runlevel=(\S*)". This could be written here as "*runlevel=%#". +
  For matching e.g. numbers, you'd most possibly best of +
  with writing your own & callback. +
  +
  returns: 1 on match, 0 on no match +
  ( RE_MATCH / RE_NOMATCH ) +
  +
  if the pointer (argument 5) st_match is nonnull, +
  the supplied struct tmatch_ext will be set to the first matching '%' location; +
  if there is no match, tmatch_ext.len will be set to 0. +
  The struct is defined as:  +
  typedef struct _tmatch_ext { char* pos; int len; } tmatch_ext; +
  +
  +
  (memo) When the regex ist defined within C/cpp source code, +
  a backslash has to be defined as double backslash. +
  +
  (note) - be careful when negating a following *, or ?. +
   somehow - it is logical, but seems to me I overshoot a bit, +
   tragically hit my own foot, and stumbled into a logical paradox. +
  +
   Negating EVERYTHING translates to true. +
   However, since truth is negated as well, there's a problem, +
   cause it's now 'false', but 'false' is true. This is very close +
   to proving 42 is the answer. What is the escape velocity +
   in km/s out of the solar system, btw. +
  +
   (I'm not kidding here. Just don't do a regex with !* or !?.. +
   And, please, do not ask me what is going to happen when the impossible +
   gets possibilized. I have to point at the according sentences of the BSD license;//  there is NO WARRANTY for CONSEQUENTIAL DAMAGE, LOSS OF PROFIT, etc pp.) +
  +
   A "!+" will translate into nongreedy matching of any char, however; +
   "%!+" will match with % everything but the last char; +
   while "%+" matches with % only the first char. +
   !+ basically sets the greedyness of the left * or % higher. +
 

match_ext2::

  int match_ext2(char *text, char *re, void(*p_matched_cb)(int number, char *pos,int len), int(*p_wildcard_cb)(int number, char *match_char),text_match *st_match);
 +
  Defines:  +
 (link:../src/match/match_ext2.c[../src/match/match_ext2.c] l.306)  +
text matching engine +
  +
  WORK IN PROGRESS, please use ext_match +
  Atm, please nested brackets are featureful. +
  nesting {} within () seems to work. +
  Nesting round brackets within {} gives sometimes +
  trouble, when wildcards are used within the brackets. +
  I'm leaving this at it is for now.  +
  Possibly I'm going to hardcode an error message for nested brackets, +
  or nested brackets with wildcards. +
  +
  This is somewhere between a fully fledged expression machine, +
  and a simplicistic solution. +
  Consciusly named 'text matching', since the inherent logic +
  is quite different to a regular expression machine; +
  "natural expressions" might fit better for the name. +
  +
  The engine matches from left to right, +
  backtracking is done as less as possible. +
  Since the matching is nongreedy in general, +
  many tries can be spared. Opposed to another route, +
  where most patterns are per default greedy, and therfore +
  not the first matching next char is seeked for, but the first +
  solution while matching the most chars. +
  (I do not want to make this a hard statement, and it  +
  depends onto each pattern. But it is the way, the solution +
  of the pattern is searched for, in most patterns.) +
  This shows up in the logic of the patterns, which is more natural to me. +
  Your mileage might vary. +
  +
  +
  It is a compromise between performance, size +
  and capabilities. +
  The logic is different of a "regular" regular expression +
  machine, but has advantages (and disadvantages). +
  I'd say, the main advantage is the easiness of adding callbacks, +
  and defining your own matching/logic within these.  +
  Performance might be better as well overall, +
  but this depends on the expressions and usecases as well. +
  +
  Yet I for myself have to get a grip of the possibilities of this engine. +
  However, I have the feeling, the logic is much more natural. +
  With regular regexes you always have to think kind of 'backwards', +
  e.g., match ".*" -> match "." (any char) x times.  +
  gets to a simple "*" +
  or, to match all group and user id's of /etc/passwd, +
  a regular expression would be: "(\d*):(\d*)" +
  This is here: "*(\d*):(\d*)*" +
  The content in the brackets looks the same, +
  but it's matched quite different. +
  The regular expression (the first) matches x times \d, for x>=0. +
  In the second expressin, the ext_match expression, +
  the first digit is matched, and then nongreedy any chars, until +
  the first occurence of ':'.  +
  It is another logic. Whether it suits you, you have to decide. +
  +
  The callbacks have shown up to be a mighty tool, while +
  at the same time having a good performance.  +
   +
  +
  A few nonextensive benchmarks show, +
  this engine is a bit faster than perl's regular expression machine, +
  slower than gnu grep (around factor2), and has the same speed as sed. +
  This might vary with each usecase, but the callbacks for extracting matches +
  have some advantage, as well as the strict left to right and nongreedy parsing. +
  +
  In favor of codesize I'm not going to optimize ext_match, +
  but there would be several possibilities, if you'd need a faster engine. +
  (Albite I'd like to emphasise, sed (and ext_match), also perl, are quite fast. +
  About 5 to 10 times faster than most expression engines.) +
  +
  matches:  +
   +
  * for every count of any char +
  + for 1 or more chars +
  ? for 1 char +
  # for space, end of text (\0), linebreak, tab ( \t \n \f \r \v ) +
  @ matches the beginning of the text or endofline (\n)  +
  $ match end of text (\0) or linebreak +
  +
  backslash: escape *,?,%,@,$,!,+,#,& and backslash itself. +
  !: invert the matching of the next character or character class +
  ,: separator. e.g. %,1 matches like ?*1.  +
    ( without the commata, the '1' would be part of the % match) +
    +
  +
  predefined character classes: +
  \d - digit +
  \D - nondigit +
  \s - space +
  \S - nonspace +
  \w - word character ( defined as ascii 32-126,160-255 ) +
  \W - nonword character ( defined as ascii 0-31,127-159 ) +
  \x - hexadecimal digit (0-9,a-f,A-F) +
  +
  +
  [xyz]: character classes, here x,y or z  +
    the characters are matched literally, also \,*,?,+,.. +
    it is not possible to match the closing bracket (]) +
    within a character class +
  +
  {nX}: counted match +
   Match n times X. +
   For X, all expressions are allowed. +
   If you need to match a number at the first char of 'X', +
   separate X by a commata. E.g. {5,0} matches 5 times '0'. +
   n can be a number, * or +.  +
   ('*' matches 0 or more, '+' 1 or more times) +
  +
  (X): match the subexpression X. atm, no nesting of round () and {} brackets allowed +
  +
  %[1]..%[9]: matches like a '+', +
   and calls the callback supplied as 3rd argument (when not null). +
   the number past the %, e.g. %1, is optional, +
   p_matched_cb will be callen with this number +
   as first parameter. +
   When not supplied, p_matched_cb will be callen with  +
   the parameter 'number' set to 0. +
  +
   The matching is 'nongreedy'. +
   It is possible to rewrite the string to match +
   from within the p_matched_cb callback. +
   This will not have an effect onto the current matching, +
   even if text is e.g. deleted by writing 0's. +
  +
   The matched positions are called in reverse order. +
  +
   (The last matched % in the regex calls p_matched_cb first,  +
   the first % in the regex from the left will be callen last) +
   / The regex is first matched; when the regex has matched, +
   the %'s are filled/ the callbacks executed. +
   (x) bracketed patterns are matched the same way. +
  +
   (Not like &, which callbacks are invoked, while matching) +
  +
  supply 0 for p_matched_cb, when you do not need to extract matches. +
  This will treat % in the regex like a *,  +
  a following digit (0..9) in the regex is ignored. +
  if the 5th argument, a pointer to a text_match struct,  +
  is supplied, it will be filled with the first match. +
  (counting from left) +
  +
  +
  &[1] .. &[9] +
   "match" like a '?' and call p_wildcard_cb +
   p_wildcard_cb has to return either RE_MATCH, RE_NOMATCH, RE_MATCHEND +
   or the number of the count of chars, which have been matched. +
  +
   Therefore it is possible to e.g. rule your own +
   character classes, defined at runtime,  +
   or do further tricks like changing the matched chars, +
   match several chars, andsoon. +
   When returning RE_NOMATCH, +
   it is possible, the p_wildcard_cb callback is callen several times, +
   but with different pos or len parameters, since p_wildcard_cb is +
   invoked while matching. +
  +
   The matching works straight from left to right. +
   So, a "*&*" will call the callback & for the first char. +
   When returning RE_NOMATCH, the second char will be tried to match. +
   Until either RE_MATCH is returned from the callback, +
   or the last char of the text has been tried to match. +
  +
   Matching several characters is also posssible from within the callback, +
   the position within the text will be incremented by that number, +
   you return from the callback. +
  +
   When returning RE_MATCHEND from the callback,  +
   the whole expression is aborted, and returns with matched; +
   no matter, if there are chars left in the expression. +
  +
  +
   The difference between % and & is the logic. +
   % matches nongreedy, and has to check therefore the right side of the star +
   for its matching. +
   Possibly this has to be repeated, when following chars do not match. +
  +
   & is matched straight from left to right. +
   Whatever number you return, the textpointer will be incremented by that value. +
   However, a & isn't expanded on it's own. ( what a % is ). +
   e.g. "x%x" will match 'aa' in xaax, x&x will match the whole expression +
   only, when you return '2' from the callback. +
  +
   Performancewise, matching with & is faster, +
   since the % has on its right side to be matched +
   with recursing calls of ext_match. +
  +
  When using closures for the callbacks, you will possibly have to +
  enable an executable stack for the trampoline code +
  of gcc. Here, gcc complains about that.  +
  For setting this bit, please have a look into the ldscripts in the folder +
  with the same name. +
  +
  supply 0 for p_wildcard_cb, when you don't need it. +
  This will treat & in the regex like ?,  +
  and match a following digit (0..9) in the text, +
  a following digit (0..9) in the regex is ignored. +
   +
  ----- +
  In general, you have to somehow invert the logic of regular expressions +
  when using ext_match. +
  Regular expressions could be regarded as "polish rpn notation", +
  first the char to be matched, then the count. +
  This expression machine could be described as "natural expression" machine. +
  First you define the number, then the chars or expression to be matched. +
   +
  Furthermore, *,% and + match as less as possible. +
  You have to think about what needs to follow the wildcards. +
  +
  e.g. when matching the parameter 'runlevel=default' at the kernel's +
  commandline, a working regular expression would be +
  "runlevel=(\S*)". This could be written here as "*runlevel=%#". +
  For matching e.g. numbers, you'd most possibly best of +
  with writing your own & callback. +
  +
  returns: 1 on match, 0 on no match +
  ( RE_MATCH / RE_NOMATCH ) +
  +
  if the pointer (argument 5) st_match is nonnull, +
  the supplied struct text_match will be set to the first matching '%' location; +
  if there is no match, text_match.len will be set to 0. +
  The struct is defined as:  +
  typedef struct _text_match { char* pos; int len; } text_match; +
  +
  +
  (memo) When the regex ist defined within C/cpp source code, +
  a backslash has to be defined as double backslash. +
  +
  (note) - be careful when negating a following *, or ?. +
   somehow - it is logical, but seems to me I overshoot a bit, +
   tragically hit my own foot, and stumbled into a logical paradox. +
  +
   Negating EVERYTHING translates to true. +
   However, since truth is negated as well, there's a problem, +
   cause it's now 'false', but 'false' is true. This is very close +
   to proving 42 is the answer. What is the escape velocity +
   in km/s out of the solar system, btw. +
  +
   (I'm not kidding here. Just don't do a regex with !* or !?.. +
   And, please, do not ask me what is going to happen when the impossible +
   gets possibilized. I have to point at the according sentences of the BSD license; +
   there is NO WARRANTY for CONSEQUENTIAL DAMAGE, LOSS OF PROFIT, etc pp.) +
  +
   A "!+" will translate into nongreedy matching of any char, however; +
   "%!+" will match with % everything but the last char; +
   while "%+" matches with % only the first char. +
   !+ basically sets the greedyness of the left * or % higher. +
  +
  (work in progress here) please use ext_match +
  return 0 for nomatch, the current textpos ( >0 ) for a match +
  With the exception of an empty text, matched by e.g. "*". +
  This will return 0, albite the regex formally matches, with 0 chars. +
  +
  (todo) +
  bracket matching () and {} needs debugging. (test/extmatch2 for testing) +
  Add a callback for bracket matches, and add a matchlist +
  (linked list, allocated with malloc_brk) +
  Trouble: e.g. *:(*) doesn't match, albite it should +
   .. better. Now: # matches the end, after a bracket. Like it should +
    $ doesn't. But should as well. +
  change '+' to greedy matching of any char +
  for {n,X} let n be * or + as well. +
   (this would be closer to regular regulars again.?.) +
  +
  +
  note. About a tokenizer: +
  matching quoted string is really easy with the callback structure: +
   just match with &. When a quote is matched, look forward to the next quote, +
   and return that many chars. Same time, the quoted string is matched. +
   That's so easy, it is hard to believe. +
   When using closures for that, it is same time easy to collect all tokens. +
  +
   It is even easier. just a "*("*")*" is enough. +
  +
   ->There is something needed for partial matching. Possibly spare the last *, and return, +
   as soon the pattern is at it's end (and not the text?) +
   Already works this way.  +
  +
   Should start to define the language for the init scripts. +
   Or better, start thinking abut that, but follow my other obligations the next time. +
  +
   Have to think thouroughly about what points would make such a language useful. +
   The reason to think about that is clear - performance squeezing, faster startup time. +
   And writing the startup scripts in C is. Well. little bit painful. +
   However, together with minilib, there is nearly no difference between having a C program compiled +
   and run, or working with scripts. To not have the overhead of linking the external libraries in, +
   is of quite some advance. +
   The only difference, the compiled binaries are "cached". +
   have just to sort something sensible out for the systematic. +
   Implement an own loader? possibly easy. Since the loading address is fixed. +
   This could possibly also be the solution for the yet unclear question of the line between parsing +
   arguments and calling the main function of the small core tools, andsoon. +
    +
  ..yet I've to fiddle out the possibilities (and quirks) of this machine. +
  seems, this expression language did overpower it's creator. +
  +
  Bugs (features):  +
  matching e.g. *matches*@*doesn't match* +
  potentiates the *@* to many possibilities. +
  One for every linebreak following 'matches'. +
 

max_groupmembers::

  #ifndef mini_max_groupmembers
 +
  (link:../include/globaldefs.h[../include/globaldefs.h] l.89)  +
The maximum number of users,  +
  which are within a group. +
  used for the allocation of the array gr_mem. +
  default: 64 +
 

memfrob::

  void* memfrob(void* s, unsigned int len);
 +
  (link:../src/memory/memfrob.c[../src/memory/memfrob.c] l.4)  +
frob string; xor every char with 42 +
 

mmap::

  static void* __attribute__((optimize("O0"))) mmap(void* addr,  size_t len,  int prot,  int flags,  int fd,  off_t off);
 +
  (link:../src/memory/mmap.c[../src/memory/mmap.c] l.8) manpage: link:manpages/sys/mmap.2.rst[mmap] +
mmap wrapper +
  address length is rounded up to a multiple of pagesize (4096 Bytes here) +
  for the description, please look up the according manpage +
  errno is only set, when mini_errno is defined +
  if not, on error the negative errno value is returned. +
  (e.g. -22 for "invalid argument") +
 

mremap::

  static void* volatile __attribute__((optimize("O0"))) mremap(void* addr, size_t old_len, size_t new_len, int flags, void* new_addr);
 +
  (link:../include/mremap.h[../include/mremap.h] l.4)  +


network::

  
 +
  (link:../include/network.h[../include/network.h] l.4)  +
network definitions +
 

ntohl::

  #define ntohl(i) htonl(i)
 +
  (link:../src/network/byteorder.c[../src/network/byteorder.c] l.31) manpage: link:manpages/net/byteorder.3.rst[ntohl] +


ntohs::

  #define ntohs(i) htons(i)
 +
  (link:../src/network/byteorder.c[../src/network/byteorder.c] l.15) manpage: link:manpages/net/byteorder.3.rst[ntohs] +


opendirp::

  static DIR *opendirp(const char *name, DIR *dir);
 +
  Defines: getbrk close 0 open dirbuf brk +
 (link:../src/directories/opendirp.c[../src/directories/opendirp.c] l.5)  +


optimization_fence::

  static void __attribute__((noipa,cold)) optimization_fence(void*p);
 +
  (link:../include/minilib_global.h[../include/minilib_global.h] l.146)  +
prevent optimizations. +
  cast a var to void*, and calling this, +
  leaves the compiler unknown on what he can strip. +
  The function attribute noipa means, +
  the compiler doesn't know, what the function itself does. +
  (the function does nothing, but don't tell that gcc, please..) +
  therefore, everything used as parameter to this function, +
  will be calculated, defined, and so on before. +
  It's used for the globals,  +
  shich are pushed within _start onto the stack. +
  since _start itself only provides a global pointer, +
  and initialitzes some of the globals, +
  but doesn't use them again, +
  this construction is needed. +
  more funnily, the function will never be called. +
  It's past the asm inline syscall to exit. +
  But again, luckily gcc doesn't know. +
  All other options, like having the globals volatile,  +
  setting the optimization flag of _start to 0,  +
  having a volatile asm call with the globals as param, and so on, +
  have been useless. All after all, seems to me, ai has it's restrictions. +
  +
  With less overhead the macro OPTFENCE(...) goes. +
  There the call to the "ipa" function is jumped over, +
  via asm inline instructions.  +
 

poll::

  static inline int poll(struct pollfd *fds, nfds_t cnt, int timeout);
 +
  (link:../include/poll.h[../include/poll.h] l.25) manpage: link:manpages/sys/poll.2.rst[poll] +


posix_openpt::

  int posix_openpt(int flags);
 +
  Defines: termio open +
 (link:../src/termios/pty.c[../src/termios/pty.c] l.8) manpage: link:manpages/sys/posix_openpt.2.rst[posix_openpt] +


print::

  #define print(str) write(STDOUT_FILENO,str,strlen(str))
 +
  Defines: write strlen +
 (link:../include/prints.h[../include/prints.h] l.53)  +
write str to stdout. Needs strlen +
 

printfs::

  #define printfs(fmt,...) fprintfs(stdout, fmt, __VA_ARGS__)
 +
  Defines: strlen write fileno +
 (link:../include/prints.h[../include/prints.h] l.122)  +
write fmt and arguments to stdout.  +
  only format %s and %c are recognized +
 

printl::

  #define printl() write(STDOUT_FILENO,"\n",1)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.62)  +
write a newline to stdout +
 

prints::

  #define prints(...) _mprints(__VA_ARGS__,0)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.18)  +
print the string(s) supplied as arg(s) to stdout, +
  this macro has an variable argument count. +
 

printsl::

  #define printsl(...) _mprints(__VA_ARGS__,"\n",0)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.42)  +
print the string(s) supplied as arg(s) and newline to stdout +
 

ptsname::

  char *ptsname(int fd);
 +
  Defines: write open ioctl termio uitodec strlen +
 (link:../src/termios/pty.c[../src/termios/pty.c] l.34) manpage: link:manpages/stdlib/ptsname.3.rst[ptsname] +


ptsname_r::

  int ptsname_r(int fd, char *buf, size_t len);
 +
  Defines: write open ioctl termio uitodec strlen +
 (link:../src/termios/pty.c[../src/termios/pty.c] l.21)  +


putenv::

  int putenv( char *string );
 +
  Defines: ret_errno environ +
 (link:../src/system/putenv.c[../src/system/putenv.c] l.10) manpage: link:manpages/stdlib/getenv.3.rst[putenv] +
put a string into the environmental vars +
  the supplied string's pointer is put into the environmental array of pointers. +
  Subsequent changes of the string therefore will change the environment, +
  and the supplied string may not be deallocated. +
  Returns:  +
  - 0 on success,  +
  - EINVAL: string was 0, didn't contain a '=', some other error +
 

pwent::

  
 +
  (link:../include/pwent.h[../include/pwent.h] l.7)  +
define passwd and group structures +
 

ret_errno::

  #ifdef mini_errno
 +
  (link:../include/ret_errno.h[../include/ret_errno.h] l.5)  +
This macro expands to a return, and +
  (when mini_errno is defined) returns -1 and sets errno, +
  or returns the negative errno value. +
 

sbrk::

  static void* sbrk(long incr);
 +
  (link:../src/memory/brk.c[../src/memory/brk.c] l.66) manpage: link:manpages/sys/brk.2.rst[sbrk] +
Set the new brk, increment/decrement by incr bytes. +
  return the old brk on success. +
  conformant sbrk, when mini_errno is defined +
  if no errno is available, +
  returns the negative errno value on error +
 

scandir_bufsize::

  //#define mini_scandir_bufsize 4096
 +
  (link:../src/directories/scandir.c[../src/directories/scandir.c] l.4)  +
the increment of the buffer of scandir in bytes for memory allocations +
  (default:4096) +
 

sdbm_hash::

  unsigned long sdbm_hash(const unsigned char *str);
 +
  (link:../src/math/sdbm_hash.c[../src/math/sdbm_hash.c] l.3)  +


setbrk::

  static int setbrk(long addr);
 +
  Defines: brk +
 (link:../src/memory/brk.c[../src/memory/brk.c] l.39)  +
set the current brk +
  wrapper for brk(), with type of brk changed to long +
 

setenv::

  int setenv( const char *name, const char *value, int overwrite );
 +
  Defines: 0 ret_errno environ strlen strcpy +
 (link:../src/system/setenv.c[../src/system/setenv.c] l.15) manpage: link:manpages/stdlib/getenv.3.rst[setenv] +
put a string into the environmental vars +
  UNTESTED (!) TODO +
  the supplied string's pointer is put into the environmental array of pointers. +
  The supplied strings are copied into memory. +
  If overwrite is zero, an existing environmental variable is not overritten. +
  If overwrite is 1, the environmental variable is overwritten, +
  but not(!) freed from memory. +
  The supplied value is not checked for e.g. an '=' +
  +
  Returns:  +
  - 0 on success +
  - EINVAL on error +
 

seterrno::

  #ifdef mini_errno
 +
  (link:../include/seterrno.h[../include/seterrno.h] l.3)  +
set errno, but only when errno is defined. +
 

setgrent::

  void setgrent();
 +
  (link:../src/userdb/setgrent.c[../src/userdb/setgrent.c] l.3) manpage: link:manpages/gen/getgrent.3.rst[setgrent] +


setpwent::

  void setpwent();
 +
  (link:../src/userdb/setpwent.c[../src/userdb/setpwent.c] l.3) manpage: link:manpages/gen/getpwent.3.rst[setpwent] +


short_errstr::

  const char* short_errstr(int num);
 +
  (link:../include/errstrshort.h[../include/errstrshort.h] l.10)  +
short error (errno) string.  +
  this adds about 2kB to the compiled binary(!) +
 

shortcolornames::

  
 +
  (link:../include/ansicolors.h[../include/ansicolors.h] l.103)  +
short ansi color names +
  all colornames, without the praefix "AC_" +
 

snprintf::

  int snprintf( char *buf, size_t size, const char *fmt, ... );
 +
  Defines: strlen write +
 (link:../src/output/snprintf.c[../src/output/snprintf.c] l.5) manpage: link:manpages/stdio/printf.3.rst[snprintf] +


snprintfs::

  int snprintfs( char* buf, int size, char *fmt, ...);
 +
  Defines: 0 +
 (link:../src/output/snprintfs.c[../src/output/snprintfs.c] l.8)  +
prints formatted and unbuffered output into buf. +
  only %s and %c are recognized. +
  snprintfs instead of snprintf can save some bytes. +
  untested +
 

stpcpy::

  char *stpcpy(char *dest, const char *src);
 +
  (link:../src/string/stpcpy.c[../src/string/stpcpy.c] l.3) manpage: link:manpages/string/string.3.rst[stpcpy] +
copy src to dest, return a pointer to the last char +1 ( ending '0' ) +
 

stplcpy::

  char *stplcpy(char *dest, const char *src, int size);
 +
  (link:../src/string/stplcpy.c[../src/string/stplcpy.c] l.4)  +
copy src to dest, return a pointer to the last char +1 ( ending '0' ) +
  doesn't pad dest with 0, when size<src; +
 

stpncpy::

  char *stpncpy(char *dest, const char *src, int size);
 +
  (link:../src/string/stpncpy.c[../src/string/stpncpy.c] l.6) manpage: link:manpages/string/strcpy.3.rst[stpncpy] +
copy src to dest, return a pointer to the last char +1 ( ending '0' ) +
  Please note stplcpy (terminology borrowed from freebsd),  +
  which does the same, +
  but doesn't pad dest with 0's. +
 

strlcpy::

  char *strlcpy(char *dest, const char *src, int n);
 +
  (link:../src/string/strlcpy.c[../src/string/strlcpy.c] l.5) manpage: link:manpages/string/strlcpy.3.rst[strlcpy] +
copy max n chars from src to dest,  +
  when src is longer than dest,  +
  end dest[n-1] with '\0'. +
 

strtoll::

  long long int strtoll(const char *c, const char **endp, int base);
 +
  (link:../src/string/strtoll.c[../src/string/strtoll.c] l.7) manpage: link:manpages/stdlib/strtol.3.rst[strtoll] +
conversion +
  doesn't check for overflow(!) +
  For linux x64, long long and long both have 64 bit. +
  Therefore, strtoll just calls strtol +
 

swap::

  static inline void swap(void* a, void* b,int size);
 +
  (link:../src/qsort.c[../src/qsort.c] l.31)  +
swap a with b, with 'size' bytes +
  swaps integers and longs at once, when size eq sizeof(int/long) +
 

sys_brk::

  static long sys_brk(unsigned long addr);
 +
  (link:../src/memory/brk.c[../src/memory/brk.c] l.6)  +
the kernel syscall brk. +
 

tcgetattr::

  int tcgetattr(int fd, struct termios *io);
 +
  Defines: termio ioctl +
 (link:../src/termios/tcgetattr.c[../src/termios/tcgetattr.c] l.19) manpage: link:manpages/gen/tcsetattr.3.rst[tcgetattr] +


tcsetattr::

  int tcsetattr(int fd, int opt, const struct termios *io);
 +
  Defines: termio ioctl +
 (link:../src/termios/tcsetattr.c[../src/termios/tcsetattr.c] l.18) manpage: link:manpages/gen/tcsetattr.3.rst[tcsetattr] +


term_width::

  int term_width();
 +
  Defines: termio environ +
 (link:../src/termios/term_width.c[../src/termios/term_width.c] l.7)  +
get the terminal width +
  reads the environmental var COLS, +
  if not present, returns 80. +
  Doesn't check for the existence of a terminal. +
 

termio::

  
 +
  (link:../include/termio.h[../include/termio.h] l.5)  +
termios structures and definitions +
 

token_i::

  int token_i( userdb* udb, char **p );
 +
  (link:../src/userdb/userdb.c[../src/userdb/userdb.c] l.33)  +


token_s::

  char *token_s( userdb *udb, char **p );
 +
  (link:../src/userdb/userdb.c[../src/userdb/userdb.c] l.19)  +
tokenizer for the passwd/group files. +
  used by the group/user pwentry access functions. +
  performance of subsequent calls could be improved by replacing all ':' and '\n' +
  by 0's when loading the db file. +
  it would be possible as well, testing not only single bytes, but +
  integers of longs at once. However, in most cases, e.g. +
  for big directories with many small files, in most cases  +
  all files do have the same owner and group. Since the last result to calls +
  of the access functions is cached, +
  there wouldn't be an improvement by optimizing the tokenizing functions. +
  So I'm leaving this for now, as it is. +
  And most possibly it would be better to implement bsd's cached versions  +
  of the user db access functions instead.  +
 

uitodec::

  int __attribute__((optimize("Os")))uitodec(unsigned int i, char *buf, int prec, char limiter, char pad );
 +
  (link:../src/conversions/itodec.c[../src/conversions/itodec.c] l.9)  +
convert int to string. +
  prec: precision, e.g. 4=> 0087  +
  pad: 0 (pad with spaces), or the char to pad +
 

ultodec::

  int ultodec(unsigned long ui, char *buf, int prec, char limiter );
 +
  (link:../src/conversions/ltodec.c[../src/conversions/ltodec.c] l.6)  +


unlockpt::

  int unlockpt(int fd);
 +
  Defines: ioctl termio +
 (link:../src/termios/pty.c[../src/termios/pty.c] l.14) manpage: link:manpages/stdlib/ptsname.3.rst[unlockpt] +


unmap_protected::

  int unmap_protected(void *p, int len);
 +
  Defines: munmap mprotect +
 (link:../src/memory/map_protected.c[../src/memory/map_protected.c] l.41)  +


userdb_open::

  int userdb_open(userdb *udb, const char* file);
 +
  Defines: write close fstat globals +
 (link:../src/userdb/userdb_open.c[../src/userdb/userdb_open.c] l.3)  +


verbose_errstr::

  const char* verbose_errstr(int num);
 +
  (link:../include/errstr.h[../include/errstr.h] l.10)  +
verbose error (errno) string.  +
  this adds about 3.5kB to the compiled binary(!) +
 

verbose_errstr2::

  static const char* verbose_errstr2(int num);
 +
  (link:../include/errstr2.h[../include/errstr2.h] l.11)  +
verbose error (errno) string.  +
  this adds about 3.5kB to the compiled binary(!) +
  Trying to shrink that here. +
 

vexec::

  int vexec( const char* path, char* const* argv, char* const* envp );
 +
  Defines: seterrno wait4 +
 (link:../src/exec/vexec.c[../src/exec/vexec.c] l.6)  +
execute a path, wait until the executed file exits. +
  Deviating of system() an absolute pathname is taken. +
  sets errno on error. +
 

vexec_q::

  int vexec_q( const char* path, char* const* argv, char* const* envp );
 +
  Defines: wait4 seterrno +
 (link:../src/exec/vexec.c[../src/exec/vexec.c] l.30)  +
execute a path, wait until the executed file exits,  +
  do not write any output of the process. (close stdout) +
  Deviating of system() an absolute pathname is taken. +
 

vsnprintf::

  int vsnprintf(char *buf, size_t size, const char* fmt, va_list args );
 +
  Defines: strlen write +
 (link:../src/output/sprintf.c[../src/output/sprintf.c] l.43) manpage: link:manpages/stdio/printf.3.rst[vsnprintf] +
the function, translating the fmt of printf. +
  warning - most possibly you'd like to define besides fprintf, or family, +
  mini_itodec (%d conversion)  +
  mini_atoi is needed for grouping numbers +
 

warn::

  #define warn( fmt ... ) { fprintf(stderr,fmt ); }
 +
  Defines: strlen fileno write +
 (link:../src/process/error.c[../src/process/error.c] l.33) manpage: link:manpages/gen/err.3.rst[warn] +
print an error message to stderr +
 

writes::

  #define writes(str) write(STDOUT_FILENO,str,sizeof(str))
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.83)  +
write the constant str to stdout. Computes length with sizeof(str) at compile time. +
 

writesl::

  #define writesl(str) write(STDOUT_FILENO,str "\n",sizeof(str)+1)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.93)  +
write the constant str to stdout, followed by a newline.  +
  Computes length with sizeof(str) at compile time. +
 



 mini_syscalls
---------------

sys__sysctl::

  sys__sysctl( struct __sysctl_args *args)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.316)  +


sys_accept::

  sys_accept( int fd,  struct sockaddr *upeersockaddr,  int *upeeraddrlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.91)  +


sys_accept4::

  sys_accept4( int fd,  struct sockaddr *upeer_sockaddr,  int *upeer_addrlen,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.552)  +


sys_access::

  sys_access( const char *filename,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.47)  +


sys_acct::

  sys_acct( const char *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.330)  +


sys_add_key::

  sys_add_key( const char *_type,  const char *_description,  const void *_payload,  size_t plen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.472)  +


sys_adjtimex::

  sys_adjtimex( struct timex *txc_p)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.322)  +


sys_alarm::

  sys_alarm( unsigned int seconds)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.79)  +


sys_arch_prctl::

  sys_arch_prctl( struct task_struct *task,  int code,  unsigned long *addr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.320)  +


sys_bind::

  sys_bind( int fd,  struct sockaddr *umyaddr,  int addrlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.103)  +


sys_capget::

  sys_capget( cap_user_header_t header,  cap_user_data_t dataptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.256)  +


sys_capset::

  sys_capset( cap_user_header_t header,  const cap_user_data_t data)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.258)  +


sys_chdir::

  sys_chdir( const char *filename)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.166)  +


sys_chmod::

  sys_chmod( const char *filename,  mode_t mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.186)  +


sys_chown::

  sys_chown( const char *filename,  uid_t user,  gid_t group)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.190)  +


sys_chroot::

  sys_chroot( const char *filename)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.326)  +


sys_clock_adjtime::

  sys_clock_adjtime( clockid_t which_clock,  struct timex *tx)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.586)  +


sys_clock_getres::

  sys_clock_getres( const clockid_t which_clock,  struct timespec *tp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.436)  +


sys_clock_gettime::

  sys_clock_gettime( const clockid_t which_clock,  struct timespec *tp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.434)  +


sys_clock_nanosleep::

  sys_clock_nanosleep( const clockid_t which_clock,  int flags,  const struct timespec *rqtp,  struct timespec *rmtp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.438)  +


sys_clock_settime::

  sys_clock_settime( const clockid_t which_clock,  const struct timespec *tp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.432)  +


sys_clone::

  sys_clone( unsigned long clone_flags,  unsigned long newsp,  void *parent_tid,  void *child_tid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.117)  +


sys_close::

  sys_close( unsigned int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.11)  +


sys_connect::

  sys_connect( int fd,  struct sockaddr *uservaddr,  int addrlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.89)  +


sys_creat::

  sys_creat( const char *pathname,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.176)  +


sys_delete_module::

  sys_delete_module( const char *name_user,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.354)  +


sys_dup::

  sys_dup( unsigned int fildes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.69)  +


sys_dup2::

  sys_dup2( unsigned int oldfd,  unsigned int newfd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.71)  +


sys_dup3::

  sys_dup3( unsigned int oldfd,  unsigned int newfd,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.560)  +


sys_epoll_create::

  sys_epoll_create( int size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.408)  +


sys_epoll_create1::

  sys_epoll_create1( int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.558)  +


sys_epoll_ctl::

  sys_epoll_ctl( int epfd,  int op,  int fd,  struct epoll_event *event)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.444)  +


sys_epoll_pwait::

  sys_epoll_pwait( int epfd,  struct epoll_event *events,  int maxevents,  int timeout,  const sigset_t *sigmask,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.538)  +


sys_epoll_wait::

  sys_epoll_wait( int epfd,  struct epoll_event *events,  int maxevents,  int timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.442)  +


sys_eventfd::

  sys_eventfd( unsigned int count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.544)  +


sys_eventfd2::

  sys_eventfd2( unsigned int count,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.556)  +


sys_execve::

  sys_execve( const char *filename,  const char *const argv[],  const char *const envp[])
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.123)  +


sys_exit_group::

  sys_exit_group( int error_code)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.440)  +


sys_faccessat::

  sys_faccessat( int dfd,  const char *filename,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.514)  +


sys_fadvise64::

  sys_fadvise64( int fd,  loff_t offset,  size_t len,  int advice)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.420)  +


sys_fallocate::

  sys_fallocate( long fd,  long mode,  loff_t offset,  loff_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.546)  +


sys_fanotify_init::

  sys_fanotify_init( unsigned int flags,  unsigned int event_f_flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.576)  +


sys_fanotify_mark::

  sys_fanotify_mark( long fanotify_fd,  long flags,  __u64 mask,  long dfd, long pathname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.578)  +


sys_fchdir::

  sys_fchdir( unsigned int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.168)  +


sys_fchmod::

  sys_fchmod( unsigned int fd,  mode_t mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.188)  +


sys_fchmodat::

  sys_fchmodat( int dfd,  const char *filename,  mode_t mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.512)  +


sys_fchown::

  sys_fchown( unsigned int fd,  uid_t user,  gid_t group)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.192)  +


sys_fchownat::

  sys_fchownat( int dfd,  const char *filename,  uid_t user,  gid_t group,  int flag)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.496)  +


sys_fcntl::

  sys_fcntl( unsigned int fd,  unsigned int cmd,  unsigned long arg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.150)  +


sys_fdatasync::

  sys_fdatasync( unsigned int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.156)  +


sys_fgetxattr::

  sys_fgetxattr( int fd,  const char *name,  void *value,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.372)  +


sys_finit_module::

  sys_finit_module( int fd,  const char  *uargs,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.602)  +


sys_flistxattr::

  sys_flistxattr( int fd,  char *list,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.378)  +


sys_flock::

  sys_flock( unsigned int fd,  unsigned int cmd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.152)  +


sys_fork::

  sysSYSDEF_syscall(_fork,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.119)  +


sys_fremovexattr::

  sys_fremovexattr( int fd,  const char *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.384)  +


sys_fsetxattr::

  sys_fsetxattr( int fd,  const char *name,  const void *value,  size_t size, int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.366)  +


sys_fstat::

  sys_fstat( unsigned int fd,  struct stat *statbuf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.15)  +


sys_fstatfs::

  sys_fstatfs( unsigned int fd,  struct statfs *buf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.280)  +


sys_fsync::

  sys_fsync( unsigned int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.154)  +


sys_ftruncate::

  sys_ftruncate( unsigned int fd,  unsigned long length)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.160)  +


sys_futex::

  sys_futex( u32 *uaddr,  int op,  u32 val,  struct timespec *utime,  u32 *uaddr2,  u32 val3)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.390)  +


sys_futimesat::

  sys_futimesat( int dfd,  const char *filename,  struct timeval *utimes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.498)  +


sys_get_mempolicy::

  sys_get_mempolicy( int *policy,  unsigned long *nmask,  unsigned long maxnode,  unsigned long addr,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.454)  +


sys_get_robust_list::

  sys_get_robust_list( int pid,  struct robust_list_head **head_ptr,  size_t *len_ptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.524)  +


sys_getcpu::

  sys_getcpu( unsigned *cpup,  unsigned *nodep,  struct getcpu_cache *unused)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.594)  +


sys_getcwd::

  sys_getcwd( char *buf,  unsigned long size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.164)  +


sys_getdents::

  sys_getdents( unsigned int fd,  struct linux_dirent *dirent,  unsigned int count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.162)  +


sys_getdents64::

  sys_getdents64( unsigned int fd,  struct linux_dirent64 *dirent,  unsigned int count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.412)  +


sys_getegid::

  sysSYSDEF_syscall(_getegid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.222)  +


sys_geteuid::

  sysSYSDEF_syscall(_geteuid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.220)  +


sys_getgid::

  sysSYSDEF_syscall(_getgid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.214)  +


sys_getgroups::

  sys_getgroups( int gidsetsize,  gid_t *grouplist)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.236)  +


sys_getitimer::

  sys_getitimer( int which,  struct itimerval *value)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.77)  +


sys_getpeername::

  sys_getpeername( int fd,  struct sockaddr *usockaddr,  int *usockaddr_len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.109)  +


sys_getpgid::

  sys_getpgid( pid_t pid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.248)  +


sys_getpgrp::

  sysSYSDEF_syscall(_getpgrp,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.228)  +


sys_getpid::

  sysSYSDEF_syscall(_getpid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.83)  +


sys_getppid::

  sysSYSDEF_syscall(_getppid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.226)  +


sys_getpriority::

  sys_getpriority( int which,  int who)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.284)  +


sys_getrandom::

  sys_getrandom( char  *buf,  size_t count,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.612)  +


sys_getresgid::

  sys_getresgid( gid_t *rgid,  gid_t *egid,  gid_t *sgid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.246)  +


sys_getresuid::

  sys_getresuid( uid_t *ruid,  uid_t *euid,  uid_t *suid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.242)  +


sys_getrlimit::

  sys_getrlimit( unsigned int resource,  struct rlimit *rlim)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.200)  +


sys_getrusage::

  sys_getrusage( int who,  struct rusage *ru)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.202)  +


sys_getsid::

  sys_getsid( pid_t pid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.254)  +


sys_getsockname::

  sys_getsockname( int fd,  struct sockaddr *usockaddr,  int *usockaddr_len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.107)  +


sys_getsockopt::

  sys_getsockopt( int fd,  int level,  int optname,  char *optval,  int *optlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.115)  +


sys_gettid::

  sysSYSDEF_syscall(_gettid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.358)  +


sys_gettimeofday::

  sys_gettimeofday( struct timeval *tv,  struct timezone *tz)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.198)  +


sys_getuid::

  sysSYSDEF_syscall(_getuid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.210)  +


sys_getxattr::

  sys_getxattr( const char *pathname,  const char *name,  void *value,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.368)  +


sys_init_module::

  sys_init_module( void *umod,  unsigned long len,  const char *uargs)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.352)  +


sys_inotify_add_watch::

  sys_inotify_add_watch( int fd,  const char *pathname,  u32 mask)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.484)  +


sys_inotify_init::

  sysSYSDEF_syscall(_inotify_init,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.482)  +


sys_inotify_init1::

  sys_inotify_init1( int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.564)  +


sys_inotify_rm_watch::

  sys_inotify_rm_watch( int fd,  __s32 wd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.486)  +


sys_io_cancel::

  sys_io_cancel( aio_context_t ctx_id,  struct iocb *iocb,  struct io_event *result)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.404)  +


sys_io_destroy::

  sys_io_destroy( aio_context_t ctx)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.398)  +


sys_io_getevents::

  sys_io_getevents( aio_context_t ctx_id,  long min_nr,  long nr,  struct io_event *events)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.400)  +


sys_io_setup::

  sys_io_setup( unsigned nr_events,  aio_context_t *ctxp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.396)  +


sys_io_submit::

  sys_io_submit( aio_context_t ctx_id,  long nr,  struct iocb **iocbpp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.402)  +


sys_ioctl::

  sys_ioctl( unsigned int fd,  unsigned int cmd,  unsigned long arg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.37)  +


sys_ioperm::

  sys_ioperm( unsigned long from,  unsigned long num,  int turn_on)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.350)  +


sys_iopl::

  sys_iopl( unsigned int level,  struct pt_regs *regs)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.348)  +


sys_ioprio_get::

  sys_ioprio_get( int which,  int who)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.480)  +


sys_ioprio_set::

  sys_ioprio_set( int which,  int who,  int ioprio)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.478)  +


sys_kcmp::

  sys_kcmp( pid_t pid1,  pid_t pid2,  int type,  unsigned long idx1,  unsigned long idx2)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.600)  +


sys_kexec_file_load::

  sys_kexec_file_load( int kernel_fd,  int initrd_fd,  unsigned long cmdline_len,  const char  *cmdline_ptr,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.616)  +


sys_kexec_load::

  sys_kexec_load( unsigned long entry,  unsigned long nr_segments,  struct kexec_segment *segments,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.468)  +


sys_keyctl::

  sys_keyctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.476)  +


sys_kill::

  sys_kill( pid_t pid,  int sig)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.130)  +


sys_lchown::

  sys_lchown( const char *filename,  uid_t user,  gid_t group)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.194)  +


sys_lgetxattr::

  sys_lgetxattr( const char *pathname,  const char *name,  void *value,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.370)  +


sys_link::

  sys_link( const char *oldname,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.178)  +


sys_linkat::

  sys_linkat( int oldfd,  const char *oldname,  int newfd,  const char *newname,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.506)  +


sys_listen::

  sys_listen( int fd,  int backlog)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.105)  +


sys_listxattr::

  sys_listxattr( const char *pathname,  char *list,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.374)  +


sys_llistxattr::

  sys_llistxattr( const char *pathname,  char *list,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.376)  +


sys_lookup_dcookie::

  sys_lookup_dcookie( u64 cookie64,  long buf,  long len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.406)  +


sys_lremovexattr::

  sys_lremovexattr( const char *pathname,  const char *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.382)  +


sys_lseek::

  sys_lseek( unsigned int fd,  off_t offset,  unsigned int origin)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.21)  +


sys_lsetxattr::

  sys_lsetxattr( const char *pathname,  const char *name,  const void *value, size_t size,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.364)  +


sys_lstat::

  sys_lstat( const char *filename,  struct stat *statbuf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.17)  +


sys_madvise::

  sys_madvise( unsigned long start,  size_t len_in,  int behavior)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.61)  +


sys_mbind::

  sys_mbind( unsigned long start,  unsigned long len,  unsigned long mode,  unsigned long *nmask,  unsigned long maxnode,  unsigned flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.450)  +


sys_memfd_create::

  sys_memfd_create( const char  *uname_ptr,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.614)  +


sys_migrate_pages::

  sys_migrate_pages( pid_t pid,  unsigned long maxnode,  const unsigned long *old_nodes,  const unsigned long *new_nodes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.488)  +


sys_mincore::

  sys_mincore( unsigned long start,  size_t len,  unsigned char *vec)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.59)  +


sys_mkdir::

  sys_mkdir( const char *pathname,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.172)  +


sys_mkdirat::

  sys_mkdirat( int dfd,  const char *pathname,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.492)  +


sys_mknod::

  sys_mknod( const char *filename,  umode_t mode,  unsigned dev)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.272)  +


sys_mknodat::

  sys_mknodat( int dfd,  const char *filename,  int mode,  unsigned dev)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.494)  +


sys_mlock::

  sys_mlock( unsigned long start,  size_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.302)  +


sys_mlockall::

  sys_mlockall( int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.306)  +


sys_mmap::

  sys_mmap( unsigned long addr,  unsigned long len,  unsigned long prot,  unsigned long flags,  unsigned long fd,  unsigned long off)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.23)  +


sys_modify_ldt::

  sys_modify_ldt( int func,  void *ptr,  unsigned long bytecount)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.312)  +


sys_mount::

  sys_mount( char *dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.334)  +


sys_move_pages::

  sys_move_pages( pid_t pid,  unsigned long nr_pages,  const void *pages[], const int *nodes,  int *status,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.534)  +


sys_mprotect::

  sys_mprotect( unsigned long start,  size_t len,  unsigned long prot)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.25)  +


sys_mq_getsetattr::

  sys_mq_getsetattr( mqd_t mqdes,  const struct mq_attr *u_mqstat,  struct mq_attr *u_omqstat)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.466)  +


sys_mq_notify::

  sys_mq_notify( mqd_t mqdes,  const struct sigevent *u_notification)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.464)  +


sys_mq_open::

  sys_mq_open( const char *u_name,  int oflag,  mode_t mode,  struct mq_attr *u_attr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.456)  +


sys_mq_timedreceive::

  sys_mq_timedreceive( mqd_t mqdes,  char *u_msg_ptr,  size_t msg_len,  unsigned int *u_msg_prio,  const struct timespec *u_abs_timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.462)  +


sys_mq_timedsend::

  sys_mq_timedsend( mqd_t mqdes,  const char *u_msg_ptr,  size_t msg_len,  unsigned int msg_prio,  const struct timespec *u_abs_timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.460)  +


sys_mq_unlink::

  sys_mq_unlink( const char *u_name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.458)  +


sys_mremap::

  sys_mremap( unsigned long addr,  unsigned long old_len,  unsigned long new_len,  unsigned long flags,  unsigned long new_addr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.55)  +


sys_msgctl::

  sys_msgctl( int msqid,  int cmd,  struct msqid_ds *buf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.148)  +


sys_msgget::

  sys_msgget( key_t key,  int msgflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.142)  +


sys_msgrcv::

  sys_msgrcv( int msqid,  struct msgbuf *msgp,  size_t msgsz,  long msgtyp,  int msgflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.146)  +


sys_msgsnd::

  sys_msgsnd( int msqid,  struct msgbuf *msgp,  size_t msgsz,  int msgflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.144)  +


sys_msync::

  sys_msync( unsigned long start,  size_t len,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.57)  +


sys_munlock::

  sys_munlock( unsigned long start,  size_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.304)  +


sys_munlockall::

  sysSYSDEF_syscall(_munlockall,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.308)  +


sys_munmap::

  sys_munmap( unsigned long addr,  size_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.27)  +


sys_name_to_handle_at::

  sys_name_to_handle_at( int dfd,  const char *name,  struct file_handle *handle,  int *mnt_id,  int flag)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.582)  +


sys_nanosleep::

  sys_nanosleep( struct timespec *rqtp,  struct timespec *rmtp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.75)  +


sys_newfstatat::

  sys_newfstatat( int dfd,  const char *filename,  struct stat *statbuf,  int flag)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.500)  +


sys_open::

  sys_open( const char *filename,  int flags,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.9)  +


sys_open_by_handle_at::

  sys_open_by_handle_at( int dfd,  const char *name,  struct file_handle *handle,  int *mnt_id,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.584)  +


sys_openat::

  sys_openat( int dfd,  const char *filename,  int flags,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.490)  +


sys_pause::

  sysSYSDEF_syscall(_pause,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.73)  +


sys_perf_event_open::

  sys_perf_event_open( struct perf_event_attr *attr_uptr,  pid_t pid,  int cpu,  int group_fd,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.572)  +


sys_personality::

  sys_personality( unsigned int personality)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.274)  +


sys_pipe::

  sys_pipe( int *filedes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.49)  +


sys_pipe2::

  sys_pipe2( int *filedes,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.562)  +


sys_pivot_root::

  sys_pivot_root( const char *new_root,  const char *put_old)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.314)  +


sys_poll::

  sys_poll( struct poll_fd *ufds,  unsigned int nfds,  long timeout_msecs)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.19)  +


sys_ppoll::

  sys_ppoll( struct pollfd *ufds,  unsigned int nfds,  struct timespec *tsp,  const sigset_t *sigmask,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.518)  +


sys_prctl::

  sys_prctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.318)  +


sys_pread64::

  sys_pread64( unsigned long fd,  char *buf,  size_t count,  loff_t pos)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.39)  +


sys_preadv::

  sys_preadv( unsigned long fd,  const struct iovec *vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.566)  +


sys_prlimit64::

  sys_prlimit64( pid_t pid,  unsigned int resource,  const struct rlimit64 *new_rlim,  struct rlimit64 *old_rlim)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.580)  +


sys_process_vm_readv::

  sys_process_vm_readv( pid_t pid,  const struct iovec *lvec,  unsigned long liovcnt,  const struct iovec *rvec,  unsigned long riovcnt,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.596)  +


sys_process_vm_writev::

  sys_process_vm_writev( pid_t pid,  const struct iovec *lvec,  unsigned long liovcnt,  const struct iovcc *rvec,  unsigned long riovcnt,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.598)  +


sys_pselect6::

  sys_pselect6( int n,  fd_set *inp,  fd_set *outp,  fd_set *exp,  struct timespec *tsp,  void *sig)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.516)  +


sys_ptrace::

  sys_ptrace( long request,  long pid,  unsigned long addr,  unsigned long data)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.208)  +


sys_pwrite64::

  sys_pwrite64( unsigned int fd,  const char *buf,  size_t count,  loff_t pos)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.41)  +


sys_pwritev::

  sys_pwritev( unsigned long fd,  const struct iovec *vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.568)  +


sys_quotactl::

  sys_quotactl( unsigned int cmd,  const char *special,  qid_t id,  void *addr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.356)  +


sys_read::

  sys_read( unsigned int fd,  char *buf,  size_t count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.5)  +


sys_readahead::

  sys_readahead( int fd,  loff_t offset,  size_t count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.360)  +


sys_readlink::

  sys_readlink( const char *path,  char *buf,  int bufsiz)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.184)  +


sys_readlinkat::

  sys_readlinkat( int dfd,  const char *pathname,  char *buf,  int bufsiz)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.510)  +


sys_readv::

  sys_readv( unsigned long fd,  const struct iovec *vec,  unsigned long vlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.43)  +


sys_reboot::

  sys_reboot( int magic1,  int magic2,  unsigned int cmd,  void *arg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.342)  +


sys_recvfrom::

  sys_recvfrom( int fd,  void *ubuf,  size_t size,  unsigned flags,  struct sockaddr *addr,  int *addr_len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.95)  +


sys_recvmmsg::

  sys_recvmmsg( int fd,  struct msghdr *mmsg,  unsigned int vlen,  unsigned int flags,  struct timespec *timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.574)  +


sys_recvmsg::

  sys_recvmsg( int fd,  struct msghdr *msg,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.99)  +


sys_remap_file_pages::

  sys_remap_file_pages( unsigned long start,  unsigned long size,  unsigned long prot,  unsigned long pgoff,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.410)  +


sys_removexattr::

  sys_removexattr( const char *pathname,  const char *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.380)  +


sys_rename::

  sys_rename( const char *oldname,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.170)  +


sys_renameat::

  sys_renameat( int oldfd,  const char *oldname,  int newfd,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.504)  +


sys_renameat2::

  sys_renameat2( int olddfd,  const char  *oldname,  int newdfd,  const char  *newname,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.608)  +


sys_request_key::

  sys_request_key( const char *_type,  const char *_description,  const char *_callout_info,  key_serial_t destringid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.474)  +


sys_restart_syscall::

  sysSYSDEF_syscall(_restart_syscall,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.416)  +


sys_rmdir::

  sys_rmdir( const char *pathname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.174)  +


sys_rt_sigaction::

  sys_rt_sigaction( int sig,  const struct sigaction *act,  struct sigaction *oact,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.31)  +


sys_rt_sigpending::

  sys_rt_sigpending( sigset_t *set,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.260)  +


sys_rt_sigprocmask::

  sys_rt_sigprocmask( int how,  sigset_t *nset,  sigset_t *oset,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.33)  +


sys_rt_sigqueueinfo::

  sys_rt_sigqueueinfo( pid_t pid,  int sig,  siginfo_t *uinfo)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.264)  +


sys_rt_sigreturn::

  sys_rt_sigreturn( unsigned long __unused)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.35)  +


sys_rt_sigsuspend::

  sys_rt_sigsuspend( sigset_t *unewset,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.266)  +


sys_rt_sigtimedwait::

  sys_rt_sigtimedwait( const sigset_t *uthese,  siginfo_t *uinfo,  const struct timespec *uts,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.262)  +


sys_rt_tgsigqueueinfo::

  sys_rt_tgsigqueueinfo( pid_t tgid,  pid_t pid,  int sig,  siginfo_t *uinfo)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.570)  +


sys_sched_get_priority_max::

  sys_sched_get_priority_max( int policy)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.296)  +


sys_sched_get_priority_min::

  sys_sched_get_priority_min( int policy)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.298)  +


sys_sched_getaffinity::

  sys_sched_getaffinity( pid_t pid,  unsigned int len,  unsigned long *user_mask_ptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.394)  +


sys_sched_getattr::

  sys_sched_getattr( pid_t pid,  struct sched_attr  *attr,  unsigned int size,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.606)  +


sys_sched_getparam::

  sys_sched_getparam( pid_t pid,  struct sched_param *param)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.290)  +


sys_sched_getscheduler::

  sys_sched_getscheduler( pid_t pid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.294)  +


sys_sched_rr_get_interval::

  sys_sched_rr_get_interval( pid_t pid,  struct timespec *interval)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.300)  +


sys_sched_setaffinity::

  sys_sched_setaffinity( pid_t pid,  unsigned int len,  unsigned long *user_mask_ptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.392)  +


sys_sched_setattr::

  sys_sched_setattr( pid_t pid,  struct sched_attr  *attr,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.604)  +


sys_sched_setparam::

  sys_sched_setparam( pid_t pid,  struct sched_param *param)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.288)  +


sys_sched_setscheduler::

  sys_sched_setscheduler( pid_t pid,  int policy,  struct sched_param *param)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.292)  +


sys_sched_yield::

  sysSYSDEF_syscall(_sched_yield,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.53)  +


sys_seccomp::

  sys_seccomp( unsigned int op,  unsigned int flags,  const char  *uargs)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.610)  +


sys_select::

  sys_select( int n,  fd_set *inp,  fd_set *outp,  fd_set *exp,  struct timeval *tvp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.51)  +


sys_semctl::

  sys_semctl( int semid,  int semnum,  int cmd,  semun_u arg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.138)  +


sys_semget::

  sys_semget( key_t key,  int nsems,  int semflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.134)  +


sys_semop::

  sys_semop( int semid,  struct sembuf *tsops,  unsigned nsops)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.136)  +


sys_semtimedop::

  sys_semtimedop( int semid,  struct sembuf *tsops,  unsigned nsops,  const struct timespec *timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.418)  +


sys_sendfile::

  sys_sendfile( int out_fd,  int in_fd,  off_t *offset,  size_t count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.85)  +


sys_sendmmsg::

  sys_sendmmsg( int fd,  struct mmsghdr *mmsg,  unsigned int vlen,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.590)  +


sys_sendmsg::

  sys_sendmsg( int fd,  struct msghdr *msg,  unsigned flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.97)  +


sys_sendto::

  sys_sendto( int fd,  void *buff,  size_t len,  unsigned flags,  struct sockaddr *addr,  int addr_len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.93)  +


sys_set_mempolicy::

  sys_set_mempolicy( int mode,  unsigned long *nmask,  unsigned long maxnode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.452)  +


sys_set_robust_list::

  sys_set_robust_list( struct robust_list_head *head,  size_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.522)  +


sys_set_tid_address::

  sys_set_tid_address( int *tidptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.414)  +


sys_setdomainname::

  sys_setdomainname( char *name,  int len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.346)  +


sys_setfsgid::

  sys_setfsgid( gid_t gid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.252)  +


sys_setfsuid::

  sys_setfsuid( uid_t uid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.250)  +


sys_setgid::

  sys_setgid( gid_t gid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.218)  +


sys_setgroups::

  sys_setgroups( int gidsetsize,  gid_t *grouplist)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.238)  +


sys_sethostname::

  sys_sethostname( char *name,  int len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.344)  +


sys_setitimer::

  sys_setitimer( int which,  struct itimerval *value,  struct itimerval *ovalue)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.81)  +


sys_setns::

  sys_setns( int fd,  int nstype)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.592)  +


sys_setpgid::

  sys_setpgid( pid_t pid,  pid_t pgid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.224)  +


sys_setpriority::

  sys_setpriority( int which,  int who,  int niceval)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.286)  +


sys_setregid::

  sys_setregid( gid_t rgid,  gid_t egid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.234)  +


sys_setresgid::

  sys_setresgid( gid_t rgid,  gid_t egid,  gid_t sgid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.244)  +


sys_setresuid::

  sys_setresuid( uid_t *ruid,  uid_t *euid,  uid_t *suid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.240)  +


sys_setreuid::

  sys_setreuid( uid_t ruid,  uid_t euid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.232)  +


sys_setrlimit::

  sys_setrlimit( unsigned int resource,  struct rlimit *rlim)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.324)  +


sys_setsid::

  sysSYSDEF_syscall(_setsid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.230)  +


sys_setsockopt::

  sys_setsockopt( int fd,  int level,  int optname,  char *optval,  int optlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.113)  +


sys_settimeofday::

  sys_settimeofday( struct timeval *tv,  struct timezone *tz)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.332)  +


sys_setuid::

  sys_setuid( uid_t uid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.216)  +


sys_setxattr::

  sys_setxattr( const char *pathname,  const char *name,  const void *value, size_t size,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.362)  +


sys_shmat::

  sys_shmat( int shmid,  char *shmaddr,  int shmflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.65)  +


sys_shmctl::

  sys_shmctl( int shmid,  int cmd,  struct shmid_ds *buf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.67)  +


sys_shmdt::

  sys_shmdt( char *shmaddr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.140)  +


sys_shmget::

  sys_shmget( key_t key,  size_t size,  int shmflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.63)  +


sys_shutdown::

  sys_shutdown( int fd,  int how)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.101)  +


sys_sigaltstack::

  sys_sigaltstack( const stack_t *uss,  stack_t *uoss)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.268)  +


sys_signalfd::

  sys_signalfd( int ufd,  sigset_t *user_mask,  size_t sizemask)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.540)  +


sys_signalfd4::

  sys_signalfd4( int ufd,  sigset_t *user_mask,  size_t sizemask,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.554)  +


sys_socket::

  sys_socket( int family,  int type,  int protocol)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.87)  +


sys_socketpair::

  sys_socketpair( int family,  int type,  int protocol,  int *usockvec)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.111)  +


sys_splice::

  sys_splice( int fd_in,  loff_t *off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.526)  +


sys_stat::

  sys_stat( const char *filename,  struct stat *statbuf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.13)  +


sys_statfs::

  sys_statfs( const char *pathname,  struct statfs *buf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.278)  +


sys_swapoff::

  sys_swapoff( const char *specialfile)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.340)  +


sys_swapon::

  sys_swapon( const char *specialfile,  int swap_flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.338)  +


sys_symlink::

  sys_symlink( const char *oldname,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.182)  +


sys_symlinkat::

  sys_symlinkat( const char *oldname,  int newfd,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.508)  +


sys_sync::

  sysSYSDEF_syscall(_sync,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.328)  +


sys_sync_file_range::

  sys_sync_file_range( long fd,  loff_t offset,  loff_t bytes,  long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.530)  +


sys_syncfs::

  sys_syncfs( int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.588)  +


sys_sysfs::

  sys_sysfs( int option,  unsigned long arg1,  unsigned long arg2)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.282)  +


sys_sysinfo::

  sys_sysinfo( struct sysinfo *info)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.204)  +


sys_syslog::

  sys_syslog( int type,  char *buf,  int len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.212)  +


sys_tee::

  sys_tee( int fdin,  int fdout,  size_t len,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.528)  +


sys_tgkill::

  sys_tgkill( pid_t tgid,  pid_t pid,  int sig)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.446)  +


sys_time::

  sys_time( time_t *tloc)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.388)  +


sys_timer_create::

  sys_timer_create( const clockid_t which_clock,  struct sigevent *timer_event_spec,  timer_t *created_timer_id)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.422)  +


sys_timer_delete::

  sys_timer_delete( timer_t timer_id)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.430)  +


sys_timer_getoverrun::

  sys_timer_getoverrun( timer_t timer_id)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.428)  +


sys_timer_gettime::

  sys_timer_gettime( timer_t timer_id,  struct itimerspec *setting)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.426)  +


sys_timer_settime::

  sys_timer_settime( timer_t timer_id,  int flags,  const struct itimerspec *new_setting,  struct itimerspec *old_setting)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.424)  +


sys_timerfd_create::

  sys_timerfd_create( int clockid,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.542)  +


sys_timerfd_gettime::

  sys_timerfd_gettime( int ufd,  struct itimerspec *otmr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.550)  +


sys_timerfd_settime::

  sys_timerfd_settime( int ufd,  int flags,  const struct itimerspec *utmr,  struct itimerspec *otmr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.548)  +


sys_times::

  sys_times( struct sysinfo *info)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.206)  +


sys_tkill::

  sys_tkill( pid_t pid,  int sig)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.386)  +


sys_truncate::

  sys_truncate( const char *path,  long length)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.158)  +


sys_umask::

  sys_umask( int mask)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.196)  +


sys_umount2::

  sys_umount2( const char *target,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.336)  +


sys_uname::

  sys_uname( struct old_utsname *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.132)  +


sys_unlink::

  sys_unlink( const char *pathname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.180)  +


sys_unlinkat::

  sys_unlinkat( int dfd,  const char *pathname,  int flag)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.502)  +


sys_unshare::

  sys_unshare( unsigned long unshare_flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.520)  +


sys_ustat::

  sys_ustat( unsigned dev,  struct ustat *ubuf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.276)  +


sys_utime::

  sys_utime( char *filename,  struct utimbuf *times)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.270)  +


sys_utimensat::

  sys_utimensat( int dfd,  const char *filename,  struct timespec *utimes, int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.536)  +


sys_utimes::

  sys_utimes( char *filename,  struct timeval *utimes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.448)  +


sys_vfork::

  sysSYSDEF_syscall(_vfork,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.121)  +


sys_vhangup::

  sysSYSDEF_syscall(_vhangup,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.310)  +


sys_vmsplice::

  sys_vmsplice( int fd,  const struct iovec *iov,  unsigned long nr_segs, unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.532)  +


sys_wait4::

  sys_wait4( pid_t upid,  int *stat_addr,  int options,  struct rusage *ru)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.128)  +


sys_waitid::

  sys_waitid( int which,  pid_t upid,  struct siginfo *infop,  int options,  struct rusage *ru)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.470)  +


sys_write::

  sys_write( unsigned int fd,  const char *buf,  size_t count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.7)  +


sys_writev::

  sys_writev( unsigned long fd,  const struct iovec *vec,  unsigned long vlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.45)  +




 signal.h
----------

raise::

  static inline int raise(int signr);
 +
  Defines: getpid kill +
 (link:../src/process/sigaction.c[../src/process/sigaction.c] l.145) manpage: link:manpages/gen/raise.3.rst[raise] +


sigaction::

  static int volatile sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
 +
  Defines: rt_sigaction memcpy +
 (link:../src/process/sigaction.c[../src/process/sigaction.c] l.117) manpage: link:manpages/sys/sigaction.2.rst[sigaction] +


sigaddset::

  int sigaddset(sigset_t *set, int sig);
 +
  (link:../src/process/sigaction.c[../src/process/sigaction.c] l.34) manpage: link:manpages/gen/sigsetops.3.rst[sigaddset] +


sigdelset::

  int sigdelset(sigset_t *set, int sig);
 +
  (link:../src/process/sigaction.c[../src/process/sigaction.c] l.68) manpage: link:manpages/gen/sigsetops.3.rst[sigdelset] +


sigemptyset::

  static int sigemptyset(sigset_t *set);
 +
  (link:../src/process/sigaction.c[../src/process/sigaction.c] l.7) manpage: link:manpages/gen/sigsetops.3.rst[sigemptyset] +


sigfillset::

  static int sigfillset(sigset_t *set);
 +
  (link:../src/process/sigaction.c[../src/process/sigaction.c] l.20) manpage: link:manpages/gen/sigsetops.3.rst[sigfillset] +


sigismember::

  int sigismember(sigset_t *set, int sig);
 +
  (link:../src/process/sigaction.c[../src/process/sigaction.c] l.85) manpage: link:manpages/gen/sigsetops.3.rst[sigismember] +


signal::

  sighandler_t signal(int sig, sighandler_t func );
 +
  Defines: rt_sigaction memcpy write +
 (link:../src/process/signal.c[../src/process/signal.c] l.5) manpage: link:manpages/gen/signal.3.rst[signal] +


sigprocmask::

  int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
 +
  Defines: rt_sigprocmask +
 (link:../src/process/sigaction.c[../src/process/sigaction.c] l.61) manpage: link:manpages/sys/sigprocmask.2.rst[sigprocmask] +


sigsuspend::

  static int sigsuspend( const sigset_t *mask );
 +
  Defines: rt_sigsuspend +
 (link:../src/process/sigaction.c[../src/process/sigaction.c] l.53) manpage: link:manpages/sys/sigsuspend.2.rst[sigsuspend] +




 stdio.h
---------

_fopen::

  FILE *_fopen(int fd, const char* filename, const char* mode, FILE *f);
 +
  Defines: close open fileno +
 (link:../src/streams/_fopen.c[../src/streams/_fopen.c] l.12)  +
modes implemented: r, r+, w, w+, a, a+ +
 

_itohex::

  int _itohex(int i,char* buf,int padding, int capitals);
 +
  (link:../src/conversions/itohex.c[../src/conversions/itohex.c] l.6)  +


clearerr::

  static inline void clearerr(FILE *f);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.191) manpage: link:manpages/stdio/ferror.3.rst[clearerr] +


clearerror::

  static inline void clearerror(FILE *f);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.196)  +


fclose::

  static inline int __attribute__((always_inline)) fclose( FILE* f );
 +
  Defines: close +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.67) manpage: link:manpages/stdio/fclose.3.rst[fclose] +


fdopen::

  FILE *fdopen(int fd, const char* mode);
 +
  Defines: fileno close open +
 (link:../src/streams/fopen.c[../src/streams/fopen.c] l.21) manpage: link:manpages/stdio/fopen.3.rst[fdopen] +
modes implemented: r, r+, w, w+, a, a+ +
 

feof::

  static inline int feof(FILE *f);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.177) manpage: link:manpages/stdio/ferror.3.rst[feof] +


ferror::

  static inline int ferror(FILE *f);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.184) manpage: link:manpages/stdio/ferror.3.rst[ferror] +


fflush::

  static inline int __attribute__((always_inline)) fflush( FILE *F );
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.28) manpage: link:manpages/stdio/fflush.3.rst[fflush] +
This does nothing, since minilib doesn't provide buffered streams yet.In order to sync data to disc, please use fsync +
 

fgetc::

  static inline int fgetc(FILE *F);
 +
  Defines: read fileno +
 (link:../src/streams/fgetc.c[../src/streams/fgetc.c] l.5) manpage: link:manpages/stdio/getc.3.rst[fgetc] +


fgetpos::

  static inline void fgetpos(FILE *f, long *pos );
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.118) manpage: link:manpages/stdio/fseek.3.rst[fgetpos] +


fgets::

  char* fgets(char *buf, int size, FILE* F);
 +
  Defines: fileno read +
 (link:../src/streams/fgets.c[../src/streams/fgets.c] l.4) manpage: link:manpages/stdio/fgets.3.rst[fgets] +


fileno::

  static int fileno( FILE *f );
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.56) manpage: link:manpages/stdio/ferror.3.rst[fileno] +
Return the fd nummber of stdin,-out,-err.  +
 

fopen::

  FILE *fopen(const char* filename, const char* mode);
 +
  Defines: close open fileno +
 (link:../src/streams/fopen.c[../src/streams/fopen.c] l.11) manpage: link:manpages/stdio/fopen.3.rst[fopen] +
modes implemented: r, r+, w, w+, a, a+ +
 

fprint::

  #define fprint(...) fprintf(__VA_ARGS__)
 +
  Defines: fileno write strlen +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.85)  +


fprintf::

  #define fprintf(stream,...)	write(fileno(stream),mlgl->mbuf,sprintf(mlgl->mbuf,__VA_ARGS__))
 +
  Defines: strlen write fileno +
 (link:../src/output/sprintf.c[../src/output/sprintf.c] l.268) manpage: link:manpages/stdio/printf.3.rst[fprintf] +
fprintf, formatted output +
  conversions implemented: +
  %d: signed int (mini_itodec) +
  %u: unsigned int (mini_uitodec) +
  %f: double (max precision 8 digits, highest possible number: 2^31 +
  %l (modify a following d,u to long) (mini_ltodec,mini_ultodec) +
  %s: string +
  %c: char +
  binary and hex output print the numbers,  +
  as they are internally stored(!). +
  Negative numbers are represented with the first sign bit set. +
  (e.g. -1 = 0xFFFFFFFF at x64) +
  %b : binary output  (mini_itobin) +
  %o : octal output (mini_itooct) +
  %x/X : hex output (small/big capitals) (mini_itohex,mini_itoHEX +
  %(: grouping (mini_atoi) +
  +
  warning - most possibly you'd like to define besides fprintf, or family, +
  mini_itodec (%d conversion)  +
   +
  For squeezing a few more bytes, and saving some checking; +
  writes(constant string) and print (variable string),  +
  prints (formatted output of one or several strings) are provided. +
  +
   +
 

fputc::

  static inline int volatile fputc(int c, FILE* F);
 +
  Defines: fileno write +
 (link:../include/fputc.h[../include/fputc.h] l.10) manpage: link:manpages/stdio/putc.3.rst[fputc] +


fputs::

  static inline int volatile fputs(const char *c, FILE *F);
 +
  Defines: strlen fileno write +
 (link:../include/fputs.h[../include/fputs.h] l.20) manpage: link:manpages/stdio/fputs.3.rst[fputs] +


fread::

  static inline size_t fread(void *ptr, size_t size, size_t nmemb, FILE *f);
 +
  Defines: read +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.153) manpage: link:manpages/stdio/fread.3.rst[fread] +


freopen::

  FILE *freopen(const char* filename, const char* mode, FILE *F);
 +
  Defines: close open fileno +
 (link:../src/streams/fopen.c[../src/streams/fopen.c] l.31) manpage: link:manpages/stdio/fopen.3.rst[freopen] +
modes implemented: r, r+, w, w+, a, a+ +
 

fseek::

  static inline int fseek(FILE *f, long offset, int whence );
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.135) manpage: link:manpages/stdio/fseek.3.rst[fseek] +


fsetpos::

  static inline int fsetpos(FILE *f, int pos );
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.124) manpage: link:manpages/stdio/fseek.3.rst[fsetpos] +


ftell::

  static inline long ftell(FILE *f);
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.112) manpage: link:manpages/stdio/fseek.3.rst[ftell] +


fwrite::

  static inline size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *f);
 +
  Defines: write +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.96) manpage: link:manpages/stdio/fread.3.rst[fwrite] +


getc::

  #define getc(F) fgetc(F)
 +
  Defines: read fileno +
 (link:../include/fgetc.h[../include/fgetc.h] l.8) manpage: link:manpages/stdio/getc.3.rst[getc] +


getchar::

  #define getchar() fgetc(0)
 +
  Defines: fileno read +
 (link:../include/fgetc.h[../include/fgetc.h] l.11) manpage: link:manpages/stdio/getc.3.rst[getchar] +


gets::

  #define gets(F) fgets(F,0xfffffff,stdin)
 +
  Defines: read fileno +
 (link:../src/streams/fgets.c[../src/streams/fgets.c] l.27) manpage: link:manpages/stdio/fgets.3.rst[gets] +


itoHEX::

  int itoHEX(int i,char* buf,int padding);
 +
  Defines:  +
 (link:../src/conversions/itohex.c[../src/conversions/itohex.c] l.65)  +
convert a number to hexadecimal representation with big capitals. +
  the conversion assumes a size of 32bits for integers, +
  negative values are represented as they are stored internally. +
  ( -1 is 0xFFFFFFFF, -2 0xFFFFFFFE, ... ) +
 

itohex::

  int itohex(int i,char* buf,int padding);
 +
  Defines:  +
 (link:../src/conversions/itohex.c[../src/conversions/itohex.c] l.53)  +
convert a number to hexadecimal representation. +
  the conversion assumes a size of 32bits for integers, +
  negative values are represented as they are stored internally. +
  ( -1 is 0xffffffff, -2 0xfffffffe, ... ) +
 

perror::

  void perror(const char *msg);
 +
  Defines: strerror strlen errno write fileno +
 (link:../src/output/perror.c[../src/output/perror.c] l.4) manpage: link:manpages/string/strerror.3.rst[perror] +


printf::

  #define printf(...) fprintf(stdout,__VA_ARGS__)
 +
  Defines: fileno write strlen +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.81) manpage: link:manpages/stdio/printf.3.rst[printf] +


putc::

  #define putc(c,stream) fputc(c,stream)
 +
  Defines: fileno write +
 (link:../include/fputc.h[../include/fputc.h] l.19) manpage: link:manpages/stdio/putc.3.rst[putc] +


putchar::

  #define putchar(c) fputc(c,stdout)
 +
  Defines: write fileno +
 (link:../include/fputc.h[../include/fputc.h] l.16) manpage: link:manpages/stdio/putc.3.rst[putchar] +


puts::

  #define puts(msg) ( print(msg) + printl() )
 +
  Defines: write fileno strlen +
 (link:../include/prints.h[../include/prints.h] l.72) manpage: link:manpages/stdio/fputs.3.rst[puts] +
write msg to stdout, append a newline. Needs strlen. +
 

rewind::

  static inline void rewind( FILE *f );
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.144) manpage: link:manpages/stdio/fseek.3.rst[rewind] +


setbuf::

  static void setbuf(FILE *stream, char *buf);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.204) manpage: link:manpages/stdio/setbuf.3.rst[setbuf] +
dummy function. +
  There is no buffering implemented for the streams yet. +
 

setvbuf::

  static int setvbuf(FILE *stream, char *buf, int mode, size_t size);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.209) manpage: link:manpages/stdio/setbuf.3.rst[setvbuf] +
dummy function +
 

sprintf::

  #define sprintf(str,...) snprintf( str, 4096,  __VA_ARGS__)
 +
  Defines: strlen write +
 (link:../src/output/sprintf.c[../src/output/sprintf.c] l.26) manpage: link:manpages/stdio/printf.3.rst[sprintf] +


ungetc::

  static int ungetc(int c, FILE *F);
 +
  (link:../src/streams/ungetc.c[../src/streams/ungetc.c] l.5) manpage: link:manpages/stdio/ungetc.3.rst[ungetc] +
pushes one char back to the stream. +
  Overwrites a previously pushed char +
  (conforming to the posix spec)  +
 

vfprintf::

  #define vfprintf(...) fprintf(__VA_ARGS__)
 +
  Defines: strlen write fileno +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.90) manpage: link:manpages/stdio/printf.3.rst[vfprintf] +


vsprintf::

  int vsprintf( char *buf, const char *fmt, ... );
 +
  Defines: 0 +
 (link:../src/output/vsprintf.c[../src/output/vsprintf.c] l.9) manpage: link:manpages/stdio/printf.3.rst[vsprintf] +
write fmt and arguments into buf +
  calls vsnprintf,  +
  the size is limited to 4096 by default. +
 



 stdlib.h
----------

abort::

  void abort();
 +
  Defines: write memcpy getpid rt_sigaction kill +
 (link:../src/process/abort.c[../src/process/abort.c] l.3) manpage: link:manpages/stdlib/abort.3.rst[abort] +


abs::

  static int abs(int i);
 +
  (link:../include/math.h[../include/math.h] l.25) manpage: link:manpages/stdlib/abs.3.rst[abs] +


atexit::

  static int atexit( functionp* func );
 +
  Defines: globals +
 (link:../src/process/atexit.c[../src/process/atexit.c] l.7) manpage: link:manpages/stdlib/atexit.3.rst[atexit] +
register functions, which are callen on exit in reverse order +
  the switch mini_atexit takes a optional number, +
  which defines the maximum numbers of functions to be registered. +
  (defaults to 8) +
 

atoi::

  int atoi(const char *c);
 +
  (link:../src/conversions/atoi.c[../src/conversions/atoi.c] l.3) manpage: link:manpages/stdlib/atoi.3.rst[atoi] +


atol::

  long atol(const char *c);
 +
  (link:../src/conversions/atol.c[../src/conversions/atol.c] l.3) manpage: link:manpages/stdlib/atol.3.rst[atol] +


calloc::

  void* calloc(int nmemb, int size);
 +
  (link:../src/memory/calloc.c[../src/memory/calloc.c] l.2) manpage: link:manpages/stdlib/memory.3.rst[calloc] +


div::

  static div_t div(int numerator, int denominator);
 +
  (link:../include/math.h[../include/math.h] l.8) manpage: link:manpages/stdlib/div.3.rst[div] +


free::

  void free(void *p);
 +
  Defines: getbrk brk +
 (link:../src/memory/malloc.c[../src/memory/malloc.c] l.146) manpage: link:manpages/stdlib/memory.3.rst[free] +


getenv::

  char* getenv(const char* name);
 +
  Defines: environ +
 (link:../src/system/getenv.c[../src/system/getenv.c] l.5) manpage: link:manpages/stdlib/getenv.3.rst[getenv] +


labs::

  static long int labs(long int i);
 +
  (link:../include/math.h[../include/math.h] l.30) manpage: link:manpages/stdlib/labs.3.rst[labs] +


ldiv::

  static ldiv_t ldiv(long int numerator, long int denominator);
 +
  (link:../include/math.h[../include/math.h] l.16) manpage: link:manpages/stdlib/ldiv.3.rst[ldiv] +


malloc::

  void* malloc(int size);
 +
  Defines: 0 +
 (link:../src/memory/malloc.c[../src/memory/malloc.c] l.126) manpage: link:manpages/stdlib/memory.3.rst[malloc] +
0 +
  Here we go.. with the .. well.  +
  Fastes and smallest malloc/free combi ever.  +
  Not the smartest. +
  Since it isn't exactly a memory allocation, +
  instead it (mis)uses the minilib buf. +
  Which is allocated by the kernel, and uses +
  either the bss section, or is allocated on the stack. +
  (option "globals_on_stack") +
  +
  This is basically a linked list, +
  optimized for fast access, allocation of new elements,  +
  and small memory overhead. +
  Albite the list structure might be hard to recognize. +
  It is not the right malloc, if you expect +
  many de- or reallocations. +
  And it obviously is not the right choose, when +
  expecting medium to big sized allocations. (> 1 page, here 4kB, as medium sized) +
   +
  Here we use mbuf from top to bottom as stack. +
  64 Bytes are left at the bottom as reserve. +
  Possibly we'd like to complain +
  about the lack of memory, before we exit. +
  +
  ATM, the 'free' is really lazy.  +
  It free's memory, but a real 'free' is only commited, +
  when all memory below a freed area is also freed. +
  Since the target of minilib atm are tiny tools,  +
  this might be ok. +
  ;) but, as I told before -  +
  probably you should look out for a proper malloc implementation. +
  It depends on your needs. +
  +
  I'm not sure yet,  +
  whether another implementation of free would be useful at all. +
  Overall, I'd really prefer keeping minilib tiny. +
  +
  Reusing sparse freed memory areas also leads  +
  to a whole bunch of complications. +
  cache misses, searching complexity, +
  storage overhead, potentially page faults, +
  just to name a few. +
  +
  I'm not sure whether it's worth it. +
  +
  And the existing malloc implementations  +
  out there are countless. +
  +
  ;) It's sometimes smarter to stay special, +
  albite in this case this means the opposite. +
  /misc +
  +
  The memory layout looks like this: +
  mlgl->ibuf and mlgl->mbuf do point to the same address range. +
  mlgl->ibuf is provided for alignment and faster access to the int values. +
  +
  flag prev free is the first bit in size. (0x8000, eq 1000 0000 0000 0000 binary when free),  +
  (mbufsize) +
  ``` +
       size  data  size    mini_buf size +
       8008dataxxxx0004data8000| +
       ----========----====----| +
  +
  also, when free space is in between two areas +
   +
  8004data8008  free  0004data8000| +
  ----====----________----====----| +
  +
  ``` +
  the free space is only freed,  +
  when all areas below (left) have been free'd as well. +
  +
  Memory is allocated from right to left,  +
  meaning from top to down. +
 

qsort::

  void qsort(void  *base,	size_t nel,	size_t width,	int (*comp)(const void *, const void *));
 +
  (link:../src/qsort.c[../src/qsort.c] l.59) manpage: link:manpages/stdlib/qsort.3.rst[qsort] +
(quick) shell sort routine +
  following the tradition, this isn't exactly a quicksort algorithm, +
  albite named quicksort. +
  It is a shell sort implementation, originally done by Ray Gardner, 5/90; +
  which in turn I did find within musl. +
 

rand::

  unsigned int rand();
 +
  (link:../src/math/rand.c[../src/math/rand.c] l.15) manpage: link:manpages/stdlib/rand.3.rst[rand] +


realloc::

  void* realloc(void *p, int size);
 +
  Defines: brk 0 getbrk +
 (link:../src/memory/malloc.c[../src/memory/malloc.c] l.210) manpage: link:manpages/stdlib/memory.3.rst[realloc] +


srand::

  void srand( unsigned int i );
 +
  (link:../src/math/rand.c[../src/math/rand.c] l.7) manpage: link:manpages/stdlib/rand.3.rst[srand] +


strtol::

  long int strtol(const char *c, const char **endp, int base);
 +
  (link:../src/string/strtol.c[../src/string/strtol.c] l.5) manpage: link:manpages/stdlib/strtol.3.rst[strtol] +
conversion +
  doesn't check for overflow(!) +
 

system::

  int system( const char* command );
 +
  Defines: vfork environ write execve wait4 +
 (link:../src/exec/system.c[../src/exec/system.c] l.4) manpage: link:manpages/stdlib/system.3.rst[system] +




 string.h
----------

_strcasecmp::

  int _strcasecmp(const char*c1,const char*c2,int len);
 +
  Defines: tolower +
 (link:../src/string/strcmp.c[../src/string/strcmp.c] l.27)  +


_strcmp::

  int _strcmp(const char*c1,const char*c2,int len);
 +
  (link:../src/string/strcmp.c[../src/string/strcmp.c] l.10)  +


memcmp::

  int memcmp(const void* c1,const void* c2,int len);
 +
  Defines: 0 +
 (link:../src/memory/memcmp.c[../src/memory/memcmp.c] l.3) manpage: link:manpages/string/memcmp.3.rst[memcmp] +


memcpy::

  void* memcpy( void*d, const void *s, int n );
 +
  (link:../src/memory/memcpy.c[../src/memory/memcpy.c] l.4) manpage: link:manpages/string/memcpy.3.rst[memcpy] +


memmove::

  void* memmove(void *dest, const void *src, int n);
 +
  (link:../src/memory/memmove.c[../src/memory/memmove.c] l.3) manpage: link:manpages/string/memmove.3.rst[memmove] +


memset::

  void *memset( void *s, int c, int n);
 +
  (link:../src/memory/memset.c[../src/memory/memset.c] l.3) manpage: link:manpages/string/memset.3.rst[memset] +


strcasecmp::

  int strcasecmp(const char*c1,const char*c2);
 +
  Defines:  +
 (link:../src/string/strcmp.c[../src/string/strcmp.c] l.48) manpage: link:manpages/string/string.3.rst[strcasecmp] +


strcat::

  char *strcat(char *dest, const char *src );
 +
  Defines: strlen +
 (link:../src/string/strcat.c[../src/string/strcat.c] l.5) manpage: link:manpages/string/string.3.rst[strcat] +


strchr::

  char *strchr(const char *s, int c);
 +
  Defines: strchrnul +
 (link:../src/string/strchr.c[../src/string/strchr.c] l.20) manpage: link:manpages/string/string.3.rst[strchr] +


strchrnul::

  char *strchrnul(const char *s, int c);
 +
  (link:../src/string/strchr.c[../src/string/strchr.c] l.7) manpage: link:manpages/string/strchr.3.rst[strchrnul] +


strcmp::

  int strcmp(const char*c1,const char*c2);
 +
  Defines:  +
 (link:../src/string/strcmp.c[../src/string/strcmp.c] l.67) manpage: link:manpages/string/string.3.rst[strcmp] +


strcpy::

  char *strcpy(char *dest, const char *src);
 +
  (link:../src/string/strcpy.c[../src/string/strcpy.c] l.3) manpage: link:manpages/string/string.3.rst[strcpy] +


strdup::

  char *strdup(const char *source);
 +
  Defines: strlen strcpy 0 +
 (link:../src/string/strdup.c[../src/string/strdup.c] l.7) manpage: link:manpages/string/strdup.3.rst[strdup] +


strerror::

  static char* strerror( int errnum );
 +
  (link:../src/string/strerror.c[../src/string/strerror.c] l.7) manpage: link:manpages/string/string.3.rst[strerror] +


strlen::

  int strlen(const char*str);
 +
  (link:../src/string/strlen.c[../src/string/strlen.c] l.4) manpage: link:manpages/string/strlen.3.rst[strlen] +


strncasecmp::

  int strncasecmp(const char*c1,const char*c2,int len);
 +
  Defines:  +
 (link:../src/string/strcmp.c[../src/string/strcmp.c] l.56) manpage: link:manpages/string/string.3.rst[strncasecmp] +


strncmp::

  int strncmp(const char*c1,const char*c2,int len);
 +
  Defines:  +
 (link:../src/string/strcmp.c[../src/string/strcmp.c] l.75) manpage: link:manpages/string/string.3.rst[strncmp] +


strncpy::

  char *strncpy(char *dest, const char *src, int n);
 +
  (link:../src/string/strncpy.c[../src/string/strncpy.c] l.7) manpage: link:manpages/string/string.3.rst[strncpy] +
copy max n chars from src to dest,  +
  write 0's up to src[n] when len of dest < n +
  Please note strlcpy (borrowed from freebsd),  +
  which does the same, +
  but doesn't pad dest with 0's. +
 

strrchr::

  char *strrchr(const char *s, int c);
 +
  Defines: strchrnul +
 (link:../src/string/strchr.c[../src/string/strchr.c] l.36) manpage: link:manpages/string/string.3.rst[strrchr] +


strstr::

  char* strstr(const char *big, const char *little);
 +
  (link:../src/string/strstr.c[../src/string/strstr.c] l.3) manpage: link:manpages/string/strstr.3.rst[strstr] +




 sys/wait.h
------------

wait::

  pid_t wait(int *wstatus);
 +
  Defines: wait4 +
 (link:../src/process/wait.c[../src/process/wait.c] l.8) manpage: link:manpages/sys/wait.2.rst[wait] +


waitpid::

  pid_t waitpid(pid_t pid, int *wstatus, int options);
 +
  Defines: wait4 +
 (link:../src/process/wait.c[../src/process/wait.c] l.16) manpage: link:manpages/sys/wait.2.rst[waitpid] +




 time.h
--------

time::

  time(unsigned int *a1 )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.257) manpage: link:manpages/gen/time.3.rst[time] +




 unistd.h
----------

access::

  access( const char *filename, int mode)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.168) manpage: link:manpages/sys/access.2.rst[access] +


chdir::

  chdir(const char* path)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.114) manpage: link:manpages/sys/chdir.2.rst[chdir] +


chown::

  chown( const char *filename, uid_t user, gid_t group)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.193) manpage: link:manpages/sys/chown.2.rst[chown] +


chroot::

  chroot( const char *filename)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.147) manpage: link:manpages/sys/chroot.2.rst[chroot] +


close::

  close( int fd )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.102) manpage: link:manpages/sys/close.2.rst[close] +


dup::

  dup(int fd)		
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.119) manpage: link:manpages/sys/dup.2.rst[dup] +


dup2::

  dup2(int oldfd, int newfd)		
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.120) manpage: link:manpages/sys/dup.2.rst[dup2] +


execl::

  static int execl(const char *pathname, const char* arg0,... );
 +
  Defines: environ execve +
 (link:../src/exec/execl.c[../src/exec/execl.c] l.6) manpage: link:manpages/gen/exec.3.rst[execl] +


execv::

  static inline int execv(const char *pathname, char *const argv[]);
 +
  Defines: environ execve +
 (link:../src/exec/_execv.c[../src/exec/_execv.c] l.4) manpage: link:manpages/gen/exec.3.rst[execv] +


execve::

  execve( const char *filename,  char* const* argv, char* const* envp)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.133) manpage: link:manpages/sys/execve.2.rst[execve] +


execvp::

  static inline int execvp(const char *file, char *const argv[]);
 +
  Defines: environ access execve +
 (link:../src/exec/_execvp.c[../src/exec/_execvp.c] l.4) manpage: link:manpages/gen/exec.3.rst[execvp] +


execvpe::

  static int execvpe(const char *file, char *const argv[], char *const envp[]);
 +
  Defines: execve environ access +
 (link:../src/exec/execvp.c[../src/exec/execvp.c] l.40)  +
When invoked with a filename, starting with "." or "/", +
  interprets this as absolute path. (calls execve with the pathname) +
  Looks for file in the PATH environment, othwerise. +
 

fork::

  DEF_syscall(fork,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.137) manpage: link:manpages/sys/fork.2.rst[fork] +


fsync::

  fsync(int a1 )
 +
 (link:../include/lseek.h[../include/lseek.h] l.22) manpage: link:manpages/sys/fsync.2.rst[fsync] +


ftruncate::

  ftruncate(unsigned int a1, unsigned int a2 )
 +
 (link:../include/lseek.h[../include/lseek.h] l.21) manpage: link:manpages/sys/truncate.2.rst[ftruncate] +


getgid::

  DEF_syscall(getgid,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.197) manpage: link:manpages/sys/getgid.2.rst[getgid] +


getgroups::

  int getgroups(int maxgroups, int *list);
 +
  Defines: open setpwent pwent token_s grent write setgrent token_i passwdfile_open getuid mmap +
 (link:../src/userdb/getgroups.c[../src/userdb/getgroups.c] l.8) manpage: link:manpages/sys/getgroups.2.rst[getgroups] +
get the groups of the calling process +
  does not necessarily contain the primary group, +
  which is given in the passwd entry. +
  This function calls internally setgrent() and getgrent(); +
  therefore any iteration with getgrent will be resetted. +
 

gethostname::

  static int gethostname(char *name,int len);
 +
  Defines: network +
 (link:../src/network/gethostname.c[../src/network/gethostname.c] l.4) manpage: link:manpages/gen/gethostname.3.rst[gethostname] +
gethostname +
 

getpgrp::

  DEF_syscall(getpgrp,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.198) manpage: link:manpages/sys/getpgrp.2.rst[getpgrp] +


getpid::

  DEF_syscall(getpid,0 )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.151) manpage: link:manpages/sys/getpid.2.rst[getpid] +


getuid::

  DEF_syscall(getuid,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.199) manpage: link:manpages/sys/getuid.2.rst[getuid] +


isatty::

  int isatty(int fd);
 +
  Defines: ioctl termio +
 (link:../src/termios/isatty.c[../src/termios/isatty.c] l.5) manpage: link:manpages/gen/ttyname.3.rst[isatty] +


link::

  link( const char *oldname, const char *newname)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.125) manpage: link:manpages/sys/link.2.rst[link] +


lseek::

  lseek(unsigned int a1, int a2, int a3 )
 +
 (link:../include/lseek.h[../include/lseek.h] l.19) manpage: link:manpages/sys/lseek.2.rst[lseek] +


mkdir::

  mkdir( const char *pathname, int mode)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.165) manpage: link:manpages/sys/mkdir.2.rst[mkdir] +


open::

  int volatile open( const char *s, int flags, ... );
 +
  (link:../src/file/open.c[../src/file/open.c] l.19) manpage: link:manpages/sys/open.2.rst[open] +
open or create a file. +
  warning: when using the flag O_CREAT, +
  file permission flags have to be given +
  as third argument. Otherwise file permission +
  flags will be random. (I still do not know, what  +
  the flag showing up as "-T" means..) +
 

pipe::

  pipe( int *filedes)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.236) manpage: link:manpages/sys/pipe.2.rst[pipe] +


read::

  read( int fd, void *buf, int len )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.103) manpage: link:manpages/sys/read.2.rst[read] +


rename::

  rename( const char* oldpath, const char* newpath )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.108) manpage: link:manpages/sys/rename.2.rst[rename] +


rmdir::

  rmdir( const char *pathname)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.166) manpage: link:manpages/sys/rmdir.2.rst[rmdir] +


select::

  static int volatile __attribute__((optimize("O0"))) select(int fd, volatile fd_set* readfd, volatile fd_set *writefd, volatile fd_set *exceptfd, volatile struct timeval *wait);
 +
  (link:../include/select.h[../include/select.h] l.17) manpage: link:manpages/sys/select.2.rst[select] +


setgid::

  setgid( gid_t gid)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.153) manpage: link:manpages/sys/setuid.2.rst[setgid] +


setpgid::

  setpgid( pid_t pid, pid_t pgid)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.196) manpage: link:manpages/sys/setpgid.2.rst[setpgid] +


setsid::

  DEF_syscall(setsid,0 )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.152) manpage: link:manpages/sys/setsid.2.rst[setsid] +


setuid::

  setuid( uid_t uid)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.154) manpage: link:manpages/sys/setuid.2.rst[setuid] +


sleep::

  unsigned int volatile sleep(unsigned int seconds);
 +
  Defines: nanosleep +
 (link:../src/process/sleep.c[../src/process/sleep.c] l.10) manpage: link:manpages/gen/sleep.3.rst[sleep] +
nonconformant sleep +
  TODO: ignore blocked signals, sigchld +
 

tcgetattr::

  int tcgetattr(int fd, struct termios *io);
 +
  Defines: termio ioctl +
 (link:../src/termios/tcgetattr.c[../src/termios/tcgetattr.c] l.19) manpage: link:manpages/gen/tcsetattr.3.rst[tcgetattr] +


tcsetattr::

  int tcsetattr(int fd, int opt, const struct termios *io);
 +
  Defines: termio ioctl +
 (link:../src/termios/tcsetattr.c[../src/termios/tcsetattr.c] l.18) manpage: link:manpages/gen/tcsetattr.3.rst[tcsetattr] +


unlink::

  unlink( const char* path)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.109) manpage: link:manpages/sys/unlink.2.rst[unlink] +


usleep::

  unsigned int volatile usleep(unsigned int useconds);
 +
  Defines: nanosleep +
 (link:../src/process/sleep.c[../src/process/sleep.c] l.31) manpage: link:manpages/gen/usleep.3.rst[usleep] +
nonconformant usleep.  +
  Sleep useconds. +
  I just hope, noone relies on an exact sleep time. +
  which isn't possible without a real time os, anyways. +
  When for whatever reason you'd need nanoseconds exact times, +
  best shot might be a spinloop, and looking for cpu ticks. +
  +
  TODO: ignore blocked signals, sigchld +
 

where::

  int where(const char *file,char *buf);
 +
  (link:../src/exec/execvp.c[../src/exec/execvp.c] l.8)  +
locate an executable in PATH +
 

write::

  write(int fd,const void *buf, int len )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.104) manpage: link:manpages/sys/write.2.rst[write] +



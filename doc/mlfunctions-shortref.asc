 implemented functions
=======================

short ref, links to source files.

Only functions defined are going to be built.

To define them, either do (for, e.g. puts) `#define mini_puts`
before you include minilib.h

Or, use the config script.: `mini_puts`

Some functions define other functions, these will be listed in the line,
starting with `Define:`


An example, using the scripting config, is given below:
(miniputs.c)
----
#if 0
mini_start
mini_puts

LDSCRIPT text_and_bss
INCLUDESRC
shrinkelf

return
#endif

int main(){
  puts("Hello, world!");
  return(0);
}
----

compile with ./mini-gcc --config miniputs.c -o miniputs miniputs.c

(what compiles to an annoying size of 251 Bytes here. Something again bloats.
replacing the puts with writes, there still are 208 Bytes. This used to
be 151 Bytes. Have to sort this out.)

:toc:






 declarations.h
----------------

chmod::

  chmod( const char *filename, mode_t mode)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.184) manpage: link:manpages/sys/chmod.2.rst[chmod] +


dup3::

  dup3(int oldfd, int newfd, int flags)		
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.114) manpage: link:manpages/gen/dup3.3.rst[dup3] +


execveat::

  execveat( int dirfd, const char *filename,  char* const* argv, char* const* envp, int flags)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.153)  +


fchmod::

  fchmod( unsigned int fd, mode_t mode)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.110) manpage: link:manpages/sys/chmod.2.rst[fchmod] +


fchown::

  fchown( unsigned int fd, uid_t user, gid_t group)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.109) manpage: link:manpages/sys/chown.2.rst[fchown] +


fcntl::

  fcntl( unsigned int fd, unsigned int cmd, unsigned long arg)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.158) manpage: link:manpages/sys/fcntl.2.rst[fcntl] +


fstat::

  fstat(int fd,struct stat* statbuf)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.105) manpage: link:manpages/sys/stat.2.rst[fstat] +


getcwd::

  getcwd( char *buf,  unsigned long size)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.116) manpage: link:manpages/gen/getcwd.3.rst[getcwd] +


getdents::

  getdents( unsigned int fd, struct dirent *direntry, unsigned int count )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.100) manpage: link:manpages/sys/getdirentries.2.rst[getdents] +


getitimer::

  getitimer( int which,  struct itimerval *value)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.198) manpage: link:manpages/sys/getitimer.2.rst[getitimer] +


getppid::

  DEF_syscall(getppid,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.187) manpage: link:manpages/sys/getpid.2.rst[getppid] +


gettimeofday::

  gettimeofday( struct timeval *a1, struct timezone *a2)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.132) manpage: link:manpages/sys/gettimeofday.2.rst[gettimeofday] +


kill::

  kill( pid_t pid,  int sig)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.125) manpage: link:manpages/sys/kill.2.rst[kill] +


memfd_create::

  memfd_create( const char  *uname_ptr,  unsigned int flags)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.170)  +


mknod::

  mknod( const char *filename,  umode_t mode,  unsigned dev)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.193) manpage: link:manpages/sys/mknod.2.rst[mknod] +


mount::

  mount( char *dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.164) manpage: link:manpages/sys/mount.2.rst[mount] +


mprotect::

  mprotect( POINTER *a1, POINTER a2, int a3 )
 +
 Returns: *a1 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.180) manpage: link:manpages/sys/mprotect.2.rst[mprotect] +


munmap::

  munmap( unsigned long addr,  size_t len)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.195) manpage: link:manpages/sys/munmap.2.rst[munmap] +


nanosleep::

  nanosleep( struct timespec *rqtp, struct timespec *rmtp)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.131) manpage: link:manpages/sys/nanosleep.2.rst[nanosleep] +


pivot_root::

  pivot_root( const char *new_root,  const char *put_old)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.138)  +


readahead::

  readahead( int fd,  loff_t offset,  size_t count)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.191)  +


reboot::

  reboot( int magic1,  int magic2,  unsigned int cmd,  void *arg)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.162) manpage: link:manpages/sys/reboot.2.rst[reboot] +


rt_sigaction::

  rt_sigaction( int sig,  const struct sigaction *act,  struct sigaction *oact,  size_t sigsetsize)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.134)  +


rt_sigprocmask::

  rt_sigprocmask( int how,  sigset_t *nset,  sigset_t *oset,  size_t sigsetsize)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.166)  +


rt_sigreturn::

  rt_sigreturn( unsigned long __unused)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.135)  +


sendfile::

  sendfile( int out_fd,  int in_fd,  off_t *offset,  size_t count)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.161) manpage: link:manpages/sys/sendfile.2.rst[sendfile] +


setitimer::

  setitimer( int which,  struct itimerval *value,  struct itimerval *ovalue)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.197) manpage: link:manpages/sys/getitimer.2.rst[setitimer] +


splice::

  splice( int fd_in,  loff_t *off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.175)  +


stat::

  stat(const char* filename,struct stat* statbuf)		
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.106) manpage: link:manpages/sys/stat.2.rst[stat] +


symlink::

  symlink( const char *oldname,  const char *newname)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.119) manpage: link:manpages/sys/symlink.2.rst[symlink] +


sync::

  DEF_syscall(sync,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.120) manpage: link:manpages/sys/sync.2.rst[sync] +


umask::

  umask( int mask)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.183) manpage: link:manpages/sys/umask.2.rst[umask] +


umount2::

  umount2( const char *mountpoint, int flags) 
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.160)  +


uname::

  uname(struct old_utsname *name )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.148) manpage: link:manpages/gen/uname.3.rst[uname] +


utime::

  utime( const char *filename, struct utimbuf *times)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.186) manpage: link:manpages/gen/utime.3.rst[utime] +


vfork::

  DEF_syscall(vfork,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.128) manpage: link:manpages/sys/vfork.2.rst[vfork] +


vhangup::

  DEF_syscall(vhangup,0 )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.146)  +


wait4::

  wait4( pid_t upid,  int *stat_addr,  int options,  struct rusage *ru)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.156) manpage: link:manpages/sys/wait.2.rst[wait4] +




 dirent.h
----------

closedir::

  int closedir(DIR *dir);
 +
  Defines: free +
 (link:../src/dirent/closedir.c[../src/dirent/closedir.c] l.6) manpage: link:manpages/gen/directory.3.rst[closedir] +


opendir::

  DIR *opendir(const char *name);
 +
  Defines: malloc close open +
 (link:../src/dirent/opendir.c[../src/dirent/opendir.c] l.9) manpage: link:manpages/gen/directory.3.rst[opendir] +


readdir::

  struct dirent *readdir(DIR *dir);
 +
  (link:../src/dirent/readdir.c[../src/dirent/readdir.c] l.9) manpage: link:manpages/gen/directory.3.rst[readdir] +
read a directory. +
  return the next dirent, or 0, if the end is reached. +
  return -1 on error and set errno, +
  if mini_errno is not defined, return -errno +
 

rewinddir::

  void rewinddir(DIR *dir);
 +
  (link:../src/dirent/rewinddir.c[../src/dirent/rewinddir.c] l.2) manpage: link:manpages/gen/directory.3.rst[rewinddir] +


seekdir::

  void seekdir(DIR *dir, long off);
 +
  (link:../src/dirent/seekdir.c[../src/dirent/seekdir.c] l.2) manpage: link:manpages/gen/directory.3.rst[seekdir] +


telldir::

  long telldir(DIR *dir);
 +
  (link:../src/dirent/telldir.c[../src/dirent/telldir.c] l.2) manpage: link:manpages/gen/directory.3.rst[telldir] +




 fcntl.h
---------

creat::

  int volatile creat( const char *s, int mode );
 +
  Defines: open +
 (link:../src/open.c[../src/open.c] l.36) manpage: link:manpages/compat-43/creat.2.rst[creat] +


mkfifo::

  static int mkfifo( const char* path, mode_t mode );
 +
  (link:../include/mkfifo.h[../include/mkfifo.h] l.4) manpage: link:manpages/sys/mkfifo.2.rst[mkfifo] +




 ioctl.h
---------

ioctl::

  int volatile  __attribute__((optimize("O0"))) ioctl( int fd, unsigned long int request, ... );
 +
  (link:../src/ioctl.c[../src/ioctl.c] l.11) manpage: link:manpages/sys/ioctl.2.rst[ioctl] +




 mini_addons.h
---------------

_itobin::

  int _itobin(int i, char*buf, int prec, int groups );
 +
  (link:../src/itobin.c[../src/itobin.c] l.8)  +


_mprints::

  #define _mprints(...) dprints(STDOUT_FILENO, __VA_ARGS__)
 +
  Defines: write +
 (link:../src/prints.c[../src/prints.c] l.69)  +


basename::

  char *basename(char *path);
 +
  Defines: strlen +
 (link:../src/basename.c[../src/basename.c] l.29) manpage: link:manpages/gen/basename.3.rst[basename] +


brk::

  static int brk( const void* addr );
 +
  (link:../src/brk.c[../src/brk.c] l.14) manpage: link:manpages/sys/brk.2.rst[brk] +
conformant brk, when mini_errno is defined +
  if no errno is available, +
  returns the negative errno value on error, +
  0 on success +
 

def::

  #define SETOPT_short( opts, option ) (;
 +
  (link:../macros/getoptm.h[../macros/getoptm.h] l.52)  +
Set a option flag(s) (bit(s))  manually. +
 		param options: e.g. just a, or ( a+h+l) to check for several flags at once +
 

dirfd::

  int dirfd(DIR *d);
 +
  (link:../src/dirent/dirfd.c[../src/dirent/dirfd.c] l.5) manpage: link:manpages/gen/directory.3.rst[dirfd] +


dirname::

  char *dirname(char *s);
 +
  Defines: strlen +
 (link:../src/dirname.c[../src/dirname.c] l.8) manpage: link:manpages/gen/dirname.3.rst[dirname] +


djb2_hash::

  unsigned long djb2_hash(const unsigned char *str);
 +
  (link:../src/hashes.c[../src/hashes.c] l.10)  +
hashes, from d.j.Bernstein +
  (http://www.cse.yorku.ca/~oz/hash.html) +
  I've tested djb2_hash, and it gives quite good results. +
  But I'm sure, Bernstein did think and test his algorithm sincerely. +
  When combining djb2_hash and sdbm_hash, the probability of collisions +
  might tend to zero. +
  Me I'm going this way. I guess. I might check djb2_hash for collisions within a space of around 8 digits. +
 

dprintf::

  int dprintf( int fd, const char *fmt, ... );
 +
  Defines: write +
 (link:../src/sprintf.c[../src/sprintf.c] l.203) manpage: link:manpages/stdio/printf.3.rst[dprintf] +


dprints::

  int dprints(int fd, const char *msg,...);
 +
  Defines: write +
 (link:../src/prints.c[../src/prints.c] l.48)  +


dtodec::

  int dtodec(double d, char* buf, int precision);
 +
  Defines: uitodec +
 (link:../src/dtodec.c[../src/dtodec.c] l.10)  +


eprint::

  #define eprint(str) write(STDERR_FILENO,str,strlen(str))
 +
  Defines: write strlen +
 (link:../include/prints.h[../include/prints.h] l.42)  +
write str to stderr. Needs strlen +
 

eprintfs::

  #define eprintfs(fmt,...) fprintfs(stderr, fmt, __VA_ARGS__)
 +
  Defines: write fileno strlen +
 (link:../include/prints.h[../include/prints.h] l.90)  +
write str to stderr.  +
  only format %s is recognized +
 

eprintl::

  #define eprintl() write(STDERR_FILENO,"\n",1)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.67)  +
write a newline to stderr +
 

eprints::

  #define eprints(...) dprints(STDERR_FILENO,__VA_ARGS__,0)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.17)  +
print the string(s) supplied as arg(s) to stdout +
 

eputs::

  #define eputs(msg) ( eprint(msg) + eprintl() )
 +
  Defines: strlen write +
 (link:../include/prints.h[../include/prints.h] l.77)  +
write msg to stderr, append a newline. Needs strlen. +
 

ewrites::

  #define ewrites(str) write(STDERR_FILENO,str,sizeof(str))
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.52)  +
write the constant str to stderr. Computes length with sizeof(str) at compile time. +
 

exit_errno::

  void exit_errno( int errnum );
 +
  Defines: errno_str exit execve write +
 (link:../src/exit_errno.c[../src/exit_errno.c] l.16)  +
exit, and execute /bin/errno +
  this is intended to give a error message for the  +
  given errno num. +
  Instead of having the error messages compiled  +
  into each binary, they can stay within one executable, "errno" +
  This spares about 4kB, but needs errno installed to /bin/errno +
  It's the drawback of not having a hared library, +
  where all executables would share the same errno messages +
  in memory. +
  On the other hand, a shared library would need to be installed +
  as well. +
  The supplied errno can be negative, +
  the absolute value is supplied to errno. +
 

fexecve::

  static inline int fexecve(int fd, char *const argv[], char *const envp[]);
 +
  (link:../include/fexecve.h[../include/fexecve.h] l.3) manpage: link:manpages/sys/execve.2.rst[fexecve] +


fexecveat::

  static inline int fexecveat(int fd, char *const argv[], char *const envp[]);
 +
  (link:../include/fexecveat.h[../include/fexecveat.h] l.3)  +


fprintfs::

  int fprintfs( FILE* F, char *fmt, ...);
 +
  Defines: fileno write strlen +
 (link:../src/fprintfs.c[../src/fprintfs.c] l.10)  +
prints formatted to the stream F.only %s is recognized.no mini_buf needed, so using fprintfs instead of fprintf can save some sections / bytes. +
 

fprints::

  #define fprints(F,str) write(fileno(F),str,strlen(str))
 +
  Defines: strlen fileno write +
 (link:../include/prints.h[../include/prints.h] l.24)  +
print the string(s) supplied as arg(s) to stream +
 

fwrites::

  #define fwrites(fd,str) write(fd,str,sizeof(str))
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.58)  +
write the constant str to fd. Computes length with sizeof(str) at compile time. +
 

grantpt::

  int grantpt(int fd);
 +
  (link:../src/pty.c[../src/pty.c] l.13) manpage: link:manpages/stdlib/ptsname.3.rst[grantpt] +


itobin::

  #define itobin(A,B,...) _itobin(A,B,VARARG(SHIFT(__VA_ARGS__),0), VARARG(SHIFT(ARG( __VA_ARGS__ )),32) )
 +
  Defines:  +
 (link:../src/itobin.c[../src/itobin.c] l.41)  +


itodec::

  int itodec(int i, char *buf, int prec, char limiter );
 +
  Defines: uitodec +
 (link:../src/itodec.c[../src/itodec.c] l.116)  +


ltodec::

  int ltodec(long i, char *buf, int prec, char limiter );
 +
  (link:../src/ltodec.c[../src/ltodec.c] l.75)  +


macro::

  static void __attribute__((noipa,cold)) optimization_fence(void*p){}
 +
  (link:../include/minilib_global.h[../include/minilib_global.h] l.77)  +
prevent optimizations. +
  cast a var to void*, and calling this, +
  leaves the compiler unknown on what he can strip. +
  (noipa) means the compiler doesn't know, what the function itself does. +
  (the function does nothing, but don't tell that gcc, please..) +
  therefore, everything used as parameter to this function, +
  will be calculated, defined, and so on before. +
  It's used for the globals,  +
  shich are pushed within _start onto the stack. +
  since _start itself only provides a global pointer, +
  and initialitzes some of the globals, +
  but doesn't use them again, +
  this construction is needed. +
  more funnily, the function will never be called. +
  It's past the asm inline syscall to exit. +
  But again, luckily gcc doesn't know. +
  All other options, like having the globals volatile,  +
  setting the optimization flag of _start to 0,  +
  having a volatile asm call with the globals as param, and so on, +
  have been useless. All after all, seems to me, ai has it's restrictions. +
 

memfrob::

  void* memfrob(void* s, unsigned int len);
 +
  (link:../src/memfrob.c[../src/memfrob.c] l.3)  +


mmap::

  static void* __attribute__((optimize("O0"))) mmap(void* addr,  size_t len,  int prot,  int flags,  int fd,  off_t off);
 +
  (link:../src/mmap.c[../src/mmap.c] l.8) manpage: link:manpages/sys/mmap.2.rst[mmap] +
mmap wrapper +
  address length is rounded up to a multiple of pagesize (4096 Bytes here) +
  for the description, please look up the according manpage +
  errno is only set, when mini_errno is defined +
  if not, on error the negative errno value is returned. +
  (e.g. -22 for "invalid argument") +
 

mremap::

  static void* volatile __attribute__((optimize("O0"))) mremap(void* addr, size_t old_len, size_t new_len, int flags, void* new_addr);
 +
  (link:../include/mremap.h[../include/mremap.h] l.4)  +


posix_openpt::

  int posix_openpt(int flags);
 +
  Defines: open +
 (link:../src/pty.c[../src/pty.c] l.8) manpage: link:manpages/sys/posix_openpt.2.rst[posix_openpt] +


print::

  #define print(str) write(STDOUT_FILENO,str,strlen(str))
 +
  Defines: write strlen +
 (link:../include/prints.h[../include/prints.h] l.38)  +
write str to stdout. Needs strlen +
 

printfs::

  #define printfs(fmt,...) fprintfs(stdout, fmt, __VA_ARGS__)
 +
  Defines: strlen fileno write +
 (link:../include/prints.h[../include/prints.h] l.84)  +
write str to stdout.  +
  only format %s is recognized +
 

printl::

  #define printl() write(STDOUT_FILENO,"\n",1)
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.63)  +
write a newline to stdout +
 

prints::

  #define prints(...) _mprints(__VA_ARGS__,0)
 +
  Defines:  +
 (link:../include/prints.h[../include/prints.h] l.11)  +
print the string(s) supplied as arg(s) to stdout +
 

printsl::

  #define printsl(...) _mprints(__VA_ARGS__,"\n",0)
 +
  Defines:  +
 (link:../include/prints.h[../include/prints.h] l.32)  +
print the string(s) supplied as arg(s) and newline to stdout +
 

ptsname::

  char *ptsname(int fd);
 +
  Defines: write uitodec ioctl open +
 (link:../src/pty.c[../src/pty.c] l.40) manpage: link:manpages/stdlib/ptsname.3.rst[ptsname] +


ptsname_r::

  int ptsname_r(int fd, char *buf, size_t len);
 +
  Defines: open ioctl uitodec write +
 (link:../src/pty.c[../src/pty.c] l.27)  +


sbrk::

  static void* sbrk(int incr);
 +
  (link:../src/brk.c[../src/brk.c] l.35) manpage: link:manpages/sys/brk.2.rst[sbrk] +
conformant sbrk, when mini_errno is defined +
  if no errno is available, +
  returns the negative errno value on error, +
  or the new break on success.  +
 

sdbm_hash::

  unsigned long sdbm_hash(const unsigned char *str);
 +
  (link:../src/hashes.c[../src/hashes.c] l.21)  +


snprintf::

  int snprintf( char *buf, size_t size, const char *fmt, ... );
 +
  Defines: write +
 (link:../src/sprintf.c[../src/sprintf.c] l.220) manpage: link:manpages/stdio/printf.3.rst[snprintf] +


sys_brk::

  static long sys_brk(unsigned long addr);
 +
  (link:../src/brk.c[../src/brk.c] l.3)  +
the kernel syscall brk. +
 

todo_abort::

  void todo_abort();
 +
  Defines: getpid +
 (link:../src/abort.c[../src/abort.c] l.3)  +


uitodec::

  int uitodec(unsigned int i, char *buf, int prec, char limiter );
 +
  (link:../src/itodec.c[../src/itodec.c] l.8)  +


ultodec::

  int ultodec(unsigned long ui, char *buf, int prec, char limiter );
 +
  (link:../src/ltodec.c[../src/ltodec.c] l.6)  +


unlockpt::

  int unlockpt(int fd);
 +
  Defines: ioctl +
 (link:../src/pty.c[../src/pty.c] l.20) manpage: link:manpages/stdlib/ptsname.3.rst[unlockpt] +


verbose_errstr::

  const char* verbose_errstr(int num);
 +
  (link:../include/errstr.h[../include/errstr.h] l.8)  +
verbose error (errno) string.  +
  this adds about 3.5kB to the compiled binary(!) +
 

vsnprintf::

  int vsnprintf(char *buf, size_t size, const char* fmt, va_list args );
 +
  Defines: write +
 (link:../src/sprintf.c[../src/sprintf.c] l.41) manpage: link:manpages/stdio/printf.3.rst[vsnprintf] +
the function, translating the fmt of printf. +
  warning - most possibly you'd like to define besides fprintf, or family, +
  mini_itodec (%d conversion)  +
  mini_atoi is needed for grouping numbers +
 

writes::

  #define writes(str) write(STDOUT_FILENO,str,sizeof(str))
 +
  Defines: write +
 (link:../include/prints.h[../include/prints.h] l.48)  +
write the constant str to stdout. Computes length with sizeof(str) at compile time. +
 



 mini_ksyscalls
----------------

ksys__sysctl::

  ksys__sysctl( struct __sysctl_args *args)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.315)  +


ksys_accept::

  ksys_accept( int fd,  struct sockaddr *upeersockaddr,  int *upeeraddrlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.91)  +


ksys_accept4::

  ksys_accept4( int fd,  struct sockaddr *upeer_sockaddr,  int *upeer_addrlen,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.551)  +


ksys_access::

  ksys_access( const char *filename,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.47)  +


ksys_acct::

  ksys_acct( const char *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.329)  +


ksys_add_key::

  ksys_add_key( const char *_type,  const char *_description,  const void *_payload,  size_t plen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.471)  +


ksys_adjtimex::

  ksys_adjtimex( struct timex *txc_p)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.321)  +


ksys_alarm::

  ksys_alarm( unsigned int seconds)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.79)  +


ksys_arch_prctl::

  ksys_arch_prctl( struct task_struct *task,  int code,  unsigned long *addr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.319)  +


ksys_bind::

  ksys_bind( int fd,  struct sockaddr *umyaddr,  int addrlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.103)  +


ksys_brk::

  ksys_brk( unsigned long brk)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.29)  +


ksys_capget::

  ksys_capget( cap_user_header_t header,  cap_user_data_t dataptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.255)  +


ksys_capset::

  ksys_capset( cap_user_header_t header,  const cap_user_data_t data)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.257)  +


ksys_chdir::

  ksys_chdir( const char *filename)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.165)  +


ksys_chmod::

  ksys_chmod( const char *filename,  mode_t mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.185)  +


ksys_chown::

  ksys_chown( const char *filename,  uid_t user,  gid_t group)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.189)  +


ksys_chroot::

  ksys_chroot( const char *filename)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.325)  +


ksys_clock_adjtime::

  ksys_clock_adjtime( clockid_t which_clock,  struct timex *tx)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.585)  +


ksys_clock_getres::

  ksys_clock_getres( const clockid_t which_clock,  struct timespec *tp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.435)  +


ksys_clock_gettime::

  ksys_clock_gettime( const clockid_t which_clock,  struct timespec *tp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.433)  +


ksys_clock_nanosleep::

  ksys_clock_nanosleep( const clockid_t which_clock,  int flags,  const struct timespec *rqtp,  struct timespec *rmtp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.437)  +


ksys_clock_settime::

  ksys_clock_settime( const clockid_t which_clock,  const struct timespec *tp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.431)  +


ksys_clone::

  ksys_clone( unsigned long clone_flags,  unsigned long newsp,  void *parent_tid,  void *child_tid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.117)  +


ksys_close::

  ksys_close( unsigned int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.11)  +


ksys_connect::

  ksys_connect( int fd,  struct sockaddr *uservaddr,  int addrlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.89)  +


ksys_creat::

  ksys_creat( const char *pathname,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.175)  +


ksys_delete_module::

  ksys_delete_module( const char *name_user,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.353)  +


ksys_dup::

  ksys_dup( unsigned int fildes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.69)  +


ksys_dup2::

  ksys_dup2( unsigned int oldfd,  unsigned int newfd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.71)  +


ksys_dup3::

  ksys_dup3( unsigned int oldfd,  unsigned int newfd,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.559)  +


ksys_epoll_create::

  ksys_epoll_create( int size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.407)  +


ksys_epoll_create1::

  ksys_epoll_create1( int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.557)  +


ksys_epoll_ctl::

  ksys_epoll_ctl( int epfd,  int op,  int fd,  struct epoll_event *event)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.443)  +


ksys_epoll_pwait::

  ksys_epoll_pwait( int epfd,  struct epoll_event *events,  int maxevents,  int timeout,  const sigset_t *sigmask,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.537)  +


ksys_epoll_wait::

  ksys_epoll_wait( int epfd,  struct epoll_event *events,  int maxevents,  int timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.441)  +


ksys_eventfd::

  ksys_eventfd( unsigned int count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.543)  +


ksys_eventfd2::

  ksys_eventfd2( unsigned int count,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.555)  +


ksys_execve::

  ksys_execve( const char *filename,  const char *const argv[],  const char *const envp[])
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.123)  +


ksys_exit::

  ksys_exit( int error_code)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.125) manpage: link:manpages/sys/_exit.2.rst[_exit] +


ksys_exit_group::

  ksys_exit_group( int error_code)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.439)  +


ksys_faccessat::

  ksys_faccessat( int dfd,  const char *filename,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.513)  +


ksys_fadvise64::

  ksys_fadvise64( int fd,  loff_t offset,  size_t len,  int advice)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.419)  +


ksys_fallocate::

  ksys_fallocate( long fd,  long mode,  loff_t offset,  loff_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.545)  +


ksys_fanotify_init::

  ksys_fanotify_init( unsigned int flags,  unsigned int event_f_flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.575)  +


ksys_fanotify_mark::

  ksys_fanotify_mark( long fanotify_fd,  long flags,  __u64 mask,  long dfd, long pathname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.577)  +


ksys_fchdir::

  ksys_fchdir( unsigned int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.167)  +


ksys_fchmod::

  ksys_fchmod( unsigned int fd,  mode_t mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.187)  +


ksys_fchmodat::

  ksys_fchmodat( int dfd,  const char *filename,  mode_t mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.511)  +


ksys_fchown::

  ksys_fchown( unsigned int fd,  uid_t user,  gid_t group)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.191)  +


ksys_fchownat::

  ksys_fchownat( int dfd,  const char *filename,  uid_t user,  gid_t group,  int flag)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.495)  +


ksys_fcntl::

  ksys_fcntl( unsigned int fd,  unsigned int cmd,  unsigned long arg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.149)  +


ksys_fdatasync::

  ksys_fdatasync( unsigned int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.155)  +


ksys_fgetxattr::

  ksys_fgetxattr( int fd,  const char *name,  void *value,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.371)  +


ksys_finit_module::

  ksys_finit_module( int fd,  const char  *uargs,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.601)  +


ksys_flistxattr::

  ksys_flistxattr( int fd,  char *list,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.377)  +


ksys_flock::

  ksys_flock( unsigned int fd,  unsigned int cmd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.151)  +


ksys_fork::

  ksysSYSDEF_syscall(_fork,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.119)  +


ksys_fremovexattr::

  ksys_fremovexattr( int fd,  const char *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.383)  +


ksys_fsetxattr::

  ksys_fsetxattr( int fd,  const char *name,  const void *value,  size_t size, int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.365)  +


ksys_fstat::

  ksys_fstat( unsigned int fd,  struct stat *statbuf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.15)  +


ksys_fstatfs::

  ksys_fstatfs( unsigned int fd,  struct statfs *buf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.279)  +


ksys_fsync::

  ksys_fsync( unsigned int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.153)  +


ksys_ftruncate::

  ksys_ftruncate( unsigned int fd,  unsigned long length)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.159)  +


ksys_futex::

  ksys_futex( u32 *uaddr,  int op,  u32 val,  struct timespec *utime,  u32 *uaddr2,  u32 val3)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.389)  +


ksys_futimesat::

  ksys_futimesat( int dfd,  const char *filename,  struct timeval *utimes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.497)  +


ksys_get_mempolicy::

  ksys_get_mempolicy( int *policy,  unsigned long *nmask,  unsigned long maxnode,  unsigned long addr,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.453)  +


ksys_get_robust_list::

  ksys_get_robust_list( int pid,  struct robust_list_head **head_ptr,  size_t *len_ptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.523)  +


ksys_getcpu::

  ksys_getcpu( unsigned *cpup,  unsigned *nodep,  struct getcpu_cache *unused)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.593)  +


ksys_getcwd::

  ksys_getcwd( char *buf,  unsigned long size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.163)  +


ksys_getdents::

  ksys_getdents( unsigned int fd,  struct linux_dirent *dirent,  unsigned int count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.161)  +


ksys_getdents64::

  ksys_getdents64( unsigned int fd,  struct linux_dirent64 *dirent,  unsigned int count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.411)  +


ksys_getegid::

  ksysSYSDEF_syscall(_getegid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.221)  +


ksys_geteuid::

  ksysSYSDEF_syscall(_geteuid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.219)  +


ksys_getgid::

  ksysSYSDEF_syscall(_getgid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.213)  +


ksys_getgroups::

  ksys_getgroups( int gidsetsize,  gid_t *grouplist)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.235)  +


ksys_getitimer::

  ksys_getitimer( int which,  struct itimerval *value)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.77)  +


ksys_getpeername::

  ksys_getpeername( int fd,  struct sockaddr *usockaddr,  int *usockaddr_len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.109)  +


ksys_getpgid::

  ksys_getpgid( pid_t pid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.247)  +


ksys_getpgrp::

  ksysSYSDEF_syscall(_getpgrp,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.227)  +


ksys_getpid::

  ksysSYSDEF_syscall(_getpid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.83)  +


ksys_getppid::

  ksysSYSDEF_syscall(_getppid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.225)  +


ksys_getpriority::

  ksys_getpriority( int which,  int who)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.283)  +


ksys_getrandom::

  ksys_getrandom( char  *buf,  size_t count,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.611)  +


ksys_getresgid::

  ksys_getresgid( gid_t *rgid,  gid_t *egid,  gid_t *sgid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.245)  +


ksys_getresuid::

  ksys_getresuid( uid_t *ruid,  uid_t *euid,  uid_t *suid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.241)  +


ksys_getrlimit::

  ksys_getrlimit( unsigned int resource,  struct rlimit *rlim)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.199)  +


ksys_getrusage::

  ksys_getrusage( int who,  struct rusage *ru)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.201)  +


ksys_getsid::

  ksys_getsid( pid_t pid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.253)  +


ksys_getsockname::

  ksys_getsockname( int fd,  struct sockaddr *usockaddr,  int *usockaddr_len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.107)  +


ksys_getsockopt::

  ksys_getsockopt( int fd,  int level,  int optname,  char *optval,  int *optlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.115)  +


ksys_gettid::

  ksysSYSDEF_syscall(_gettid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.357)  +


ksys_gettimeofday::

  ksys_gettimeofday( struct timeval *tv,  struct timezone *tz)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.197)  +


ksys_getuid::

  ksysSYSDEF_syscall(_getuid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.209)  +


ksys_getxattr::

  ksys_getxattr( const char *pathname,  const char *name,  void *value,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.367)  +


ksys_init_module::

  ksys_init_module( void *umod,  unsigned long len,  const char *uargs)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.351)  +


ksys_inotify_add_watch::

  ksys_inotify_add_watch( int fd,  const char *pathname,  u32 mask)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.483)  +


ksys_inotify_init::

  ksysSYSDEF_syscall(_inotify_init,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.481)  +


ksys_inotify_init1::

  ksys_inotify_init1( int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.563)  +


ksys_inotify_rm_watch::

  ksys_inotify_rm_watch( int fd,  __s32 wd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.485)  +


ksys_io_cancel::

  ksys_io_cancel( aio_context_t ctx_id,  struct iocb *iocb,  struct io_event *result)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.403)  +


ksys_io_destroy::

  ksys_io_destroy( aio_context_t ctx)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.397)  +


ksys_io_getevents::

  ksys_io_getevents( aio_context_t ctx_id,  long min_nr,  long nr,  struct io_event *events)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.399)  +


ksys_io_setup::

  ksys_io_setup( unsigned nr_events,  aio_context_t *ctxp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.395)  +


ksys_io_submit::

  ksys_io_submit( aio_context_t ctx_id,  long nr,  struct iocb **iocbpp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.401)  +


ksys_ioctl::

  ksys_ioctl( unsigned int fd,  unsigned int cmd,  unsigned long arg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.37)  +


ksys_ioperm::

  ksys_ioperm( unsigned long from,  unsigned long num,  int turn_on)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.349)  +


ksys_iopl::

  ksys_iopl( unsigned int level,  struct pt_regs *regs)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.347)  +


ksys_ioprio_get::

  ksys_ioprio_get( int which,  int who)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.479)  +


ksys_ioprio_set::

  ksys_ioprio_set( int which,  int who,  int ioprio)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.477)  +


ksys_kcmp::

  ksys_kcmp( pid_t pid1,  pid_t pid2,  int type,  unsigned long idx1,  unsigned long idx2)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.599)  +


ksys_kexec_file_load::

  ksys_kexec_file_load( int kernel_fd,  int initrd_fd,  unsigned long cmdline_len,  const char  *cmdline_ptr,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.615)  +


ksys_kexec_load::

  ksys_kexec_load( unsigned long entry,  unsigned long nr_segments,  struct kexec_segment *segments,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.467)  +


ksys_keyctl::

  ksys_keyctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.475)  +


ksys_kill::

  ksys_kill( pid_t pid,  int sig)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.129)  +


ksys_lchown::

  ksys_lchown( const char *filename,  uid_t user,  gid_t group)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.193)  +


ksys_lgetxattr::

  ksys_lgetxattr( const char *pathname,  const char *name,  void *value,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.369)  +


ksys_link::

  ksys_link( const char *oldname,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.177)  +


ksys_linkat::

  ksys_linkat( int oldfd,  const char *oldname,  int newfd,  const char *newname,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.505)  +


ksys_listen::

  ksys_listen( int fd,  int backlog)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.105)  +


ksys_listxattr::

  ksys_listxattr( const char *pathname,  char *list,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.373)  +


ksys_llistxattr::

  ksys_llistxattr( const char *pathname,  char *list,  size_t size)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.375)  +


ksys_lookup_dcookie::

  ksys_lookup_dcookie( u64 cookie64,  long buf,  long len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.405)  +


ksys_lremovexattr::

  ksys_lremovexattr( const char *pathname,  const char *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.381)  +


ksys_lseek::

  ksys_lseek( unsigned int fd,  off_t offset,  unsigned int origin)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.21)  +


ksys_lsetxattr::

  ksys_lsetxattr( const char *pathname,  const char *name,  const void *value, size_t size,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.363)  +


ksys_lstat::

  ksys_lstat( const char *filename,  struct stat *statbuf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.17)  +


ksys_madvise::

  ksys_madvise( unsigned long start,  size_t len_in,  int behavior)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.61)  +


ksys_mbind::

  ksys_mbind( unsigned long start,  unsigned long len,  unsigned long mode,  unsigned long *nmask,  unsigned long maxnode,  unsigned flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.449)  +


ksys_memfd_create::

  ksys_memfd_create( const char  *uname_ptr,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.613)  +


ksys_migrate_pages::

  ksys_migrate_pages( pid_t pid,  unsigned long maxnode,  const unsigned long *old_nodes,  const unsigned long *new_nodes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.487)  +


ksys_mincore::

  ksys_mincore( unsigned long start,  size_t len,  unsigned char *vec)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.59)  +


ksys_mkdir::

  ksys_mkdir( const char *pathname,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.171)  +


ksys_mkdirat::

  ksys_mkdirat( int dfd,  const char *pathname,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.491)  +


ksys_mknod::

  ksys_mknod( const char *filename,  umode_t mode,  unsigned dev)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.271)  +


ksys_mknodat::

  ksys_mknodat( int dfd,  const char *filename,  int mode,  unsigned dev)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.493)  +


ksys_mlock::

  ksys_mlock( unsigned long start,  size_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.301)  +


ksys_mlockall::

  ksys_mlockall( int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.305)  +


ksys_mmap::

  ksys_mmap( unsigned long addr,  unsigned long len,  unsigned long prot,  unsigned long flags,  unsigned long fd,  unsigned long off)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.23)  +


ksys_modify_ldt::

  ksys_modify_ldt( int func,  void *ptr,  unsigned long bytecount)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.311)  +


ksys_mount::

  ksys_mount( char *dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.333)  +


ksys_move_pages::

  ksys_move_pages( pid_t pid,  unsigned long nr_pages,  const void *pages[], const int *nodes,  int *status,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.533)  +


ksys_mprotect::

  ksys_mprotect( unsigned long start,  size_t len,  unsigned long prot)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.25)  +


ksys_mq_getsetattr::

  ksys_mq_getsetattr( mqd_t mqdes,  const struct mq_attr *u_mqstat,  struct mq_attr *u_omqstat)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.465)  +


ksys_mq_notify::

  ksys_mq_notify( mqd_t mqdes,  const struct sigevent *u_notification)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.463)  +


ksys_mq_open::

  ksys_mq_open( const char *u_name,  int oflag,  mode_t mode,  struct mq_attr *u_attr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.455)  +


ksys_mq_timedreceive::

  ksys_mq_timedreceive( mqd_t mqdes,  char *u_msg_ptr,  size_t msg_len,  unsigned int *u_msg_prio,  const struct timespec *u_abs_timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.461)  +


ksys_mq_timedsend::

  ksys_mq_timedsend( mqd_t mqdes,  const char *u_msg_ptr,  size_t msg_len,  unsigned int msg_prio,  const struct timespec *u_abs_timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.459)  +


ksys_mq_unlink::

  ksys_mq_unlink( const char *u_name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.457)  +


ksys_mremap::

  ksys_mremap( unsigned long addr,  unsigned long old_len,  unsigned long new_len,  unsigned long flags,  unsigned long new_addr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.55)  +


ksys_msgctl::

  ksys_msgctl( int msqid,  int cmd,  struct msqid_ds *buf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.147)  +


ksys_msgget::

  ksys_msgget( key_t key,  int msgflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.141)  +


ksys_msgrcv::

  ksys_msgrcv( int msqid,  struct msgbuf *msgp,  size_t msgsz,  long msgtyp,  int msgflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.145)  +


ksys_msgsnd::

  ksys_msgsnd( int msqid,  struct msgbuf *msgp,  size_t msgsz,  int msgflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.143)  +


ksys_msync::

  ksys_msync( unsigned long start,  size_t len,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.57)  +


ksys_munlock::

  ksys_munlock( unsigned long start,  size_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.303)  +


ksys_munlockall::

  ksysSYSDEF_syscall(_munlockall,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.307)  +


ksys_munmap::

  ksys_munmap( unsigned long addr,  size_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.27)  +


ksys_name_to_handle_at::

  ksys_name_to_handle_at( int dfd,  const char *name,  struct file_handle *handle,  int *mnt_id,  int flag)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.581)  +


ksys_nanosleep::

  ksys_nanosleep( struct timespec *rqtp,  struct timespec *rmtp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.75)  +


ksys_newfstatat::

  ksys_newfstatat( int dfd,  const char *filename,  struct stat *statbuf,  int flag)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.499)  +


ksys_open::

  ksys_open( const char *filename,  int flags,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.9)  +


ksys_open_by_handle_at::

  ksys_open_by_handle_at( int dfd,  const char *name,  struct file_handle *handle,  int *mnt_id,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.583)  +


ksys_openat::

  ksys_openat( int dfd,  const char *filename,  int flags,  int mode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.489)  +


ksys_pause::

  ksysSYSDEF_syscall(_pause,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.73)  +


ksys_perf_event_open::

  ksys_perf_event_open( struct perf_event_attr *attr_uptr,  pid_t pid,  int cpu,  int group_fd,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.571)  +


ksys_personality::

  ksys_personality( unsigned int personality)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.273)  +


ksys_pipe::

  ksys_pipe( int *filedes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.49)  +


ksys_pipe2::

  ksys_pipe2( int *filedes,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.561)  +


ksys_pivot_root::

  ksys_pivot_root( const char *new_root,  const char *put_old)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.313)  +


ksys_poll::

  ksys_poll( struct poll_fd *ufds,  unsigned int nfds,  long timeout_msecs)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.19)  +


ksys_ppoll::

  ksys_ppoll( struct pollfd *ufds,  unsigned int nfds,  struct timespec *tsp,  const sigset_t *sigmask,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.517)  +


ksys_prctl::

  ksys_prctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.317)  +


ksys_pread64::

  ksys_pread64( unsigned long fd,  char *buf,  size_t count,  loff_t pos)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.39)  +


ksys_preadv::

  ksys_preadv( unsigned long fd,  const struct iovec *vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.565)  +


ksys_prlimit64::

  ksys_prlimit64( pid_t pid,  unsigned int resource,  const struct rlimit64 *new_rlim,  struct rlimit64 *old_rlim)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.579)  +


ksys_process_vm_readv::

  ksys_process_vm_readv( pid_t pid,  const struct iovec *lvec,  unsigned long liovcnt,  const struct iovec *rvec,  unsigned long riovcnt,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.595)  +


ksys_process_vm_writev::

  ksys_process_vm_writev( pid_t pid,  const struct iovec *lvec,  unsigned long liovcnt,  const struct iovcc *rvec,  unsigned long riovcnt,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.597)  +


ksys_pselect6::

  ksys_pselect6( int n,  fd_set *inp,  fd_set *outp,  fd_set *exp,  struct timespec *tsp,  void *sig)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.515)  +


ksys_ptrace::

  ksys_ptrace( long request,  long pid,  unsigned long addr,  unsigned long data)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.207)  +


ksys_pwrite64::

  ksys_pwrite64( unsigned int fd,  const char *buf,  size_t count,  loff_t pos)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.41)  +


ksys_pwritev::

  ksys_pwritev( unsigned long fd,  const struct iovec *vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.567)  +


ksys_quotactl::

  ksys_quotactl( unsigned int cmd,  const char *special,  qid_t id,  void *addr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.355)  +


ksys_read::

  ksys_read( unsigned int fd,  char *buf,  size_t count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.5)  +


ksys_readahead::

  ksys_readahead( int fd,  loff_t offset,  size_t count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.359)  +


ksys_readlink::

  ksys_readlink( const char *path,  char *buf,  int bufsiz)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.183)  +


ksys_readlinkat::

  ksys_readlinkat( int dfd,  const char *pathname,  char *buf,  int bufsiz)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.509)  +


ksys_readv::

  ksys_readv( unsigned long fd,  const struct iovec *vec,  unsigned long vlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.43)  +


ksys_reboot::

  ksys_reboot( int magic1,  int magic2,  unsigned int cmd,  void *arg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.341)  +


ksys_recvfrom::

  ksys_recvfrom( int fd,  void *ubuf,  size_t size,  unsigned flags,  struct sockaddr *addr,  int *addr_len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.95)  +


ksys_recvmmsg::

  ksys_recvmmsg( int fd,  struct msghdr *mmsg,  unsigned int vlen,  unsigned int flags,  struct timespec *timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.573)  +


ksys_recvmsg::

  ksys_recvmsg( int fd,  struct msghdr *msg,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.99)  +


ksys_remap_file_pages::

  ksys_remap_file_pages( unsigned long start,  unsigned long size,  unsigned long prot,  unsigned long pgoff,  unsigned long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.409)  +


ksys_removexattr::

  ksys_removexattr( const char *pathname,  const char *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.379)  +


ksys_rename::

  ksys_rename( const char *oldname,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.169)  +


ksys_renameat::

  ksys_renameat( int oldfd,  const char *oldname,  int newfd,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.503)  +


ksys_renameat2::

  ksys_renameat2( int olddfd,  const char  *oldname,  int newdfd,  const char  *newname,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.607)  +


ksys_request_key::

  ksys_request_key( const char *_type,  const char *_description,  const char *_callout_info,  key_serial_t destringid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.473)  +


ksys_restart_syscall::

  ksysSYSDEF_syscall(_restart_syscall,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.415)  +


ksys_rmdir::

  ksys_rmdir( const char *pathname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.173)  +


ksys_rt_sigaction::

  ksys_rt_sigaction( int sig,  const struct sigaction *act,  struct sigaction *oact,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.31)  +


ksys_rt_sigpending::

  ksys_rt_sigpending( sigset_t *set,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.259)  +


ksys_rt_sigprocmask::

  ksys_rt_sigprocmask( int how,  sigset_t *nset,  sigset_t *oset,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.33)  +


ksys_rt_sigqueueinfo::

  ksys_rt_sigqueueinfo( pid_t pid,  int sig,  siginfo_t *uinfo)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.263)  +


ksys_rt_sigreturn::

  ksys_rt_sigreturn( unsigned long __unused)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.35)  +


ksys_rt_sigsuspend::

  ksys_rt_sigsuspend( sigset_t *unewset,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.265)  +


ksys_rt_sigtimedwait::

  ksys_rt_sigtimedwait( const sigset_t *uthese,  siginfo_t *uinfo,  const struct timespec *uts,  size_t sigsetsize)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.261)  +


ksys_rt_tgsigqueueinfo::

  ksys_rt_tgsigqueueinfo( pid_t tgid,  pid_t pid,  int sig,  siginfo_t *uinfo)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.569)  +


ksys_sched_get_priority_max::

  ksys_sched_get_priority_max( int policy)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.295)  +


ksys_sched_get_priority_min::

  ksys_sched_get_priority_min( int policy)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.297)  +


ksys_sched_getaffinity::

  ksys_sched_getaffinity( pid_t pid,  unsigned int len,  unsigned long *user_mask_ptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.393)  +


ksys_sched_getattr::

  ksys_sched_getattr( pid_t pid,  struct sched_attr  *attr,  unsigned int size,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.605)  +


ksys_sched_getparam::

  ksys_sched_getparam( pid_t pid,  struct sched_param *param)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.289)  +


ksys_sched_getscheduler::

  ksys_sched_getscheduler( pid_t pid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.293)  +


ksys_sched_rr_get_interval::

  ksys_sched_rr_get_interval( pid_t pid,  struct timespec *interval)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.299)  +


ksys_sched_setaffinity::

  ksys_sched_setaffinity( pid_t pid,  unsigned int len,  unsigned long *user_mask_ptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.391)  +


ksys_sched_setattr::

  ksys_sched_setattr( pid_t pid,  struct sched_attr  *attr,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.603)  +


ksys_sched_setparam::

  ksys_sched_setparam( pid_t pid,  struct sched_param *param)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.287)  +


ksys_sched_setscheduler::

  ksys_sched_setscheduler( pid_t pid,  int policy,  struct sched_param *param)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.291)  +


ksys_sched_yield::

  ksysSYSDEF_syscall(_sched_yield,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.53)  +


ksys_seccomp::

  ksys_seccomp( unsigned int op,  unsigned int flags,  const char  *uargs)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.609)  +


ksys_select::

  ksys_select( int n,  fd_set *inp,  fd_set *outp,  fd_set *exp,  struct timeval *tvp)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.51)  +


ksys_semctl::

  ksys_semctl( int semid,  int semnum,  int cmd,  semun_u arg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.137)  +


ksys_semget::

  ksys_semget( key_t key,  int nsems,  int semflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.133)  +


ksys_semop::

  ksys_semop( int semid,  struct sembuf *tsops,  unsigned nsops)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.135)  +


ksys_semtimedop::

  ksys_semtimedop( int semid,  struct sembuf *tsops,  unsigned nsops,  const struct timespec *timeout)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.417)  +


ksys_sendfile::

  ksys_sendfile( int out_fd,  int in_fd,  off_t *offset,  size_t count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.85)  +


ksys_sendmmsg::

  ksys_sendmmsg( int fd,  struct mmsghdr *mmsg,  unsigned int vlen,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.589)  +


ksys_sendmsg::

  ksys_sendmsg( int fd,  struct msghdr *msg,  unsigned flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.97)  +


ksys_sendto::

  ksys_sendto( int fd,  void *buff,  size_t len,  unsigned flags,  struct sockaddr *addr,  int addr_len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.93)  +


ksys_set_mempolicy::

  ksys_set_mempolicy( int mode,  unsigned long *nmask,  unsigned long maxnode)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.451)  +


ksys_set_robust_list::

  ksys_set_robust_list( struct robust_list_head *head,  size_t len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.521)  +


ksys_set_tid_address::

  ksys_set_tid_address( int *tidptr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.413)  +


ksys_setdomainname::

  ksys_setdomainname( char *name,  int len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.345)  +


ksys_setfsgid::

  ksys_setfsgid( gid_t gid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.251)  +


ksys_setfsuid::

  ksys_setfsuid( uid_t uid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.249)  +


ksys_setgid::

  ksys_setgid( gid_t gid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.217)  +


ksys_setgroups::

  ksys_setgroups( int gidsetsize,  gid_t *grouplist)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.237)  +


ksys_sethostname::

  ksys_sethostname( char *name,  int len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.343)  +


ksys_setitimer::

  ksys_setitimer( int which,  struct itimerval *value,  struct itimerval *ovalue)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.81)  +


ksys_setns::

  ksys_setns( int fd,  int nstype)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.591)  +


ksys_setpgid::

  ksys_setpgid( pid_t pid,  pid_t pgid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.223)  +


ksys_setpriority::

  ksys_setpriority( int which,  int who,  int niceval)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.285)  +


ksys_setregid::

  ksys_setregid( gid_t rgid,  gid_t egid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.233)  +


ksys_setresgid::

  ksys_setresgid( gid_t rgid,  gid_t egid,  gid_t sgid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.243)  +


ksys_setresuid::

  ksys_setresuid( uid_t *ruid,  uid_t *euid,  uid_t *suid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.239)  +


ksys_setreuid::

  ksys_setreuid( uid_t ruid,  uid_t euid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.231)  +


ksys_setrlimit::

  ksys_setrlimit( unsigned int resource,  struct rlimit *rlim)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.323)  +


ksys_setsid::

  ksysSYSDEF_syscall(_setsid,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.229)  +


ksys_setsockopt::

  ksys_setsockopt( int fd,  int level,  int optname,  char *optval,  int optlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.113)  +


ksys_settimeofday::

  ksys_settimeofday( struct timeval *tv,  struct timezone *tz)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.331)  +


ksys_setuid::

  ksys_setuid( uid_t uid)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.215)  +


ksys_setxattr::

  ksys_setxattr( const char *pathname,  const char *name,  const void *value, size_t size,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.361)  +


ksys_shmat::

  ksys_shmat( int shmid,  char *shmaddr,  int shmflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.65)  +


ksys_shmctl::

  ksys_shmctl( int shmid,  int cmd,  struct shmid_ds *buf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.67)  +


ksys_shmdt::

  ksys_shmdt( char *shmaddr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.139)  +


ksys_shmget::

  ksys_shmget( key_t key,  size_t size,  int shmflg)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.63)  +


ksys_shutdown::

  ksys_shutdown( int fd,  int how)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.101)  +


ksys_sigaltstack::

  ksys_sigaltstack( const stack_t *uss,  stack_t *uoss)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.267)  +


ksys_signalfd::

  ksys_signalfd( int ufd,  sigset_t *user_mask,  size_t sizemask)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.539)  +


ksys_signalfd4::

  ksys_signalfd4( int ufd,  sigset_t *user_mask,  size_t sizemask,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.553)  +


ksys_socket::

  ksys_socket( int family,  int type,  int protocol)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.87)  +


ksys_socketpair::

  ksys_socketpair( int family,  int type,  int protocol,  int *usockvec)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.111)  +


ksys_splice::

  ksys_splice( int fd_in,  loff_t *off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.525)  +


ksys_stat::

  ksys_stat( const char *filename,  struct stat *statbuf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.13)  +


ksys_statfs::

  ksys_statfs( const char *pathname,  struct statfs *buf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.277)  +


ksys_swapoff::

  ksys_swapoff( const char *specialfile)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.339)  +


ksys_swapon::

  ksys_swapon( const char *specialfile,  int swap_flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.337)  +


ksys_symlink::

  ksys_symlink( const char *oldname,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.181)  +


ksys_symlinkat::

  ksys_symlinkat( const char *oldname,  int newfd,  const char *newname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.507)  +


ksys_sync::

  ksysSYSDEF_syscall(_sync,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.327)  +


ksys_sync_file_range::

  ksys_sync_file_range( long fd,  loff_t offset,  loff_t bytes,  long flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.529)  +


ksys_syncfs::

  ksys_syncfs( int fd)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.587)  +


ksys_sysfs::

  ksys_sysfs( int option,  unsigned long arg1,  unsigned long arg2)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.281)  +


ksys_sysinfo::

  ksys_sysinfo( struct sysinfo *info)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.203)  +


ksys_syslog::

  ksys_syslog( int type,  char *buf,  int len)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.211)  +


ksys_tee::

  ksys_tee( int fdin,  int fdout,  size_t len,  unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.527)  +


ksys_tgkill::

  ksys_tgkill( pid_t tgid,  pid_t pid,  int sig)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.445)  +


ksys_time::

  ksys_time( time_t *tloc)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.387)  +


ksys_timer_create::

  ksys_timer_create( const clockid_t which_clock,  struct sigevent *timer_event_spec,  timer_t *created_timer_id)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.421)  +


ksys_timer_delete::

  ksys_timer_delete( timer_t timer_id)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.429)  +


ksys_timer_getoverrun::

  ksys_timer_getoverrun( timer_t timer_id)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.427)  +


ksys_timer_gettime::

  ksys_timer_gettime( timer_t timer_id,  struct itimerspec *setting)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.425)  +


ksys_timer_settime::

  ksys_timer_settime( timer_t timer_id,  int flags,  const struct itimerspec *new_setting,  struct itimerspec *old_setting)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.423)  +


ksys_timerfd_create::

  ksys_timerfd_create( int clockid,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.541)  +


ksys_timerfd_gettime::

  ksys_timerfd_gettime( int ufd,  struct itimerspec *otmr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.549)  +


ksys_timerfd_settime::

  ksys_timerfd_settime( int ufd,  int flags,  const struct itimerspec *utmr,  struct itimerspec *otmr)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.547)  +


ksys_times::

  ksys_times( struct sysinfo *info)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.205)  +


ksys_tkill::

  ksys_tkill( pid_t pid,  int sig)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.385)  +


ksys_truncate::

  ksys_truncate( const char *path,  long length)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.157)  +


ksys_umask::

  ksys_umask( int mask)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.195)  +


ksys_umount2::

  ksys_umount2( const char *target,  int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.335)  +


ksys_uname::

  ksys_uname( struct old_utsname *name)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.131)  +


ksys_unlink::

  ksys_unlink( const char *pathname)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.179)  +


ksys_unlinkat::

  ksys_unlinkat( int dfd,  const char *pathname,  int flag)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.501)  +


ksys_unshare::

  ksys_unshare( unsigned long unshare_flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.519)  +


ksys_ustat::

  ksys_ustat( unsigned dev,  struct ustat *ubuf)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.275)  +


ksys_utime::

  ksys_utime( char *filename,  struct utimbuf *times)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.269)  +


ksys_utimensat::

  ksys_utimensat( int dfd,  const char *filename,  struct timespec *utimes, int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.535)  +


ksys_utimes::

  ksys_utimes( char *filename,  struct timeval *utimes)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.447)  +


ksys_vfork::

  ksysSYSDEF_syscall(_vfork,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.121)  +


ksys_vhangup::

  ksysSYSDEF_syscall(_vhangup,0)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.309)  +


ksys_vmsplice::

  ksys_vmsplice( int fd,  const struct iovec *iov,  unsigned long nr_segs, unsigned int flags)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.531)  +


ksys_wait4::

  ksys_wait4( pid_t upid,  int *stat_addr,  int options,  struct rusage *ru)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.127)  +


ksys_waitid::

  ksys_waitid( int which,  pid_t upid,  struct siginfo *infop,  int options,  struct rusage *ru)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.469)  +


ksys_write::

  ksys_write( unsigned int fd,  const char *buf,  size_t count)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.7)  +


ksys_writev::

  ksys_writev( unsigned long fd,  const struct iovec *vec,  unsigned long vlen)
 +
 (link:../include/syscalls_x64.h[../include/syscalls_x64.h] l.45)  +




 signal.h
----------

raise::

  static inline int raise(int signr);
 +
  Defines: getpid +
 (link:../src/sigaction.c[../src/sigaction.c] l.135) manpage: link:manpages/gen/raise.3.rst[raise] +


sigaction::

  static int volatile sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
 +
  Defines: memcpy +
 (link:../src/sigaction.c[../src/sigaction.c] l.107) manpage: link:manpages/sys/sigaction.2.rst[sigaction] +


sigaddset::

  int sigaddset(sigset_t *set, int sig);
 +
  (link:../src/sigaction.c[../src/sigaction.c] l.34) manpage: link:manpages/gen/sigsetops.3.rst[sigaddset] +


sigdelset::

  int sigdelset(sigset_t *set, int sig);
 +
  (link:../src/sigaction.c[../src/sigaction.c] l.58) manpage: link:manpages/gen/sigsetops.3.rst[sigdelset] +


sigemptyset::

  static int sigemptyset(sigset_t *set);
 +
  (link:../src/sigaction.c[../src/sigaction.c] l.7) manpage: link:manpages/gen/sigsetops.3.rst[sigemptyset] +


sigfillset::

  static int sigfillset(sigset_t *set);
 +
  (link:../src/sigaction.c[../src/sigaction.c] l.20) manpage: link:manpages/gen/sigsetops.3.rst[sigfillset] +


sigismember::

  int sigismember(sigset_t *set, int sig);
 +
  (link:../src/sigaction.c[../src/sigaction.c] l.75) manpage: link:manpages/gen/sigsetops.3.rst[sigismember] +


signal::

  sighandler_t signal(int sig, sighandler_t func );
 +
  Defines: memcpy write +
 (link:../src/signal.c[../src/signal.c] l.8) manpage: link:manpages/gen/signal.3.rst[signal] +


sigprocmask::

  int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
 +
  (link:../src/sigaction.c[../src/sigaction.c] l.52) manpage: link:manpages/sys/sigprocmask.2.rst[sigprocmask] +




 stdio.h
---------

_fopen::

  FILE *_fopen(int fd, const char* filename, const char* mode, FILE *f);
 +
  Defines: open close fileno +
 (link:../src/fopen.c[../src/fopen.c] l.12)  +
modes implemented: r, r+, w, w+, a, a+ +
 

_itohex::

  int _itohex(int i,char* buf,int padding, int capitals);
 +
  (link:../src/itohex.c[../src/itohex.c] l.6)  +


clearerr::

  static inline void clearerr(FILE *f);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.198) manpage: link:manpages/stdio/ferror.3.rst[clearerr] +


clearerror::

  static inline void clearerror(FILE *f);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.203)  +


fclose::

  static inline int __attribute__((always_inline)) fclose( FILE* f );
 +
  Defines: close +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.65) manpage: link:manpages/stdio/fclose.3.rst[fclose] +


fdopen::

  FILE *fdopen(int fd, const char* mode);
 +
  Defines: open close fileno +
 (link:../src/fopen.c[../src/fopen.c] l.90) manpage: link:manpages/stdio/fopen.3.rst[fdopen] +
modes implemented: r, r+, w, w+, a, a+ +
 

feof::

  static inline int feof(FILE *f);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.184) manpage: link:manpages/stdio/ferror.3.rst[feof] +


ferror::

  static inline int ferror(FILE *f);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.191) manpage: link:manpages/stdio/ferror.3.rst[ferror] +


fflush::

  static inline int __attribute__((always_inline)) fflush( FILE *F );
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.28) manpage: link:manpages/stdio/fflush.3.rst[fflush] +
This does nothing, since minilib doesn't provide buffered streams yet.In order to sync data to disc, please use fsync +
 

fgetc::

  static inline int fgetc(FILE *F);
 +
  Defines: fileno read +
 (link:../include/fgetc.h[../include/fgetc.h] l.11) manpage: link:manpages/stdio/getc.3.rst[fgetc] +


fgetpos::

  static inline void fgetpos(FILE *f, long *pos );
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.127) manpage: link:manpages/stdio/fseek.3.rst[fgetpos] +


fgets::

  char* fgets(char *buf, int size, FILE* F);
 +
  Defines: read fileno +
 (link:../src/fgets.c[../src/fgets.c] l.6) manpage: link:manpages/stdio/fgets.3.rst[fgets] +


fileno::

  static int fileno( FILE *f );
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.56) manpage: link:manpages/stdio/ferror.3.rst[fileno] +
Return the fd nummber of stdin,-out,-err.  +
 

fopen::

  FILE *fopen(const char* filename, const char* mode);
 +
  Defines: open close fileno +
 (link:../src/fopen.c[../src/fopen.c] l.80) manpage: link:manpages/stdio/fopen.3.rst[fopen] +
modes implemented: r, r+, w, w+, a, a+ +
 

fprint::

  #define fprint(...) fprintf(__VA_ARGS__)
 +
  Defines: fileno write +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.95)  +


fprintf::

  #define fprintf(stream,...)	write(fileno(stream),mlgl->mbuf,sprintf(mlgl->mbuf,__VA_ARGS__))
 +
  Defines: write fileno +
 (link:../src/sprintf.c[../src/sprintf.c] l.245) manpage: link:manpages/stdio/printf.3.rst[fprintf] +


fputc::

  static inline int volatile fputc(int c, FILE* F);
 +
  Defines: fileno write +
 (link:../include/fputc.h[../include/fputc.h] l.10) manpage: link:manpages/stdio/putc.3.rst[fputc] +


fputs::

  static inline int volatile fputs(const char *c, FILE *F);
 +
  Defines: write fileno strlen +
 (link:../include/fputs.h[../include/fputs.h] l.20) manpage: link:manpages/stdio/fputs.3.rst[fputs] +


fread::

  static inline size_t fread(void *ptr, size_t size, size_t nmemb, FILE *f);
 +
  Defines: read +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.162) manpage: link:manpages/stdio/fread.3.rst[fread] +


freopen::

  FILE *freopen(const char* filename, const char* mode, FILE *F);
 +
  Defines: open close fileno +
 (link:../src/fopen.c[../src/fopen.c] l.100) manpage: link:manpages/stdio/fopen.3.rst[freopen] +
modes implemented: r, r+, w, w+, a, a+ +
 

fseek::

  static inline int fseek(FILE *f, long offset, int whence );
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.146) manpage: link:manpages/stdio/fseek.3.rst[fseek] +


fsetpos::

  static inline int fsetpos(FILE *f, int pos );
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.133) manpage: link:manpages/stdio/fseek.3.rst[fsetpos] +


ftell::

  static inline long ftell(FILE *f);
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.121) manpage: link:manpages/stdio/fseek.3.rst[ftell] +


fwrite::

  static inline size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *f);
 +
  Defines: write +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.106) manpage: link:manpages/stdio/fread.3.rst[fwrite] +


getc::

  #define getc(F) fgetc(F)
 +
  Defines: read fileno +
 (link:../include/fgetc.h[../include/fgetc.h] l.26) manpage: link:manpages/stdio/getc.3.rst[getc] +


getchar::

  #define getchar() fgetc(0)
 +
  Defines: read fileno +
 (link:../include/fgetc.h[../include/fgetc.h] l.29) manpage: link:manpages/stdio/getc.3.rst[getchar] +


gets::

  #define gets(F) fgets(F,0xfffffff,stdin)
 +
  Defines: read fileno +
 (link:../src/fgets.c[../src/fgets.c] l.29) manpage: link:manpages/stdio/fgets.3.rst[gets] +


itoHEX::

  int itoHEX(int i,char* buf,int padding);
 +
  Defines:  +
 (link:../src/itohex.c[../src/itohex.c] l.56)  +


itohex::

  int itohex(int i,char* buf,int padding);
 +
  Defines:  +
 (link:../src/itohex.c[../src/itohex.c] l.49)  +


perror::

  void perror(const char *msg);
 +
  Defines: errno strlen strerror fileno write +
 (link:../src/perror.c[../src/perror.c] l.4) manpage: link:manpages/string/strerror.3.rst[perror] +


printf::

  #define printf(...) fprintf(stdout,__VA_ARGS__)
 +
  Defines: fileno write +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.91) manpage: link:manpages/stdio/printf.3.rst[printf] +


putc::

  #define putc(c,stream) fputc(c,stream)
 +
  Defines: write fileno +
 (link:../include/fputc.h[../include/fputc.h] l.19) manpage: link:manpages/stdio/putc.3.rst[putc] +


putchar::

  #define putchar(c) fputc(c,stdout)
 +
  Defines: write fileno +
 (link:../include/fputc.h[../include/fputc.h] l.16) manpage: link:manpages/stdio/putc.3.rst[putchar] +


puts::

  #define puts(msg) ( print(msg) + printl() )
 +
  Defines: strlen write +
 (link:../include/prints.h[../include/prints.h] l.73) manpage: link:manpages/stdio/fputs.3.rst[puts] +
write msg to stdout, append a newline. Needs strlen. +
 

rewind::

  static inline void rewind( FILE *f );
 +
  Defines: lseek +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.156) manpage: link:manpages/stdio/fseek.3.rst[rewind] +


setbuf::

  static void setbuf(FILE *stream, char *buf);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.211) manpage: link:manpages/stdio/setbuf.3.rst[setbuf] +
dummy function. +
  There is no buffering implemented for the streams yet. +
 

setvbuf::

  static int setvbuf(FILE *stream, char *buf, int mode, size_t size);
 +
  (link:../include/mini_fstream.h[../include/mini_fstream.h] l.216) manpage: link:manpages/stdio/setbuf.3.rst[setvbuf] +
dummy function +
 

sprintf::

  #define sprintf(str,...) snprintf( str, 4096,  __VA_ARGS__)
 +
  Defines: write +
 (link:../src/sprintf.c[../src/sprintf.c] l.26) manpage: link:manpages/stdio/printf.3.rst[sprintf] +


ungetc::

  static int ungetc(int c, FILE *F);
 +
  (link:../include/fgetc.h[../include/fgetc.h] l.35) manpage: link:manpages/stdio/ungetc.3.rst[ungetc] +
pushes one char back to the stream. +
  Overwrites a previously pushed char +
  (conforming to the posix spec)  +
 

vfprintf::

  #define vfprintf(...) fprintf(__VA_ARGS__)
 +
  Defines: write fileno +
 (link:../include/mini_fstream.h[../include/mini_fstream.h] l.100) manpage: link:manpages/stdio/printf.3.rst[vfprintf] +




 stdlib.h
----------

abs::

  static int abs(int i);
 +
  (link:../include/math.h[../include/math.h] l.25) manpage: link:manpages/stdlib/abs.3.rst[abs] +


atoi::

  int atoi(const char *c);
 +
  (link:../src/atoi.c[../src/atoi.c] l.6) manpage: link:manpages/stdlib/atoi.3.rst[atoi] +


atol::

  long atol(const char *c);
 +
  (link:../src/atoi.c[../src/atoi.c] l.43) manpage: link:manpages/stdlib/atol.3.rst[atol] +


div::

  static div_t div(int numerator, int denominator);
 +
  (link:../include/math.h[../include/math.h] l.8) manpage: link:manpages/stdlib/div.3.rst[div] +


free::

  void volatile free(void* p);
 +
  (link:../src/malloc.c[../src/malloc.c] l.278) manpage: link:manpages/stdlib/memory.3.rst[free] +


getenv::

  char* getenv(const char* name);
 +
  Defines: environ +
 (link:../src/getenv.c[../src/getenv.c] l.8) manpage: link:manpages/stdlib/getenv.3.rst[getenv] +


labs::

  static long int labs(long int i);
 +
  (link:../include/math.h[../include/math.h] l.30) manpage: link:manpages/stdlib/labs.3.rst[labs] +


ldiv::

  static ldiv_t ldiv(long int numerator, long int denominator);
 +
  (link:../include/math.h[../include/math.h] l.16) manpage: link:manpages/stdlib/ldiv.3.rst[ldiv] +


malloc::

  void* volatile malloc(int size);
 +
  (link:../src/malloc.c[../src/malloc.c] l.228) manpage: link:manpages/stdlib/memory.3.rst[malloc] +


rand::

  unsigned int rand();
 +
  (link:../src/rand.c[../src/rand.c] l.15) manpage: link:manpages/stdlib/rand.3.rst[rand] +


realloc::

  void* realloc(void *p, int size);
 +
  Defines: malloc free +
 (link:../src/malloc.c[../src/malloc.c] l.159) manpage: link:manpages/stdlib/memory.3.rst[realloc] +


srand::

  void srand( unsigned int i );
 +
  (link:../src/rand.c[../src/rand.c] l.7) manpage: link:manpages/stdlib/rand.3.rst[srand] +


strtol::

  long int strtol(const char *c, const char **endp, int base);
 +
  (link:../src/strtol.c[../src/strtol.c] l.5) manpage: link:manpages/stdlib/strtol.3.rst[strtol] +
conversion +
  doesn't check for overflow(!) +
 

system::

  int system( const char* command );
 +
  Defines: write environ wait4 vfork execve +
 (link:../src/system.c[../src/system.c] l.4) manpage: link:manpages/stdlib/system.3.rst[system] +


todo_putenv::

  int todo_putenv( char *s );
 +
  Defines: environ +
 (link:../src/getenv.c[../src/getenv.c] l.22)  +




 string.h
----------

_strcasecmp::

  int _strcasecmp(const char*c1,const char*c2,int len);
 +
  Defines: tolower +
 (link:../src/strcmp.c[../src/strcmp.c] l.30)  +


_strcmp::

  int _strcmp(const char*c1,const char*c2,int len);
 +
  (link:../src/strcmp.c[../src/strcmp.c] l.13)  +


errno_str::

  const char *errno_str(int err);
 +
  (link:../src/strerror.c[../src/strerror.c] l.31)  +
convert errno to str, with 3 chars length +
  ending the string (located in the bss section) +
  with two \0\0, when errno<100 +
 

memcmp::

  int memcmp(const void* c1,const void* c2,int len);
 +
  Defines: 0 +
 (link:../src/strcmp.c[../src/strcmp.c] l.85) manpage: link:manpages/string/memcmp.3.rst[memcmp] +


memcpy::

  void *memcpy( void *d, const void *s, int n );
 +
  (link:../src/memcpy.c[../src/memcpy.c] l.6) manpage: link:manpages/string/memcpy.3.rst[memcpy] +


memmove::

  void* memmove(void *dest, const void *src, int n);
 +
  (link:../src/memmove.c[../src/memmove.c] l.3) manpage: link:manpages/string/memmove.3.rst[memmove] +


memset::

  void *memset( void *s, int c, int n);
 +
  (link:../src/memset.c[../src/memset.c] l.3) manpage: link:manpages/string/memset.3.rst[memset] +


strcasecmp::

  int strcasecmp(const char*c1,const char*c2);
 +
  Defines:  +
 (link:../src/strcmp.c[../src/strcmp.c] l.49) manpage: link:manpages/string/string.3.rst[strcasecmp] +


strcat::

  char *strcat(char *dest, const char *src );
 +
  Defines: strlen +
 (link:../src/strcat.c[../src/strcat.c] l.7) manpage: link:manpages/string/string.3.rst[strcat] +


strchr::

  char *strchr(const char *s, int c);
 +
  Defines: strchrnul +
 (link:../src/strchr.c[../src/strchr.c] l.20) manpage: link:manpages/string/string.3.rst[strchr] +


strchrnul::

  char *strchrnul(const char *s, int c);
 +
  (link:../src/strchr.c[../src/strchr.c] l.7) manpage: link:manpages/string/strchr.3.rst[strchrnul] +


strcmp::

  int strcmp(const char*c1,const char*c2);
 +
  Defines:  +
 (link:../src/strcmp.c[../src/strcmp.c] l.68) manpage: link:manpages/string/string.3.rst[strcmp] +


strcpy::

  char *strcpy(char *dest, const char *src);
 +
  (link:../src/memcpy.c[../src/memcpy.c] l.17) manpage: link:manpages/string/string.3.rst[strcpy] +


strdup::

  char *strdup(const char *source);
 +
  Defines: malloc strcpy strlen +
 (link:../src/strdup.c[../src/strdup.c] l.7) manpage: link:manpages/string/strdup.3.rst[strdup] +


strerror::

  char* strerror( int errnum );
 +
  (link:../src/strerror.c[../src/strerror.c] l.7) manpage: link:manpages/string/string.3.rst[strerror] +


strlen::

  int strlen(const char*str);
 +
  (link:../src/strlen.c[../src/strlen.c] l.7) manpage: link:manpages/string/strlen.3.rst[strlen] +


strncasecmp::

  int strncasecmp(const char*c1,const char*c2,int len);
 +
  Defines:  +
 (link:../src/strcmp.c[../src/strcmp.c] l.57) manpage: link:manpages/string/string.3.rst[strncasecmp] +


strncmp::

  int strncmp(const char*c1,const char*c2,int len);
 +
  Defines:  +
 (link:../src/strcmp.c[../src/strcmp.c] l.76) manpage: link:manpages/string/string.3.rst[strncmp] +


strncpy::

  char *strncpy(char *dest, const char *src, int n);
 +
  Defines: memcpy +
 (link:../src/memcpy.c[../src/memcpy.c] l.27) manpage: link:manpages/string/string.3.rst[strncpy] +


strrchr::

  char *strrchr(const char *s, int c);
 +
  Defines: strchrnul +
 (link:../src/strchr.c[../src/strchr.c] l.36) manpage: link:manpages/string/string.3.rst[strrchr] +


strstr::

  char* strstr(const char *big, const char *little);
 +
  (link:../src/strstr.c[../src/strstr.c] l.3) manpage: link:manpages/string/strstr.3.rst[strstr] +




 sys/wait.h
------------

wait::

  pid_t wait(int *wstatus);
 +
  Defines: wait4 +
 (link:../src/wait.c[../src/wait.c] l.8) manpage: link:manpages/sys/wait.2.rst[wait] +


waitpid::

  pid_t waitpid(pid_t pid, int *wstatus, int options);
 +
  Defines: wait4 +
 (link:../src/wait.c[../src/wait.c] l.16) manpage: link:manpages/sys/wait.2.rst[waitpid] +




 time.h
--------

time::

  time(unsigned int *a1 )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.203) manpage: link:manpages/gen/time.3.rst[time] +




 unistd.h
----------

access::

  access( const char *filename, int mode)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.157) manpage: link:manpages/sys/access.2.rst[access] +


chdir::

  chdir(const char* path)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.107) manpage: link:manpages/sys/chdir.2.rst[chdir] +


chown::

  chown( const char *filename, uid_t user, gid_t group)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.185) manpage: link:manpages/sys/chown.2.rst[chown] +


chroot::

  chroot( const char *filename)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.137) manpage: link:manpages/sys/chroot.2.rst[chroot] +


close::

  close( int fd )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.96) manpage: link:manpages/sys/close.2.rst[close] +


dup::

  dup(int fd)		
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.112) manpage: link:manpages/sys/dup.2.rst[dup] +


dup2::

  dup2(int oldfd, int newfd)		
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.113) manpage: link:manpages/sys/dup.2.rst[dup2] +


execl::

  static int execl(const char *pathname, const char* arg0,... );
 +
  Defines: environ execve +
 (link:../src/execl.c[../src/execl.c] l.6) manpage: link:manpages/gen/exec.3.rst[execl] +


execv::

  static inline int execv(const char *pathname, char *const argv[]);
 +
  Defines: execve environ +
 (link:../src/execvp.c[../src/execvp.c] l.9) manpage: link:manpages/gen/exec.3.rst[execv] +


execve::

  execve( const char *filename,  char* const* argv, char* const* envp)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.123) manpage: link:manpages/sys/execve.2.rst[execve] +


execvp::

  static inline int execvp(const char *file, char *const argv[]);
 +
  Defines: environ execve access +
 (link:../src/execvp.c[../src/execvp.c] l.58) manpage: link:manpages/gen/exec.3.rst[execvp] +


execvpe::

  static int execvpe(const char *file, char *const argv[], char *const envp[]);
 +
  Defines: environ execve access +
 (link:../src/execvp.c[../src/execvp.c] l.18)  +
When invoked with a filename, starting with "." or "/", +
  interprets this as absolute path. (calls execve with the pathname) +
  Looks for file in the PATH environment, othwerise. +
 

fork::

  DEF_syscall(fork,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.127) manpage: link:manpages/sys/fork.2.rst[fork] +


fsync::

  fsync(int a1 )
 +
 (link:../include/lseek.h[../include/lseek.h] l.22) manpage: link:manpages/sys/fsync.2.rst[fsync] +


ftruncate::

  ftruncate(unsigned int a1, unsigned int a2 )
 +
 (link:../include/lseek.h[../include/lseek.h] l.21) manpage: link:manpages/sys/truncate.2.rst[ftruncate] +


getgid::

  DEF_syscall(getgid,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.189) manpage: link:manpages/sys/getgid.2.rst[getgid] +


getpgrp::

  DEF_syscall(getpgrp,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.190) manpage: link:manpages/sys/getpgrp.2.rst[getpgrp] +


getpid::

  DEF_syscall(getpid,0 )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.141) manpage: link:manpages/sys/getpid.2.rst[getpid] +


getuid::

  DEF_syscall(getuid,0)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.192) manpage: link:manpages/sys/getuid.2.rst[getuid] +


isatty::

  int isatty(int fd);
 +
  Defines: ioctl +
 (link:../src/isatty.c[../src/isatty.c] l.7) manpage: link:manpages/gen/ttyname.3.rst[isatty] +


link::

  link( const char *oldname, const char *newname)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.118) manpage: link:manpages/sys/link.2.rst[link] +


lseek::

  lseek(unsigned int a1, int a2, int a3 )
 +
 (link:../include/lseek.h[../include/lseek.h] l.19) manpage: link:manpages/sys/lseek.2.rst[lseek] +


mkdir::

  mkdir( const char *pathname, int mode)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.154) manpage: link:manpages/sys/mkdir.2.rst[mkdir] +


open::

  int volatile open( const char *s, int flags, ... );
 +
  (link:../src/open.c[../src/open.c] l.19) manpage: link:manpages/sys/open.2.rst[open] +
open or create a file. +
  warning: when using the flag O_CREAT, +
  file permission flags have to be given +
  as third argument. Otherwise file permission +
  flags will be random. (I still do not know, what  +
  the flag showing up as "-T" means..) +
 

pipe::

  pipe( int *filedes)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.182) manpage: link:manpages/sys/pipe.2.rst[pipe] +


read::

  read( int fd, void *buf, int len )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.97) manpage: link:manpages/sys/read.2.rst[read] +


rename::

  rename( const char* oldpath, const char* newpath )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.102) manpage: link:manpages/sys/rename.2.rst[rename] +


rmdir::

  rmdir( const char *pathname)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.155) manpage: link:manpages/sys/rmdir.2.rst[rmdir] +


select::

  static int volatile __attribute__((optimize("O0"))) select(int fd, volatile fd_set* readfd, volatile fd_set *writefd, volatile fd_set *exceptfd, volatile struct timeval *wait);
 +
  (link:../include/select.h[../include/select.h] l.9) manpage: link:manpages/sys/select.2.rst[select] +


setgid::

  setgid( gid_t gid)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.143) manpage: link:manpages/sys/setuid.2.rst[setgid] +


setpgid::

  setpgid( pid_t pid, pid_t pgid)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.188) manpage: link:manpages/sys/setpgid.2.rst[setpgid] +


setsid::

  DEF_syscall(setsid,0 )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.142) manpage: link:manpages/sys/setsid.2.rst[setsid] +


setuid::

  setuid( uid_t uid)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.144) manpage: link:manpages/sys/setuid.2.rst[setuid] +


sleep::

  unsigned int volatile sleep(unsigned int seconds);
 +
  (link:../src/sleep.c[../src/sleep.c] l.10) manpage: link:manpages/gen/sleep.3.rst[sleep] +
nonconformant sleep +
  TODO: ignore blocked signals, sigchld +
 

tcgetattr::

  static inline int __attribute__((always_inline)) tcgetattr(int fd, struct termios *io);
 +
  Defines: ioctl +
 (link:../include/tcgetattr.h[../include/tcgetattr.h] l.21) manpage: link:manpages/gen/tcsetattr.3.rst[tcgetattr] +


tcsetattr::

  static inline int __attribute__((always_inline)) tcsetattr(int fd, int opt, const struct termios *io);
 +
  Defines: ioctl +
 (link:../include/tcsetattr.h[../include/tcsetattr.h] l.20) manpage: link:manpages/gen/tcsetattr.3.rst[tcsetattr] +


unlink::

  unlink( const char* path)
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.103) manpage: link:manpages/sys/unlink.2.rst[unlink] +


usleep::

  unsigned int volatile usleep(unsigned int useconds);
 +
  (link:../src/sleep.c[../src/sleep.c] l.31) manpage: link:manpages/gen/usleep.3.rst[usleep] +
nonconformant usleep.  +
  Sleep useconds. +
  I just hope, noone relies on an exact sleep time. +
  which isn't possible without a real time os, anyways. +
  When for whatever reason you'd need nanoseconds exact times, +
  best shot might be a spinloop, and looking for cpu ticks. +
  +
  TODO: ignore blocked signals, sigchld +
 

write::

  write(int fd,const void *buf, int len )
 +
 (link:../include/syscall_stubs.h[../include/syscall_stubs.h] l.98) manpage: link:manpages/sys/write.2.rst[write] +



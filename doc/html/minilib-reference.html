<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="AsciiDoc 9.0.5">
<title> minilib reference</title>
</head>
<body>
<h1> minilib reference</h1>
<p>
</p>
<a name="preamble"></a>
<p>The given sizes are estimations, each function added as single function within
a binary that much bytes to the overall size.</p>
<p>It is however not possible to give exact numbers, these depend on how much the compiler
can optimize for each call. What is different each time, depending on the circumstances.</p>
<p>To complicate things more, some functions will be inlined, others will be reused.</p>
<p>And, the choosen linker script will have it&#8217;s (sometimes surprising) influence.</p>
<p>---</p>
<hr>
<h2><a name="_configuration"></a>1.  Configuration</h2>
<p>Before the include of minilib.h, the minilib has to be configured.</p>
<p>The proposed way is to use the supplied script minicc,<br>
which translates config options to define flags,<br>
and pipes the minilib header to gcc.</p>
<p>The config file is a bash script and can be a separate file,
or within one of the source files.</p>
<p>Since it is a bash script, it is possible to e.g.<br>
source other files from within the configuration.</p>
<p>A simple example is given below:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>#if 0  // has to be the first line
# mini_start is the start routine.
# Most possibly needed
mini_start

# define and compile puts
mini_puts

INCLUDESRC
# this is a comment.
# INCLUDESRC has to be defined for one sourcefile.
# without it only the defines, and no implementations are parsed.

# shrink the binary with tools/shrinkelf
SHRINKELF

# use the linker script onlytext
# meaning, only text and stack sections are loaded
LDSCRIPT onlytext

# return, and the #endif statement are the last lines of the config
return
#endif

int main(int argc, char *argv[] ){
    puts("Hello, world!");
                return(0);
}</code></pre>
</td></tr></table>
<p>Only functions defined are going to be built.</p>
<p>There are several examples given within the folder examples,<br>
the files within the folder test are there for regression tests,<br>
but might also be helpful.</p>
<p>To compile a c source file with embedded configuration (as in the example above),<br>
type <em>minicc --config example.c -o example example.c</em>.<br>
(Shortcut <em>minicc -mlc example.c</em>)</p>
<p>(minicc needs to be in the standard search path)<br>
If you&#8217;d like to "install" the minicc, simply copy the script minicc into /usr/local/bin,<br>
or wherever your executables live and can be found.</p>
<p>The minilib itself, as well as the supllied linker scripts are embedded into minicc,<br>
and extracted and piped to gcc on demand.</p>
<p>(There are compatibility headers provided, e.g. stdio.h;<br>
these are however not stable and will most probably not work.<br>
I&#8217;m going to update them, as soon other and more important things are finished.)</p>
<p>In addition to the switches, which are built of the function&#8217;s name and the prefix <em>mini_</em>;<br>
e.g. <em>mini_puts</em>, these switches are defined for the configuration of minilib:</p>
<dl>
<dt>
mini_start
</dt>
<dd>
<p>
        Built the start routine, which is needed for the execution of the binary.
</p>
</dd>
<dt>
mini_buf 512
</dt>
<dd>
<p>
        the buf size in Bytes (here 512Bytes), which is used by minilib for input/output functions,
        the globals and malloc/free.
        Uncomment this, if you do not need globals or functions,
        depending on the buffer.
</p>
</dd>
<dt>
globals_on_stack
</dt>
<dd>
<p>
  put the minibuf and all globals onto the stack
        (this enables to omit all sections besides text and stack of the binary,
        when nowhere else globals (ans static variables) are used,
        for aggressive size optimization)
        The address of the globals is going to be stored within a fixed cpu register. (r15 at amd64)
        The globals are stored at the end of the stack, behind the first return addresse.
        (They are setup within startup.c; however, startup calls main, but never returns itself,
        instead the function exits via syscall. So it is not possible to overwrite the return addresse
        with a Bufferoverflow. In case you have to work with unsafe userinput, please have a look
        into map_protected)
</p>
</dd>
<dt>
mini_errno
</dt>
<dd>
<p>
        generate the code for the errno variable.<br>
        This generates some overhead<br>
        (a few bytes per every syscall, and every function which sets errno;
        globals are generated as well)<br>
        Without the switch, syscalls do return the negative errno value on failure.
</p>
</dd>
<dt>
mini_syscalls
</dt>
<dd>
<p>
        define the syscall wrappers, starting with <em>sys_</em>
</p>
</dd>
<dt>
HEADERGUARDS
</dt>
<dd>
<p>
        define the headerguards, which hopefully prevent the inclusion
        of the standard library headers.
</p>
</dd>
<dt>
OPTFLAG -Os
</dt>
<dd>
<p>
  optimization Flag. Os,O1,O2 should be save. O3 causes sometimes troubles
</p>
<pre><code>e.g. OPTFLAG '-g -O0'
(compile with debug info)</code></pre>
</dd>
<dt>
OPTIMIZE
</dt>
<dd>
<p>
        add some speed optimizations, mainly vectorizations for 64bit.<br>
        This comes naturally with a memory penalty,<br>
        yet, the raise in memory usage is neglectible. (a few hundred bytes)
</p>
</dd>
<dt>
STRIPFLAG
</dt>
<dd>
<p>
  stripflag ( defaults to -s)<br>
        Leaving <em>STRIPFLAG</em> alone removes the flag parameter from gcc&#8217;s commandline.
</p>
</dd>
<dt>
SOURCES file1 file2 &#8230;
</dt>
<dd>
<p>
        (optional)<br>
        define other files as sources, to be compiled into the binary.
</p>
</dd>
<dt>
BINARY name
</dt>
<dd>
<p>
        (optional)<br>
        Set the name of the resulting binary.+
        (supplied to gcc as -o name)
</p>
</dd>
<dt>
INCLUDESRC
</dt>
<dd>
<p>
  Build minilib with source.<br>
        Without this switch, only defines and declarations are included.<br>
        When building with several object files, most probably you should<br>
        enable this flag only for one object file.<br>
        It&#8217;s also possible to pass the switch via a define flag to gcc.<br>
        (<em>-DINCLUDESRC</em>)
</p>
</dd>
<dt>
LDSCRIPT default
</dt>
<dd>
<p>
        The ldscript to use<br>
  Defines, which executable sections are going to be built.<br>
        Can be one of:<br>
</p>
<ul>
<li>
<p>
<strong>default</strong>: .text .data .rodata .bss (.stack)<br>
</p>
</li>
<li>
<p>
<strong>default_execstack</strong>: .text .data .rodata .bss (.stack)<br>
      The stack is executable, what is needed for e.g. closures+
</p>
</li>
<li>
<p>
<strong>textandbss</strong>: .text .bss (.stack)<br>
</p>
</li>
<li>
<p>
<strong>onlytext</strong>: .text (.stack)<br>
</p>
</li>
<li>
<p>
<strong>onlytext_tiny</strong>: .text (the stack is defined by the kernel, and made executable)<br>
           Despite general meaning, an executable stack isn&#8217;t harmful on its own,and even widely used.
     It just is important (as always), to check user input against e.g. overflows.
</p>
</li>
</ul>
</dd>
<dt>
SHRINKELF
</dt>
<dd>
<p>
  Shrink the compiled binary with shrinkelf.<br>
        Aggressively strip the elf headers.
</p>
</dd>
<dt>
DEBUG
</dt>
<dd>
<p>
  generate debug info (-O0 -g). Overwrites OPTFLAG, STRIPFLAG and SHRINKELF
</p>
</dd>
<dt>
DEFINE def value
</dt>
<dd>
<p>
        add a #define def value
        "def" and "value" have to be within apostrophes,
        when they contain either brackets,spaces, or other operators.
        Multilines are possible, with a preceding \\ before the linebreak.
</p>
</dd>
</dl>
<p>---</p>
<hr>
<h2><a name="_conversions"></a>2. conversions</h2>
<a name="_itobin"></a><dl>
<dt>
_itobin
</dt>
<dd>
<p>
  <em>int _itobin(int i, char*buf, int prec, int groups )</em><br>
Size: ~188B <a href="../src/conversions/itobin.c">../src/conversions/itobin.c</a> l.8
</p>
</dd>
<dt>
_itohex
</dt>
<dd>
<p>
  <em>int _itohex(int i,char* buf,int padding, int capitals)</em><br>
Size: ~250B <a href="../src/conversions/itohex.c">../src/conversions/itohex.c</a> l.6
</p>
</dd>
<dt>
atoi
</dt>
<dd>
<p>
  <em>int atoi(const char <strong>c)</em><br>
 *convert a string to an integer</strong>
Size: ~32B <a href="../src/conversions/atoi.c">../src/conversions/atoi.c</a> l.3 manpage: <a href="manpages/stdlib/atoi.3.rst">atoi</a><br>
</p>
</dd>
<dt>
atol
</dt>
<dd>
<p>
  <em>long atol(const char <strong>c)</em><br>
 *convert a string to a long integer</strong>
Size: ~108B <a href="../src/conversions/atol.c">../src/conversions/atol.c</a> l.3 manpage: <a href="manpages/stdlib/atol.3.rst">atol</a><br>
</p>
</dd>
<dt>
dtodec
</dt>
<dd>
<p>
  <em>int dtodec(double d, char* buf, int precision)</em><br>
 <strong>Defines:</strong> uitodec<br>
Size: ~760B <a href="../src/conversions/dtodec.c">../src/conversions/dtodec.c</a> l.10
</p>
</dd>
<dt>
itoHEX
</dt>
<dd>
<p>
  <em>int itoHEX(int i,char* buf,int padding)</em><br>
</p>
</dd>
</dl>
<a name="itoHEX"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>convert a number to hexadecimal representation with big capitals.
 the conversion assumes a size of 32bits for integers,
 negative values are represented as they are stored internally.
 ( -1 is 0xFFFFFFFF, -2 0xFFFFFFFE, ... )</code></pre>
</td></tr></table>
<p>Size: ~250B <a href="../src/conversions/itohex.c">../src/conversions/itohex.c</a> l.65</p>
<a name="itobin"></a><dl>
<dt>
itobin
</dt>
<dd>
<p>
  <em>#define itobin(A,B,&#8230;) _itobin(A,B,VARARG(SHIFT(<em>VA_ARGS</em>),0), VARARG(SHIFT(ARG( <em>VA_ARGS</em> )),32) )</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>convert a number to a binary representation.
 the conversion assumes a size of 32bits for integers,
 negative values are represented as they are stored internally.
 ( -1 is 11111111111111111111111111111111,
   -2    11111111111111111111111111111110, ...)</code></pre>
</td></tr></table>
<p><a href="../src/conversions/itobin.c">../src/conversions/itobin.c</a> l.46</p>
<a name="itodec"></a><dl>
<dt>
itodec
</dt>
<dd>
<p>
  <em>int itodec(int i, char <strong>buf, int prec, char limiter, char pad )</em><br>
 *Defines:</strong> uitodec<br>
Size: ~555B <a href="../src/conversions/itodec.c">../src/conversions/itodec.c</a> l.123
</p>
</dd>
<dt>
itohex
</dt>
<dd>
<p>
  <em>int itohex(int i,char* buf,int padding)</em><br>
</p>
</dd>
</dl>
<a name="itohex"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>convert a number to hexadecimal representation.
 the conversion assumes a size of 32bits for integers,
 negative values are represented as they are stored internally.
 ( -1 is 0xffffffff, -2 0xfffffffe, ... )</code></pre>
</td></tr></table>
<p>Size: ~247B <a href="../src/conversions/itohex.c">../src/conversions/itohex.c</a> l.53</p>
<a name="itooct"></a><dl>
<dt>
itooct
</dt>
<dd>
<p>
  <em>int itooct(int i, char *buf)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>convert int to octal
 return the number of chars written.</code></pre>
</td></tr></table>
<p><a href="../src/conversions/itooct.c">../src/conversions/itooct.c</a> l.4</p>
<a name="ltodec"></a><dl>
<dt>
ltodec
</dt>
<dd>
<p>
  <em>int ltodec(long i, char <strong>buf, int prec, char limiter )</em><br>
 *Defines:</strong> ultodec<br>
Size: ~323B <a href="../src/conversions/ltodec.c">../src/conversions/ltodec.c</a> l.3
</p>
</dd>
<dt>
strtol
</dt>
<dd>
<p>
  <em>long int strtol(const char <strong>c, const char **endp, int base)</em><br>
 *convert a string to a long integer</strong>
</p>
</dd>
</dl>
<a name="strtol"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>conversion</code></pre>
</td></tr></table>
<p>Size: ~252B <a href="../src/string/strtol.c">../src/string/strtol.c</a> l.4 manpage: <a href="manpages/stdlib/strtol.3.rst">strtol</a><br></p>
<a name="uitodec"></a><dl>
<dt>
uitodec
</dt>
<dd>
<p>
  <em>int ATTR_OPT("Os")uitodec(unsigned int i, char *buf, int prec, char limiter, char pad )</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>convert int to string.
 prec: precision, e.g. 4=&gt; 0087
 pad: 0 (pad with spaces), or the char to pad</code></pre>
</td></tr></table>
<p><a href="../src/conversions/itodec.c">../src/conversions/itodec.c</a> l.9</p>
<a name="ultodec"></a><dl>
<dt>
ultodec
</dt>
<dd>
<p>
  <em>int ultodec(unsigned long ui, char *buf, int prec, char limiter )</em><br>
Size: ~293B <a href="../src/conversions/ultodec.c">../src/conversions/ultodec.c</a> l.2
</p>
</dd>
</dl>
<p>---</p>
<hr>
<h2><a name="_directories"></a>3. directories</h2>
<a name="alphasort"></a><dl>
<dt>
alphasort
</dt>
<dd>
<p>
  <em>int alphasort( const struct dirent<strong> de1, const struct dirent</strong> de2 )</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>Sort dirents by name.
 Deviating of the standard,
 the asciitables is used for the comparison
 (using strcmp)</code></pre>
</td></tr></table>
<p><a href="../src/directories/alphasort.c">../src/directories/alphasort.c</a> l.7 manpage: <a href="manpages/gen/scandir.3.rst">alphasort</a><br></p>
<a name="basename"></a><dl>
<dt>
basename
</dt>
<dd>
<p>
  <em>char <strong>basename(char *path)</em><br>
 *return the last component of a pathname</strong>
Size: ~151B <a href="../src/directories/basename.c">../src/directories/basename.c</a> l.2 manpage: <a href="manpages/gen/basename.3.rst">basename</a><br>
</p>
</dd>
<dt>
chdir
</dt>
<dd>
<p>
  <em>int chdir(const char* path)</em><br>
 <strong>change working directory</strong>
Size: ~47B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.114 manpage: <a href="manpages/sys/chdir.2.rst">chdir</a><br>
</p>
</dd>
<dt>
dirbuf
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<a name="dirbuf"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>the switch for defining the dirbuf.
 used internally</code></pre>
</td></tr></table>
<p><a href="../include/dirent.h">../include/dirent.h</a> l.7</p>
<a name="dirbufsize"></a><dl>
<dt>
dirbufsize
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
<dt>
dirfd
</dt>
<dd>
<p>
  <em>int dirfd(DIR <strong>d)</em><br>
 *extract the file descriptor used by a DIR stream</strong>
<a href="../src/directories/dirfd.c">../src/directories/dirfd.c</a> l.2 manpage: <a href="manpages/gen/directory.3.rst">dirfd</a><br>
</p>
</dd>
<dt>
dirname
</dt>
<dd>
<p>
  <em>char <strong>dirname(char *s)</em><br>
 *Defines:</strong> strlen<br>
 <strong>report the parent directory name of a file pathname</strong>
Size: ~179B <a href="../src/directories/dirname.c">../src/directories/dirname.c</a> l.8 manpage: <a href="manpages/gen/dirname.3.rst">dirname</a><br>
</p>
</dd>
<dt>
fstat
</dt>
<dd>
<p>
  <em>int fstat(int fd,struct stat* statbuf)</em><br>
 <strong>get file status</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.111 manpage: <a href="manpages/sys/stat.2.rst">fstat</a><br>
</p>
</dd>
<dt>
getcwd
</dt>
<dd>
<p>
  <em>int getcwd( char <strong>buf,  unsigned long size)</em><br>
 *get the pathname of the current working directory</strong>
Size: ~61B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.123 manpage: <a href="manpages/gen/getcwd.3.rst">getcwd</a><br>
</p>
</dd>
<dt>
getdents
</dt>
<dd>
<p>
  <em>int getdents( unsigned int fd, struct dirent <strong>direntry, unsigned int count )</em><br>
 *get directory entries</strong>
Size: ~65B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.106 manpage: <a href="manpages/sys/getdirentries.2.rst">getdents</a><br>
</p>
</dd>
<dt>
inotify_add_watch
</dt>
<dd>
<p>
  <em>int inotify_add_watch( int fd,  const char *pathname,  u32 mask)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.220
</p>
</dd>
<dt>
inotify_init
</dt>
<dd>
<p>
  <em>int DEF_syscall(inotify_init,0)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.219
</p>
</dd>
<dt>
inotify_init1
</dt>
<dd>
<p>
  <em>int inotify_init1( int flags)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.222
</p>
</dd>
<dt>
inotify_rm_watch
</dt>
<dd>
<p>
  <em>int inotify_rm_watch( int fd,  __s32 wd)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.221
</p>
</dd>
<dt>
mkdir
</dt>
<dd>
<p>
  <em>int mkdir( const char <strong>pathname, int mode)</em><br>
 *make a directory relative to directory file descriptor</strong>
Size: ~59B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.174 manpage: <a href="manpages/sys/mkdir.2.rst">mkdir</a><br>
</p>
</dd>
<dt>
opendir
</dt>
<dd>
<p>
  <em>DIR <strong>opendir(const char *name )</em><br>
 *Defines:</strong> close dirbuf sys_brk write open 0 getbrk<br>
 <strong>open directory associated with file descriptor</strong>
Size: ~281B <a href="../src/directories/opendir.c">../src/directories/opendir.c</a> l.10 manpage: <a href="manpages/gen/directory.3.rst">opendir</a><br>
</p>
</dd>
<dt>
opendirp
</dt>
<dd>
<p>
  <em>DIR <strong>opendirp(const char *name, DIR *dir)</em><br>
 *Defines:</strong> dirbuf sys_brk close getbrk 0 open<br>
<a href="../src/directories/opendirp.c">../src/directories/opendirp.c</a> l.5
</p>
</dd>
<dt>
readdir
</dt>
<dd>
<p>
  <em>struct dirent <strong>readdir(DIR *dir)</em><br>
 *Defines:</strong> getdents dirbuf<br>
 <strong>read a directory</strong>
</p>
</dd>
</dl>
<a name="readdir"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>read a directory.
 return the next dirent, or 0, if the end is reached.
 return 0 on error and set errno,
 if mini_errno is not defined, return -errno on error</code></pre>
</td></tr></table>
<p>Size: ~133B <a href="../src/directories/readdir.c">../src/directories/readdir.c</a> l.10 manpage: <a href="manpages/gen/directory.3.rst">readdir</a><br></p>
<a name="rewinddir"></a><dl>
<dt>
rewinddir
</dt>
<dd>
<p>
  <em>void rewinddir(DIR <strong>dir)</em><br>
 *reset the position of a directory stream to the beginning</strong>
Size: ~80B <a href="../src/directories/rewinddir.c">../src/directories/rewinddir.c</a> l.2 manpage: <a href="manpages/gen/directory.3.rst">rewinddir</a><br>
</p>
</dd>
<dt>
rmdir
</dt>
<dd>
<p>
  <em>int rmdir( const char <strong>pathname)</em><br>
 *remove a directory</strong>
Size: ~47B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.175 manpage: <a href="manpages/sys/rmdir.2.rst">rmdir</a><br>
</p>
</dd>
<dt>
scandir
</dt>
<dd>
<p>
  <em>int scandir(const char <strong>path, struct dirent <strong>listing[], int (*fp_select)(const struct dirent *),    int (*cmp)(const struct dirent </strong>, const struct dirent *</strong>))</em><br>
 <strong>Defines:</strong> dirbuf sys_brk getbrk swap seterrno getdents getpid kill errno 0 open write strlen memcpy<br>
 <strong>scan a directory</strong>
</p>
</dd>
</dl>
<a name="scandir"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>list files and dirs in a directory

 This implementation uses malloc_brk() for the dynamic allocation
 of the listing, and tries to do as less copies as possible.
 The dynamically allocated space for the result list (**listing[])
 is guaranteed to be at one continuous memory location.

 if the select callback is 0, meaning all entries should be returned,
 There are no copies done at all,
 besides the copying from kernelspace to userspace.

 To free the space, allocated for the listing,
 either call free_brk(),
 when no other allocations via malloc_brk took place.

 Or save the brk before you call scandir,
 and restore it after the call.
 (e.g.)
 long savebrk=getbrk();
 int ret=scandir(...);
 brk(savebrk);
 Freeing single list entries might give unexpected results.

 returns the number of the read entries,
 or the negative errno on error.</code></pre>
</td></tr></table>
<p><a href="../src/directories/scandir.c">../src/directories/scandir.c</a> l.30 manpage: <a href="manpages/gen/scandir.3.rst">scandir</a><br></p>
<a name="scandir_bufsize"></a><dl>
<dt>
scandir_bufsize
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>the increment of the buffer of scandir in bytes for memory allocations
 (default:4096)</code></pre>
</td></tr></table>
<p><a href="../src/directories/scandir_bufsize.c">../src/directories/scandir_bufsize.c</a> l.4</p>
<a name="seekdir"></a><dl>
<dt>
seekdir
</dt>
<dd>
<p>
  <em>void seekdir(DIR <strong>dir, long off)</em><br>
 *set the position of a directory stream</strong>
Size: ~100B <a href="../src/directories/seekdir.c">../src/directories/seekdir.c</a> l.2 manpage: <a href="manpages/gen/directory.3.rst">seekdir</a><br>
</p>
</dd>
<dt>
telldir
</dt>
<dd>
<p>
  <em>long telldir(DIR <strong>dir)</em><br>
 *current location of a named directory stream</strong>
Size: ~32B <a href="../src/directories/telldir.c">../src/directories/telldir.c</a> l.2 manpage: <a href="manpages/gen/directory.3.rst">telldir</a><br>
</p>
</dd>
</dl>
<p><a name="telldir"></a>---</p>
<hr>
<h2><a name="_errno"></a>4. errno</h2>
<a name="errno"></a><dl>
<dt>
errno
</dt>
<dd>
<p>
  <em>#ifdef mini_errno</em><br>
 <strong>error return value</strong>
</p>
</dd>
<dt>
errno_str
</dt>
<dd>
<p>
  <em>char *errno_str(int err)</em><br>
</p>
</dd>
</dl>
<a name="errno_str"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>convert errno to str, with 3 chars length
 ending the string (global)
 with two \0\0, when errno&lt;100
 errnum must be &lt;200.</code></pre>
</td></tr></table>
<p>Size: ~123B <a href="../src/process/errno_str.c">../src/process/errno_str.c</a> l.7</p>
<a name="exit_errno"></a><dl>
<dt>
exit_errno
</dt>
<dd>
<p>
  <em>void exit_errno( int errnum )</em><br>
 <strong>Defines:</strong> write errno_str execve exit<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>exit, and execute /bin/errno
 this is intended to give a error message for the
 given errno num.
 Instead of having the error messages compiled
 into each binary, they can stay within one executable, "errno"
 This spares about 4kB, but needs errno installed to /bin/errno
 It's the drawback of not having a shared library,
 where all executables would share the same errno messages
 in memory.
 On the other hand, a shared library would need to be installed
 as well.
 The supplied errno can be negative,
 the absolute value is supplied to errno.</code></pre>
</td></tr></table>
<p><a href="../src/process/exit_errno.c">../src/process/exit_errno.c</a> l.17</p>
<a name="perror"></a><dl>
<dt>
perror
</dt>
<dd>
<p>
  <em>void perror(const char <strong>msg)</em><br>
 *Defines:</strong> strlen write strerror errno fileno<br>
 <strong>write error messages to standard error</strong>
Size: ~329B <a href="../src/output/perror.c">../src/output/perror.c</a> l.4 manpage: <a href="manpages/string/strerror.3.rst">perror</a><br>
</p>
</dd>
<dt>
ret_errno
</dt>
<dd>
<p>
  <em>#ifdef mini_errno</em><br>
</p>
</dd>
</dl>
<a name="ret_errno"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>This macro expands to a return, and
 (when mini_errno is defined) returns -1 and sets errno,
 or returns the negative errno value.</code></pre>
</td></tr></table>
<p><a href="../include/ret_errno.h">../include/ret_errno.h</a> l.5</p>
<a name="seterrno"></a><dl>
<dt>
seterrno
</dt>
<dd>
<p>
  <em>#ifdef mini_errno</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>set errno, but only when errno is defined.</code></pre>
</td></tr></table>
<p><a href="../include/seterrno.h">../include/seterrno.h</a> l.3</p>
<a name="strerror"></a><dl>
<dt>
strerror
</dt>
<dd>
<p>
  <em>char* strerror( int errnum )</em><br>
<a href="../src/string/strerror.c">../src/string/strerror.c</a> l.7 manpage: <a href="manpages/string/string.3.rst">strerror</a><br>
</p>
</dd>
<dt>
verbose_errstr
</dt>
<dd>
<p>
  <em>const char* verbose_errstr(int num)</em><br>
</p>
</dd>
</dl>
<a name="verbose_errstr"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>verbose error (errno) string.
 this adds about 3.5kB to the compiled binary(!)</code></pre>
</td></tr></table>
<p><a href="../include/errstr.h">../include/errstr.h</a> l.10</p>
<a name="verbose_errstr2"></a><dl>
<dt>
verbose_errstr2
</dt>
<dd>
<p>
  <em>const char* verbose_errstr2(int num)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>verbose error (errno) string.
 this adds about 3.5kB to the compiled binary(!)
 Trying to shrink that here.</code></pre>
</td></tr></table>
<p><a href="../include/errstr2.h">../include/errstr2.h</a> l.11</p>
<p>---</p>
<hr>
<h2><a name="_files"></a>5. files</h2>
<a name="_fopen"></a><dl>
<dt>
_fopen
</dt>
<dd>
<p>
  <em>FILE <strong>_fopen(int fd, const char</strong> filename, const char* mode, FILE <strong>f)</em><br>
 *Defines:</strong> close fileno open<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>modes implemented: r, r+, w, w+, a, a+</code></pre>
</td></tr></table>
<p>Size: ~316B <a href="../src/streams/_fopen.c">../src/streams/_fopen.c</a> l.12</p>
<a name="access"></a><dl>
<dt>
access
</dt>
<dd>
<p>
  <em>int access( const char <strong>filename, int mode)</em><br>
 *determine accessibility of a file relative to directory file</strong>
Size: ~59B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.177 manpage: <a href="manpages/sys/access.2.rst">access</a><br>
</p>
</dd>
<dt>
chmod
</dt>
<dd>
<p>
  <em>int chmod( const char <strong>filename, mode_t mode)</em><br>
 *change mode of a file relative to directory file descriptor</strong>
Size: ~59B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.201 manpage: <a href="manpages/sys/chmod.2.rst">chmod</a><br>
</p>
</dd>
<dt>
chown
</dt>
<dd>
<p>
  <em>int chown( const char <strong>filename, uid_t user, gid_t group)</em><br>
 *change owner and group of a file relative to directory</strong>
Size: ~71B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.202 manpage: <a href="manpages/sys/chown.2.rst">chown</a><br>
</p>
</dd>
<dt>
close
</dt>
<dd>
<p>
  <em>int close( int fd )</em><br>
 <strong>close a file descriptor</strong>
Size: ~51B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.102 manpage: <a href="manpages/sys/close.2.rst">close</a><br>
</p>
</dd>
<dt>
closedir
</dt>
<dd>
<p>
  <em>int closedir(DIR <strong>dir)</em><br>
 *Defines:</strong> sys_brk getbrk<br>
 <strong>close a directory stream</strong>
Size: ~323B <a href="../src/directories/closedir.c">../src/directories/closedir.c</a> l.6 manpage: <a href="manpages/gen/directory.3.rst">closedir</a><br>
</p>
</dd>
<dt>
creat
</dt>
<dd>
<p>
  <em>int volatile creat( const char <strong>s, int mode )</em><br>
 *Defines:</strong> open<br>
 <strong>create a new file or rewrite an existing one</strong>
Size: ~124B <a href="../src/file/creat.c">../src/file/creat.c</a> l.5 manpage: <a href="manpages/compat-43/creat.2.rst">creat</a><br>
</p>
</dd>
<dt>
dup
</dt>
<dd>
<p>
  <em>int dup(int fd)</em><br>
 <strong>duplicate an open file descriptor</strong>
Size: ~51B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.119 manpage: <a href="manpages/sys/dup.2.rst">dup</a><br>
</p>
</dd>
<dt>
dup2
</dt>
<dd>
<p>
  <em>int dup2(int oldfd, int newfd)</em><br>
 <strong>duplicate a file descriptor</strong>
Size: ~63B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.120 manpage: <a href="manpages/sys/dup.2.rst">dup2</a><br>
</p>
</dd>
<dt>
dup3
</dt>
<dd>
<p>
  <em>int dup3(int oldfd, int newfd, int flags)</em><br>
 <strong>duplicate a file descriptor</strong>
Size: ~75B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.121 manpage: <a href="manpages/gen/dup3.3.rst">dup3</a><br>
</p>
</dd>
<dt>
fchmod
</dt>
<dd>
<p>
  <em>int fchmod( unsigned int fd, mode_t mode)</em><br>
 <strong>change mode of a file</strong>
Size: ~63B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.117 manpage: <a href="manpages/sys/chmod.2.rst">fchmod</a><br>
</p>
</dd>
<dt>
fchown
</dt>
<dd>
<p>
  <em>int fchown( unsigned int fd, uid_t user, gid_t group)</em><br>
 <strong>change owner and group of a file</strong>
Size: ~75B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.116 manpage: <a href="manpages/sys/chown.2.rst">fchown</a><br>
</p>
</dd>
<dt>
fcntl
</dt>
<dd>
<p>
  <em>int fcntl( unsigned int fd, unsigned int cmd, unsigned long arg)</em><br>
 <strong>file control</strong>
Size: ~77B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.178 manpage: <a href="manpages/sys/fcntl.2.rst">fcntl</a><br>
</p>
</dd>
<dt>
fsync
</dt>
<dd>
<p>
  <em>int fsync(int a1 )</em><br>
 <strong>synchronize changes to a file</strong>
Size: ~51B <a href="../include/lseek.h">../include/lseek.h</a> l.21 manpage: <a href="manpages/sys/fsync.2.rst">fsync</a><br>
</p>
</dd>
<dt>
ftruncate
</dt>
<dd>
<p>
  <em>int ftruncate(unsigned int a1, unsigned int a2 )</em><br>
 <strong>truncate a file to a specified length</strong>
Size: ~63B <a href="../include/lseek.h">../include/lseek.h</a> l.20 manpage: <a href="manpages/sys/truncate.2.rst">ftruncate</a><br>
</p>
</dd>
<dt>
link
</dt>
<dd>
<p>
  <em>int link( const char <strong>oldname, const char *newname)</em><br>
 *link one file to another file relative to two directory</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.125 manpage: <a href="manpages/sys/link.2.rst">link</a><br>
</p>
</dd>
<dt>
lseek
</dt>
<dd>
<p>
  <em>int lseek(unsigned int a1, int a2, int a3 )</em><br>
 <strong>move the read/write file offset</strong>
Size: ~75B <a href="../include/lseek.h">../include/lseek.h</a> l.18 manpage: <a href="manpages/sys/lseek.2.rst">lseek</a><br>
</p>
</dd>
<dt>
open
</dt>
<dd>
<p>
  <em>int volatile open( const char <strong>s, int flags, &#8230; )</em><br>
 *open file relative to directory file descriptor</strong>
</p>
</dd>
</dl>
<a name="open"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>open or create a file.
 warning: when using the flag O_CREAT,
 file permission flags have to be given
 as third argument. Otherwise file permission
 flags will be random. (I still do not know, what
 the flag showing up as "-T" means..)</code></pre>
</td></tr></table>
<p>Size: ~124B <a href="../src/file/open.c">../src/file/open.c</a> l.18 manpage: <a href="manpages/sys/open.2.rst">open</a><br></p>
<a name="readahead"></a><dl>
<dt>
readahead
</dt>
<dd>
<p>
  <em>int readahead( int fd,  loff_t offset,  size_t count)</em><br>
 <strong>initiate file readahead into page cache</strong>
Size: ~79B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.258
</p>
</dd>
<dt>
rename
</dt>
<dd>
<p>
  <em>int rename( const char* oldpath, const char* newpath )</em><br>
 <strong>rename file relative to directory file descriptor</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.108 manpage: <a href="manpages/sys/rename.2.rst">rename</a><br>
</p>
</dd>
<dt>
select
</dt>
<dd>
<p>
  <em>int volatile ATTR_OPT("O0") select(int fd, volatile fd_set* readfd, volatile fd_set <strong>writefd, volatile fd_set *exceptfd, volatile struct timeval *wait)</em><br>
 *synchronous I/O multiplexing</strong>
Size: ~138B <a href="../include/select.h">../include/select.h</a> l.16 manpage: <a href="manpages/sys/select.2.rst">select</a><br>
</p>
</dd>
<dt>
sendfile
</dt>
<dd>
<p>
  <em>int sendfile( int out_fd,  int in_fd,  off_t <strong>offset,  size_t count)</em><br>
 *transfer data between file descriptors</strong>
Size: ~142B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.181 manpage: <a href="manpages/sys/sendfile.2.rst">sendfile</a><br>
</p>
</dd>
<dt>
stat
</dt>
<dd>
<p>
  <em>int stat(const char* filename,struct stat* statbuf)</em><br>
 <strong>get file status</strong>
Size: ~49B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.112 manpage: <a href="manpages/sys/stat.2.rst">stat</a><br>
</p>
</dd>
<dt>
symlink
</dt>
<dd>
<p>
  <em>int symlink( const char <strong>oldname,  const char *newname)</em><br>
 *make a symbolic link relative to directory file descriptor</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.126 manpage: <a href="manpages/sys/symlink.2.rst">symlink</a><br>
</p>
</dd>
<dt>
umask
</dt>
<dd>
<p>
  <em>int umask( int mask)</em><br>
 <strong>set and get the file mode creation mask</strong>
Size: ~51B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.257 manpage: <a href="manpages/sys/umask.2.rst">umask</a><br>
</p>
</dd>
<dt>
unlink
</dt>
<dd>
<p>
  <em>int unlink( const char* path)</em><br>
 <strong>remove a directory entry relative to directory file descriptor</strong>
Size: ~47B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.109 manpage: <a href="manpages/sys/unlink.2.rst">unlink</a><br>
</p>
</dd>
</dl>
<p><a name="unlink"></a>---</p>
<hr>
<h2><a name="_hashes"></a>6. hashes</h2>
<a name="djb_cksum"></a><dl>
<dt>
djb_cksum
</dt>
<dd>
<p>
  <em>unsigned int djb_cksum( const char* p, unsigned int len )</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>checksum algorithm by d.j.bernstein.
 Didn't do any benchmarks, but the computation
 might be quite performant.
 It is a bitshift and two additions per byte.</code></pre>
</td></tr></table>
<p><a href="../src/file/cksum.c">../src/file/cksum.c</a> l.8</p>
<p>---</p>
<hr>
<h2><a name="_input"></a>7. input</h2>
<a name="fgetc"></a><dl>
<dt>
fgetc
</dt>
<dd>
<p>
  <em>int fgetc(FILE <strong>F)</em><br>
 *Defines:</strong> read fileno<br>
 <strong>get a byte from a stream</strong>
Size: ~57B <a href="../src/streams/fgetc.c">../src/streams/fgetc.c</a> l.5 manpage: <a href="manpages/stdio/getc.3.rst">fgetc</a><br>
</p>
</dd>
<dt>
fgets
</dt>
<dd>
<p>
  <em>char* fgets(char <strong>buf, int size, FILE</strong> F)</em><br>
 <strong>Defines:</strong> fileno read<br>
 <strong>get a string from a stream</strong>
<a href="../src/streams/fgets.c">../src/streams/fgets.c</a> l.4 manpage: <a href="manpages/stdio/fgets.3.rst">fgets</a><br>
</p>
</dd>
<dt>
getc
</dt>
<dd>
<p>
  <em>#define getc(F) fgetc(F)</em><br>
 <strong>Defines:</strong> fileno read<br>
 <strong>get a byte from a stream</strong>
<a href="../include/fgetc.h">../include/fgetc.h</a> l.8 manpage: <a href="manpages/stdio/getc.3.rst">getc</a><br>
</p>
</dd>
<dt>
getchar
</dt>
<dd>
<p>
  <em>#define getchar() fgetc(0)</em><br>
 <strong>Defines:</strong> fileno read<br>
 <strong>get a byte from a</strong>
<a href="../include/fgetc.h">../include/fgetc.h</a> l.11 manpage: <a href="manpages/stdio/getc.3.rst">getchar</a><br>
</p>
</dd>
<dt>
gets
</dt>
<dd>
<p>
  <em>#define gets(F) fgets(F,0xfffffff,stdin)</em><br>
 <strong>Defines:</strong> fileno read<br>
 <strong>get a string from a</strong>
<a href="../src/streams/gets.c">../src/streams/gets.c</a> l.3 manpage: <a href="manpages/stdio/fgets.3.rst">gets</a><br>
</p>
</dd>
<dt>
read
</dt>
<dd>
<p>
  <em>int read( int fd, void <strong>buf, int len )</em><br>
 *read from a file</strong>
Size: ~62B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.103 manpage: <a href="manpages/sys/read.2.rst">read</a><br>
</p>
</dd>
<dt>
ungetc
</dt>
<dd>
<p>
  <em>int ungetc(int c, FILE <strong>F)</em><br>
 *push byte back into input stream</strong>
</p>
</dd>
</dl>
<a name="ungetc"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>pushes one char back to the stream.
 Overwrites a previously pushed char
 (conforming to the posix spec)</code></pre>
</td></tr></table>
<p>Size: ~66B <a href="../src/streams/ungetc.c">../src/streams/ungetc.c</a> l.5 manpage: <a href="manpages/stdio/ungetc.3.rst">ungetc</a><br></p>
<p>---</p>
<hr>
<h2><a name="_ipc"></a>8. ipc</h2>
<a name="kill"></a><dl>
<dt>
kill
</dt>
<dd>
<p>
  <em>int kill( pid_t pid,  int sig)</em><br>
 <strong>send a signal to a process or a group of processes</strong>
Size: ~63B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.136 manpage: <a href="manpages/sys/kill.2.rst">kill</a><br>
</p>
</dd>
<dt>
mkfifo
</dt>
<dd>
<p>
  <em>int mkfifo( const char* path, mode_t mode )</em><br>
 <strong>make a FIFO special file relative to directory file descriptor</strong>
Size: ~68B <a href="../include/mkfifo.h">../include/mkfifo.h</a> l.4 manpage: <a href="manpages/sys/mkfifo.2.rst">mkfifo</a><br>
</p>
</dd>
<dt>
pipe
</dt>
<dd>
<p>
  <em>int pipe( int <strong>filedes)</em><br>
 *create an interprocess channel</strong>
Size: ~41B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.256 manpage: <a href="manpages/sys/pipe.2.rst">pipe</a><br>
</p>
</dd>
<dt>
raise
</dt>
<dd>
<p>
  <em>int raise(int signr)</em><br>
 <strong>Defines:</strong> kill getpid<br>
 <strong>send a signal to the executing process</strong>
Size: ~68B <a href="../src/process/sigaction.c">../src/process/sigaction.c</a> l.145 manpage: <a href="manpages/gen/raise.3.rst">raise</a><br>
</p>
</dd>
<dt>
rt_sigaction
</dt>
<dd>
<p>
  <em>int rt_sigaction( int sig,  const struct sigaction <strong>act,  struct sigaction *oact,  size_t sigsetsize)</em><br>
 *examine and change a signal action</strong>
Size: ~132B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.152
</p>
</dd>
<dt>
rt_sigprocmask
</dt>
<dd>
<p>
  <em>int rt_sigprocmask( int how,  sigset_t <strong>nset,  sigset_t *oset,  size_t sigsetsize)</em><br>
 *examine and change blocked signals</strong>
Size: ~132B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.186
</p>
</dd>
<dt>
rt_sigreturn
</dt>
<dd>
<p>
  <em>int rt_sigreturn( unsigned long __unused)</em><br>
 <strong>return from signal handler and cleanup stack frame</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.153
</p>
</dd>
<dt>
sigaction
</dt>
<dd>
<p>
  <em>int volatile sigaction(int sig, const struct sigaction <strong>act, struct sigaction *oact)</em><br>
 *Defines:</strong> memcpy rt_sigaction<br>
 <strong>examine and change a signal action</strong>
Size: ~215B <a href="../src/process/sigaction.c">../src/process/sigaction.c</a> l.117 manpage: <a href="manpages/sys/sigaction.2.rst">sigaction</a><br>
</p>
</dd>
<dt>
sigaddset
</dt>
<dd>
<p>
  <em>int sigaddset(sigset_t <strong>set, int sig)</em><br>
 *add a signal to a signal set</strong>
Size: ~85B <a href="../src/process/sigaction.c">../src/process/sigaction.c</a> l.34 manpage: <a href="manpages/gen/sigsetops.3.rst">sigaddset</a><br>
</p>
</dd>
<dt>
sigdelset
</dt>
<dd>
<p>
  <em>int sigdelset(sigset_t <strong>set, int sig)</em><br>
 *delete a signal from a signal set</strong>
Size: ~85B <a href="../src/process/sigaction.c">../src/process/sigaction.c</a> l.68 manpage: <a href="manpages/gen/sigsetops.3.rst">sigdelset</a><br>
</p>
</dd>
<dt>
sigemptyset
</dt>
<dd>
<p>
  <em>int sigemptyset(sigset_t <strong>set)</em><br>
 *initialize and empty a signal set</strong>
Size: ~41B <a href="../src/process/sigaction.c">../src/process/sigaction.c</a> l.7 manpage: <a href="manpages/gen/sigsetops.3.rst">sigemptyset</a><br>
</p>
</dd>
<dt>
sigfillset
</dt>
<dd>
<p>
  <em>int sigfillset(sigset_t <strong>set)</em><br>
 *initialize and fill a signal set</strong>
Size: ~41B <a href="../src/process/sigaction.c">../src/process/sigaction.c</a> l.20 manpage: <a href="manpages/gen/sigsetops.3.rst">sigfillset</a><br>
</p>
</dd>
<dt>
sigismember
</dt>
<dd>
<p>
  <em>int sigismember(sigset_t <strong>set, int sig)</em><br>
 *test for a signal in a signal set</strong>
Size: ~44B <a href="../src/process/sigaction.c">../src/process/sigaction.c</a> l.85 manpage: <a href="manpages/gen/sigsetops.3.rst">sigismember</a><br>
</p>
</dd>
<dt>
signal
</dt>
<dd>
<p>
  <em>sighandler_t signal(int sig, sighandler_t func )</em><br>
 <strong>Defines:</strong> memcpy write rt_sigaction<br>
 <strong>signal management</strong>
Size: ~337B <a href="../src/process/signal.c">../src/process/signal.c</a> l.5 manpage: <a href="manpages/gen/signal.3.rst">signal</a><br>
</p>
</dd>
<dt>
sigprocmask
</dt>
<dd>
<p>
  <em>int sigprocmask(int how, const sigset_t <strong>set, sigset_t *oldset)</em><br>
 *Defines:</strong> rt_sigprocmask<br>
 <strong>examine and change blocked signals</strong>
Size: ~130B <a href="../src/process/sigaction.c">../src/process/sigaction.c</a> l.61 manpage: <a href="manpages/sys/sigprocmask.2.rst">sigprocmask</a><br>
</p>
</dd>
<dt>
wait
</dt>
<dd>
<p>
  <em>pid_t wait(int <strong>wstatus)</em><br>
 *Defines:</strong> wait4<br>
 <strong>wait for a child process to stop or terminate</strong>
Size: ~122B <a href="../src/process/wait.c">../src/process/wait.c</a> l.8 manpage: <a href="manpages/sys/wait.2.rst">wait</a><br>
</p>
</dd>
<dt>
wait4
</dt>
<dd>
<p>
  <em>int wait4( pid_t upid,  int <strong>stat_addr,  int options,  struct rusage *ru)</em><br>
 *wait for process to change state, BSD style</strong>
Size: ~133B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.176 manpage: <a href="manpages/sys/wait.2.rst">wait4</a><br>
</p>
</dd>
<dt>
waitpid
</dt>
<dd>
<p>
  <em>pid_t waitpid(pid_t pid, int <strong>wstatus, int options)</em><br>
 *Defines:</strong> wait4<br>
 <strong>wait for a child process to stop or terminate</strong>
Size: ~138B <a href="../src/process/wait.c">../src/process/wait.c</a> l.16 manpage: <a href="manpages/sys/wait.2.rst">waitpid</a><br>
</p>
</dd>
</dl>
<p><a name="waitpid"></a>---</p>
<hr>
<h2><a name="_math"></a>9. math</h2>
<a name="abs"></a><dl>
<dt>
abs
</dt>
<dd>
<p>
  <em>int abs(int i)</em><br>
 <strong>return an integer absolute value</strong>
<a href="../include/math.h">../include/math.h</a> l.25 manpage: <a href="manpages/stdlib/abs.3.rst">abs</a><br>
</p>
</dd>
<dt>
div
</dt>
<dd>
<p>
  <em>div_t div(int numerator, int denominator)</em><br>
 <strong>compute the quotient and remainder of an integer division</strong>
Size: ~84B <a href="../include/math.h">../include/math.h</a> l.8 manpage: <a href="manpages/stdlib/div.3.rst">div</a><br>
</p>
</dd>
<dt>
djb2_hash
</dt>
<dd>
<p>
  <em>unsigned long djb2_hash(const unsigned char *str)</em><br>
</p>
</dd>
</dl>
<a name="djb2_hash"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>hashes, from d.j.Bernstein
 (http://www.cse.yorku.ca/~oz/hash.html)
 I've tested djb2_hash, and it gives quite good results.
 I'm sure, Bernstein did think and test his algorithm sincerely.
 When combining djb2_hash and sdbm_hash, the probability of collisions
 might tend to zero.
 Me I'm going this way. I guess. I might check djb2_hash for collisions within a space of around 8 digits.
 The hash functions compute the hashes of a c string with a 0 at the end.
 The cksum functions do work with a pointer and a given len.</code></pre>
</td></tr></table>
<p>Size: ~86B <a href="../src/math/hashes.c">../src/math/hashes.c</a> l.12</p>
<a name="labs"></a><dl>
<dt>
labs
</dt>
<dd>
<p>
  <em>long int labs(long int i)</em><br>
 <strong>return a long integer absolute value</strong>
Size: ~46B <a href="../include/math.h">../include/math.h</a> l.30 manpage: <a href="manpages/stdlib/labs.3.rst">labs</a><br>
</p>
</dd>
<dt>
ldiv
</dt>
<dd>
<p>
  <em>ldiv_t ldiv(long int numerator, long int denominator)</em><br>
 <strong>compute quotient and remainder of a long division</strong>
Size: ~82B <a href="../include/math.h">../include/math.h</a> l.16 manpage: <a href="manpages/stdlib/ldiv.3.rst">ldiv</a><br>
</p>
</dd>
<dt>
rand
</dt>
<dd>
<p>
  <em>unsigned int rand()</em><br>
Size: ~118B <a href="../src/math/rand.c">../src/math/rand.c</a> l.7 manpage: <a href="manpages/stdlib/rand.3.rst">rand</a><br>
</p>
</dd>
<dt>
sdbm_hash
</dt>
<dd>
<p>
  <em>unsigned long sdbm_hash(const unsigned char *str)</em><br>
Size: ~80B <a href="../src/math/sdbm_hash.c">../src/math/sdbm_hash.c</a> l.3
</p>
</dd>
<dt>
srand
</dt>
<dd>
<p>
  <em>void srand( unsigned int i )</em><br>
 <strong>pseudo-random number generator</strong>
Size: ~48B <a href="../src/math/srand.c">../src/math/srand.c</a> l.4 manpage: <a href="manpages/stdlib/rand.3.rst">srand</a><br>
</p>
</dd>
</dl>
<p><a name="srand"></a>---</p>
<hr>
<h2><a name="_memory"></a>10. memory</h2>
<a name="brk"></a><dl>
<dt>
brk
</dt>
<dd>
<p>
  <em>int brk( const void* addr )</em><br>
 <strong>Defines:</strong> sys_brk<br>
 <strong>change data segment size</strong>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>set the brk to addr
 return 0 on success.
 conformant brk, when mini_errno is defined return -1 and set errno.
 if errno isn't available,
 returns the negative errno value on error</code></pre>
</td></tr></table>
<p>Size: ~66B <a href="../src/memory/brk.c">../src/memory/brk.c</a> l.8 manpage: <a href="manpages/sys/brk.2.rst">brk</a><br></p>
<a name="free"></a><dl>
<dt>
free
</dt>
<dd>
<p>
  <em>void free(void <strong>p)</em><br>
 *Defines:</strong> sys_brk getbrk<br>
 <strong>free allocated memory</strong>
Size: ~32B <a href="../src/memory/malloc.c">../src/memory/malloc.c</a> l.157 manpage: <a href="manpages/stdlib/memory.3.rst">free</a><br>
</p>
</dd>
<dt>
free_brk
</dt>
<dd>
<p>
  <em>int free_brk()</em><br>
</p>
</dd>
</dl>
<a name="free_brk"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>free all memory,
 which has been allocated with malloc_brk.
 Returns 0, if memory has been freed;
 1, when there hasn't been any memory allocations with
 malloc_brk before.
 Then brk() gives an error, return the return value of brk</code></pre>
</td></tr></table>
<p><a href="../src/memory/freebrk.c">../src/memory/freebrk.c</a> l.9</p>
<a name="getbrk"></a><dl>
<dt>
getbrk
</dt>
<dd>
<p>
  <em>long getbrk()</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>get the current brk
 does either a syscall to brk,
 or returns the globally saved var</code></pre>
</td></tr></table>
<p><a href="../src/memory/getbrk.c">../src/memory/getbrk.c</a> l.6</p>
<a name="malloc"></a><dl>
<dt>
malloc
</dt>
<dd>
<p>
  <em>void* malloc(int size)</em><br>
 <strong>a memory allocator</strong>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>0
 Here we go.. with the .. well.
 Fastes and smallest malloc/free combi ever.
 Not the smartest.
 Since it isn't exactly a memory allocation,
 instead it uses the minilib buf.
 Which is allocated by the kernel, and located
 either in the bss section, or is allocated on the stack.
 (option "globals_on_stack")
 When allocated at the stack, the stack is first expanded
 within startup_c.c, and the return address of startup_c
 discarded. (Jump to exit)
 Therefore an overflow of the globals would result in a segfault.

 For debugging and analization of mallocs and free's, there's
 the option analyzemalloc; which dumps all malloc's and free's to stderr.
 Format: Address - size)

 This is basically a linked list,
 optimized for fast access, allocation of new elements,
 and small memory overhead.
 Albite the list structure might be hard to recognize.
 It is not the right malloc, if you expect
 many de- or reallocations.
 And it obviously is not the right choose, when
 expecting medium to big sized allocations. (&gt; 1 page, here 4kB, as medium sized)

 Here we use mbuf from top to bottom as stack.
 64 Bytes are left at the bottom as reserve.
 Possibly we'd like to complain
 about the lack of memory, before we exit.

 ATM, the 'free' is really lazy.
 It free's memory, but a real 'free' is only commited,
 when all memory below a freed area is also freed.
 Since the target of minilib atm are tiny tools,
 this might be ok.
 ;) but, as I told before -
 probably you should look out for a proper malloc implementation.
 It depends on your needs.

 I'm not sure yet,
 whether another implementation of free would be useful at all.
 Overall, I'd really prefer keeping minilib tiny.

 Reusing sparse freed memory areas also leads
 to a whole bunch of complications.
 cache misses, searching complexity,
 storage overhead, potentially page faults,
 just to name a few.

 I'm not sure whether it's worth it.

 And the existing malloc implementations
 out there are countless.

 ;) It's sometimes smarter to stay special,
 albite in this case this means the opposite.
 /misc

 The memory layout looks like this:
 mlgl-&gt;ibuf and mlgl-&gt;mbuf do point to the same address range.
 mlgl-&gt;ibuf is provided for alignment and faster access to the int values.

 flag prev free is the first bit in size. (0x8000, eq 1000 0000 0000 0000 binary when free),
 (mbufsize)
 ```
      size  data  size    mini_buf size
      8008dataxxxx0004data8000</code></pre>
</td></tr></table>
<p>Size: ~173B <a href="../src/memory/malloc.c">../src/memory/malloc.c</a> l.133 manpage: <a href="manpages/stdlib/memory.3.rst">malloc</a><br></p>
<a name="malloc_brk"></a><dl>
<dt>
malloc_brk
</dt>
<dd>
<p>
  <em>void* malloc_brk(int size)</em><br>
 <strong>Defines:</strong> getbrk sys_brk<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>allocate via setting the brk
 free and realloc can be used normally.
 The intention of malloc_brk is for subsequent calls to realloc.
 The saved data has not to be copied,
 instead realloc just writes the new size and sets
 the brk accordingly.
 if the break is saved before one or more calls to malloc_brk,
 the allocated memory can also be free'd by setting the brk to the saved value
 with brk(saved_brk)
 free_brk() free's all memory, which has been allocated with malloc_brk</code></pre>
</td></tr></table>
<p><a href="../src/memory/malloc_brk.c">../src/memory/malloc_brk.c</a> l.16</p>
<a name="map_protected"></a><dl>
<dt>
map_protected
</dt>
<dd>
<p>
  <em>void* map_protected(int len)</em><br>
 <strong>Defines:</strong> mprotect mmap<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>allocate a buffer, which is surrounded by protected pages.
 mprotect(PROT_NONE)
 When there is a buffer overflow,
 neither the stack, nor other structures can be overwritten.
 Instead the overflow (or underflow) touches the next protected page,
 what results in a segfault.
 Most probably you'd like to catch the segfault signal.
 (By installing a segfault signal handler)

 The size is always a multiple of the systems pagesize, 4kB here.
 The len of the mapped memory area is rounded up to the next pagesize.
 The mapped area can only be freed by call(s) to munmap,
 neither realloc nor free are allowed.
 There is one page before, and one page after the mapped area
 protected with PROT_NONE, and len rounded up to the next
 pagebreak. So this is the overhead.
 If an error occures, errno is set (when defined by the switch mini_errno),
 and -1 returned, or the negative errno value, when errno isn't defined.</code></pre>
</td></tr></table>
<p><a href="../src/memory/map_protected.c">../src/memory/map_protected.c</a> l.22</p>
<a name="memcmp"></a><dl>
<dt>
memcmp
</dt>
<dd>
<p>
  <em>int memcmp(const void* c1,const void* c2,int len)</em><br>
 <strong>compare bytes in memory</strong>
Size: ~44B <a href="../src/memory/memcmp.c">../src/memory/memcmp.c</a> l.3 manpage: <a href="manpages/string/memcmp.3.rst">memcmp</a><br>
</p>
</dd>
<dt>
memcpy
</dt>
<dd>
<p>
  <em>void* memcpy( void*d, const void <strong>s, int n )</em><br>
 *copy bytes in memory</strong>
Size: ~84B <a href="../src/memory/memcpy.c">../src/memory/memcpy.c</a> l.4 manpage: <a href="manpages/string/memcpy.3.rst">memcpy</a><br>
</p>
</dd>
<dt>
memfd_create
</dt>
<dd>
<p>
  <em>int memfd_create( const char  <strong>uname_ptr,  unsigned int flags)</em><br>
 *create an anonymous file</strong>
Size: ~59B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.191
</p>
</dd>
<dt>
memfrob
</dt>
<dd>
<p>
  <em>void* memfrob(void* s, unsigned int len)</em><br>
 <strong>frobnicate (encrypt) a memory area</strong>
</p>
</dd>
</dl>
<a name="memfrob"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>frob string; xor every char with 42</code></pre>
</td></tr></table>
<p>Size: ~78B <a href="../src/memory/memfrob.c">../src/memory/memfrob.c</a> l.4</p>
<a name="memmove"></a><dl>
<dt>
memmove
</dt>
<dd>
<p>
  <em>void* memmove(void <strong>dest, const void *src, int n)</em><br>
 *copy bytes in memory with overlapping areas</strong>
Size: ~88B <a href="../src/memory/memmove.c">../src/memory/memmove.c</a> l.3 manpage: <a href="manpages/string/memmove.3.rst">memmove</a><br>
</p>
</dd>
<dt>
memset
</dt>
<dd>
<p>
  <em>void <strong>memset( void *s, int c, int n)</em><br>
 *set bytes in memory</strong>
Size: ~90B <a href="../src/memory/memset.c">../src/memory/memset.c</a> l.3 manpage: <a href="manpages/string/memset.3.rst">memset</a><br>
</p>
</dd>
<dt>
mmap
</dt>
<dd>
<p>
  <em>void* ATTR_OPT("O0") mmap(void* addr,  size_t len,  int prot,  int flags,  int fd,  off_t off)</em><br>
 <strong>map pages of memory</strong>
</p>
</dd>
</dl>
<a name="mmap"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>mmap wrapper
 address length is rounded up to a multiple of pagesize (4096 Bytes here)
 for the description, please look up the according manpage
 errno is only set, when mini_errno is defined
 if not, on error the negative errno value is returned.
 (e.g. -22 for "invalid argument")</code></pre>
</td></tr></table>
<p>Size: ~197B <a href="../src/memory/mmap.c">../src/memory/mmap.c</a> l.8 manpage: <a href="manpages/sys/mmap.2.rst">mmap</a><br></p>
<a name="mprotect"></a><dl>
<dt>
mprotect
</dt>
<dd>
<p>
  <em>int mprotect( POINTER <strong>a1, POINTER a2, int a3 )</em><br>
 *set protection of memory mapping</strong>
Size: ~146B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.254 manpage: <a href="manpages/sys/mprotect.2.rst">mprotect</a><br>
</p>
</dd>
<dt>
mremap
</dt>
<dd>
<p>
  <em>void* volatile ATTR_OPT("O0") mremap(void* addr, size_t old_len, size_t new_len, int flags, void* new_addr)</em><br>
 <strong>remap a virtual memory address</strong>
Size: ~162B <a href="../include/mremap.h">../include/mremap.h</a> l.4
</p>
</dd>
<dt>
munmap
</dt>
<dd>
<p>
  <em>int munmap( void* addr,  size_t len)</em><br>
 <strong>unmap pages of memory</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.261 manpage: <a href="manpages/sys/munmap.2.rst">munmap</a><br>
</p>
</dd>
<dt>
realloc
</dt>
<dd>
<p>
  <em>void* realloc(void <strong>p, int size)</em><br>
 *Defines:</strong> getbrk 0 sys_brk<br>
 <strong>memory reallocator</strong>
Size: ~636B <a href="../src/memory/malloc.c">../src/memory/malloc.c</a> l.229 manpage: <a href="manpages/stdlib/memory.3.rst">realloc</a><br>
</p>
</dd>
<dt>
sbrk
</dt>
<dd>
<p>
  <em>void* sbrk(long incr)</em><br>
 <strong>Defines:</strong> sys_brk<br>
 <strong>change data segment size</strong>
</p>
</dd>
</dl>
<a name="sbrk"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>Set the new brk, increment/decrement by incr bytes.
 return the old brk on success.
 conformant sbrk, when mini_errno is defined
 if no errno is available,
 returns the negative errno value on error</code></pre>
</td></tr></table>
<p>Size: ~108B <a href="../src/memory/sbrk.c">../src/memory/sbrk.c</a> l.9 manpage: <a href="manpages/sys/brk.2.rst">sbrk</a><br></p>
<a name="splice"></a><dl>
<dt>
splice
</dt>
<dd>
<p>
  <em>int splice( int fd_in,  loff_t <strong>off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)</em><br>
 *splice data to/from a pipe</strong>
Size: ~178B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.196
</p>
</dd>
<dt>
swap
</dt>
<dd>
<p>
  <em>void swap(void* a, void* b,int size)</em><br>
</p>
</dd>
</dl>
<a name="swap"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>swap a with b, with 'size' bytes
 swaps integers and longs at once, when size eq sizeof(int/long)</code></pre>
</td></tr></table>
<p><a href="../src/sort/swap.c">../src/sort/swap.c</a> l.5</p>
<a name="unmap_protected"></a><dl>
<dt>
unmap_protected
</dt>
<dd>
<p>
  <em>int unmap_protected(void <strong>p, int len)</em><br>
 *Defines:</strong> mprotect munmap<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>free an area, allocated before with map_protected
 (len must be the same, when at the invocation of map_protected)
 returns the value of munmap, when an error occures.
 errno is set, when defined.
 return 0 on success.</code></pre>
</td></tr></table>
<p><a href="../src/memory/map_protected.c">../src/memory/map_protected.c</a> l.44</p>
<p>---</p>
<hr>
<h2><a name="_output"></a>11. output</h2>
<a name="_mprints"></a><dl>
<dt>
_mprints
</dt>
<dd>
<p>
  <em>#define _mprints(&#8230;) dprints(STDOUT_FILENO, <em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> write<br>
<a href="../include/prints.h">../include/prints.h</a> l.10
</p>
</dd>
<dt>
ansicolors
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<a name="ansicolors"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>defines for ansicolors at the console, 16 color mode
the names are:
 AC_NORM ( white text on black background)
 AC_BLACK
 AC_RED
 AC_GREEN
 AC_BROWN
 AC_BLUE
 AC_MAGENTA
 AC_MARINE (= AC_CYAN)
 AC_LGREY
 AC_WHITE
 AC_GREY
 AC_LRED
 AC_LGREEN
 AC_YELLOW
 AC_LBLUE
 AC_LMAGENTA
 AC_LMARINE (= AC_LCYAN)
 AC_LWHITE
 AC_BGBLACK
 AC_BGRED
 AC_BGGREEN
 AC_BGBROWN
 AC_BGBLUE
 AC_BGMAGENTA
 AC_BGMARINE
 AC_BGLGREY
 AC_BGWHITE

 AC_BOLD
 AC_FAINT
 AC_CURSIVE
 AC_UNDERLINE
 AC_LIGHTBG
 AC_BLINK
 AC_INVERTED
 AC_INVERSE

 ( Faint to inverse are not available at every terminal )</code></pre>
</td></tr></table>
<p><a href="../include/ansicolors.h">../include/ansicolors.h</a> l.45</p>
<a name="dprintf"></a><dl>
<dt>
dprintf
</dt>
<dd>
<p>
  <em>int dprintf( int fd, const char <strong>fmt, &#8230; )</em><br>
 *Defines:</strong> getpid strlen write kill<br>
 <strong>print formatted output</strong>
Size: ~818B <a href="../src/output/dprintf.c">../src/output/dprintf.c</a> l.5 manpage: <a href="manpages/stdio/printf.3.rst">dprintf</a><br>
</p>
</dd>
<dt>
dprints
</dt>
<dd>
<p>
  <em>int dprints(int fd, const char <strong>msg,&#8230;)</em><br>
 *Defines:</strong> write<br>
<a href="../src/output/dprints.c">../src/output/dprints.c</a> l.12
</p>
</dd>
<dt>
eprint
</dt>
<dd>
<p>
  <em>#define eprint(str) write(STDERR_FILENO,str,strlen(str))</em><br>
 <strong>Defines:</strong> strlen write<br>
</p>
</dd>
</dl>
<a name="eprint"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write str to stderr. Needs strlen</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.57</p>
<a name="eprintfs"></a><dl>
<dt>
eprintfs
</dt>
<dd>
<p>
  <em>#define eprintfs(fmt,&#8230;) fprintfs(stderr, fmt, <em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> fileno strlen write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write fmt and arguments to stderr.
 only format %s and %c are recognized</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.128</p>
<a name="eprintl"></a><dl>
<dt>
eprintl
</dt>
<dd>
<p>
  <em>#define eprintl() write(STDERR_FILENO,"\n",1)</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write a newline to stderr</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.66</p>
<a name="eprints"></a><dl>
<dt>
eprints
</dt>
<dd>
<p>
  <em>#define eprints(&#8230;) dprints(STDERR_FILENO,<em>VA_ARGS</em>,0)</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>print the string(s) supplied as arg(s) to stdout
 this macro has an variable argument count.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.26</p>
<a name="eprintsl"></a><dl>
<dt>
eprintsl
</dt>
<dd>
<p>
  <em>#define eprintsl(&#8230;) dprints(STDERR_FILENO,<em>VA_ARGS</em>,"\n",0)</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>print the string(s) supplied as arg(s) and newline to stderr</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.48</p>
<a name="eputs"></a><dl>
<dt>
eputs
</dt>
<dd>
<p>
  <em>#define eputs(msg) ( eprint(msg) + eprintl() )</em><br>
 <strong>Defines:</strong> write strlen<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write msg to stderr, append a newline. Needs strlen.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.76</p>
<a name="ewrites"></a><dl>
<dt>
ewrites
</dt>
<dd>
<p>
  <em>#define ewrites(str) write(STDERR_FILENO,str,sizeof(str))</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write the constant str to stderr. Computes length with sizeof(str) at compile time.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.87</p>
<a name="fprint"></a><dl>
<dt>
fprint
</dt>
<dd>
<p>
  <em>#define fprint(&#8230;) fprintf(<em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> write fileno kill globals strlen getpid<br>
<a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.84
</p>
</dd>
<dt>
fprintf
</dt>
<dd>
<p>
  <em>#define fprintf(stream,&#8230;)  write(fileno(stream),mlgl&#8594;mbuf,snprintf(mlgl&#8594;mbuf,mlgl&#8594;mbufsize,<em>VA_ARGS</em>))</em><br>
 <strong>Defines:</strong> fileno kill write globals strlen getpid<br>
</p>
</dd>
</dl>
<a name="fprintf"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>fprintf, formatted output
 conversions implemented:
 %d: signed int (mini_itodec)
 %u: unsigned int (mini_uitodec)
 %f: double (max precision 8 digits, highest possible number: 2^31 (mini_dtodec)
 %l (modify a following d,u to long) (mini_ltodec,mini_ultodec)
 %s: string
 %c: char
 binary and hex output print the numbers,
 as they are internally stored(!).
 Negative numbers are represented with the first sign bit set.
 (e.g. -1 = 0xFFFFFFFF at x64)
 %b : binary output  (mini_itobin)
 %o : octal output (mini_itooct)
 %x/X : hex output (small/big capitals) (mini_itohex,mini_itoHEX
 %(: grouping (mini_atoi)

 warning - most possibly you'd like to define besides fprintf, or family,
 mini_itodec (%d conversion)

 For squeezing a few more bytes, and saving some checking;
 writes(constant string) and print (variable string),
 prints (formatted output of one or several strings) are provided.</code></pre>
</td></tr></table>
<p><a href="../src/output/fprintf.c">../src/output/fprintf.c</a> l.32 manpage: <a href="manpages/stdio/printf.3.rst">fprintf</a><br></p>
<a name="fprintfs"></a><dl>
<dt>
fprintfs
</dt>
<dd>
<p>
  <em>int fprintfs( FILE* F, char <strong>fmt, &#8230;)</em><br>
 *Defines:</strong> fileno write strlen<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>prints formatted and unbuffered output to the stream F.
 only %s and %c are recognized.
 no mini_buf or globals are used, so using fprintfs instead of fprintf can save some sections / bytes.</code></pre>
</td></tr></table>
<p>Size: ~427B <a href="../src/output/fprintfs.c">../src/output/fprintfs.c</a> l.8</p>
<a name="fprints"></a><dl>
<dt>
fprints
</dt>
<dd>
<p>
  <em>#define fprints(F,&#8230;) dprints(fileno(F),<em>VA_ARGS</em>,0)</em><br>
 <strong>Defines:</strong> fileno write strlen<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>print the string(s) supplied as arg(s) to stream
 this macro has an variable argument count.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.34</p>
<a name="fputc"></a><dl>
<dt>
fputc
</dt>
<dd>
<p>
  <em>int volatile fputc(int c, FILE* F)</em><br>
 <strong>Defines:</strong> write fileno<br>
 <strong>put a byte on a stream</strong>
Size: ~64B <a href="../include/fputc.h">../include/fputc.h</a> l.9 manpage: <a href="manpages/stdio/putc.3.rst">fputc</a><br>
</p>
</dd>
<dt>
fwrite
</dt>
<dd>
<p>
  <em>size_t fwrite(const void <strong>ptr, size_t size, size_t nmemb, FILE *f)</em><br>
 *Defines:</strong> write<br>
 <strong>binary output</strong>
Size: ~117B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.95 manpage: <a href="manpages/stdio/fread.3.rst">fwrite</a><br>
</p>
</dd>
<dt>
fwrites
</dt>
<dd>
<p>
  <em>#define fwrites(fd,str) write(fd,str,sizeof(str))</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<a name="fwrites"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write the constant str to fd. Computes length with sizeof(str) at compile time.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.107</p>
<a name="group_print"></a><dl>
<dt>
group_print
</dt>
<dd>
<p>
  __<br>
 <strong>Defines:</strong> write kill fileno getpid strlen globals<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>enable print and related functions
 This switch enables strlen;
 but neither globals nor the mini_buf are used.</code></pre>
</td></tr></table>
<p><a href="../macros/defgroups.h">../macros/defgroups.h</a> l.13</p>
<a name="group_write"></a><dl>
<dt>
group_write
</dt>
<dd>
<p>
  __<br>
 <strong>Defines:</strong> ewrite write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write, and related functions
 these functions do not depend on strlen,
 or any globals.</code></pre>
</td></tr></table>
<p><a href="../macros/defgroups.h">../macros/defgroups.h</a> l.23</p>
<a name="print"></a><dl>
<dt>
print
</dt>
<dd>
<p>
  <em>#define print(str) write(STDOUT_FILENO,str,strlen(str))</em><br>
 <strong>Defines:</strong> write strlen<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write str to stdout. Needs strlen</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.53</p>
<a name="printf"></a><dl>
<dt>
printf
</dt>
<dd>
<p>
  <em>#define printf(&#8230;) fprintf(stdout,<em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> fileno kill write globals strlen getpid<br>
 <strong>print formatted output</strong>
<a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.80 manpage: <a href="manpages/stdio/printf.3.rst">printf</a><br>
</p>
</dd>
<dt>
printfs
</dt>
<dd>
<p>
  <em>#define printfs(fmt,&#8230;) fprintfs(stdout, fmt, <em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> write strlen fileno<br>
</p>
</dd>
</dl>
<a name="printfs"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write fmt and arguments to stdout.
 only format %s and %c are recognized</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.122</p>
<a name="printl"></a><dl>
<dt>
printl
</dt>
<dd>
<p>
  <em>#define printl() write(STDOUT_FILENO,"\n",1)</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write a newline to stdout</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.62</p>
<a name="prints"></a><dl>
<dt>
prints
</dt>
<dd>
<p>
  <em>#define prints(&#8230;) _mprints(<em>VA_ARGS</em>,0)</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>print the string(s) supplied as arg(s) to stdout,
 this macro has an variable argument count.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.18</p>
<a name="printsl"></a><dl>
<dt>
printsl
</dt>
<dd>
<p>
  <em>#define printsl(&#8230;) _mprints(<em>VA_ARGS</em>,"\n",0)</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>print the string(s) supplied as arg(s) and newline to stdout</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.42</p>
<a name="putc"></a><dl>
<dt>
putc
</dt>
<dd>
<p>
  <em>#define putc(c,stream) fputc(c,stream)</em><br>
 <strong>Defines:</strong> write fileno<br>
 <strong>put a byte on a stream</strong>
<a href="../include/fputc.h">../include/fputc.h</a> l.18 manpage: <a href="manpages/stdio/putc.3.rst">putc</a><br>
</p>
</dd>
<dt>
putchar
</dt>
<dd>
<p>
  <em>#define putchar(c) fputc(c,stdout)</em><br>
 <strong>Defines:</strong> fileno write<br>
 <strong>put a byte on a stdout stream</strong>
<a href="../include/fputc.h">../include/fputc.h</a> l.15 manpage: <a href="manpages/stdio/putc.3.rst">putchar</a><br>
</p>
</dd>
<dt>
puts
</dt>
<dd>
<p>
  <em>#define puts(msg) ( print(msg) + printl() )</em><br>
 <strong>Defines:</strong> globals getpid strlen write fileno kill<br>
 <strong>put a string on standard output</strong>
</p>
</dd>
</dl>
<a name="puts"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write msg to stdout, append a newline. Needs strlen.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.72 manpage: <a href="manpages/stdio/fputs.3.rst">puts</a><br></p>
<a name="shortcolornames"></a><dl>
<dt>
shortcolornames
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>short ansi color names
 all colornames, without the praefix "AC_"</code></pre>
</td></tr></table>
<p><a href="../include/ansicolors.h">../include/ansicolors.h</a> l.103</p>
<a name="snprintf"></a><dl>
<dt>
snprintf
</dt>
<dd>
<p>
  <em>int snprintf( char <strong>buf, size_t size, const char *fmt, &#8230; )</em><br>
 *Defines:</strong> strlen getpid write kill<br>
 <strong>print formatted output</strong>
Size: ~738B <a href="../src/output/snprintf.c">../src/output/snprintf.c</a> l.5 manpage: <a href="manpages/stdio/printf.3.rst">snprintf</a><br>
</p>
</dd>
<dt>
vfprintf
</dt>
<dd>
<p>
  <em>#define vfprintf(&#8230;) fprintf(<em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> kill fileno write getpid strlen globals<br>
<a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.89 manpage: <a href="manpages/stdio/printf.3.rst">vfprintf</a><br>
</p>
</dd>
<dt>
vsnprintf
</dt>
<dd>
<p>
  <em>int vsnprintf(char <strong>buf, size_t size, const char</strong> fmt, va_list args )</em><br>
 <strong>Defines:</strong> write strlen getpid kill<br>
 <strong>format output of a stdarg argument list</strong>
</p>
</dd>
</dl>
<a name="vsnprintf"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>the function, translating the fmt of printf.
 warning - most possibly you'd like to define besides fprintf, or family,
 mini_itodec (%d conversion)
 mini_atoi is needed for grouping numbers</code></pre>
</td></tr></table>
<p>Size: ~590B <a href="../src/output/vsnprintf.c">../src/output/vsnprintf.c</a> l.18 manpage: <a href="manpages/stdio/printf.3.rst">vsnprintf</a><br></p>
<a name="vsprintf"></a><dl>
<dt>
vsprintf
</dt>
<dd>
<p>
  <em>int vsprintf( char *buf, const char *fmt, &#8230; )</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write fmt and arguments into buf
 calls vsnprintf,
 the size is limited to 4096 by default and assumes
 a buf len of 4096.</code></pre>
</td></tr></table>
<p><a href="../src/output/vsprintf.c">../src/output/vsprintf.c</a> l.10 manpage: <a href="manpages/stdio/printf.3.rst">vsprintf</a><br></p>
<a name="write"></a><dl>
<dt>
write
</dt>
<dd>
<p>
  <em>int write(int fd,const void <strong>buf, int len )</em><br>
 *write on a file</strong>
Size: ~65B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.104 manpage: <a href="manpages/sys/write.2.rst">write</a><br>
</p>
</dd>
<dt>
writes
</dt>
<dd>
<p>
  <em>#define writes(str) write(STDOUT_FILENO,str,sizeof(str))</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<a name="writes"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write the constant str to stdout. Computes length with sizeof(str) at compile time.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.83</p>
<p>---</p>
<hr>
<h2><a name="_process"></a>12. process</h2>
<a name="abort"></a><dl>
<dt>
abort
</dt>
<dd>
<p>
  <em>void abort()</em><br>
 <strong>Defines:</strong> memcpy write getpid rt_sigaction kill<br>
<a href="../src/process/abort.c">../src/process/abort.c</a> l.3 manpage: <a href="manpages/stdlib/abort.3.rst">abort</a><br>
</p>
</dd>
<dt>
atexit
</dt>
<dd>
<p>
  <em>int atexit( functionp* func )</em><br>
 <strong>Defines:</strong> globals<br>
</p>
</dd>
</dl>
<a name="atexit"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>register functions, which are callen on exit in reverse order
 the switch mini_atexit takes a optional number,
 which defines the maximum numbers of functions to be registered.
 (defaults to 8)</code></pre>
</td></tr></table>
<p><a href="../src/process/atexit.c">../src/process/atexit.c</a> l.7 manpage: <a href="manpages/stdlib/atexit.3.rst">atexit</a><br></p>
<a name="clone"></a><dl>
<dt>
clone
</dt>
<dd>
<p>
  <em>int clone( int clone_flags,  unsigned long stack,  void *parent_tid,  void *child_tid)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.225
</p>
</dd>
<dt>
clone_t
</dt>
<dd>
<p>
  <em>int clone_t(int flags)</em><br>
<a href="../src/process/clone.c">../src/process/clone.c</a> l.7
</p>
</dd>
<dt>
execl
</dt>
<dd>
<p>
  <em>int execl(const char <strong>pathname, const char</strong> arg0,&#8230; )</em><br>
 <strong>Defines:</strong> environ execve<br>
<a href="../src/exec/execl.c">../src/exec/execl.c</a> l.6 manpage: <a href="manpages/gen/exec.3.rst">execl</a><br>
</p>
</dd>
<dt>
execv
</dt>
<dd>
<p>
  <em>int execv(const char <strong>pathname, char *const argv[])</em><br>
 *Defines:</strong> environ execve<br>
 <strong>execute a file</strong>
Size: ~300B <a href="../src/exec/_execv.c">../src/exec/_execv.c</a> l.4 manpage: <a href="manpages/gen/exec.3.rst">execv</a><br>
</p>
</dd>
<dt>
execve
</dt>
<dd>
<p>
  <em>int execve( const char <strong>filename,  char</strong> const* argv, char* const* envp)</em><br>
 <strong>execute program</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.134 manpage: <a href="manpages/sys/execve.2.rst">execve</a><br>
</p>
</dd>
<dt>
execveat
</dt>
<dd>
<p>
  <em>int execveat( int dirfd, const char <strong>filename,  char</strong> const* argv, char* const* envp, int flags)</em><br>
 <strong>execute program relative to a directory file descriptor</strong>
Size: ~158B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.173
</p>
</dd>
<dt>
execvp
</dt>
<dd>
<p>
  <em>int execvp(const char <strong>file, char *const argv[])</em><br>
 *Defines:</strong> environ access execve<br>
 <strong>execute a file</strong>
Size: ~556B <a href="../src/exec/_execvp.c">../src/exec/_execvp.c</a> l.4 manpage: <a href="manpages/gen/exec.3.rst">execvp</a><br>
</p>
</dd>
<dt>
execvpe
</dt>
<dd>
<p>
  <em>int execvpe(const char <strong>file, char *const argv[], char *const envp[])</em><br>
 *Defines:</strong> execve access environ<br>
 <strong>execute a file</strong>
</p>
</dd>
</dl>
<a name="execvpe"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>When invoked with a filename, starting with "." or "/",
 interprets this as absolute path. (calls execve with the pathname)
 Looks for file in the PATH environment, othwerise.</code></pre>
</td></tr></table>
<p>Size: ~556B <a href="../src/exec/execvp.c">../src/exec/execvp.c</a> l.11</p>
<a name="fexecve"></a><dl>
<dt>
fexecve
</dt>
<dd>
<p>
  <em>int fexecve(int fd, char <strong>const argv[], char *const envp[])</em><br>
 *execute a file</strong>
Size: ~151B <a href="../include/fexecve.h">../include/fexecve.h</a> l.3 manpage: <a href="manpages/sys/execve.2.rst">fexecve</a><br>
</p>
</dd>
<dt>
fexecveat
</dt>
<dd>
<p>
  <em>int fexecveat(int fd, char *const argv[], char *const envp[])</em><br>
Size: ~151B <a href="../include/fexecveat.h">../include/fexecveat.h</a> l.3
</p>
</dd>
<dt>
fork
</dt>
<dd>
<p>
  <em>int DEF_syscall(fork,0)</em><br>
 <strong>create a new process</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.138 manpage: <a href="manpages/sys/fork.2.rst">fork</a><br>
</p>
</dd>
<dt>
getenv
</dt>
<dd>
<p>
  <em>char* getenv(const char* name)</em><br>
 <strong>Defines:</strong> environ<br>
 <strong>get value of an environment variable</strong>
Size: ~106B <a href="../src/system/getenv.c">../src/system/getenv.c</a> l.5 manpage: <a href="manpages/stdlib/getenv.3.rst">getenv</a><br>
</p>
</dd>
<dt>
getpgrp
</dt>
<dd>
<p>
  <em>int DEF_syscall(getpgrp,0)</em><br>
 <strong>get the process group ID of the calling process</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.207 manpage: <a href="manpages/sys/getpgrp.2.rst">getpgrp</a><br>
</p>
</dd>
<dt>
getpid
</dt>
<dd>
<p>
  <em>int DEF_syscall(getpid,0 )</em><br>
 <strong>get the process ID</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.159 manpage: <a href="manpages/sys/getpid.2.rst">getpid</a><br>
</p>
</dd>
<dt>
getppid
</dt>
<dd>
<p>
  <em>int DEF_syscall(getppid,0)</em><br>
 <strong>get the parent process ID</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.204 manpage: <a href="manpages/sys/getpid.2.rst">getppid</a><br>
</p>
</dd>
<dt>
setpgid
</dt>
<dd>
<p>
  <em>int setpgid( pid_t pid, pid_t pgid)</em><br>
 <strong>set process group ID for job control</strong>
Size: ~63B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.205 manpage: <a href="manpages/sys/setpgid.2.rst">setpgid</a><br>
</p>
</dd>
<dt>
setsid
</dt>
<dd>
<p>
  <em>int DEF_syscall(setsid,0 )</em><br>
 <strong>create session and set process group ID</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.160 manpage: <a href="manpages/sys/setsid.2.rst">setsid</a><br>
</p>
</dd>
<dt>
system
</dt>
<dd>
<p>
  <em>int system( const char* command )</em><br>
 <strong>Defines:</strong> environ write vfork wait4 execve<br>
 <strong>issue a command</strong>
Size: ~326B <a href="../src/exec/system.c">../src/exec/system.c</a> l.4 manpage: <a href="manpages/stdlib/system.3.rst">system</a><br>
</p>
</dd>
<dt>
vexec
</dt>
<dd>
<p>
  <em>int vexec( const char* path, char* const* argv, char* const* envp )</em><br>
 <strong>Defines:</strong> vfork seterrno exit execve wait4<br>
</p>
</dd>
</dl>
<a name="vexec"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>execute a path, wait until the executed file exits.
 Deviating of system() an absolute pathname is taken.
 sets errno on error.</code></pre>
</td></tr></table>
<p><a href="../src/exec/vexec.c">../src/exec/vexec.c</a> l.6</p>
<a name="vexec_q"></a><dl>
<dt>
vexec_q
</dt>
<dd>
<p>
  <em>int vexec_q( const char* path, char* const* argv, char* const* envp )</em><br>
 <strong>Defines:</strong> seterrno vfork execve wait4 exit<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>execute a path, wait until the executed file exits,
 do not write any output of the process. (close stdout)
 Deviating of system() an absolute pathname is taken.</code></pre>
</td></tr></table>
<p><a href="../src/exec/vexec_q.c">../src/exec/vexec_q.c</a> l.6</p>
<a name="vfork"></a><dl>
<dt>
vfork
</dt>
<dd>
<p>
  <em>int DEF_syscall(vfork,0)</em><br>
 <strong>create a child process and block parent</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.139 manpage: <a href="manpages/sys/vfork.2.rst">vfork</a><br>
</p>
</dd>
</dl>
<p>---</p>
<hr>
<h2><a name="_regex"></a>13. regex</h2>
<a name="ext_match"></a><dl>
<dt>
ext_match
</dt>
<dd>
<p>
  <em>int ext_match(char *text, const char *re, void(*p_match)(int number, char *pos,int len), int(*p_match_char)(int number, char *match_char), regex_match *st_match)</em><br>
</p>
</dd>
<dt>
match
</dt>
<dd>
<p>
  <em>int match(char *text, const char *re, text_match *st_match)</em><br>
</p>
</dd>
</dl>
<a name="match"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>text matching engine

 little bit simpler version than match_ext.
 Consciusly named 'text matching', since the inherent logic
 is quite different to a regular expression machine.

 The engine matches nongreedy straight from left to right,
 so backtracking is minimized.
 It is a compromise between performance, size
 and capabilities.


 matches:

 * for every count of any char (nongreedy(!))
 + for 1 or more chars
 % for 1 or more chars, and fills in arg 3 (text_match)
 ? for 1 char
 @ matches the beginning of the text or endofline (\n)
   -&gt; beginning of a line
 # for space, endofline, \t, \n, \f, \r, \v  or end of text (0)
 $ match end of text
 backslash: escape *,?,%,!,+,#,$ and backslash itself.
 ! : invert the matching of the next character or character class

 [xyz]: character classes, here x,y or z
   the characters are matched literally, also \,*,?,+,..
   it is not possible to match the closing bracket (])
   within a character class


 % : matches like a '+', and fills in argument 3,
 the text_match struct, when the pointer is non null.
 The matching is 'nongreedy'.


 returns: 1 on match, 0 on no match
 ( RE_MATCH / RE_NOMATCH )

 if the pointer (argument 3) st_match is nonnull,
 the supplied struct text_match will be set to the first matching '%' location;
 if there is no match, text_match.len will be set to 0.

 The struct is defined as:
 typedef struct _text_match { char* pos; int len; } text_match;

 examples:
 "*word*"  matches "words are true" or "true words are rare"
 "word*"   matches "words are true" and not "true words are rare"
 "word"    matches none of the above two texts (!)
 "*words%" extracts with % " are true" and " are rare"
           into text_match

 "Some\ntext\nwith\nlinebreaks\n\n"
 "*@%#*" matches with % "Some"
 "*@line%#*" matches % = "breaks"
 "*text\n%"  % = "with linebreaks\n\n"


 (memo) When the regex ist defined within C/cpp source code,
 a backslash has to be defined as double backslash.

 (note) - be careful when negating a following *, or ?.
  somehow - it is logical, but seems to me I overshoot a bit,
  and tapped into a logical paradox.
  Negating EVERYTHING translates to true.
  However, since truth is negated as,... well, there's a problem.

  (I'm not kidding here. Just don't do a regex with !* or !?.,
  or you might experience the meaning of full featured.
  Maybe I should say, it's not allowed?)

  A "!+" will translate into nongreedy matching of any char, however;
  "%!+" will match with % everything but the last char;
  while "%+" matches with % only the first char.
  !+ basically sets the greedyness of the left * or % higher.</code></pre>
</td></tr></table>
<p><a href="../src/match/match.c">../src/match/match.c</a> l.83</p>
<p>---</p>
<hr>
<h2><a name="_streams"></a>14. streams</h2>
<a name="clearerr"></a><dl>
<dt>
clearerr
</dt>
<dd>
<p>
  <em>void clearerr(FILE <strong>f)</em><br>
 *clear indicators on a stream</strong>
Size: ~36B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.189 manpage: <a href="manpages/stdio/ferror.3.rst">clearerr</a><br>
</p>
</dd>
<dt>
clearerror
</dt>
<dd>
<p>
  <em>void clearerror(FILE *f)</em><br>
Size: ~36B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.194
</p>
</dd>
<dt>
fclose
</dt>
<dd>
<p>
  <em>int  fclose( FILE* f )</em><br>
 <strong>Defines:</strong> close<br>
 <strong>close a stream</strong>
Size: ~40B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.66 manpage: <a href="manpages/stdio/fclose.3.rst">fclose</a><br>
</p>
</dd>
<dt>
fdopen
</dt>
<dd>
<p>
  <em>FILE <strong>fdopen(int fd, const char</strong> mode)</em><br>
 <strong>Defines:</strong> open fileno close<br>
 <strong>associate a stream with a file descriptor</strong>
</p>
</dd>
</dl>
<a name="fdopen"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>modes implemented: r, r+, w, w+, a, a+</code></pre>
</td></tr></table>
<p>Size: ~323B <a href="../src/streams/fdopen.c">../src/streams/fdopen.c</a> l.6 manpage: <a href="manpages/stdio/fopen.3.rst">fdopen</a><br></p>
<a name="feof"></a><dl>
<dt>
feof
</dt>
<dd>
<p>
  <em>int feof(FILE <strong>f)</em><br>
 *test end-of-file indicator on a stream</strong>
<a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.175 manpage: <a href="manpages/stdio/ferror.3.rst">feof</a><br>
</p>
</dd>
<dt>
ferror
</dt>
<dd>
<p>
  <em>int ferror(FILE <strong>f)</em><br>
 *test error indicator on a stream</strong>
Size: ~32B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.182 manpage: <a href="manpages/stdio/ferror.3.rst">ferror</a><br>
</p>
</dd>
<dt>
fflush
</dt>
<dd>
<p>
  <em>int  fflush( FILE <strong>F )</em><br>
 *flush a stream</strong>
</p>
</dd>
</dl>
<a name="fflush"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>This does nothing, since minilib doesn't provide buffered streams yet.In order to sync data to disc, please use fsync</code></pre>
</td></tr></table>
<p>Size: ~32B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.28 manpage: <a href="manpages/stdio/fflush.3.rst">fflush</a><br></p>
<a name="fgetpos"></a><dl>
<dt>
fgetpos
</dt>
<dd>
<p>
  <em>void fgetpos(FILE <strong>f, long *pos )</em><br>
 *Defines:</strong> lseek<br>
 <strong>get current file position information</strong>
Size: ~62B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.117 manpage: <a href="manpages/stdio/fseek.3.rst">fgetpos</a><br>
</p>
</dd>
<dt>
fileno
</dt>
<dd>
<p>
  <em>int fileno( FILE <strong>f )</em><br>
 *map a stream pointer to a file descriptor</strong>
</p>
</dd>
</dl>
<a name="fileno"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>Return the fd nummber of stdin,-out,-err.</code></pre>
</td></tr></table>
<p>Size: ~32B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.56 manpage: <a href="manpages/stdio/ferror.3.rst">fileno</a><br></p>
<a name="fopen"></a><dl>
<dt>
fopen
</dt>
<dd>
<p>
  <em>FILE <strong>fopen(const char</strong> filename, const char* mode)</em><br>
 <strong>Defines:</strong> close fileno open<br>
 <strong>open a stream</strong>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>modes implemented: r, r+, w, w+, a, a+</code></pre>
</td></tr></table>
<p>Size: ~324B <a href="../src/streams/fopen.c">../src/streams/fopen.c</a> l.8 manpage: <a href="manpages/stdio/fopen.3.rst">fopen</a><br></p>
<a name="fputs"></a><dl>
<dt>
fputs
</dt>
<dd>
<p>
  <em>int volatile fputs(const char <strong>c, FILE *F)</em><br>
 *Defines:</strong> strlen write fileno<br>
 <strong>put a string on a stream</strong>
Size: ~90B <a href="../include/fputs.h">../include/fputs.h</a> l.18 manpage: <a href="manpages/stdio/fputs.3.rst">fputs</a><br>
</p>
</dd>
<dt>
fread
</dt>
<dd>
<p>
  <em>size_t fread(void <strong>ptr, size_t size, size_t nmemb, FILE *f)</em><br>
 *Defines:</strong> read<br>
 <strong>binary input</strong>
Size: ~110B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.152 manpage: <a href="manpages/stdio/fread.3.rst">fread</a><br>
</p>
</dd>
<dt>
freopen
</dt>
<dd>
<p>
  <em>FILE <strong>freopen(const char</strong> filename, const char* mode, FILE <strong>F)</em><br>
 *Defines:</strong> open close fileno<br>
 <strong>open a stream</strong>
</p>
</dd>
</dl>
<a name="freopen"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>modes implemented: r, r+, w, w+, a, a+</code></pre>
</td></tr></table>
<p>Size: ~320B <a href="../src/streams/freopen.c">../src/streams/freopen.c</a> l.7 manpage: <a href="manpages/stdio/fopen.3.rst">freopen</a><br></p>
<a name="fseek"></a><dl>
<dt>
fseek
</dt>
<dd>
<p>
  <em>int fseek(FILE <strong>f, long offset, int whence )</em><br>
 *Defines:</strong> lseek<br>
 <strong>reposition a file-position indicator in a stream</strong>
Size: ~80B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.134 manpage: <a href="manpages/stdio/fseek.3.rst">fseek</a><br>
</p>
</dd>
<dt>
fsetpos
</dt>
<dd>
<p>
  <em>int fsetpos(FILE <strong>f, int pos )</em><br>
 *Defines:</strong> lseek<br>
 <strong>set current file position</strong>
Size: ~78B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.123 manpage: <a href="manpages/stdio/fseek.3.rst">fsetpos</a><br>
</p>
</dd>
<dt>
ftell
</dt>
<dd>
<p>
  <em>long ftell(FILE <strong>f)</em><br>
 *Defines:</strong> lseek<br>
 <strong>return a file offset in a stream</strong>
Size: ~53B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.111 manpage: <a href="manpages/stdio/fseek.3.rst">ftell</a><br>
</p>
</dd>
<dt>
rewind
</dt>
<dd>
<p>
  <em>void rewind( FILE <strong>f )</em><br>
 *Defines:</strong> lseek<br>
 <strong>reset the file position indicator in a stream</strong>
Size: ~58B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.143 manpage: <a href="manpages/stdio/fseek.3.rst">rewind</a><br>
</p>
</dd>
<dt>
setbuf
</dt>
<dd>
<p>
  <em>void setbuf(FILE <strong>stream, char *buf)</em><br>
 *assign buffering to a stream</strong>
</p>
</dd>
</dl>
<a name="setbuf"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>dummy function.
 There is no buffering implemented for the streams yet.</code></pre>
</td></tr></table>
<p>Size: ~32B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.202 manpage: <a href="manpages/stdio/setbuf.3.rst">setbuf</a><br></p>
<a name="setvbuf"></a><dl>
<dt>
setvbuf
</dt>
<dd>
<p>
  <em>int setvbuf(FILE <strong>stream, char *buf, int mode, size_t size)</em><br>
 *assign buffering to a stream</strong>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>dummy function</code></pre>
</td></tr></table>
<p>Size: ~58B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.207 manpage: <a href="manpages/stdio/setbuf.3.rst">setvbuf</a><br></p>
<p>---</p>
<hr>
<h2><a name="_strings"></a>15. strings</h2>
<a name="_strcasecmp"></a><dl>
<dt>
_strcasecmp
</dt>
<dd>
<p>
  <em>int _strcasecmp(const char*c1,const char*c2,int len)</em><br>
 <strong>Defines:</strong> tolower<br>
Size: ~44B <a href="../src/string/strcasecmp.c">../src/string/strcasecmp.c</a> l.5
</p>
</dd>
<dt>
_strcmp
</dt>
<dd>
<p>
  <em>int _strcmp(const char *s1, const char *s2, int n)</em><br>
Size: ~44B <a href="../src/string/strcmp.c">../src/string/strcmp.c</a> l.10
</p>
</dd>
<dt>
sprintf
</dt>
<dd>
<p>
  <em>#define sprintf(str,&#8230;) snprintf( str, mini_buf,  <em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> kill getpid strlen write<br>
 <strong>print formatted output</strong>
</p>
</dd>
</dl>
<a name="sprintf"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>I'm really uncertain about the size arg here, amongst others
 these are just misdefined functions, inhaerent insecure. :/
 If possible, do not use sprintf. Use snprintf instead.</code></pre>
</td></tr></table>
<p><a href="../src/output/sprintf.c">../src/output/sprintf.c</a> l.9 manpage: <a href="manpages/stdio/printf.3.rst">sprintf</a><br></p>
<a name="strcasecmp"></a><dl>
<dt>
strcasecmp
</dt>
<dd>
<p>
  <em>int strcasecmp(const char*c1,const char*c2)</em><br>
<a href="../src/string/strcasecmp.c">../src/string/strcasecmp.c</a> l.26 manpage: <a href="manpages/string/string.3.rst">strcasecmp</a><br>
</p>
</dd>
<dt>
strcat
</dt>
<dd>
<p>
  <em>char <strong>strcat(char *dest, const char *src )</em><br>
 *Defines:</strong> strlen<br>
 <strong>concatenate two strings</strong>
Size: ~126B <a href="../src/string/strcat.c">../src/string/strcat.c</a> l.5 manpage: <a href="manpages/string/string.3.rst">strcat</a><br>
</p>
</dd>
<dt>
strchr
</dt>
<dd>
<p>
  <em>char <strong>strchr(const char *s, int c)</em><br>
 *Defines:</strong> strchrnul<br>
 <strong>string scanning operation</strong>
Size: ~104B <a href="../src/string/strchr.c">../src/string/strchr.c</a> l.6 manpage: <a href="manpages/string/string.3.rst">strchr</a><br>
</p>
</dd>
<dt>
strchrnul
</dt>
<dd>
<p>
  <em>char <strong>strchrnul(const char *s, int c)</em><br>
 *locate character in string</strong>
Size: ~87B <a href="../src/string/strchrnul.c">../src/string/strchrnul.c</a> l.3 manpage: <a href="manpages/string/strchr.3.rst">strchrnul</a><br>
</p>
</dd>
<dt>
strcmp
</dt>
<dd>
<p>
  <em>int strcmp(const char*c1,const char*c2)</em><br>
 <strong>compare two strings</strong>
Size: ~32B <a href="../src/string/strcmp.c">../src/string/strcmp.c</a> l.36 manpage: <a href="manpages/string/string.3.rst">strcmp</a><br>
</p>
</dd>
<dt>
strcpy
</dt>
<dd>
<p>
  <em>char <strong>strcpy(char *dest, const char *src)</em><br>
 *copy a string and return a pointer to the end of the result</strong>
Size: ~84B <a href="../src/string/strcpy.c">../src/string/strcpy.c</a> l.3 manpage: <a href="manpages/string/string.3.rst">strcpy</a><br>
</p>
</dd>
<dt>
strdup
</dt>
<dd>
<p>
  <em>char <strong>strdup(const char *source)</em><br>
 *Defines:</strong> strcpy strlen 0<br>
 <strong>duplicate a specific number of bytes from a string</strong>
Size: ~258B <a href="../src/string/strdup.c">../src/string/strdup.c</a> l.7 manpage: <a href="manpages/string/strdup.3.rst">strdup</a><br>
</p>
</dd>
<dt>
strlen
</dt>
<dd>
<p>
  <em>int strlen(const char*str)</em><br>
 <strong>get length of fixed size string</strong>
</p>
</dd>
</dl>
<a name="strlen"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>return len of str.
 if str points to 0, return 0</code></pre>
</td></tr></table>
<p>Size: ~32B <a href="../src/string/strlen.c">../src/string/strlen.c</a> l.6 manpage: <a href="manpages/string/strlen.3.rst">strlen</a><br></p>
<a name="strncasecmp"></a><dl>
<dt>
strncasecmp
</dt>
<dd>
<p>
  <em>int strncasecmp(const char*c1,const char*c2,int len)</em><br>
 <strong>case-insensitive string comparisons</strong>
<a href="../src/string/strcasecmp.c">../src/string/strcasecmp.c</a> l.34 manpage: <a href="manpages/string/string.3.rst">strncasecmp</a><br>
</p>
</dd>
<dt>
strncmp
</dt>
<dd>
<p>
  <em>int strncmp(const char*c1,const char*c2,int len)</em><br>
 <strong>compare part of two strings</strong>
Size: ~44B <a href="../src/string/strcmp.c">../src/string/strcmp.c</a> l.44 manpage: <a href="manpages/string/string.3.rst">strncmp</a><br>
</p>
</dd>
<dt>
strncpy
</dt>
<dd>
<p>
  <em>char <strong>strncpy(char *dest, const char *src, int n)</em><br>
 *copy fixed length string, returning a pointer to the array end</strong>
</p>
</dd>
</dl>
<a name="strncpy"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>copy max n chars from src to dest,
 write 0's up to src[n] when len of dest &lt; n
 Please note strlcpy (borrowed from freebsd),
 which does the same,
 but doesn't pad dest with 0's.</code></pre>
</td></tr></table>
<p>Size: ~96B <a href="../src/string/strncpy.c">../src/string/strncpy.c</a> l.7 manpage: <a href="manpages/string/string.3.rst">strncpy</a><br></p>
<a name="strrchr"></a><dl>
<dt>
strrchr
</dt>
<dd>
<p>
  <em>char <strong>strrchr(const char *s, int c)</em><br>
 *Defines:</strong> strchrnul<br>
 <strong>string scanning operation</strong>
Size: ~122B <a href="../src/string/strrchr.c">../src/string/strrchr.c</a> l.4 manpage: <a href="manpages/string/string.3.rst">strrchr</a><br>
</p>
</dd>
<dt>
strstr
</dt>
<dd>
<p>
  <em>char* strstr(const char <strong>big, const char *little)</em><br>
 *find a substring</strong>
Size: ~104B <a href="../src/string/strstr.c">../src/string/strstr.c</a> l.3 manpage: <a href="manpages/string/strstr.3.rst">strstr</a><br>
</p>
</dd>
</dl>
<p><a name="strstr"></a>---</p>
<hr>
<h2><a name="_system"></a>16. system</h2>
<a name="chroot"></a><dl>
<dt>
chroot
</dt>
<dd>
<p>
  <em>int chroot( const char <strong>filename)</em><br>
 *change root directory</strong>
Size: ~47B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.155 manpage: <a href="manpages/sys/chroot.2.rst">chroot</a><br>
</p>
</dd>
<dt>
getgid
</dt>
<dd>
<p>
  <em>int DEF_syscall(getgid,0)</em><br>
 <strong>get the real group ID</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.206 manpage: <a href="manpages/sys/getgid.2.rst">getgid</a><br>
</p>
</dd>
<dt>
getuid
</dt>
<dd>
<p>
  <em>int DEF_syscall(getuid,0)</em><br>
 <strong>get a real user ID</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.208 manpage: <a href="manpages/sys/getuid.2.rst">getuid</a><br>
</p>
</dd>
<dt>
ioctl
</dt>
<dd>
<p>
  <em>int volatile  ATTR_OPT("O0") ioctl( int fd, unsigned long int request, &#8230; )</em><br>
 <strong>control a STREAMS device (\fBSTREAMS\fP)</strong>
Size: ~319B <a href="../src/system/ioctl.c">../src/system/ioctl.c</a> l.9 manpage: <a href="manpages/sys/ioctl.2.rst">ioctl</a><br>
</p>
</dd>
<dt>
macro
</dt>
<dd>
<p>
  <em>void  optimization_fence(void*p){}</em><br>
Size: ~32B
</p>
</dd>
<dt>
mknod
</dt>
<dd>
<p>
  <em>int mknod( const char <strong>filename,  umode_t mode,  unsigned dev)</em><br>
 *make directory, special file, or regular file</strong>
Size: ~73B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.259 manpage: <a href="manpages/sys/mknod.2.rst">mknod</a><br>
</p>
</dd>
<dt>
mount
</dt>
<dd>
<p>
  <em>int mount( char <strong>dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)</em><br>
 *mount filesystem</strong>
Size: ~151B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.184 manpage: <a href="manpages/sys/mount.2.rst">mount</a><br>
</p>
</dd>
<dt>
pivot_root
</dt>
<dd>
<p>
  <em>int pivot_root( const char <strong>new_root,  const char *put_old)</em><br>
 *change the root mount</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.156
</p>
</dd>
<dt>
putenv
</dt>
<dd>
<p>
  <em>int putenv( char <strong>string )</em><br>
 *Defines:</strong> environ ret_errno<br>
</p>
</dd>
</dl>
<a name="putenv"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>put a string into the environmental vars
 the supplied string's pointer is put into the environmental array of pointers.
 Subsequent changes of the string therefore will change the environment,
 and the supplied string may not be deallocated.
 Returns:
 - 0 on success,
 - EINVAL: string was 0, didn't contain a '=', some other error</code></pre>
</td></tr></table>
<p><a href="../src/system/putenv.c">../src/system/putenv.c</a> l.10 manpage: <a href="manpages/stdlib/getenv.3.rst">putenv</a><br></p>
<a name="reboot"></a><dl>
<dt>
reboot
</dt>
<dd>
<p>
  <em>int reboot( int magic1,  int magic2,  unsigned int cmd,  void <strong>arg)</em><br>
 *reboot or enable/disable Ctrl-Alt-Del</strong>
Size: ~139B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.182 manpage: <a href="manpages/sys/reboot.2.rst">reboot</a><br>
</p>
</dd>
<dt>
setgid
</dt>
<dd>
<p>
  <em>int setgid( gid_t gid)</em><br>
 <strong>set-group-ID</strong>
Size: ~51B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.161 manpage: <a href="manpages/sys/setuid.2.rst">setgid</a><br>
</p>
</dd>
<dt>
setgroups
</dt>
<dd>
<p>
  <em>int setgroups( int gidsetsize,  gid_t *grouplist)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.199 manpage: <a href="manpages/sys/setgroups.2.rst">setgroups</a><br>
</p>
</dd>
<dt>
setuid
</dt>
<dd>
<p>
  <em>int setuid( uid_t uid)</em><br>
 <strong>set user ID</strong>
Size: ~51B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.162 manpage: <a href="manpages/sys/setuid.2.rst">setuid</a><br>
</p>
</dd>
<dt>
sync
</dt>
<dd>
<p>
  <em>int DEF_syscall(sync,0)</em><br>
 <strong>schedule file system updates</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.128 manpage: <a href="manpages/sys/sync.2.rst">sync</a><br>
</p>
</dd>
<dt>
umount2
</dt>
<dd>
<p>
  <em>int umount2( const char <strong>mountpoint, int flags)</em><br>
 *unmount filesystem</strong>
Size: ~59B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.180
</p>
</dd>
<dt>
uname
</dt>
<dd>
<p>
  <em>int uname(struct new_utsname <strong>name )</em><br>
 *get the name of the current system</strong>
Size: ~41B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.168 manpage: <a href="manpages/gen/uname.3.rst">uname</a><br>
</p>
</dd>
</dl>
<p><a name="uname"></a>---</p>
<hr>
<h2><a name="_terminal"></a>17. terminal</h2>
<a name="grantpt"></a><dl>
<dt>
grantpt
</dt>
<dd>
<p>
  <em>int grantpt(int fd)</em><br>
 <strong>Defines:</strong> fstat getpid ioctl strlen uitodec kill open termio write<br>
 <strong>grant access to the slave pseudo-terminal device</strong>
Size: ~44B <a href="../src/termios/pty.c">../src/termios/pty.c</a> l.49 manpage: <a href="manpages/stdlib/ptsname.3.rst">grantpt</a><br>
</p>
</dd>
<dt>
isatty
</dt>
<dd>
<p>
  <em>int isatty(int fd)</em><br>
 <strong>Defines:</strong> termio ioctl<br>
 <strong>test for a terminal device</strong>
Size: ~325B <a href="../src/termios/isatty.c">../src/termios/isatty.c</a> l.5 manpage: <a href="manpages/gen/ttyname.3.rst">isatty</a><br>
</p>
</dd>
<dt>
nanosleep
</dt>
<dd>
<p>
  <em>int nanosleep( struct timespec <strong>rqtp, struct timespec *rmtp)</em><br>
 *high resolution sleep</strong>
Size: ~47B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.146 manpage: <a href="manpages/sys/nanosleep.2.rst">nanosleep</a><br>
</p>
</dd>
<dt>
posix_openpt
</dt>
<dd>
<p>
  <em>int posix_openpt(int flags)</em><br>
 <strong>Defines:</strong> open termio<br>
 <strong>open a pseudo-terminal device</strong>
Size: ~140B <a href="../src/termios/pty.c">../src/termios/pty.c</a> l.8 manpage: <a href="manpages/sys/posix_openpt.2.rst">posix_openpt</a><br>
</p>
</dd>
<dt>
ptsname
</dt>
<dd>
<p>
  <em>char <strong>ptsname(int fd)</em><br>
 *Defines:</strong> getpid ioctl strlen kill uitodec write open termio<br>
 <strong>get name of the slave pseudo-terminal device</strong>
Size: ~1767B <a href="../src/termios/pty.c">../src/termios/pty.c</a> l.34 manpage: <a href="manpages/stdlib/ptsname.3.rst">ptsname</a><br>
</p>
</dd>
<dt>
ptsname_r
</dt>
<dd>
<p>
  <em>int ptsname_r(int fd, char <strong>buf, size_t len)</em><br>
 *Defines:</strong> ioctl strlen getpid open termio write uitodec kill<br>
 <strong>get the name of the slave pseudoterminal</strong>
Size: ~1748B <a href="../src/termios/pty.c">../src/termios/pty.c</a> l.21
</p>
</dd>
<dt>
tcgetattr
</dt>
<dd>
<p>
  <em>int tcgetattr(int fd, struct termios <strong>io)</em><br>
 *Defines:</strong> termio ioctl<br>
 <strong>get the parameters associated with the terminal</strong>
Size: ~300B <a href="../src/termios/tcgetattr.c">../src/termios/tcgetattr.c</a> l.12 manpage: <a href="manpages/gen/tcsetattr.3.rst">tcgetattr</a><br>
</p>
</dd>
<dt>
tcsetattr
</dt>
<dd>
<p>
  <em>int tcsetattr(int fd, int opt, const struct termios <strong>io)</em><br>
 *Defines:</strong> termio ioctl<br>
 <strong>set the parameters associated with the terminal</strong>
Size: ~316B <a href="../src/termios/tcsetattr.c">../src/termios/tcsetattr.c</a> l.12 manpage: <a href="manpages/gen/tcsetattr.3.rst">tcsetattr</a><br>
</p>
</dd>
<dt>
unlockpt
</dt>
<dd>
<p>
  <em>int unlockpt(int fd)</em><br>
 <strong>Defines:</strong> termio ioctl<br>
 <strong>unlock a pseudo-terminal master/slave pair</strong>
Size: ~325B <a href="../src/termios/pty.c">../src/termios/pty.c</a> l.14 manpage: <a href="manpages/stdlib/ptsname.3.rst">unlockpt</a><br>
</p>
</dd>
<dt>
vhangup
</dt>
<dd>
<p>
  <em>int DEF_syscall(vhangup,0 )</em><br>
 <strong>virtually hangup the current terminal</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.166
</p>
</dd>
</dl>
<p><a name="vhangup"></a>---</p>
<hr>
<h2><a name="_time"></a>18. time</h2>
<a name="getitimer"></a><dl>
<dt>
getitimer
</dt>
<dd>
<p>
  <em>int getitimer( int which,  struct itimerval <strong>value)</em><br>
 *get and set value of interval timer</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.265 manpage: <a href="manpages/sys/getitimer.2.rst">getitimer</a><br>
</p>
</dd>
<dt>
gettimeofday
</dt>
<dd>
<p>
  <em>int gettimeofday( struct timeval <strong>a1, struct timezone *a2)</em><br>
 *get the date and time</strong>
Size: ~47B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.147 manpage: <a href="manpages/sys/gettimeofday.2.rst">gettimeofday</a><br>
</p>
</dd>
<dt>
setitimer
</dt>
<dd>
<p>
  <em>int setitimer( int which,  struct itimerval <strong>value,  struct itimerval *ovalue)</em><br>
 *set the value of an interval timer</strong>
Size: ~56B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.264 manpage: <a href="manpages/sys/getitimer.2.rst">setitimer</a><br>
</p>
</dd>
<dt>
sleep
</dt>
<dd>
<p>
  <em>unsigned int volatile sleep(unsigned int seconds)</em><br>
 <strong>Defines:</strong> nanosleep<br>
 <strong>suspend execution for an interval of time</strong>
</p>
</dd>
</dl>
<a name="sleep"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>nonconformant sleep
 TODO: ignore blocked signals, sigchld</code></pre>
</td></tr></table>
<p>Size: ~123B <a href="../src/process/sleep.c">../src/process/sleep.c</a> l.10 manpage: <a href="manpages/gen/sleep.3.rst">sleep</a><br></p>
<a name="time"></a><dl>
<dt>
time
</dt>
<dd>
<p>
  <em>int time(unsigned int <strong>a1 )</em><br>
 *get time</strong>
Size: ~41B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.277 manpage: <a href="manpages/gen/time.3.rst">time</a><br>
</p>
</dd>
<dt>
usleep
</dt>
<dd>
<p>
  <em>unsigned int volatile usleep(unsigned int useconds)</em><br>
 <strong>Defines:</strong> nanosleep<br>
 <strong>suspend execution for microsecond intervals</strong>
</p>
</dd>
</dl>
<a name="usleep"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>nonconformant usleep.
 Sleep useconds.
 I just hope, noone relies on an exact sleep time.
 which isn't possible without a real time os, anyways.
 When for whatever reason you'd need nanoseconds exact times,
 best shot might be a spinloop, and looking for cpu ticks.

 TODO: ignore blocked signals, sigchld</code></pre>
</td></tr></table>
<p>Size: ~147B <a href="../src/process/sleep.c">../src/process/sleep.c</a> l.31 manpage: <a href="manpages/gen/usleep.3.rst">usleep</a><br></p>
<a name="utime"></a><dl>
<dt>
utime
</dt>
<dd>
<p>
  <em>int utime( const char <strong>filename, struct utimbuf *times)</em><br>
 *set file access and modification times</strong>
Size: ~49B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.203 manpage: <a href="manpages/gen/utime.3.rst">utime</a><br>
</p>
</dd>
</dl>
<p>---</p>
<hr>
<h2><a name="_unsorted"></a>19. unsorted</h2>
<a name="ALIGN"></a><dl>
<dt>
ALIGN
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>macros for alignment.
 They take a number or pointer, and align upwards to 2,4,8,..256
 There are the macros ALIGN_2 ALIGN_4 ALIGN_8 ...,
 and ALIGN_P, which aligns to the size of a pointer. (8 for amd64)</code></pre>
</td></tr></table>
<p><a href="../macros/alignment.h">../macros/alignment.h</a> l.9</p>
<a name="OPTFENCE"></a><dl>
<dt>
OPTFENCE
</dt>
<dd>
<p>
  <em>#ifndef <em>clang</em></em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>prevent gcc to optimize away registers and variables
 the macro OPTFENCE(...) can be invoked with any parameter.
 The parameters will get calculated, even if gcc doesn't recognize
 the use of the parameters, e.g. cause they are needed for an inlined asm syscall.

 The macro translates to an asm jmp and a function call to the function
 opt_fence, which is defined with the attribute "noipa" -
 (the compiler "forgets" the function body, so gcc is forced
 to generate all arguments for the function)
 The generated asm jump hops over the call to the function,
 but this gcc doesn't recognize.

 This generates some overhead,
 (a few (never reached) bytes for setting up the function call, and the jmp)
 but I didn't find any other solution,
 which gcc wouldn't cut for optimizations from time to time.
 (volatile, volatile asm, optimize attributes,
 andsoon have all shown up to be unreliable - sometimes(!)).

 Had some fun debugging these bugs, which naturally showed up only sometimes.
 (Many syscalls also work with scrambled arguments..)
 And, I believe it IS a compiler bug.
 Volatile should be volatile for sure, not only sometimes.
 I mean, why the heck do I write volatile??</code></pre>
</td></tr></table>
<p><a href="../include/syscall.h">../include/syscall.h</a> l.66</p>
<a name="OPTIMIZATIONS"></a><dl>
<dt>
OPTIMIZATIONS
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>enable some optimizations,
 with a slitghtly bigger memory footprint.
 defaults to off
 (yet only calloc is optimized. todo)</code></pre>
</td></tr></table>
<p><a href="../include/config.h">../include/config.h</a> l.33</p>
<a name="_die"></a><dl>
<dt>
_die
</dt>
<dd>
<p>
  <em>void _die()</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>internal implementation of die</code></pre>
</td></tr></table>
<p><a href="../src/process/die.c">../src/process/die.c</a> l.36</p>
<a name="_match"></a><dl>
<dt>
_match
</dt>
<dd>
<p>
  <em>int _match(char *text, const char *re, text_match *st_match)</em><br>
<a href="../src/match/match.c">../src/match/match.c</a> l.96
</p>
</dd>
<dt>
_match_ext2
</dt>
<dd>
<p>
  <em>char* _match_ext2(char *text, char *re, void(*p_matched_cb)(int number, char *pos,int len), int(*p_wildcard_cb)(int number, char *match_char), text_match *st_match)</em><br>
</p>
</dd>
</dl>
<a name="_match_ext2"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>internal implementation of match_ext</code></pre>
</td></tr></table>
<p><a href="../src/match/match_ext2.c">../src/match/match_ext2.c</a> l.326</p>
<a name="accept"></a><dl>
<dt>
accept
</dt>
<dd>
<p>
  <em>int accept( int fd,  struct sockaddr *upeersockaddr,  int *upeeraddrlen)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.247 manpage: <a href="manpages/sys/accept.2.rst">accept</a><br>
</p>
</dd>
<dt>
assert
</dt>
<dd>
<p>
  __<br>
 <strong>Defines:</strong> getpid memcpy write rt_sigaction kill<br>
<a href="../macros/assert.h">../macros/assert.h</a> l.4
</p>
</dd>
<dt>
bind
</dt>
<dd>
<p>
  <em>int bind( int fd,  struct sockaddr *umyaddr,  int addrlen)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.241 manpage: <a href="manpages/sys/bind.2.rst">bind</a><br>
</p>
</dd>
<dt>
bsd_cksum
</dt>
<dd>
<p>
  <em>unsigned int bsd_cksum( const char* p, unsigned int len )</em><br>
</p>
</dd>
</dl>
<a name="bsd_cksum"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>bsd checksum</code></pre>
</td></tr></table>
<p><a href="../src/file/cksum.c">../src/file/cksum.c</a> l.31</p>
<a name="bsd_cksumblock"></a><dl>
<dt>
bsd_cksumblock
</dt>
<dd>
<p>
  <em>unsigned int bsd_cksumblock( unsigned int hash, const char* p, unsigned int len )</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>bsd checksum, called by bsd_cksum,
 with initial hash value</code></pre>
</td></tr></table>
<p><a href="../src/file/cksum.c">../src/file/cksum.c</a> l.20</p>
<a name="bsd_definitions"></a><dl>
<dt>
bsd_definitions
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>definitions, found at BSD
 enable with mini_bsd_definitions</code></pre>
</td></tr></table>
<p><a href="../include/bsd_definitions.h">../include/bsd_definitions.h</a> l.5</p>
<a name="bsd_timespec"></a><dl>
<dt>
bsd_timespec
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>timespec functions, copied from freebsd</code></pre>
</td></tr></table>
<p><a href="../include/bsd_timespec.h">../include/bsd_timespec.h</a> l.5</p>
<a name="bsearch"></a><dl>
<dt>
bsearch
</dt>
<dd>
<p>
  <em>void* bsearch(const void *key, const void *base0, size_t nmemb, size_t size, int (*compar)(const void *, const void *))</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>search for an element
 code is copied from netbsd</code></pre>
</td></tr></table>
<p><a href="../src/sort/bsearch.c">../src/sort/bsearch.c</a> l.55 manpage: <a href="manpages/stdlib/bsearch.3.rst">bsearch</a><br></p>
<a name="calloc"></a><dl>
<dt>
calloc
</dt>
<dd>
<p>
  <em>void* calloc(int nmemb, int size)</em><br>
<a href="../src/memory/calloc.c">../src/memory/calloc.c</a> l.2 manpage: <a href="manpages/stdlib/memory.3.rst">calloc</a><br>
</p>
</dd>
<dt>
cfmakeraw
</dt>
<dd>
<p>
  <em>void cfmakeraw(struct termios <strong>tp)</em><br>
 *Defines:</strong> termio<br>
<a href="../src/termios/cfmakeraw.c">../src/termios/cfmakeraw.c</a> l.3 manpage: <a href="manpages/gen/tcsetattr.3.rst">cfmakeraw</a><br>
</p>
</dd>
<dt>
config
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<a name="config"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>configuration settings, to be compiled statically.
 System specific paths, maximums, etc go here.
 Other values are within globaldefs.h;
 architecture specific values are within the folder headers.</code></pre>
</td></tr></table>
<p><a href="../include/config.h">../include/config.h</a> l.6</p>
<a name="ctype_functions"></a><dl>
<dt>
ctype_functions
</dt>
<dd>
<p>
  <em>#ifdef mini_ctype_functions</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>create functions instead of macros for isalpha, .., isprint</code></pre>
</td></tr></table>
<p><a href="../include/ctype.h">../include/ctype.h</a> l.22</p>
<a name="def"></a><dl>
<dt>
def
</dt>
<dd>
<p>
  <em>#define SETOPT_short( opts, option ) (</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>Set a option flag(s) (bit(s))  manually.
                param options: e.g. just a, or ( a+h+l) to check for several flags at once</code></pre>
</td></tr></table>
<p><a href="../macros/getoptm.h">../macros/getoptm.h</a> l.52</p>
<a name="die"></a><dl>
<dt>
die
</dt>
<dd>
<p>
  <em>#define die(errnum,msg) {ewritesl(msg);exit_errno(errnum);}</em><br>
 <strong>Defines:</strong> write errno_str execve exit<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write msg to stderr and exit with failure
 if errno is defined and set, /bin/errno is executed to give a verbose error
 message
 if errno is either not defined or not set,
 exit with -1</code></pre>
</td></tr></table>
<p><a href="../src/process/die.c">../src/process/die.c</a> l.11</p>
<a name="die_if"></a><dl>
<dt>
die_if
</dt>
<dd>
<p>
  <em>#define die_if( when, errnum, msg ) if( when ) die( errnum, msg )</em><br>
 <strong>Defines:</strong> exit execve errno_str write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>when arg1 is true, write msg to stderr and exit with failure
 if errno is defined and set, /bin/errno is executed to give a verbose error
 message
 if errno is either not defined or not set,
 exit with -1</code></pre>
</td></tr></table>
<p><a href="../src/process/die.c">../src/process/die.c</a> l.59</p>
<a name="dief"></a><dl>
<dt>
dief
</dt>
<dd>
<p>
  <em>#define dief(errnum,fmt,&#8230;) {fprintf(stderr,fmt,<em>VA_ARGS</em>);exit_errno(errnum);}</em><br>
 <strong>Defines:</strong> errno_str write exit fileno execve kill globals strlen getpid<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write fmt andargs via fprintf to stderr and exit with failure
 if errno is defined and set, /bin/errno is executed to give a verbose error
 message
 if errno is either not defined or not set,
 exit with -1</code></pre>
</td></tr></table>
<p><a href="../src/process/die.c">../src/process/die.c</a> l.20</p>
<a name="dief_if"></a><dl>
<dt>
dief_if
</dt>
<dd>
<p>
  <em>#define dief_if( when, errnum, fmt,&#8230; ) if( when ) dief( errnum, fmt, <em>VA_ARGS</em> )</em><br>
 <strong>Defines:</strong> write errno_str execve exit<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>when arg1 is true, vall dief(errnum,fmt)
 if errno is defined and set, /bin/errno is executed to give a verbose error
 message
 if errno is either not defined or not set,
 exit with -1</code></pre>
</td></tr></table>
<p><a href="../src/process/die.c">../src/process/die.c</a> l.69</p>
<a name="dies"></a><dl>
<dt>
dies
</dt>
<dd>
<p>
  <em>#define dies(errnum,&#8230;) {eprintsl(<em>VA_ARGS</em>);exit_errno(errnum);}</em><br>
 <strong>Defines:</strong> execve exit write errno_str<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write variable string list to stderr and exit with failure
 if errno is defined and set, /bin/errno is executed to give a verbose error
 message
 if errno is either not defined or not set,
 exit with -1</code></pre>
</td></tr></table>
<p><a href="../src/process/die.c">../src/process/die.c</a> l.30</p>
<a name="dies_if"></a><dl>
<dt>
dies_if
</dt>
<dd>
<p>
  <em>#define dies_if( when, errnum, &#8230; ) if( when ) dies( errnum, <em>VA_ARGS</em> )</em><br>
 <strong>Defines:</strong> write errno_str execve exit<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>when arg1 is true, vall dies(errnum, ... )
 if errno is defined and set, /bin/errno is executed to give a verbose error
 message
 if errno is either not defined or not set,
 exit with -1</code></pre>
</td></tr></table>
<p><a href="../src/process/die.c">../src/process/die.c</a> l.80</p>
<a name="dirbuf_malloc"></a><dl>
<dt>
dirbuf_malloc
</dt>
<dd>
<p>
  <em>#ifndef mini_dirbuf_malloc</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>which malloc to use for allocating the dir handles
 malloc : use malloc, therefore the minibuf
 malloc_brk : use malloc_brk
 defaults to malloc</code></pre>
</td></tr></table>
<p><a href="../include/dirent.h">../include/dirent.h</a> l.31</p>
<a name="eprintf"></a><dl>
<dt>
eprintf
</dt>
<dd>
<p>
  <em>#define eprintf(fmt,&#8230;) fprintf(stderr, fmt, <em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> write strlen fileno<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write fmt and arguments to stderr.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.133</p>
<a name="err"></a><dl>
<dt>
err
</dt>
<dd>
<p>
  <em>#define err( status, fmt &#8230; ) { fprintf(stderr,fmt ); fprints(stderr,":",strerror(errno)); exit(status); }</em><br>
 <strong>Defines:</strong> errno fileno exit kill strerror write globals getpid strlen<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>print an error message to stderr,
 print an error message dependend on errno ( strerror(errno) ),
 exit with status</code></pre>
</td></tr></table>
<p><a href="../src/process/error.h">../src/process/error.h</a> l.20 manpage: <a href="manpages/gen/err.3.rst">err</a><br></p>
<a name="error"></a><dl>
<dt>
error
</dt>
<dd>
<p>
  <em>#define error( status, errnum, fmt &#8230; ) { fprintf(stderr,fmt ); if (errnum) fprints(stderr,":",strerror(errnum)); if ( status ) exit(status); }</em><br>
 <strong>Defines:</strong> strerror kill exit fileno write getpid strlen globals<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>print an error message to stderr
 when errnum is not 0, print either the number,
  or a verbose error message (with strerror),
  when mini_verbose_errstr is defined.
  (verbose error messages add aboyut 4kB)

 when status is non null, terminate with status</code></pre>
</td></tr></table>
<p><a href="../src/process/error.h">../src/process/error.h</a> l.13</p>
<a name="errx"></a><dl>
<dt>
errx
</dt>
<dd>
<p>
  <em>#define errx( status, fmt &#8230; ) { fprintf(stderr,fmt); exit(status); }</em><br>
 <strong>Defines:</strong> fileno exit kill write globals strlen getpid<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>print an error message to stderr,
 exit with status</code></pre>
</td></tr></table>
<p><a href="../src/process/error.h">../src/process/error.h</a> l.27 manpage: <a href="manpages/gen/err.3.rst">errx</a><br></p>
<a name="ether_ntoa"></a><dl>
<dt>
ether_ntoa
</dt>
<dd>
<p>
  <em>char* ether_ntoa( const struct ether_addr <strong>e )</em><br>
 *Defines:</strong> network<br>
<a href="../src/network/ether_ntoa.c">../src/network/ether_ntoa.c</a> l.3 manpage: <a href="manpages/net/ethers.3.rst">ether_ntoa</a><br>
</p>
</dd>
<dt>
ewritesl
</dt>
<dd>
<p>
  <em>#define ewritesl(str) write(STDERR_FILENO,str"\n",sizeof(str)+1)</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<a name="ewritesl"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write the constant str to stderr, followed by a newline.
 Computes length with sizeof(str) at compile time.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.100</p>
<a name="fgetsn"></a><dl>
<dt>
fgetsn
</dt>
<dd>
<p>
  <em>int fgetsn(char <strong>buf, int size, FILE</strong> F)</em><br>
 <strong>Defines:</strong> read fileno<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>get a line like fgets, but return the len of the read string.</code></pre>
</td></tr></table>
<p><a href="../src/streams/fgetsn.c">../src/streams/fgetsn.c</a> l.4</p>
<a name="fgetsp"></a><dl>
<dt>
fgetsp
</dt>
<dd>
<p>
  <em>char* fgetsp(char <strong>buf, int size, FILE</strong> F)</em><br>
 <strong>Defines:</strong> read fileno<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>read a line from F into buf with max chars size.
 Return a pointer to the terminating '0' byte.
 A terminating linebreak is not written to buf.</code></pre>
</td></tr></table>
<p><a href="../src/streams/fgetsp.c">../src/streams/fgetsp.c</a> l.7</p>
<a name="fgetud"></a><dl>
<dt>
fgetud
</dt>
<dd>
<p>
  <em>unsigned int fgetud(FILE* F)</em><br>
 <strong>Defines:</strong> fileno read<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>read an unsigned integer from the stream F
 reads all digits until a nondigit is read.</code></pre>
</td></tr></table>
<p><a href="../src/streams/fgetud.c">../src/streams/fgetud.c</a> l.5</p>
<a name="fgetul"></a><dl>
<dt>
fgetul
</dt>
<dd>
<p>
  <em>unsigned long int fgetul(FILE* F)</em><br>
 <strong>Defines:</strong> read fileno<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>read an unsigned long integer from the stream F
 reads all digits until a nondigit is read.</code></pre>
</td></tr></table>
<p><a href="../src/streams/fgetul.c">../src/streams/fgetul.c</a> l.5</p>
<a name="flock"></a><dl>
<dt>
flock
</dt>
<dd>
<p>
  <em>int flock( unsigned int fd,  unsigned int cmd)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.130 manpage: <a href="manpages/sys/flock.2.rst">flock</a><br>
</p>
</dd>
<dt>
fwritesl
</dt>
<dd>
<p>
  <em>#define fwritesl(fd,str) write(fd,str"\n",sizeof(str)+1)</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<a name="fwritesl"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write the constant str to fd,followed by a newline.
 Computes length with sizeof(str) at compile time.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.114</p>
<a name="getegid"></a><dl>
<dt>
getegid
</dt>
<dd>
<p>
  <em>int DEF_syscall(getegid,0)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.215 manpage: <a href="manpages/sys/getgid.2.rst">getegid</a><br>
</p>
</dd>
<dt>
geteuid
</dt>
<dd>
<p>
  <em>int DEF_syscall(geteuid,0)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.213 manpage: <a href="manpages/sys/getuid.2.rst">geteuid</a><br>
</p>
</dd>
<dt>
getgrouplist
</dt>
<dd>
<p>
  <em>int getgrouplist(const char* user, gid_t group, gid_t <strong>groups, int *ngroups)</em><br>
 *Defines:</strong> token_i mmap grent passwdfile_open setgrent userdb open write setpwent pwent token_s<br>
</p>
</dd>
</dl>
<a name="getgrouplist"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>needs rewrite.
 now nonstandard.</code></pre>
</td></tr></table>
<p><a href="../src/userdb/getgrouplist.c">../src/userdb/getgrouplist.c</a> l.5 manpage: <a href="manpages/gen/getgrouplist.3.rst">getgrouplist</a><br></p>
<a name="getgroups"></a><dl>
<dt>
getgroups
</dt>
<dd>
<p>
  <em>int getgroups(int maxgroups, int <strong>list)</em><br>
 *Defines:</strong> token_i mmap userdb passwdfile_open grent setgrent pwent write open setpwent getuid token_s<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>get the groups of the calling process
 does not necessarily contain the primary group,
 which is given in the passwd entry.
 This function calls internally setgrent() and getgrent();
 therefore any iteration with getgrent will be resetted.</code></pre>
</td></tr></table>
<p><a href="../src/userdb/getgroups.c">../src/userdb/getgroups.c</a> l.8 manpage: <a href="manpages/sys/getgroups.2.rst">getgroups</a><br></p>
<a name="gethostname"></a><dl>
<dt>
gethostname
</dt>
<dd>
<p>
  <em>int gethostname(char <strong>name,int len)</em><br>
 *Defines:</strong> network uname<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>gethostname</code></pre>
</td></tr></table>
<p><a href="../src/network/gethostname.c">../src/network/gethostname.c</a> l.4 manpage: <a href="manpages/gen/gethostname.3.rst">gethostname</a><br></p>
<a name="getresuid"></a><dl>
<dt>
getresuid
</dt>
<dd>
<p>
  <em>int getresuid( uid_t *ruid,  uid_t *euid,  uid_t *suid)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.210 manpage: <a href="manpages/sys/setresuid.2.rst">getresuid</a><br>
</p>
</dd>
<dt>
getrlimit
</dt>
<dd>
<p>
  <em>int getrlimit( unsigned int resource,  struct rlimit *rlim)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.231 manpage: <a href="manpages/sys/getrlimit.2.rst">getrlimit</a><br>
</p>
</dd>
<dt>
getrusage
</dt>
<dd>
<p>
  <em>int getrusage( int who,  struct rusage *ru)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.142 manpage: <a href="manpages/sys/getrusage.2.rst">getrusage</a><br>
</p>
</dd>
<dt>
getsid
</dt>
<dd>
<p>
  <em>int getsid( pid_t pid)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.164 manpage: <a href="manpages/sys/getsid.2.rst">getsid</a><br>
</p>
</dd>
<dt>
getsockopt
</dt>
<dd>
<p>
  <em>int getsockopt( int fd,  int level,  int optname,  char *optval,  int *optlen)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.245 manpage: <a href="manpages/sys/getsockopt.2.rst">getsockopt</a><br>
</p>
</dd>
<dt>
getusergroups
</dt>
<dd>
<p>
  <em>int getusergroups(const char* user, int maxgroups, int <strong>list)</em><br>
 *Defines:</strong> token_s pwent setpwent open write userdb setgrent grent passwdfile_open mmap token_i<br>
</p>
</dd>
</dl>
<a name="getusergroups"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>get the supplementary groups for the user uid.
 does not necessarily contain the primary group,
 which is given in the passwd entry.
 This function calls internally setgrent() and getgrent();
 therefore any iteration with getgrent will be resetted.</code></pre>
</td></tr></table>
<p><a href="../src/userdb/getusergroups.c">../src/userdb/getusergroups.c</a> l.8</p>
<a name="group_printf"></a><dl>
<dt>
group_printf
</dt>
<dd>
<p>
  <em>//</em><br>
 <strong>Defines:</strong> uitodec uitoHEX getpid itooct globals ultodec uitohex atoi write kill fileno strlen<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>printf, eprintf, fprintf, itodec, ltodec, itohex, anprintf, sprintf (conversions %d %l %x %ud %ul %ux ),</code></pre>
</td></tr></table>
<p><a href="../macros/defgroups.h">../macros/defgroups.h</a> l.29</p>
<a name="htonl"></a><dl>
<dt>
htonl
</dt>
<dd>
<p>
  <em>uint32_t htonl(uint32_t i)</em><br>
 <strong>Defines:</strong> network<br>
<a href="../src/network/htonl.c">../src/network/htonl.c</a> l.5 manpage: <a href="manpages/net/byteorder.3.rst">htonl</a><br>
</p>
</dd>
<dt>
htons
</dt>
<dd>
<p>
  <em>uint16_t htons(uint16_t i)</em><br>
 <strong>Defines:</strong> network<br>
<a href="../src/network/htons.c">../src/network/htons.c</a> l.3 manpage: <a href="manpages/net/byteorder.3.rst">htons</a><br>
</p>
</dd>
<dt>
inet_aton
</dt>
<dd>
<p>
  <em>int inet_aton(const char* s, struct in_addr <strong>addr)</em><br>
 *Defines:</strong> network<br>
<a href="../src/network/inet_aton.c">../src/network/inet_aton.c</a> l.3 manpage: <a href="manpages/net/inet.3.rst">inet_aton</a><br>
</p>
</dd>
<dt>
inet_ntoa
</dt>
<dd>
<p>
  <em>char* inet_ntoa( struct in_addr in)</em><br>
 <strong>Defines:</strong> network<br>
</p>
</dd>
</dl>
<a name="inet_ntoa"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>convert a address
 This returns a pointer to a string in the globals,
 therefore the routine isn't reentrant.
 (whoever thought this might be a good idea..)</code></pre>
</td></tr></table>
<p><a href="../src/network/inet_ntoa.c">../src/network/inet_ntoa.c</a> l.7 manpage: <a href="manpages/net/inet.3.rst">inet_ntoa</a><br></p>
<a name="initgroups"></a><dl>
<dt>
initgroups
</dt>
<dd>
<p>
  <em>int initgroups(const char* user, gid_t group)</em><br>
<a href="../src/userdb/initgroups.c">../src/userdb/initgroups.c</a> l.2 manpage: <a href="manpages/gen/initgroups.3.rst">initgroups</a><br>
</p>
</dd>
<dt>
killpg
</dt>
<dd>
<p>
  <em>int killpg( int pid, int signal )</em><br>
<a href="../src/process/killpg.c">../src/process/killpg.c</a> l.2 manpage: <a href="manpages/compat-43/killpg.2.rst">killpg</a><br>
</p>
</dd>
<dt>
listen
</dt>
<dd>
<p>
  <em>int listen( int fd,  int backlog)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.248 manpage: <a href="manpages/sys/listen.2.rst">listen</a><br>
</p>
</dd>
<dt>
locale_dummies
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<a name="locale_dummies"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>several dummy definitions,
 mostly locale related.
 (locales are not the target of minilib,
 so define mini_dummies to have code relying on locales
 running)
 Quite often some code does only checking for locales,
 but doesn't rely on them.</code></pre>
</td></tr></table>
<p><a href="../include/dummies.h">../include/dummies.h</a> l.10</p>
<a name="lstat"></a><dl>
<dt>
lstat
</dt>
<dd>
<p>
  <em>int lstat(const char* filename,struct stat* statbuf)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.113 manpage: <a href="manpages/sys/stat.2.rst">lstat</a><br>
</p>
</dd>
<dt>
match_ext
</dt>
<dd>
<p>
  <em>int match_ext(char *text, const char *re, void(*p_match)(int number, char *pos,int len, void *userdata), int(*p_match_char)(int number, char *match_char, void *userdata), tmatch_ext *st_match, void *userdata)</em><br>
</p>
</dd>
</dl>
<a name="match_ext"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>text matching engine

 This is somewhere between a fully fledged expression machine,
 and a simplicistic solution.
 Consciusly named 'text matching', since the inherent logic
 is quite different to a regular expression machine.

 The engine matches from left to right,
 backtracking is done as less as possible.
 Since the matching is nongreedy in general,
 many tries can be spared. Opposed to another route,
 where most patterns are per default greedy, and therfore
 not the first matching next char is seeked for, but the first
 solution while matching the most chars.
 (I do not want to make this a hard statement, and it
 depends onto each pattern. But it is the way, the solution
 of the pattern is searched for, in most patterns.)
 This shows up in the logic of the patterns, which is more natural to me.

 It is a compromise between performance, size
 and capabilities.
 The logic is different of a "regular" regular expression
 machine, but has advantages (and disadvantages).
 I'd say, the main advantage is the easiness of adding callbacks,
 and defining your own matching/logic within these.
 Performance might be better as well overall,
 but this depends also on the expressions.

 A few nonextensive benchmarks show,
 this engine is a bit faster than perl's regular expression machine,
 slower than gnu grep (around factor2), and has the same speed as sed.
 This might however vary with each usecase.
 In favor of codesize I'm not going to optimize match_ext,
 but there would be several possibilities, if you'd need a faster engine.
 (Albite I'd like to emphasise, sed (and match_ext), also perl, are quite fast.
 About 10 times faster than most expression engines.)

 matches:

 * for every count of any char
 + for 1 or more chars
 ? for 1 char
 # for space or end of text (0)
 $ match end of text

 backslash: escape *,?,%,$,!,+,#,&amp; and backslash itself.
 !: invert the matching of the next character or character class
 ,: separator. e.g. %,1 matches like ?*1.
   ( without the commata, the '1' would be part of the % match)


 predefined character classes:
 \d - digit
 \D - nondigit
 \s - space
 \S - nonspace
 \w - word character ( defined as ascii 32-126,160-255 )
 \W - nonword character ( defined as ascii 0-31,127-159 )


 [xyz]: character classes, here x,y or z
   the characters are matched literally, also \,*,?,+,..
   it is not possible to match the closing bracket (])
   within a character class

 {nX}: counted match
  Match n times X.
  For X, all expressions are allowed.
  If you need to match a number at the first char of 'X',
  separate X by a commata. E.g. {5,0} matches 5 times '0'.

 %[1]..%[9]: matches like a '+',
  and calls the callback supplied as 3rd argument (when not null).
  the number past the %, e.g. %1, is optional,
  p_match will be callen with this number
  as first parameter.
  When not supplied, p_matched will be callen with
  the parameter 'number' set to 0.

  The matching is 'nongreedy'.
  It is possible to rewrite the string to match
  from within the p_matched callback.
  This will not have an effect onto the current matching,
  even if text is e.g. deleted by writing 0's.
  The matched positions are called in reverse order.
  (The last matched % in the regex calls p_match first,
  the first % in the regex from the left will be callen last)

 supply 0 for p_matched, when you do not need to extract matches.
 This will treat % in the regex like a *,
 a following digit (0..9) in the regex is ignored.
 if the 5th argument, a pointer to a tmatch_ext struct,
 is supplied, it will be filled with the first match.
 (counting from left)


 &amp;[1] .. &amp;[9]
  "match" like a '?' and call p_match_char
  p_match_char has to return either RE_MATCH, RE_NOMATCH, RE_MATCHEND
  or a number of the count of chars, which have been matched.

  Therefore it is possible to e.g. rule your own
  character classes, defined at runtime,
  or do further tricks like changing the matched chars,
  match several chars, andsoon.
  When returning RE_NOMATCH,
  it is possible, the p_match and p_match_char callbacks are callen several times,
  but with different pos or len parameters.

  The matching works straight from left to right.
  So, a "*&amp;*" will call the callback &amp; for the first char.
  When returning RE_NOMATCH, the second char will be matched.
  Until either RE_MATCH is returned from the callback,
  or the last char has been matched.

  Matching several characters is also posssible from within the callback,
  the position within the text will be incremented by that number,
  you return from the callback.

  When returning RE_MATCHEND from the callback,
  the whole regular expression is aborted, and returns with matched;
  no matter, if there are chars left in the expression.


  The difference between % and &amp; is the logic.
  % matches nongreedy, and has to check therefore the right side of the star
  for its matching.
  Possibly this has to be repeated, when following chars do not match.

  &amp; is matched straight from left to right.
  Whatever number you return, the textpointer will be incremented by that value.
  However, a &amp; isn't expanded on it's own. ( what a % is ).
  e.g. "x%x" will match 'aa' in xaax, x&amp;x will match the whole expression
  only, when you return '2' from the callback.

  Performancewise, matching with &amp; is faster,
  since the % has on its right side to be matched
  with recursing calls of match_ext.

 When using closures for the callbacks, you will possibly have to
 enable an executable stack for the trampoline code
 of gcc. Here, gcc complains about that.
 For setting this bit, have a look into the ldscripts in the folder
 with the same name.

 supply 0 for p_match_char, when you don't need it.
 This will treat &amp; in the regex like ?,
 and match a following digit (0..9) in the text,
 a following digit (0..9) in the regex is ignored.

 -----
 In general, you have to somehow invert the logic of regular expressions
 when using match_ext.
 e.g. when matching the parameter 'runlevel=default' at the kernel's
 commandline, a working regular expression would be
 "runlevel=(\S*)". This could be written here as "*runlevel=%#".
 For matching e.g. numbers, you'd most possibly best of
 with writing your own &amp; callback.

 returns: 1 on match, 0 on no match
 ( RE_MATCH / RE_NOMATCH )

 if the pointer (argument 5) st_match is nonnull,
 the supplied struct tmatch_ext will be set to the first matching '%' location;
 if there is no match, tmatch_ext.len will be set to 0.
 The struct is defined as:
 typedef struct _tmatch_ext { char* pos; int len; } tmatch_ext;


 (memo) When the regex ist defined within C/cpp source code,
 a backslash has to be defined as double backslash.

 (note) - be careful when negating a following *, or ?.
  somehow - it is logical, but seems to me I overshoot a bit,
  tragically hit my own foot, and stumbled into a logical paradox.

  Negating EVERYTHING translates to true.
  However, since truth is negated as well, there's a problem,
  cause it's now 'false', but 'false' is true. This is very close
  to proving 42 is the answer. What is the escape velocity
  in km/s out of the solar system, btw.

  (I'm not kidding here. Just don't do a regex with !* or !?..
  And, please, do not ask me what is going to happen when the impossible
  gets possibilized. I have to point at the according sentences of the BSD license;//  there is NO WARRANTY for CONSEQUENTIAL DAMAGE, LOSS OF PROFIT, etc pp.)

  A "!+" will translate into nongreedy matching of any char, however;
  "%!+" will match with % everything but the last char;
  while "%+" matches with % only the first char.
  !+ basically sets the greedyness of the left * or % higher.</code></pre>
</td></tr></table>
<p><a href="../src/match/match_ext.c">../src/match/match_ext.c</a> l.193</p>
<a name="match_ext2"></a><dl>
<dt>
match_ext2
</dt>
<dd>
<p>
  <em>int match_ext2(char *text, char *re, void(*p_matched_cb)(int number, char *pos,int len), int(*p_wildcard_cb)(int number, char *match_char),text_match *st_match)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>text matching engine

 WORK IN PROGRESS, please use ext_match
 Atm, please nested brackets are featureful.
 nesting {} within () seems to work.
 Nesting round brackets within {} gives sometimes
 trouble, when wildcards are used within the brackets.
 I'm leaving this at it is for now.
 Possibly I'm going to hardcode an error message for nested brackets,
 or nested brackets with wildcards.

 This is somewhere between a fully fledged expression machine,
 and a simplicistic solution.
 Consciusly named 'text matching', since the inherent logic
 is quite different to a regular expression machine;
 "natural expressions" might fit better for the name.

 The engine matches from left to right,
 backtracking is done as less as possible.
 Since the matching is nongreedy in general,
 many tries can be spared. Opposed to another route,
 where most patterns are per default greedy, and therfore
 not the first matching next char is seeked for, but the first
 solution while matching the most chars.
 (I do not want to make this a hard statement, and it
 depends onto each pattern. But it is the way, the solution
 of the pattern is searched for, in most patterns.)
 This shows up in the logic of the patterns, which is more natural to me.
 Your mileage might vary.


 It is a compromise between performance, size
 and capabilities.
 The logic is different of a "regular" regular expression
 machine, but has advantages (and disadvantages).
 I'd say, the main advantage is the easiness of adding callbacks,
 and defining your own matching/logic within these.
 Performance might be better as well overall,
 but this depends on the expressions and usecases as well.

 Yet I for myself have to get a grip of the possibilities of this engine.
 However, I have the feeling, the logic is much more natural.
 With regular regexes you always have to think kind of 'backwards',
 e.g., match ".*" -&gt; match "." (any char) x times.
 gets to a simple "*"
 or, to match all group and user id's of /etc/passwd,
 a regular expression would be: "(\d*):(\d*)"
 This is here: "*(\d*):(\d*)*"
 The content in the brackets looks the same,
 but it's matched quite different.
 The regular expression (the first) matches x times \d, for x&gt;=0.
 In the second expressin, the ext_match expression,
 the first digit is matched, and then nongreedy any chars, until
 the first occurence of ':'.
 It is another logic. Whether it suits you, you have to decide.

 The callbacks have shown up to be a mighty tool, while
 at the same time having a good performance.


 A few nonextensive benchmarks show,
 this engine is a bit faster than perl's regular expression machine,
 slower than gnu grep (around factor2), and has the same speed as sed.
 This might vary with each usecase, but the callbacks for extracting matches
 have some advantage, as well as the strict left to right and nongreedy parsing.

 In favor of codesize I'm not going to optimize ext_match,
 but there would be several possibilities, if you'd need a faster engine.
 (Albite I'd like to emphasise, sed (and ext_match), also perl, are quite fast.
 About 5 to 10 times faster than most expression engines.)

 matches:

 * for every count of any char
 + for 1 or more chars
 ? for 1 char
 # for space, end of text (\0), linebreak, tab ( \t \n \f \r \v )
 @ matches the beginning of the text or endofline (\n)
 $ match end of text (\0) or linebreak

 backslash: escape *,?,%,@,$,!,+,#,&amp; and backslash itself.
 !: invert the matching of the next character or character class
 ,: separator. e.g. %,1 matches like ?*1.
   ( without the commata, the '1' would be part of the % match)


 predefined character classes:
 \d - digit
 \D - nondigit
 \s - space
 \S - nonspace
 \w - word character ( defined as ascii 32-126,160-255 )
 \W - nonword character ( defined as ascii 0-31,127-159 )
 \x - hexadecimal digit (0-9,a-f,A-F)


 [xyz]: character classes, here x,y or z
   the characters are matched literally, also \,*,?,+,..
   it is not possible to match the closing bracket (])
   within a character class

 {nX}: counted match
  Match n times X.
  For X, all expressions are allowed.
  If you need to match a number at the first char of 'X',
  separate X by a commata. E.g. {5,0} matches 5 times '0'.
  n can be a number, * or +.
  ('*' matches 0 or more, '+' 1 or more times)

 (X): match the subexpression X. atm, no nesting of round () and {} brackets allowed

 %[1]..%[9]: matches like a '+',
  and calls the callback supplied as 3rd argument (when not null).
  the number past the %, e.g. %1, is optional,
  p_matched_cb will be callen with this number
  as first parameter.
  When not supplied, p_matched_cb will be callen with
  the parameter 'number' set to 0.

  The matching is 'nongreedy'.
  It is possible to rewrite the string to match
  from within the p_matched_cb callback.
  This will not have an effect onto the current matching,
  even if text is e.g. deleted by writing 0's.

  The matched positions are called in reverse order.

  (The last matched % in the regex calls p_matched_cb first,
  the first % in the regex from the left will be callen last)
  / The regex is first matched; when the regex has matched,
  the %'s are filled/ the callbacks executed.
  (x) bracketed patterns are matched the same way.

  (Not like &amp;, which callbacks are invoked, while matching)

 supply 0 for p_matched_cb, when you do not need to extract matches.
 This will treat % in the regex like a *,
 a following digit (0..9) in the regex is ignored.
 if the 5th argument, a pointer to a text_match struct,
 is supplied, it will be filled with the first match.
 (counting from left)


 &amp;[1] .. &amp;[9]
  "match" like a '?' and call p_wildcard_cb
  p_wildcard_cb has to return either RE_MATCH, RE_NOMATCH, RE_MATCHEND
  or the number of the count of chars, which have been matched.

  Therefore it is possible to e.g. rule your own
  character classes, defined at runtime,
  or do further tricks like changing the matched chars,
  match several chars, andsoon.
  When returning RE_NOMATCH,
  it is possible, the p_wildcard_cb callback is callen several times,
  but with different pos or len parameters, since p_wildcard_cb is
  invoked while matching.

  The matching works straight from left to right.
  So, a "*&amp;*" will call the callback &amp; for the first char.
  When returning RE_NOMATCH, the second char will be tried to match.
  Until either RE_MATCH is returned from the callback,
  or the last char of the text has been tried to match.

  Matching several characters is also posssible from within the callback,
  the position within the text will be incremented by that number,
  you return from the callback.

  When returning RE_MATCHEND from the callback,
  the whole expression is aborted, and returns with matched;
  no matter, if there are chars left in the expression.


  The difference between % and &amp; is the logic.
  % matches nongreedy, and has to check therefore the right side of the star
  for its matching.
  Possibly this has to be repeated, when following chars do not match.

  &amp; is matched straight from left to right.
  Whatever number you return, the textpointer will be incremented by that value.
  However, a &amp; isn't expanded on it's own. ( what a % is ).
  e.g. "x%x" will match 'aa' in xaax, x&amp;x will match the whole expression
  only, when you return '2' from the callback.

  Performancewise, matching with &amp; is faster,
  since the % has on its right side to be matched
  with recursing calls of ext_match.

 When using closures for the callbacks, you will possibly have to
 enable an executable stack for the trampoline code
 of gcc. Here, gcc complains about that.
 For setting this bit, please have a look into the ldscripts in the folder
 with the same name.

 supply 0 for p_wildcard_cb, when you don't need it.
 This will treat &amp; in the regex like ?,
 and match a following digit (0..9) in the text,
 a following digit (0..9) in the regex is ignored.

 -----
 In general, you have to somehow invert the logic of regular expressions
 when using ext_match.
 Regular expressions could be regarded as "polish rpn notation",
 first the char to be matched, then the count.
 This expression machine could be described as "natural expression" machine.
 First you define the number, then the chars or expression to be matched.

 Furthermore, *,% and + match as less as possible.
 You have to think about what needs to follow the wildcards.

 e.g. when matching the parameter 'runlevel=default' at the kernel's
 commandline, a working regular expression would be
 "runlevel=(\S*)". This could be written here as "*runlevel=%#".
 For matching e.g. numbers, you'd most possibly best of
 with writing your own &amp; callback.

 returns: 1 on match, 0 on no match
 ( RE_MATCH / RE_NOMATCH )

 if the pointer (argument 5) st_match is nonnull,
 the supplied struct text_match will be set to the first matching '%' location;
 if there is no match, text_match.len will be set to 0.
 The struct is defined as:
 typedef struct _text_match { char* pos; int len; } text_match;


 (memo) When the regex ist defined within C/cpp source code,
 a backslash has to be defined as double backslash.

 (note) - be careful when negating a following *, or ?.
  somehow - it is logical, but seems to me I overshoot a bit,
  tragically hit my own foot, and stumbled into a logical paradox.

  Negating EVERYTHING translates to true.
  However, since truth is negated as well, there's a problem,
  cause it's now 'false', but 'false' is true. This is very close
  to proving 42 is the answer. What is the escape velocity
  in km/s out of the solar system, btw.

  (I'm not kidding here. Just don't do a regex with !* or !?..
  And, please, do not ask me what is going to happen when the impossible
  gets possibilized. I have to point at the according sentences of the BSD license;
  there is NO WARRANTY for CONSEQUENTIAL DAMAGE, LOSS OF PROFIT, etc pp.)

  A "!+" will translate into nongreedy matching of any char, however;
  "%!+" will match with % everything but the last char;
  while "%+" matches with % only the first char.
  !+ basically sets the greedyness of the left * or % higher.

 (work in progress here) please use ext_match
 return 0 for nomatch, the current textpos ( &gt;0 ) for a match
 With the exception of an empty text, matched by e.g. "*".
 This will return 0, albite the regex formally matches, with 0 chars.

 (todo)
 bracket matching () and {} needs debugging. (test/extmatch2 for testing)
 Add a callback for bracket matches, and add a matchlist
 (linked list, allocated with malloc_brk)
 Trouble: e.g. *:(*) doesn't match, albite it should
  .. better. Now: # matches the end, after a bracket. Like it should
   $ doesn't. But should as well.
 change '+' to greedy matching of any char
 for {n,X} let n be * or + as well.
  (this would be closer to regular regulars again.?.)


 note. About a tokenizer:
 matching quoted string is really easy with the callback structure:
  just match with &amp;. When a quote is matched, look forward to the next quote,
  and return that many chars. Same time, the quoted string is matched.
  That's so easy, it is hard to believe.
  When using closures for that, it is same time easy to collect all tokens.

  It is even easier. just a "*("*")*" is enough.

  -&gt;There is something needed for partial matching. Possibly spare the last *, and return,
  as soon the pattern is at it's end (and not the text?)
  Already works this way.

  Should start to define the language for the init scripts.
  Or better, start thinking abut that, but follow my other obligations the next time.

  Have to think thouroughly about what points would make such a language useful.
  The reason to think about that is clear - performance squeezing, faster startup time.
  And writing the startup scripts in C is. Well. little bit painful.
  However, together with minilib, there is nearly no difference between having a C program compiled
  and run, or working with scripts. To not have the overhead of linking the external libraries in,
  is of quite some advance.
  The only difference, the compiled binaries are "cached".
  have just to sort something sensible out for the systematic.
  Implement an own loader? possibly easy. Since the loading address is fixed.
  This could possibly also be the solution for the yet unclear question of the line between parsing
  arguments and calling the main function of the small core tools, andsoon.

 ..yet I've to fiddle out the possibilities (and quirks) of this machine.
 seems, this expression language did overpower it's creator.

 Bugs (features):
 matching e.g. *matches*@*doesn't match*
 potentiates the *@* to many possibilities.
 One for every linebreak following 'matches'.</code></pre>
</td></tr></table>
<p><a href="../src/match/match_ext2.c">../src/match/match_ext2.c</a> l.306</p>
<a name="memchr"></a><dl>
<dt>
memchr
</dt>
<dd>
<p>
  <em>void* memchr(const void *s, int c, unsigned int n)</em><br>
<a href="../src/memory/memchr.c">../src/memory/memchr.c</a> l.2 manpage: <a href="manpages/string/memchr.3.rst">memchr</a><br>
</p>
</dd>
<dt>
msync
</dt>
<dd>
<p>
  <em>int msync( void* addr,  size_t len, int flags)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.262 manpage: <a href="manpages/sys/msync.2.rst">msync</a><br>
</p>
</dd>
<dt>
network
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<a name="network"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>network definitions</code></pre>
</td></tr></table>
<p><a href="../include/network.h">../include/network.h</a> l.5</p>
<a name="ntohl"></a><dl>
<dt>
ntohl
</dt>
<dd>
<p>
  <em>#define ntohl(i) htonl(i)</em><br>
<a href="../src/network/ntohl.h">../src/network/ntohl.h</a> l.2 manpage: <a href="manpages/net/byteorder.3.rst">ntohl</a><br>
</p>
</dd>
<dt>
ntohs
</dt>
<dd>
<p>
  <em>#define ntohs(i) htons(i)</em><br>
 <strong>Defines:</strong> network<br>
<a href="../src/network/macros.h">../src/network/macros.h</a> l.2 manpage: <a href="manpages/net/byteorder.3.rst">ntohs</a><br>
</p>
</dd>
<dt>
optimization_fence
</dt>
<dd>
<p>
  <em>void  optimization_fence(void*p)</em><br>
</p>
</dd>
</dl>
<a name="optimization_fence"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>prevent optimizations.
 cast a var to void*, and calling this,
 leaves the compiler unknown on what he can strip.
 The function attribute noipa means,
 the compiler doesn't know, what the function itself does.
 (the function does nothing, but don't tell that gcc, please..)
 therefore, everything used as parameter to this function,
 will be calculated, defined, and so on before.
 It's used for the globals,
 shich are pushed within _start onto the stack.
 since _start itself only provides a global pointer,
 and initialitzes some of the globals,
 but doesn't use them again,
 this construction is needed.
 more funnily, the function will never be called.
 It's past the asm inline syscall to exit.
 But again, luckily gcc doesn't know.
 All other options, like having the globals volatile,
 setting the optimization flag of _start to 0,
 having a volatile asm call with the globals as param, and so on,
 have been useless. All after all, seems to me, ai has it's restrictions.

 With less overhead the macro OPTFENCE(...) goes.
 There the call to the "ipa" function is jumped over,
 via asm inline instructions.
 Doesn't work with clang.
 But yet I also didn't it with clang.</code></pre>
</td></tr></table>
<p><a href="../include/minilib_global.h">../include/minilib_global.h</a> l.218</p>
<a name="poll"></a><dl>
<dt>
poll
</dt>
<dd>
<p>
  <em>int poll(struct pollfd *fds, nfds_t cnt, int timeout)</em><br>
<a href="../include/poll.h">../include/poll.h</a> l.25 manpage: <a href="manpages/sys/poll.2.rst">poll</a><br>
</p>
</dd>
<dt>
prctl
</dt>
<dd>
<p>
  <em>int prctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.274
</p>
</dd>
<dt>
pwent
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<a name="pwent"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>define passwd and group structures</code></pre>
</td></tr></table>
<p><a href="../include/pwent.h">../include/pwent.h</a> l.7</p>
<a name="qsort"></a><dl>
<dt>
qsort
</dt>
<dd>
<p>
  <em>void qsort(void  <strong>base,      size_t nel,     size_t width,   int (*comp)(const void *, const void *))</em><br>
 *Defines:</strong> swap<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>(quick) shell sort routine
 following the tradition, this isn't exactly a quicksort algorithm,
 albite named quicksort.
 It is a shell sort implementation, originally done by Ray Gardner, 5/90;
 which in turn I did find within musl.</code></pre>
</td></tr></table>
<p><a href="../src/sort/qsort.c">../src/sort/qsort.c</a> l.35 manpage: <a href="manpages/stdlib/qsort.3.rst">qsort</a><br></p>
<a name="readlink"></a><dl>
<dt>
readlink
</dt>
<dd>
<p>
  <em>int readlink( const char *path,  char *buf,  int bufsiz)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.127 manpage: <a href="manpages/sys/readlink.2.rst">readlink</a><br>
</p>
</dd>
<dt>
recv
</dt>
<dd>
<p>
  <em>int recv(int sockfd, void <strong>buf, size_t len, int flags)</em><br>
 *Defines:</strong> recvfrom<br>
<a href="../src/network/recv.c">../src/network/recv.c</a> l.3 manpage: <a href="manpages/sys/recv.2.rst">recv</a><br>
</p>
</dd>
<dt>
recvfrom
</dt>
<dd>
<p>
  <em>int recvfrom( int fd,  void *ubuf,  size_t size,  unsigned flags,  struct sockaddr *addr,  unsigned int *addr_len)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.236 manpage: <a href="manpages/sys/recv.2.rst">recvfrom</a><br>
</p>
</dd>
<dt>
rt_sigsuspend
</dt>
<dd>
<p>
  <em>int rt_sigsuspend( const sigset_t *mask, size_t sigsetsize)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.188
</p>
</dd>
<dt>
sendto
</dt>
<dd>
<p>
  <em>int sendto( int fd,  void *buff,  size_t len,  unsigned flags,  struct sockaddr *addr,  int addr_len)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.239 manpage: <a href="manpages/sys/send.2.rst">sendto</a><br>
</p>
</dd>
<dt>
setbrk
</dt>
<dd>
<p>
  <em>int setbrk(long addr)</em><br>
 <strong>Defines:</strong> sys_brk<br>
</p>
</dd>
</dl>
<a name="setbrk"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>set the current brk
 wrapper for brk(), with type of brk changed to long</code></pre>
</td></tr></table>
<p><a href="../src/memory/setbrk.c">../src/memory/setbrk.c</a> l.6</p>
<a name="setenv"></a><dl>
<dt>
setenv
</dt>
<dd>
<p>
  <em>int setenv( const char <strong>name, const char *value, int overwrite )</em><br>
 *Defines:</strong> 0 ret_errno stpcpy strlen environ strcpy<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>put a string into the environmental vars
 UNTESTED (!) TODO
 the supplied string's pointer is put into the environmental array of pointers.
 The supplied strings are copied into memory.
 If overwrite is zero, an existing environmental variable is not overritten.
 If overwrite is 1, the environmental variable is overwritten,
 but not(!) freed from memory.
 The supplied value is not checked for e.g. an '='

 Returns:
 - 0 on success
 - EINVAL on error</code></pre>
</td></tr></table>
<p><a href="../src/system/setenv.c">../src/system/setenv.c</a> l.15 manpage: <a href="manpages/stdlib/getenv.3.rst">setenv</a><br></p>
<a name="setresuid"></a><dl>
<dt>
setresuid
</dt>
<dd>
<p>
  <em>int setresuid( uid_t *ruid,  uid_t *euid,  uid_t *suid)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.211 manpage: <a href="manpages/sys/setresuid.2.rst">setresuid</a><br>
</p>
</dd>
<dt>
setreuid
</dt>
<dd>
<p>
  <em>int setreuid( uid_t ruid,  uid_t euid)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.163 manpage: <a href="manpages/sys/setreuid.2.rst">setreuid</a><br>
</p>
</dd>
<dt>
setrlimit
</dt>
<dd>
<p>
  <em>int setrlimit( unsigned int resource,  struct rlimit *rlim)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.232 manpage: <a href="manpages/sys/getrlimit.2.rst">setrlimit</a><br>
</p>
</dd>
<dt>
setsockopt
</dt>
<dd>
<p>
  <em>int setsockopt( int fd,  int level,  int optname,  const void *optval,  int optlen)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.243 manpage: <a href="manpages/sys/getsockopt.2.rst">setsockopt</a><br>
</p>
</dd>
<dt>
short_errstr
</dt>
<dd>
<p>
  <em>const char* short_errstr(int num)</em><br>
</p>
</dd>
</dl>
<a name="short_errstr"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>short error (errno) string.
 this adds about 2kB to the compiled binary(!)</code></pre>
</td></tr></table>
<p><a href="../include/errstrshort.h">../include/errstrshort.h</a> l.10</p>
<a name="sigsuspend"></a><dl>
<dt>
sigsuspend
</dt>
<dd>
<p>
  <em>int sigsuspend( const sigset_t <strong>mask )</em><br>
 *Defines:</strong> rt_sigsuspend<br>
<a href="../src/process/sigaction.c">../src/process/sigaction.c</a> l.53 manpage: <a href="manpages/sys/sigsuspend.2.rst">sigsuspend</a><br>
</p>
</dd>
<dt>
snprintfs
</dt>
<dd>
<p>
  <em>int snprintfs( char* buf, int size, char *fmt, &#8230;)</em><br>
</p>
</dd>
</dl>
<a name="snprintfs"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>prints formatted and unbuffered output into buf.
 only %s and %c are recognized.
 snprintfs instead of snprintf can save some bytes.
 untested</code></pre>
</td></tr></table>
<p><a href="../src/output/snprintfs.c">../src/output/snprintfs.c</a> l.8</p>
<a name="socket"></a><dl>
<dt>
socket
</dt>
<dd>
<p>
  <em>int socket( int family,  int type,  int protocol)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.229 manpage: <a href="manpages/sys/socket.2.rst">socket</a><br>
</p>
</dd>
<dt>
stpcpy
</dt>
<dd>
<p>
  <em>char *stpcpy(char *dest, const char *src)</em><br>
</p>
</dd>
</dl>
<a name="stpcpy"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>copy src to dest, return a pointer to the last char +1 ( ending '0' )</code></pre>
</td></tr></table>
<p><a href="../src/string/stpcpy.c">../src/string/stpcpy.c</a> l.3 manpage: <a href="manpages/string/string.3.rst">stpcpy</a><br></p>
<a name="stplcpy"></a><dl>
<dt>
stplcpy
</dt>
<dd>
<p>
  <em>char *stplcpy(char *dest, const char *src, int size)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>copy src to dest, return a pointer to the last char +1 ( ending '0' )
 doesn't pad dest with 0, when size&lt;src;</code></pre>
</td></tr></table>
<p><a href="../src/string/stplcpy.c">../src/string/stplcpy.c</a> l.4</p>
<a name="stpncpy"></a><dl>
<dt>
stpncpy
</dt>
<dd>
<p>
  <em>char *stpncpy(char *dest, const char *src, int size)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>copy src to dest, return a pointer to the last char +1 ( ending '0' )
 Please note stplcpy (terminology borrowed from freebsd),
 which does the same,
 but doesn't pad dest with 0's.</code></pre>
</td></tr></table>
<p><a href="../src/string/stpncpy.c">../src/string/stpncpy.c</a> l.6 manpage: <a href="manpages/string/strcpy.3.rst">stpncpy</a><br></p>
<a name="strcspn"></a><dl>
<dt>
strcspn
</dt>
<dd>
<p>
  <em>int strcspn(const char *s1, const char *s2)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>look for the first place in s1,
 containing one of the chars of s2.
 Optimizes a bit (+16Bytes code),
 when OPTIMIZE is defined</code></pre>
</td></tr></table>
<p><a href="../src/string/strcspn.c">../src/string/strcspn.c</a> l.6 manpage: <a href="manpages/string/strspn.3.rst">strcspn</a><br></p>
<a name="strlcpy"></a><dl>
<dt>
strlcpy
</dt>
<dd>
<p>
  <em>char *strlcpy(char *dest, const char *src, int n)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>copy max n chars from src to dest,
 when src is longer than dest,
 end dest[n-1] with '\0'.</code></pre>
</td></tr></table>
<p><a href="../src/string/strlcpy.c">../src/string/strlcpy.c</a> l.5 manpage: <a href="manpages/string/strlcpy.3.rst">strlcpy</a><br></p>
<a name="strncat"></a><dl>
<dt>
strncat
</dt>
<dd>
<p>
  <em>char* strncat( char* dst, const char* src, unsigned int n)</em><br>
<a href="../src/string/strncat.c">../src/string/strncat.c</a> l.2 manpage: <a href="manpages/string/string.3.rst">strncat</a><br>
</p>
</dd>
<dt>
strndup
</dt>
<dd>
<p>
  <em>char <strong>strndup(const char *source, int maxlen)</em><br>
 *Defines:</strong> stplcpy strlen 0<br>
<a href="../src/string/strndup.c">../src/string/strndup.c</a> l.5 manpage: <a href="manpages/string/strdup.3.rst">strndup</a><br>
</p>
</dd>
<dt>
strnlen
</dt>
<dd>
<p>
  <em>int strnlen(const char*str, int max)</em><br>
</p>
</dd>
</dl>
<a name="strnlen"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>return len of str.
 if str points to 0, return 0
 if no 0 is within max chars of str,
 return max</code></pre>
</td></tr></table>
<p><a href="../src/string/strnlen.c">../src/string/strnlen.c</a> l.8 manpage: <a href="manpages/string/strlen.3.rst">strnlen</a><br></p>
<a name="strpbrk"></a><dl>
<dt>
strpbrk
</dt>
<dd>
<p>
  <em>char* strpbrk(const char* s, const char* charset)</em><br>
<a href="../src/string/strpbrk.c">../src/string/strpbrk.c</a> l.2 manpage: <a href="manpages/string/string.3.rst">strpbrk</a><br>
</p>
</dd>
<dt>
strspn
</dt>
<dd>
<p>
  <em>int strspn(const char *s1, const char *s2)</em><br>
<a href="../src/string/strspn.c">../src/string/strspn.c</a> l.2 manpage: <a href="manpages/string/strspn.3.rst">strspn</a><br>
</p>
</dd>
<dt>
strtoimax
</dt>
<dd>
<p>
  <em>int strtoimax(const char *c, const char **endp, int base)</em><br>
</p>
</dd>
</dl>
<a name="strtoimax"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>conversion</code></pre>
</td></tr></table>
<p><a href="../src/string/strtoimax.c">../src/string/strtoimax.c</a> l.4 manpage: <a href="manpages/stdlib/strtol.3.rst">strtoimax</a><br></p>
<a name="strtok"></a><dl>
<dt>
strtok
</dt>
<dd>
<p>
  <em>char* strtok(char <strong>s, const char *delim)</em><br>
 *Defines:</strong> strtok_r<br>
<a href="../src/string/strtok.c">../src/string/strtok.c</a> l.3 manpage: <a href="manpages/string/strtok.3.rst">strtok</a><br>
</p>
</dd>
<dt>
strtok_r
</dt>
<dd>
<p>
  <em>char* strtok_r(char *s, const char *delim, char **last)</em><br>
<a href="../src/string/strtok_r.c">../src/string/strtok_r.c</a> l.2 manpage: <a href="manpages/string/strtok.3.rst">strtok_r</a><br>
</p>
</dd>
<dt>
strtoll
</dt>
<dd>
<p>
  <em>long long int strtoll(const char <strong>c, const char **endp, int base)</em><br>
 *Defines:</strong> strtol<br>
</p>
</dd>
</dl>
<a name="strtoll"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>conversion
 doesn't check for overflow(!)
 For linux x64, long long and long both have 64 bit.
 Therefore, strtoll just calls strtol</code></pre>
</td></tr></table>
<p><a href="../src/string/strtoll.c">../src/string/strtoll.c</a> l.8 manpage: <a href="manpages/stdlib/strtol.3.rst">strtoll</a><br></p>
<a name="sys_signame"></a><dl>
<dt>
sys_signame
</dt>
<dd>
<p>
  _const char* sys_signame[] = _<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>abbreviated signal names, according to BSD &gt; 4.2</code></pre>
</td></tr></table>
<p><a href="../src/process/signames.h">../src/process/signames.h</a> l.3 manpage: <a href="manpages/gen/psignal.3.rst">sys_signame</a><br></p>
<a name="tcgetpgrp"></a><dl>
<dt>
tcgetpgrp
</dt>
<dd>
<p>
  <em>int tcgetpgrp(int fd)</em><br>
<a href="../src/termios/tcgetpgrp.c">../src/termios/tcgetpgrp.c</a> l.2 manpage: <a href="manpages/gen/tcgetpgrp.3.rst">tcgetpgrp</a><br>
</p>
</dd>
<dt>
tcsetpgrp
</dt>
<dd>
<p>
  <em>int tcsetpgrp(int fd, int pgrp)</em><br>
<a href="../src/termios/tcsetpgrp.c">../src/termios/tcsetpgrp.c</a> l.2 manpage: <a href="manpages/gen/tcsetpgrp.3.rst">tcsetpgrp</a><br>
</p>
</dd>
<dt>
term_width
</dt>
<dd>
<p>
  <em>int term_width()</em><br>
 <strong>Defines:</strong> termio environ<br>
</p>
</dd>
</dl>
<a name="term_width"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>get the terminal width
 reads the environmental var COLS,
 if not present, returns 80.
 Doesn't check for the existence of a terminal.</code></pre>
</td></tr></table>
<p><a href="../src/termios/term_width.c">../src/termios/term_width.c</a> l.7</p>
<a name="termio"></a><dl>
<dt>
termio
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>termios structures and definitions</code></pre>
</td></tr></table>
<p><a href="../include/termio.h">../include/termio.h</a> l.5</p>
<a name="timerfd_create"></a><dl>
<dt>
timerfd_create
</dt>
<dd>
<p>
  <em>int timerfd_create( int clockid,  int flags)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.268
</p>
</dd>
<dt>
timerfd_gettime
</dt>
<dd>
<p>
  <em>int timerfd_gettime( int ufd,  struct itimerspec *otmr)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.272
</p>
</dd>
<dt>
timerfd_settime
</dt>
<dd>
<p>
  <em>int timerfd_settime( int ufd,  int flags,  const struct itimerspec *utmr,  struct itimerspec *otmr)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.270
</p>
</dd>
<dt>
times
</dt>
<dd>
<p>
  <em>int times( struct tms *info)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.149 manpage: <a href="manpages/gen/times.3.rst">times</a><br>
</p>
</dd>
<dt>
token_i
</dt>
<dd>
<p>
  <em>int token_i( userdb* udb, char **p )</em><br>
<a href="../src/userdb/userdb.c">../src/userdb/userdb.c</a> l.33
</p>
</dd>
<dt>
token_s
</dt>
<dd>
<p>
  <em>char *token_s( userdb *udb, char **p )</em><br>
</p>
</dd>
</dl>
<a name="token_s"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>tokenizer for the passwd/group files.
 used by the group/user pwentry access functions.
 performance of subsequent calls could be improved by replacing all ':' and '\n'
 by 0's when loading the db file.
 it would be possible as well, testing not only single bytes, but
 integers of longs at once. However, in most cases, e.g.
 for big directories with many small files, in most cases
 all files do have the same owner and group. Since the last result to calls
 of the access functions is cached,
 there wouldn't be an improvement by optimizing the tokenizing functions.
 So I'm leaving this for now, as it is.
 And most possibly it would be better to implement bsd's cached versions
 of the user db access functions instead.</code></pre>
</td></tr></table>
<p><a href="../src/userdb/userdb.c">../src/userdb/userdb.c</a> l.19</p>
<a name="unsetenv"></a><dl>
<dt>
unsetenv
</dt>
<dd>
<p>
  <em>int unsetenv( char <strong>name)</em><br>
 *Defines:</strong> environ ret_errno<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>remove a string from the environmental vars
 The env var is not free'd. (It's not possible,
 since we don't know whether the string has been allocated
 with malloc or has been setup by the system )
 Returns:
 - 0 on success,
 - EINVAL: string was 0, did contain a '=', some other error</code></pre>
</td></tr></table>
<p><a href="../src/system/unsetenv.c">../src/system/unsetenv.c</a> l.10 manpage: <a href="manpages/stdlib/getenv.3.rst">unsetenv</a><br></p>
<a name="userdb_open"></a><dl>
<dt>
userdb_open
</dt>
<dd>
<p>
  <em>int userdb_open(userdb <strong>udb, const char</strong> file)</em><br>
 <strong>Defines:</strong> globals write fstat close<br>
<a href="../src/userdb/userdb_open.c">../src/userdb/userdb_open.c</a> l.3
</p>
</dd>
<dt>
warn
</dt>
<dd>
<p>
  <em>#define warn( fmt &#8230; ) { fprintf(stderr,fmt ); }</em><br>
 <strong>Defines:</strong> strlen getpid globals write kill fileno<br>
</p>
</dd>
</dl>
<a name="warn"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>print an error message to stderr</code></pre>
</td></tr></table>
<p><a href="../src/process/error.h">../src/process/error.h</a> l.33 manpage: <a href="manpages/gen/err.3.rst">warn</a><br></p>
<a name="where"></a><dl>
<dt>
where
</dt>
<dd>
<p>
  <em>int where(const char <strong>file,char *buf)</em><br>
 *Defines:</strong> access environ<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>locate an executable in PATH</code></pre>
</td></tr></table>
<p><a href="../src/exec/where.c">../src/exec/where.c</a> l.4</p>
<a name="writesl"></a><dl>
<dt>
writesl
</dt>
<dd>
<p>
  <em>#define writesl(str) write(STDOUT_FILENO,str "\n",sizeof(str)+1)</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write the constant str to stdout, followed by a newline.
 Computes length with sizeof(str) at compile time.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.93</p>
<p>---</p>
<hr>
<h2><a name="_userdb"></a>20. userdb</h2>
<a name="endgrent"></a><dl>
<dt>
endgrent
</dt>
<dd>
<p>
  <em>void endgrent()</em><br>
 <strong>Defines:</strong> pwent munmap<br>
<a href="../src/userdb/endgrent.c">../src/userdb/endgrent.c</a> l.4 manpage: <a href="manpages/gen/getgrent.3.rst">endgrent</a><br>
</p>
</dd>
<dt>
endpwent
</dt>
<dd>
<p>
  <em>void endpwent()</em><br>
 <strong>Defines:</strong> pwent munmap<br>
<a href="../src/userdb/endpwent.c">../src/userdb/endpwent.c</a> l.4 manpage: <a href="manpages/gen/getpwent.3.rst">endpwent</a><br>
</p>
</dd>
<dt>
getgrent
</dt>
<dd>
<p>
  <em>struct group* getgrent()</em><br>
 <strong>Defines:</strong> userdb open pwent<br>
<a href="../src/userdb/getgrent.c">../src/userdb/getgrent.c</a> l.4 manpage: <a href="manpages/gen/getgrent.3.rst">getgrent</a><br>
</p>
</dd>
<dt>
getgrgid
</dt>
<dd>
<p>
  <em>struct group <strong>getgrgid(gid_t gid)</em><br>
 *Defines:</strong> open write close token_i mmap userdb setgrent fstat pwent token_s globals grent<br>
</p>
</dd>
</dl>
<a name="getgrgid"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>get the group entry of the group "gid".
 the last result is cached, multiple calls with the same
 name will return the cached result.</code></pre>
</td></tr></table>
<p><a href="../src/userdb/getgrgid.c">../src/userdb/getgrgid.c</a> l.7 manpage: <a href="manpages/gen/getgrent.3.rst">getgrgid</a><br></p>
<a name="getgrnam"></a><dl>
<dt>
getgrnam
</dt>
<dd>
<p>
  <em>struct group <strong>getgrnam(const char</strong> name)</em><br>
 <strong>Defines:</strong> close write open userdb fstat setgrent token_i mmap token_s pwent grent globals<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>get the group entry of the group "name".
 the last result is cached, multiple calls with the same
 name will return the cached result.</code></pre>
</td></tr></table>
<p><a href="../src/userdb/getgrnam.c">../src/userdb/getgrnam.c</a> l.7 manpage: <a href="manpages/gen/getgrent.3.rst">getgrnam</a><br></p>
<a name="getpwent"></a><dl>
<dt>
getpwent
</dt>
<dd>
<p>
  <em>struct passwd* getpwent()</em><br>
 <strong>Defines:</strong> open userdb<br>
<a href="../src/userdb/getpwent.c">../src/userdb/getpwent.c</a> l.4 manpage: <a href="manpages/gen/getpwent.3.rst">getpwent</a><br>
</p>
</dd>
<dt>
getpwnam
</dt>
<dd>
<p>
  <em>struct passwd <strong>getpwnam(const char</strong> name)</em><br>
 <strong>Defines:</strong> mmap globals token_i fstat pwent write open token_s close<br>
</p>
</dd>
</dl>
<a name="getpwnam"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>get the passwd entry of the user "name".
 the last result is cached, multiple calls with the same
 name will return the cached result.</code></pre>
</td></tr></table>
<p><a href="../src/userdb/getpwnam.c">../src/userdb/getpwnam.c</a> l.7 manpage: <a href="manpages/gen/getpwent.3.rst">getpwnam</a><br></p>
<a name="getpwuid"></a><dl>
<dt>
getpwuid
</dt>
<dd>
<p>
  <em>struct passwd <strong>getpwuid(uid_t uid)</em><br>
 *Defines:</strong> passwdfile_open mmap token_i token_s pwent setpwent write open<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>get the passwd entry of the user with uid.
 the last result is cached, multiple calls with the same
 uid will return the cached result.</code></pre>
</td></tr></table>
<p><a href="../src/userdb/getpwuid.c">../src/userdb/getpwuid.c</a> l.7 manpage: <a href="manpages/gen/getpwent.3.rst">getpwuid</a><br></p>
<a name="max_groupmembers"></a><dl>
<dt>
max_groupmembers
</dt>
<dd>
<p>
  <em>#ifndef mini_max_groupmembers</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>The maximum number of users,
 which are within a group.
 used for the allocation of the array gr_mem.
 default: 64</code></pre>
</td></tr></table>
<p><a href="../include/globaldefs.h">../include/globaldefs.h</a> l.108</p>
<a name="setgrent"></a><dl>
<dt>
setgrent
</dt>
<dd>
<p>
  <em>void setgrent()</em><br>
<a href="../src/userdb/setgrent.c">../src/userdb/setgrent.c</a> l.3 manpage: <a href="manpages/gen/getgrent.3.rst">setgrent</a><br>
</p>
</dd>
<dt>
setpwent
</dt>
<dd>
<p>
  <em>void setpwent()</em><br>
<a href="../src/userdb/setpwent.c">../src/userdb/setpwent.c</a> l.3 manpage: <a href="manpages/gen/getpwent.3.rst">setpwent</a><br>
</p>
</dd>
</dl>
<p><a name="setpwent"></a>---</p>
<hr>
<h2><a name="_x64_syscalls"></a>21. x64-syscalls</h2>
<a name="sys__sysctl"></a><dl>
<dt>
sys__sysctl
</dt>
<dd>
<p>
  <em>sys<em>sysctl( struct </em>sysctl_args <strong>args)</em><br>
 *read/write system parameters</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.316
</p>
</dd>
<dt>
sys_accept
</dt>
<dd>
<p>
  <em>sys_accept( int fd,  struct sockaddr <strong>upeersockaddr,  int *upeeraddrlen)</em><br>
 *accept a new connection on a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.91
</p>
</dd>
<dt>
sys_accept4
</dt>
<dd>
<p>
  <em>sys_accept4( int fd,  struct sockaddr <strong>upeer_sockaddr,  int *upeer_addrlen,  int flags)</em><br>
 *accept a connection on a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.552
</p>
</dd>
<dt>
sys_access
</dt>
<dd>
<p>
  <em>sys_access( const char <strong>filename,  int mode)</em><br>
 *determine accessibility of a file relative to directory file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.47
</p>
</dd>
<dt>
sys_acct
</dt>
<dd>
<p>
  <em>sys_acct( const char <strong>name)</em><br>
 *switch process accounting on or off</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.330
</p>
</dd>
<dt>
sys_add_key
</dt>
<dd>
<p>
  <em>sys_add_key( const char <strong>_type,  const char *_description,  const void *_payload,  size_t plen)</em><br>
 *add a key to the kernel&#8217;s key management facility</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.472
</p>
</dd>
<dt>
sys_adjtimex
</dt>
<dd>
<p>
  <em>sys_adjtimex( struct timex <strong>txc_p)</em><br>
 *tune kernel clock</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.322
</p>
</dd>
<dt>
sys_alarm
</dt>
<dd>
<p>
  <em>sys_alarm( unsigned int seconds)</em><br>
 <strong>schedule an alarm signal</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.79
</p>
</dd>
<dt>
sys_arch_prctl
</dt>
<dd>
<p>
  <em>sys_arch_prctl( struct task_struct <strong>task,  int code,  unsigned long *addr)</em><br>
 *set architecture-specific thread state</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.320
</p>
</dd>
<dt>
sys_bind
</dt>
<dd>
<p>
  <em>sys_bind( int fd,  struct sockaddr <strong>umyaddr,  int addrlen)</em><br>
 *bind a name to a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.103
</p>
</dd>
<dt>
sys_brk
</dt>
<dd>
<p>
  <em>long sys_brk(unsigned long addr)</em><br>
 <strong>change data segment size</strong>
</p>
</dd>
</dl>
<a name="sys_brk"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>the kernel syscall brk.</code></pre>
</td></tr></table>
<p><a href="../src/memory/sys_brk.c">../src/memory/sys_brk.c</a> l.4</p>
<a name="sys_capget"></a><dl>
<dt>
sys_capget
</dt>
<dd>
<p>
  <em>sys_capget( cap_user_header_t header,  cap_user_data_t dataptr)</em><br>
 <strong>set/get capabilities of thread(s)</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.256
</p>
</dd>
<dt>
sys_capset
</dt>
<dd>
<p>
  <em>sys_capset( cap_user_header_t header,  const cap_user_data_t data)</em><br>
 <strong>set/get capabilities of thread(s)</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.258
</p>
</dd>
<dt>
sys_chdir
</dt>
<dd>
<p>
  <em>sys_chdir( const char <strong>filename)</em><br>
 *change working directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.166
</p>
</dd>
<dt>
sys_chmod
</dt>
<dd>
<p>
  <em>sys_chmod( const char <strong>filename,  mode_t mode)</em><br>
 *change mode of a file relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.186
</p>
</dd>
<dt>
sys_chown
</dt>
<dd>
<p>
  <em>sys_chown( const char <strong>filename,  uid_t user,  gid_t group)</em><br>
 *change owner and group of a file relative to directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.190
</p>
</dd>
<dt>
sys_chroot
</dt>
<dd>
<p>
  <em>sys_chroot( const char <strong>filename)</em><br>
 *change root directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.326
</p>
</dd>
<dt>
sys_clock_adjtime
</dt>
<dd>
<p>
  <em>sys_clock_adjtime( clockid_t which_clock,  struct timex *tx)</em><br>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.586
</p>
</dd>
<dt>
sys_clock_getres
</dt>
<dd>
<p>
  <em>sys_clock_getres( const clockid_t which_clock,  struct timespec *tp)</em><br>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.436
</p>
</dd>
<dt>
sys_clock_gettime
</dt>
<dd>
<p>
  <em>sys_clock_gettime( const clockid_t which_clock,  struct timespec <strong>tp)</em><br>
 *clock and time functions</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.434
</p>
</dd>
<dt>
sys_clock_nanosleep
</dt>
<dd>
<p>
  <em>sys_clock_nanosleep( const clockid_t which_clock,  int flags,  const struct timespec <strong>rqtp,  struct timespec *rmtp)</em><br>
 *high resolution sleep with specifiable clock</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.438
</p>
</dd>
<dt>
sys_clock_settime
</dt>
<dd>
<p>
  <em>sys_clock_settime( const clockid_t which_clock,  const struct timespec <strong>tp)</em><br>
 *clock and timer functions</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.432
</p>
</dd>
<dt>
sys_clone
</dt>
<dd>
<p>
  <em>sys_clone( unsigned long clone_flags,  unsigned long newsp,  void <strong>parent_tid,  void *child_tid)</em><br>
 *create a child process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.117
</p>
</dd>
<dt>
sys_close
</dt>
<dd>
<p>
  <em>sys_close( unsigned int fd)</em><br>
 <strong>close a file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.11
</p>
</dd>
<dt>
sys_connect
</dt>
<dd>
<p>
  <em>sys_connect( int fd,  struct sockaddr <strong>uservaddr,  int addrlen)</em><br>
 *connect a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.89
</p>
</dd>
<dt>
sys_creat
</dt>
<dd>
<p>
  <em>sys_creat( const char <strong>pathname,  int mode)</em><br>
 *create a new file or rewrite an existing one</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.176
</p>
</dd>
<dt>
sys_delete_module
</dt>
<dd>
<p>
  <em>sys_delete_module( const char <strong>name_user,  unsigned int flags)</em><br>
 *unload a kernel module</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.354
</p>
</dd>
<dt>
sys_dup
</dt>
<dd>
<p>
  <em>sys_dup( unsigned int fildes)</em><br>
 <strong>duplicate an open file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.69
</p>
</dd>
<dt>
sys_dup2
</dt>
<dd>
<p>
  <em>sys_dup2( unsigned int oldfd,  unsigned int newfd)</em><br>
 <strong>duplicate a file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.71
</p>
</dd>
<dt>
sys_dup3
</dt>
<dd>
<p>
  <em>sys_dup3( unsigned int oldfd,  unsigned int newfd,  int flags)</em><br>
 <strong>duplicate a file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.560
</p>
</dd>
<dt>
sys_epoll_create
</dt>
<dd>
<p>
  <em>sys_epoll_create( int size)</em><br>
 <strong>open an epoll file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.408
</p>
</dd>
<dt>
sys_epoll_create1
</dt>
<dd>
<p>
  <em>sys_epoll_create1( int flags)</em><br>
 <strong>open an epoll file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.558
</p>
</dd>
<dt>
sys_epoll_ctl
</dt>
<dd>
<p>
  <em>sys_epoll_ctl( int epfd,  int op,  int fd,  struct epoll_event <strong>event)</em><br>
 *control interface for an epoll file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.444
</p>
</dd>
<dt>
sys_epoll_pwait
</dt>
<dd>
<p>
  <em>sys_epoll_pwait( int epfd,  struct epoll_event <strong>events,  int maxevents,  int timeout,  const sigset_t *sigmask,  size_t sigsetsize)</em><br>
 *wait for an I/O event on an epoll file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.538
</p>
</dd>
<dt>
sys_epoll_wait
</dt>
<dd>
<p>
  <em>sys_epoll_wait( int epfd,  struct epoll_event <strong>events,  int maxevents,  int timeout)</em><br>
 *wait for an I/O event on an epoll file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.442
</p>
</dd>
<dt>
sys_eventfd
</dt>
<dd>
<p>
  <em>sys_eventfd( unsigned int count)</em><br>
 <strong>create a file descriptor for event notification</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.544
</p>
</dd>
<dt>
sys_eventfd2
</dt>
<dd>
<p>
  <em>sys_eventfd2( unsigned int count,  int flags)</em><br>
 <strong>create a file descriptor for event notification</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.556
</p>
</dd>
<dt>
sys_execve
</dt>
<dd>
<p>
  <em>sys_execve( const char <strong>filename,  const char *const argv[],  const char *const envp[])</em><br>
 *execute program</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.123
</p>
</dd>
<dt>
sys_exit
</dt>
<dd>
<p>
  <em>sys_exit( int error_code)</em><br>
 <strong>terminate a process</strong>
</p>
</dd>
<dt>
sys_exit_group
</dt>
<dd>
<p>
  <em>sys_exit_group( int error_code)</em><br>
 <strong>exit all threads in a process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.440
</p>
</dd>
<dt>
sys_faccessat
</dt>
<dd>
<p>
  <em>sys_faccessat( int dfd,  const char <strong>filename,  int mode)</em><br>
 *determine accessibility of a file relative to directory file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.514
</p>
</dd>
<dt>
sys_fadvise64
</dt>
<dd>
<p>
  <em>sys_fadvise64( int fd,  loff_t offset,  size_t len,  int advice)</em><br>
 <strong>predeclare an access pattern for file data</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.420
</p>
</dd>
<dt>
sys_fallocate
</dt>
<dd>
<p>
  <em>sys_fallocate( long fd,  long mode,  loff_t offset,  loff_t len)</em><br>
 <strong>manipulate file space</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.546
</p>
</dd>
<dt>
sys_fanotify_init
</dt>
<dd>
<p>
  <em>sys_fanotify_init( unsigned int flags,  unsigned int event_f_flags)</em><br>
 <strong>create and initialize fanotify group</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.576
</p>
</dd>
<dt>
sys_fanotify_mark
</dt>
<dd>
<p>
  <em>sys_fanotify_mark( long fanotify_fd,  long flags,  __u64 mask,  long dfd, long pathname)</em><br>
 <strong>add, remove, or modify an fanotify mark on a filesystem</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.578
</p>
</dd>
<dt>
sys_fchdir
</dt>
<dd>
<p>
  <em>sys_fchdir( unsigned int fd)</em><br>
 <strong>change working directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.168
</p>
</dd>
<dt>
sys_fchmod
</dt>
<dd>
<p>
  <em>sys_fchmod( unsigned int fd,  mode_t mode)</em><br>
 <strong>change mode of a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.188
</p>
</dd>
<dt>
sys_fchmodat
</dt>
<dd>
<p>
  <em>sys_fchmodat( int dfd,  const char <strong>filename,  mode_t mode)</em><br>
 *change mode of a file relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.512
</p>
</dd>
<dt>
sys_fchown
</dt>
<dd>
<p>
  <em>sys_fchown( unsigned int fd,  uid_t user,  gid_t group)</em><br>
 <strong>change owner and group of a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.192
</p>
</dd>
<dt>
sys_fchownat
</dt>
<dd>
<p>
  <em>sys_fchownat( int dfd,  const char <strong>filename,  uid_t user,  gid_t group,  int flag)</em><br>
 *change owner and group of a file relative to directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.496
</p>
</dd>
<dt>
sys_fcntl
</dt>
<dd>
<p>
  <em>sys_fcntl( unsigned int fd,  unsigned int cmd,  unsigned long arg)</em><br>
 <strong>file control</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.150
</p>
</dd>
<dt>
sys_fdatasync
</dt>
<dd>
<p>
  <em>sys_fdatasync( unsigned int fd)</em><br>
 <strong>synchronize the data of a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.156
</p>
</dd>
<dt>
sys_fgetxattr
</dt>
<dd>
<p>
  <em>sys_fgetxattr( int fd,  const char <strong>name,  void *value,  size_t size)</em><br>
 *retrieve an extended attribute value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.372
</p>
</dd>
<dt>
sys_finit_module
</dt>
<dd>
<p>
  <em>sys_finit_module( int fd,  const char  <strong>uargs,  int flags)</em><br>
 *load a kernel module</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.602
</p>
</dd>
<dt>
sys_flistxattr
</dt>
<dd>
<p>
  <em>sys_flistxattr( int fd,  char <strong>list,  size_t size)</em><br>
 *list extended attribute names</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.378
</p>
</dd>
<dt>
sys_flock
</dt>
<dd>
<p>
  <em>sys_flock( unsigned int fd,  unsigned int cmd)</em><br>
 <strong>apply or remove an advisory lock on an open file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.152
</p>
</dd>
<dt>
sys_fork
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_fork,0)</em><br>
 <strong>create a new process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.119
</p>
</dd>
<dt>
sys_fremovexattr
</dt>
<dd>
<p>
  <em>sys_fremovexattr( int fd,  const char <strong>name)</em><br>
 *remove an extended attribute</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.384
</p>
</dd>
<dt>
sys_fsetxattr
</dt>
<dd>
<p>
  <em>sys_fsetxattr( int fd,  const char <strong>name,  const void *value,  size_t size, int flags)</em><br>
 *set an extended attribute value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.366
</p>
</dd>
<dt>
sys_fstat
</dt>
<dd>
<p>
  <em>sys_fstat( unsigned int fd,  struct stat <strong>statbuf)</em><br>
 *get file status</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.15
</p>
</dd>
<dt>
sys_fstatfs
</dt>
<dd>
<p>
  <em>sys_fstatfs( unsigned int fd,  struct statfs <strong>buf)</em><br>
 *get filesystem statistics</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.280
</p>
</dd>
<dt>
sys_fsync
</dt>
<dd>
<p>
  <em>sys_fsync( unsigned int fd)</em><br>
 <strong>synchronize changes to a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.154
</p>
</dd>
<dt>
sys_ftruncate
</dt>
<dd>
<p>
  <em>sys_ftruncate( unsigned int fd,  unsigned long length)</em><br>
 <strong>truncate a file to a specified length</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.160
</p>
</dd>
<dt>
sys_futex
</dt>
<dd>
<p>
  <em>sys_futex( u32 <strong>uaddr,  int op,  u32 val,  struct timespec *utime,  u32 *uaddr2,  u32 val3)</em><br>
 *fast user-space locking</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.390
</p>
</dd>
<dt>
sys_futimesat
</dt>
<dd>
<p>
  <em>sys_futimesat( int dfd,  const char <strong>filename,  struct timeval *utimes)</em><br>
 *change timestamps of a file relative to a directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.498
</p>
</dd>
<dt>
sys_get_mempolicy
</dt>
<dd>
<p>
  <em>sys_get_mempolicy( int <strong>policy,  unsigned long *nmask,  unsigned long maxnode,  unsigned long addr,  unsigned long flags)</em><br>
 *retrieve NUMA memory policy for a thread</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.454
</p>
</dd>
<dt>
sys_get_robust_list
</dt>
<dd>
<p>
  <em>sys_get_robust_list( int pid,  struct robust_list_head <strong>*head_ptr,  size_t *len_ptr)</em><br>
 *get/set list of robust futexes</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.524
</p>
</dd>
<dt>
sys_getcpu
</dt>
<dd>
<p>
  <em>sys_getcpu( unsigned <strong>cpup,  unsigned *nodep,  struct getcpu_cache *unused)</em><br>
 *determine CPU and NUMA node on which the calling thread is running</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.594
</p>
</dd>
<dt>
sys_getcwd
</dt>
<dd>
<p>
  <em>sys_getcwd( char <strong>buf,  unsigned long size)</em><br>
 *get the pathname of the current working directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.164
</p>
</dd>
<dt>
sys_getdents
</dt>
<dd>
<p>
  <em>sys_getdents( unsigned int fd,  struct linux_dirent <strong>dirent,  unsigned int count)</em><br>
 *get directory entries</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.162
</p>
</dd>
<dt>
sys_getdents64
</dt>
<dd>
<p>
  <em>sys_getdents64( unsigned int fd,  struct linux_dirent64 <strong>dirent,  unsigned int count)</em><br>
 *get directory entries</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.412
</p>
</dd>
<dt>
sys_getegid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_getegid,0)</em><br>
 <strong>get the effective group ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.222
</p>
</dd>
<dt>
sys_geteuid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_geteuid,0)</em><br>
 <strong>get the effective user ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.220
</p>
</dd>
<dt>
sys_getgid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_getgid,0)</em><br>
 <strong>get the real group ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.214
</p>
</dd>
<dt>
sys_getgroups
</dt>
<dd>
<p>
  <em>sys_getgroups( int gidsetsize,  gid_t <strong>grouplist)</em><br>
 *get supplementary group IDs</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.236
</p>
</dd>
<dt>
sys_getitimer
</dt>
<dd>
<p>
  <em>sys_getitimer( int which,  struct itimerval <strong>value)</em><br>
 *get and set value of interval timer</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.77
</p>
</dd>
<dt>
sys_getpeername
</dt>
<dd>
<p>
  <em>sys_getpeername( int fd,  struct sockaddr <strong>usockaddr,  int *usockaddr_len)</em><br>
 *get the name of the peer socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.109
</p>
</dd>
<dt>
sys_getpgid
</dt>
<dd>
<p>
  <em>sys_getpgid( pid_t pid)</em><br>
 <strong>get the process group ID for a process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.248
</p>
</dd>
<dt>
sys_getpgrp
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_getpgrp,0)</em><br>
 <strong>get the process group ID of the calling process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.228
</p>
</dd>
<dt>
sys_getpid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_getpid,0)</em><br>
 <strong>get the process ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.83
</p>
</dd>
<dt>
sys_getppid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_getppid,0)</em><br>
 <strong>get the parent process ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.226
</p>
</dd>
<dt>
sys_getpriority
</dt>
<dd>
<p>
  <em>sys_getpriority( int which,  int who)</em><br>
 <strong>get and set the nice value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.284
</p>
</dd>
<dt>
sys_getrandom
</dt>
<dd>
<p>
  <em>sys_getrandom( char  <strong>buf,  size_t count,  unsigned int flags)</em><br>
 *obtain a series of random bytes</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.612
</p>
</dd>
<dt>
sys_getresgid
</dt>
<dd>
<p>
  <em>sys_getresgid( gid_t <strong>rgid,  gid_t *egid,  gid_t *sgid)</em><br>
 *get real, effective and saved user/group IDs</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.246
</p>
</dd>
<dt>
sys_getresuid
</dt>
<dd>
<p>
  <em>sys_getresuid( uid_t <strong>ruid,  uid_t *euid,  uid_t *suid)</em><br>
 *get real, effective and saved user/group IDs</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.242
</p>
</dd>
<dt>
sys_getrlimit
</dt>
<dd>
<p>
  <em>sys_getrlimit( unsigned int resource,  struct rlimit <strong>rlim)</em><br>
 *control maximum resource consumption</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.200
</p>
</dd>
<dt>
sys_getrusage
</dt>
<dd>
<p>
  <em>sys_getrusage( int who,  struct rusage <strong>ru)</em><br>
 *get information about resource utilization</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.202
</p>
</dd>
<dt>
sys_getsid
</dt>
<dd>
<p>
  <em>sys_getsid( pid_t pid)</em><br>
 <strong>get the process group ID of a session leader</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.254
</p>
</dd>
<dt>
sys_getsockname
</dt>
<dd>
<p>
  <em>sys_getsockname( int fd,  struct sockaddr <strong>usockaddr,  int *usockaddr_len)</em><br>
 *get the socket name</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.107
</p>
</dd>
<dt>
sys_getsockopt
</dt>
<dd>
<p>
  <em>sys_getsockopt( int fd,  int level,  int optname,  char <strong>optval,  int *optlen)</em><br>
 *get the socket options</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.115
</p>
</dd>
<dt>
sys_gettid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_gettid,0)</em><br>
 <strong>get thread identification</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.358
</p>
</dd>
<dt>
sys_gettimeofday
</dt>
<dd>
<p>
  <em>sys_gettimeofday( struct timeval <strong>tv,  struct timezone *tz)</em><br>
 *get the date and time</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.198
</p>
</dd>
<dt>
sys_getuid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_getuid,0)</em><br>
 <strong>get a real user ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.210
</p>
</dd>
<dt>
sys_getxattr
</dt>
<dd>
<p>
  <em>sys_getxattr( const char <strong>pathname,  const char *name,  void *value,  size_t size)</em><br>
 *retrieve an extended attribute value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.368
</p>
</dd>
<dt>
sys_init_module
</dt>
<dd>
<p>
  <em>sys_init_module( void <strong>umod,  unsigned long len,  const char *uargs)</em><br>
 *load a kernel module</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.352
</p>
</dd>
<dt>
sys_inotify_add_watch
</dt>
<dd>
<p>
  <em>sys_inotify_add_watch( int fd,  const char <strong>pathname,  u32 mask)</em><br>
 *add a watch to an initialized inotify instance</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.484
</p>
</dd>
<dt>
sys_inotify_init
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_inotify_init,0)</em><br>
 <strong>initialize an inotify instance</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.482
</p>
</dd>
<dt>
sys_inotify_init1
</dt>
<dd>
<p>
  <em>sys_inotify_init1( int flags)</em><br>
 <strong>initialize an inotify instance</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.564
</p>
</dd>
<dt>
sys_inotify_rm_watch
</dt>
<dd>
<p>
  <em>sys_inotify_rm_watch( int fd,  __s32 wd)</em><br>
 <strong>remove an existing watch from an inotify instance</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.486
</p>
</dd>
<dt>
sys_io_cancel
</dt>
<dd>
<p>
  <em>sys_io_cancel( aio_context_t ctx_id,  struct iocb <strong>iocb,  struct io_event *result)</em><br>
 *cancel an outstanding asynchronous I/O operation</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.404
</p>
</dd>
<dt>
sys_io_destroy
</dt>
<dd>
<p>
  <em>sys_io_destroy( aio_context_t ctx)</em><br>
 <strong>destroy an asynchronous I/O context</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.398
</p>
</dd>
<dt>
sys_io_getevents
</dt>
<dd>
<p>
  <em>sys_io_getevents( aio_context_t ctx_id,  long min_nr,  long nr,  struct io_event <strong>events)</em><br>
 *read asynchronous I/O events from the completion queue</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.400
</p>
</dd>
<dt>
sys_io_setup
</dt>
<dd>
<p>
  <em>sys_io_setup( unsigned nr_events,  aio_context_t <strong>ctxp)</em><br>
 *create an asynchronous I/O context</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.396
</p>
</dd>
<dt>
sys_io_submit
</dt>
<dd>
<p>
  <em>sys_io_submit( aio_context_t ctx_id,  long nr,  struct iocb <strong>*iocbpp)</em><br>
 *submit asynchronous I/O blocks for processing</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.402
</p>
</dd>
<dt>
sys_ioctl
</dt>
<dd>
<p>
  <em>sys_ioctl( unsigned int fd,  unsigned int cmd,  unsigned long arg)</em><br>
 <strong>control a STREAMS device (\fBSTREAMS\fP)</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.37
</p>
</dd>
<dt>
sys_ioperm
</dt>
<dd>
<p>
  <em>sys_ioperm( unsigned long from,  unsigned long num,  int turn_on)</em><br>
 <strong>set port input/output permissions</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.350
</p>
</dd>
<dt>
sys_iopl
</dt>
<dd>
<p>
  <em>sys_iopl( unsigned int level,  struct pt_regs <strong>regs)</em><br>
 *change I/O privilege level</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.348
</p>
</dd>
<dt>
sys_ioprio_get
</dt>
<dd>
<p>
  <em>sys_ioprio_get( int which,  int who)</em><br>
 <strong>get/set I/O scheduling class and priority</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.480
</p>
</dd>
<dt>
sys_ioprio_set
</dt>
<dd>
<p>
  <em>sys_ioprio_set( int which,  int who,  int ioprio)</em><br>
 <strong>get/set I/O scheduling class and priority</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.478
</p>
</dd>
<dt>
sys_kcmp
</dt>
<dd>
<p>
  <em>sys_kcmp( pid_t pid1,  pid_t pid2,  int type,  unsigned long idx1,  unsigned long idx2)</em><br>
 <strong>compare two processes to determine if they share a kernel resource</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.600
</p>
</dd>
<dt>
sys_kexec_file_load
</dt>
<dd>
<p>
  <em>sys_kexec_file_load( int kernel_fd,  int initrd_fd,  unsigned long cmdline_len,  const char  <strong>cmdline_ptr,  unsigned long flags)</em><br>
 *load a new kernel for later execution</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.616
</p>
</dd>
<dt>
sys_kexec_load
</dt>
<dd>
<p>
  <em>sys_kexec_load( unsigned long entry,  unsigned long nr_segments,  struct kexec_segment <strong>segments,  unsigned long flags)</em><br>
 *load a new kernel for later execution</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.468
</p>
</dd>
<dt>
sys_keyctl
</dt>
<dd>
<p>
  <em>sys_keyctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)</em><br>
 <strong>key management function wrappers</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.476
</p>
</dd>
<dt>
sys_kill
</dt>
<dd>
<p>
  <em>sys_kill( pid_t pid,  int sig)</em><br>
 <strong>send a signal to a process or a group of processes</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.130
</p>
</dd>
<dt>
sys_lchown
</dt>
<dd>
<p>
  <em>sys_lchown( const char <strong>filename,  uid_t user,  gid_t group)</em><br>
 *change the owner and group of a symbolic link</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.194
</p>
</dd>
<dt>
sys_lgetxattr
</dt>
<dd>
<p>
  <em>sys_lgetxattr( const char <strong>pathname,  const char *name,  void *value,  size_t size)</em><br>
 *retrieve an extended attribute value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.370
</p>
</dd>
<dt>
sys_link
</dt>
<dd>
<p>
  <em>sys_link( const char <strong>oldname,  const char *newname)</em><br>
 *link one file to another file relative to two directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.178
</p>
</dd>
<dt>
sys_linkat
</dt>
<dd>
<p>
  <em>sys_linkat( int oldfd,  const char <strong>oldname,  int newfd,  const char *newname,  int flags)</em><br>
 *make a new name for a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.506
</p>
</dd>
<dt>
sys_listen
</dt>
<dd>
<p>
  <em>sys_listen( int fd,  int backlog)</em><br>
 <strong>listen for socket connections and limit the queue of incoming</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.105
</p>
</dd>
<dt>
sys_listxattr
</dt>
<dd>
<p>
  <em>sys_listxattr( const char <strong>pathname,  char *list,  size_t size)</em><br>
 *list extended attribute names</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.374
</p>
</dd>
<dt>
sys_llistxattr
</dt>
<dd>
<p>
  <em>sys_llistxattr( const char <strong>pathname,  char *list,  size_t size)</em><br>
 *list extended attribute names</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.376
</p>
</dd>
<dt>
sys_lookup_dcookie
</dt>
<dd>
<p>
  <em>sys_lookup_dcookie( u64 cookie64,  long buf,  long len)</em><br>
 <strong>return a directory entry&#8217;s path</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.406
</p>
</dd>
<dt>
sys_lremovexattr
</dt>
<dd>
<p>
  <em>sys_lremovexattr( const char <strong>pathname,  const char *name)</em><br>
 *remove an extended attribute</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.382
</p>
</dd>
<dt>
sys_lseek
</dt>
<dd>
<p>
  <em>sys_lseek( unsigned int fd,  off_t offset,  unsigned int origin)</em><br>
 <strong>move the read/write file offset</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.21
</p>
</dd>
<dt>
sys_lsetxattr
</dt>
<dd>
<p>
  <em>sys_lsetxattr( const char <strong>pathname,  const char *name,  const void *value, size_t size,  int flags)</em><br>
 *set an extended attribute value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.364
</p>
</dd>
<dt>
sys_lstat
</dt>
<dd>
<p>
  <em>sys_lstat( const char <strong>filename,  struct stat *statbuf)</em><br>
 *get file status</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.17
</p>
</dd>
<dt>
sys_madvise
</dt>
<dd>
<p>
  <em>sys_madvise( unsigned long start,  size_t len_in,  int behavior)</em><br>
 <strong>give advice about use of memory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.61
</p>
</dd>
<dt>
sys_mbind
</dt>
<dd>
<p>
  <em>sys_mbind( unsigned long start,  unsigned long len,  unsigned long mode,  unsigned long <strong>nmask,  unsigned long maxnode,  unsigned flags)</em><br>
 *set memory policy for a memory range</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.450
</p>
</dd>
<dt>
sys_memfd_create
</dt>
<dd>
<p>
  <em>sys_memfd_create( const char  <strong>uname_ptr,  unsigned int flags)</em><br>
 *create an anonymous file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.614
</p>
</dd>
<dt>
sys_migrate_pages
</dt>
<dd>
<p>
  <em>sys_migrate_pages( pid_t pid,  unsigned long maxnode,  const unsigned long <strong>old_nodes,  const unsigned long *new_nodes)</em><br>
 *move all pages in a process to another set of nodes</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.488
</p>
</dd>
<dt>
sys_mincore
</dt>
<dd>
<p>
  <em>sys_mincore( unsigned long start,  size_t len,  unsigned char <strong>vec)</em><br>
 *determine whether pages are resident in memory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.59
</p>
</dd>
<dt>
sys_mkdir
</dt>
<dd>
<p>
  <em>sys_mkdir( const char <strong>pathname,  int mode)</em><br>
 *make a directory relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.172
</p>
</dd>
<dt>
sys_mkdirat
</dt>
<dd>
<p>
  <em>sys_mkdirat( int dfd,  const char <strong>pathname,  int mode)</em><br>
 *create a directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.492
</p>
</dd>
<dt>
sys_mknod
</dt>
<dd>
<p>
  <em>sys_mknod( const char <strong>filename,  umode_t mode,  unsigned dev)</em><br>
 *make directory, special file, or regular file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.272
</p>
</dd>
<dt>
sys_mknodat
</dt>
<dd>
<p>
  <em>sys_mknodat( int dfd,  const char <strong>filename,  int mode,  unsigned dev)</em><br>
 *create a special or ordinary file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.494
</p>
</dd>
<dt>
sys_mlock
</dt>
<dd>
<p>
  <em>sys_mlock( unsigned long start,  size_t len)</em><br>
 <strong>lock or unlock a range of process address space</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.302
</p>
</dd>
<dt>
sys_mlockall
</dt>
<dd>
<p>
  <em>sys_mlockall( int flags)</em><br>
 <strong>lock/unlock the address space of a process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.306
</p>
</dd>
<dt>
sys_mmap
</dt>
<dd>
<p>
  <em>sys_mmap( unsigned long addr,  unsigned long len,  unsigned long prot,  unsigned long flags,  unsigned long fd,  unsigned long off)</em><br>
 <strong>map pages of memory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.23
</p>
</dd>
<dt>
sys_modify_ldt
</dt>
<dd>
<p>
  <em>sys_modify_ldt( int func,  void <strong>ptr,  unsigned long bytecount)</em><br>
 *get or set a per-process LDT entry</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.312
</p>
</dd>
<dt>
sys_mount
</dt>
<dd>
<p>
  <em>sys_mount( char <strong>dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)</em><br>
 *mount filesystem</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.334
</p>
</dd>
<dt>
sys_move_pages
</dt>
<dd>
<p>
  <em>sys_move_pages( pid_t pid,  unsigned long nr_pages,  const void <strong>pages[], const int *nodes,  int *status,  int flags)</em><br>
 *move individual pages of a process to another node</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.534
</p>
</dd>
<dt>
sys_mprotect
</dt>
<dd>
<p>
  <em>sys_mprotect( unsigned long start,  size_t len,  unsigned long prot)</em><br>
 <strong>set protection of memory mapping</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.25
</p>
</dd>
<dt>
sys_mq_getsetattr
</dt>
<dd>
<p>
  <em>sys_mq_getsetattr( mqd_t mqdes,  const struct mq_attr <strong>u_mqstat,  struct mq_attr *u_omqstat)</em><br>
 *get/set message queue attributes</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.466
</p>
</dd>
<dt>
sys_mq_notify
</dt>
<dd>
<p>
  <em>sys_mq_notify( mqd_t mqdes,  const struct sigevent <strong>u_notification)</em><br>
 *notify process that a message is available</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.464
</p>
</dd>
<dt>
sys_mq_open
</dt>
<dd>
<p>
  <em>sys_mq_open( const char <strong>u_name,  int oflag,  mode_t mode,  struct mq_attr *u_attr)</em><br>
 *open a message queue</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.456
</p>
</dd>
<dt>
sys_mq_timedreceive
</dt>
<dd>
<p>
  <em>sys_mq_timedreceive( mqd_t mqdes,  char <strong>u_msg_ptr,  size_t msg_len,  unsigned int *u_msg_prio,  const struct timespec *u_abs_timeout)</em><br>
 *receive a message from a message queue</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.462
</p>
</dd>
<dt>
sys_mq_timedsend
</dt>
<dd>
<p>
  <em>sys_mq_timedsend( mqd_t mqdes,  const char <strong>u_msg_ptr,  size_t msg_len,  unsigned int msg_prio,  const struct timespec *u_abs_timeout)</em><br>
 *send a message to a message queue</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.460
</p>
</dd>
<dt>
sys_mq_unlink
</dt>
<dd>
<p>
  <em>sys_mq_unlink( const char <strong>u_name)</em><br>
 *remove a message queue</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.458
</p>
</dd>
<dt>
sys_mremap
</dt>
<dd>
<p>
  <em>sys_mremap( unsigned long addr,  unsigned long old_len,  unsigned long new_len,  unsigned long flags,  unsigned long new_addr)</em><br>
 <strong>remap a virtual memory address</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.55
</p>
</dd>
<dt>
sys_msgctl
</dt>
<dd>
<p>
  <em>sys_msgctl( int msqid,  int cmd,  struct msqid_ds <strong>buf)</em><br>
 *XSI message control operations</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.148
</p>
</dd>
<dt>
sys_msgget
</dt>
<dd>
<p>
  <em>sys_msgget( key_t key,  int msgflg)</em><br>
 <strong>get the XSI message queue identifier</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.142
</p>
</dd>
<dt>
sys_msgrcv
</dt>
<dd>
<p>
  <em>sys_msgrcv( int msqid,  struct msgbuf <strong>msgp,  size_t msgsz,  long msgtyp,  int msgflg)</em><br>
 *XSI message receive operation</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.146
</p>
</dd>
<dt>
sys_msgsnd
</dt>
<dd>
<p>
  <em>sys_msgsnd( int msqid,  struct msgbuf <strong>msgp,  size_t msgsz,  int msgflg)</em><br>
 *XSI message send operation</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.144
</p>
</dd>
<dt>
sys_msync
</dt>
<dd>
<p>
  <em>sys_msync( unsigned long start,  size_t len,  int flags)</em><br>
 <strong>synchronize memory with physical storage</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.57
</p>
</dd>
<dt>
sys_munlock
</dt>
<dd>
<p>
  <em>sys_munlock( unsigned long start,  size_t len)</em><br>
 <strong>unlock a range of process address space</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.304
</p>
</dd>
<dt>
sys_munlockall
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_munlockall,0)</em><br>
 <strong>unlock the address space of a process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.308
</p>
</dd>
<dt>
sys_munmap
</dt>
<dd>
<p>
  <em>sys_munmap( unsigned long addr,  size_t len)</em><br>
 <strong>unmap pages of memory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.27
</p>
</dd>
<dt>
sys_name_to_handle_at
</dt>
<dd>
<p>
  <em>sys_name_to_handle_at( int dfd,  const char <strong>name,  struct file_handle *handle,  int *mnt_id,  int flag)</em><br>
 *obtain handle</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.582
</p>
</dd>
<dt>
sys_nanosleep
</dt>
<dd>
<p>
  <em>sys_nanosleep( struct timespec <strong>rqtp,  struct timespec *rmtp)</em><br>
 *high resolution sleep</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.75
</p>
</dd>
<dt>
sys_newfstatat
</dt>
<dd>
<p>
  <em>sys_newfstatat( int dfd,  const char <strong>filename,  struct stat *statbuf,  int flag)</em><br>
 *get file status</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.500
</p>
</dd>
<dt>
sys_open
</dt>
<dd>
<p>
  <em>sys_open( const char <strong>filename,  int flags,  int mode)</em><br>
 *open file relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.9
</p>
</dd>
<dt>
sys_open_by_handle_at
</dt>
<dd>
<p>
  <em>sys_open_by_handle_at( int dfd,  const char <strong>name,  struct file_handle *handle,  int *mnt_id,  int flags)</em><br>
 *obtain handle</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.584
</p>
</dd>
<dt>
sys_openat
</dt>
<dd>
<p>
  <em>sys_openat( int dfd,  const char <strong>filename,  int flags,  int mode)</em><br>
 *open file relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.490
</p>
</dd>
<dt>
sys_pause
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_pause,0)</em><br>
 <strong>suspend the thread until a signal is received</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.73
</p>
</dd>
<dt>
sys_perf_event_open
</dt>
<dd>
<p>
  <em>sys_perf_event_open( struct perf_event_attr <strong>attr_uptr,  pid_t pid,  int cpu,  int group_fd,  unsigned long flags)</em><br>
 *set up performance monitoring</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.572
</p>
</dd>
<dt>
sys_personality
</dt>
<dd>
<p>
  <em>sys_personality( unsigned int personality)</em><br>
 <strong>set the process execution domain</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.274
</p>
</dd>
<dt>
sys_pipe
</dt>
<dd>
<p>
  <em>sys_pipe( int <strong>filedes)</em><br>
 *create an interprocess channel</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.49
</p>
</dd>
<dt>
sys_pipe2
</dt>
<dd>
<p>
  <em>sys_pipe2( int <strong>filedes,  int flags)</em><br>
 *create pipe</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.562
</p>
</dd>
<dt>
sys_pivot_root
</dt>
<dd>
<p>
  <em>sys_pivot_root( const char <strong>new_root,  const char *put_old)</em><br>
 *change the root mount</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.314
</p>
</dd>
<dt>
sys_poll
</dt>
<dd>
<p>
  <em>sys_poll( struct poll_fd <strong>ufds,  unsigned int nfds,  long timeout_msecs)</em><br>
 *input/output multiplexing</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.19
</p>
</dd>
<dt>
sys_ppoll
</dt>
<dd>
<p>
  <em>sys_ppoll( struct pollfd <strong>ufds,  unsigned int nfds,  struct timespec *tsp,  const sigset_t *sigmask,  size_t sigsetsize)</em><br>
 *wait for some event on a file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.518
</p>
</dd>
<dt>
sys_prctl
</dt>
<dd>
<p>
  <em>sys_prctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)</em><br>
 <strong>operations on a process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.318
</p>
</dd>
<dt>
sys_pread64
</dt>
<dd>
<p>
  <em>sys_pread64( unsigned long fd,  char <strong>buf,  size_t count,  loff_t pos)</em><br>
 *read from or write to a file descriptor at a given offset</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.39
</p>
</dd>
<dt>
sys_preadv
</dt>
<dd>
<p>
  <em>sys_preadv( unsigned long fd,  const struct iovec <strong>vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)</em><br>
 *read or write data into multiple buffers</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.566
</p>
</dd>
<dt>
sys_prlimit64
</dt>
<dd>
<p>
  <em>sys_prlimit64( pid_t pid,  unsigned int resource,  const struct rlimit64 <strong>new_rlim,  struct rlimit64 *old_rlim)</em><br>
 *get/set resource limits</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.580
</p>
</dd>
<dt>
sys_process_vm_readv
</dt>
<dd>
<p>
  <em>sys_process_vm_readv( pid_t pid,  const struct iovec <strong>lvec,  unsigned long liovcnt,  const struct iovec *rvec,  unsigned long riovcnt,  unsigned long flags)</em><br>
 *transfer data between process address spaces</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.596
</p>
</dd>
<dt>
sys_process_vm_writev
</dt>
<dd>
<p>
  <em>sys_process_vm_writev( pid_t pid,  const struct iovec <strong>lvec,  unsigned long liovcnt,  const struct iovcc *rvec,  unsigned long riovcnt,  unsigned long flags)</em><br>
 *transfer data between process address spaces</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.598
</p>
</dd>
<dt>
sys_pselect6
</dt>
<dd>
<p>
  <em>sys_pselect6( int n,  fd_set <strong>inp,  fd_set *outp,  fd_set *exp,  struct timespec *tsp,  void *sig)</em><br>
 *select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO \-</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.516
</p>
</dd>
<dt>
sys_ptrace
</dt>
<dd>
<p>
  <em>sys_ptrace( long request,  long pid,  unsigned long addr,  unsigned long data)</em><br>
 <strong>process trace</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.208
</p>
</dd>
<dt>
sys_pwrite64
</dt>
<dd>
<p>
  <em>sys_pwrite64( unsigned int fd,  const char <strong>buf,  size_t count,  loff_t pos)</em><br>
 *read from or write to a file descriptor at a given offset</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.41
</p>
</dd>
<dt>
sys_pwritev
</dt>
<dd>
<p>
  <em>sys_pwritev( unsigned long fd,  const struct iovec <strong>vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)</em><br>
 *read or write data into multiple buffers</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.568
</p>
</dd>
<dt>
sys_quotactl
</dt>
<dd>
<p>
  <em>sys_quotactl( unsigned int cmd,  const char <strong>special,  qid_t id,  void *addr)</em><br>
 *manipulate disk quotas</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.356
</p>
</dd>
<dt>
sys_read
</dt>
<dd>
<p>
  <em>sys_read( unsigned int fd,  char <strong>buf,  size_t count)</em><br>
 *read from a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.5
</p>
</dd>
<dt>
sys_readahead
</dt>
<dd>
<p>
  <em>sys_readahead( int fd,  loff_t offset,  size_t count)</em><br>
 <strong>initiate file readahead into page cache</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.360
</p>
</dd>
<dt>
sys_readlink
</dt>
<dd>
<p>
  <em>sys_readlink( const char <strong>path,  char *buf,  int bufsiz)</em><br>
 *read the contents of a symbolic link</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.184
</p>
</dd>
<dt>
sys_readlinkat
</dt>
<dd>
<p>
  <em>sys_readlinkat( int dfd,  const char <strong>pathname,  char *buf,  int bufsiz)</em><br>
 *read value of a symbolic link</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.510
</p>
</dd>
<dt>
sys_readv
</dt>
<dd>
<p>
  <em>sys_readv( unsigned long fd,  const struct iovec <strong>vec,  unsigned long vlen)</em><br>
 *read a vector</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.43
</p>
</dd>
<dt>
sys_reboot
</dt>
<dd>
<p>
  <em>sys_reboot( int magic1,  int magic2,  unsigned int cmd,  void <strong>arg)</em><br>
 *reboot or enable/disable Ctrl-Alt-Del</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.342
</p>
</dd>
<dt>
sys_recvfrom
</dt>
<dd>
<p>
  <em>sys_recvfrom( int fd,  void <strong>ubuf,  size_t size,  unsigned flags,  struct sockaddr *addr,  int *addr_len)</em><br>
 *receive a message from a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.95
</p>
</dd>
<dt>
sys_recvmmsg
</dt>
<dd>
<p>
  <em>sys_recvmmsg( int fd,  struct msghdr <strong>mmsg,  unsigned int vlen,  unsigned int flags,  struct timespec *timeout)</em><br>
 *receive multiple messages on a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.574
</p>
</dd>
<dt>
sys_recvmsg
</dt>
<dd>
<p>
  <em>sys_recvmsg( int fd,  struct msghdr <strong>msg,  unsigned int flags)</em><br>
 *receive a message from a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.99
</p>
</dd>
<dt>
sys_remap_file_pages
</dt>
<dd>
<p>
  <em>sys_remap_file_pages( unsigned long start,  unsigned long size,  unsigned long prot,  unsigned long pgoff,  unsigned long flags)</em><br>
 <strong>create a nonlinear file mapping</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.410
</p>
</dd>
<dt>
sys_removexattr
</dt>
<dd>
<p>
  <em>sys_removexattr( const char <strong>pathname,  const char *name)</em><br>
 *remove an extended attribute</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.380
</p>
</dd>
<dt>
sys_rename
</dt>
<dd>
<p>
  <em>sys_rename( const char <strong>oldname,  const char *newname)</em><br>
 *rename file relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.170
</p>
</dd>
<dt>
sys_renameat
</dt>
<dd>
<p>
  <em>sys_renameat( int oldfd,  const char <strong>oldname,  int newfd,  const char *newname)</em><br>
 *change the name or location of a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.504
</p>
</dd>
<dt>
sys_renameat2
</dt>
<dd>
<p>
  <em>sys_renameat2( int olddfd,  const char  <strong>oldname,  int newdfd,  const char  *newname,  unsigned int flags)</em><br>
 *change the name or location of a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.608
</p>
</dd>
<dt>
sys_request_key
</dt>
<dd>
<p>
  <em>sys_request_key( const char <strong>_type,  const char *_description,  const char *_callout_info,  key_serial_t destringid)</em><br>
 *request a key from the kernel&#8217;s key management facility</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.474
</p>
</dd>
<dt>
sys_restart_syscall
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_restart_syscall,0)</em><br>
 <strong>restart a system call after interruption by a stop signal</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.416
</p>
</dd>
<dt>
sys_rmdir
</dt>
<dd>
<p>
  <em>sys_rmdir( const char <strong>pathname)</em><br>
 *remove a directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.174
</p>
</dd>
<dt>
sys_rt_sigaction
</dt>
<dd>
<p>
  <em>sys_rt_sigaction( int sig,  const struct sigaction <strong>act,  struct sigaction *oact,  size_t sigsetsize)</em><br>
 *examine and change a signal action</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.31
</p>
</dd>
<dt>
sys_rt_sigpending
</dt>
<dd>
<p>
  <em>sys_rt_sigpending( sigset_t <strong>set,  size_t sigsetsize)</em><br>
 *examine pending signals</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.260
</p>
</dd>
<dt>
sys_rt_sigprocmask
</dt>
<dd>
<p>
  <em>sys_rt_sigprocmask( int how,  sigset_t <strong>nset,  sigset_t *oset,  size_t sigsetsize)</em><br>
 *examine and change blocked signals</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.33
</p>
</dd>
<dt>
sys_rt_sigqueueinfo
</dt>
<dd>
<p>
  <em>sys_rt_sigqueueinfo( pid_t pid,  int sig,  siginfo_t <strong>uinfo)</em><br>
 *queue a signal and data</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.264
</p>
</dd>
<dt>
sys_rt_sigreturn
</dt>
<dd>
<p>
  <em>sys_rt_sigreturn( unsigned long __unused)</em><br>
 <strong>return from signal handler and cleanup stack frame</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.35
</p>
</dd>
<dt>
sys_rt_sigsuspend
</dt>
<dd>
<p>
  <em>sys_rt_sigsuspend( sigset_t <strong>unewset,  size_t sigsetsize)</em><br>
 *wait for a signal</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.266
</p>
</dd>
<dt>
sys_rt_sigtimedwait
</dt>
<dd>
<p>
  <em>sys_rt_sigtimedwait( const sigset_t <strong>uthese,  siginfo_t *uinfo,  const struct timespec *uts,  size_t sigsetsize)</em><br>
 *synchronously wait</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.262
</p>
</dd>
<dt>
sys_rt_tgsigqueueinfo
</dt>
<dd>
<p>
  <em>sys_rt_tgsigqueueinfo( pid_t tgid,  pid_t pid,  int sig,  siginfo_t <strong>uinfo)</em><br>
 *queue a signal and data</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.570
</p>
</dd>
<dt>
sys_sched_get_priority_max
</dt>
<dd>
<p>
  <em>sys_sched_get_priority_max( int policy)</em><br>
 <strong>get priority limits</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.296
</p>
</dd>
<dt>
sys_sched_get_priority_min
</dt>
<dd>
<p>
  <em>sys_sched_get_priority_min( int policy)</em><br>
 <strong>get static priority range</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.298
</p>
</dd>
<dt>
sys_sched_getaffinity
</dt>
<dd>
<p>
  <em>sys_sched_getaffinity( pid_t pid,  unsigned int len,  unsigned long <strong>user_mask_ptr)</em><br>
 *set and get a thread&#8217;s CPU affinity mask</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.394
</p>
</dd>
<dt>
sys_sched_getattr
</dt>
<dd>
<p>
  <em>sys_sched_getattr( pid_t pid,  struct sched_attr  <strong>attr,  unsigned int size,  unsigned int flags)</em><br>
 *sched_setattr, sched_getattr \-</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.606
</p>
</dd>
<dt>
sys_sched_getparam
</dt>
<dd>
<p>
  <em>sys_sched_getparam( pid_t pid,  struct sched_param <strong>param)</em><br>
 *get scheduling parameters</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.290
</p>
</dd>
<dt>
sys_sched_getscheduler
</dt>
<dd>
<p>
  <em>sys_sched_getscheduler( pid_t pid)</em><br>
 <strong>get scheduling policy</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.294
</p>
</dd>
<dt>
sys_sched_rr_get_interval
</dt>
<dd>
<p>
  <em>sys_sched_rr_get_interval( pid_t pid,  struct timespec <strong>interval)</em><br>
 *get execution time limits</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.300
</p>
</dd>
<dt>
sys_sched_setaffinity
</dt>
<dd>
<p>
  <em>sys_sched_setaffinity( pid_t pid,  unsigned int len,  unsigned long <strong>user_mask_ptr)</em><br>
 *set and get a thread&#8217;s CPU affinity mask</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.392
</p>
</dd>
<dt>
sys_sched_setattr
</dt>
<dd>
<p>
  <em>sys_sched_setattr( pid_t pid,  struct sched_attr  <strong>attr,  unsigned int flags)</em><br>
 *sched_setattr, sched_getattr \-</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.604
</p>
</dd>
<dt>
sys_sched_setparam
</dt>
<dd>
<p>
  <em>sys_sched_setparam( pid_t pid,  struct sched_param <strong>param)</em><br>
 *set scheduling parameters</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.288
</p>
</dd>
<dt>
sys_sched_setscheduler
</dt>
<dd>
<p>
  <em>sys_sched_setscheduler( pid_t pid,  int policy,  struct sched_param <strong>param)</em><br>
 *set scheduling policy and parameters</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.292
</p>
</dd>
<dt>
sys_sched_yield
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_sched_yield,0)</em><br>
 <strong>yield the processor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.53
</p>
</dd>
<dt>
sys_seccomp
</dt>
<dd>
<p>
  <em>sys_seccomp( unsigned int op,  unsigned int flags,  const char  <strong>uargs)</em><br>
 *operate on Secure Computing state of the process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.610
</p>
</dd>
<dt>
sys_select
</dt>
<dd>
<p>
  <em>sys_select( int n,  fd_set <strong>inp,  fd_set *outp,  fd_set *exp,  struct timeval *tvp)</em><br>
 *synchronous I/O multiplexing</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.51
</p>
</dd>
<dt>
sys_semctl
</dt>
<dd>
<p>
  <em>sys_semctl( int semid,  int semnum,  int cmd,  semun_u arg)</em><br>
 <strong>XSI semaphore control operations</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.138
</p>
</dd>
<dt>
sys_semget
</dt>
<dd>
<p>
  <em>sys_semget( key_t key,  int nsems,  int semflg)</em><br>
 <strong>get set of XSI semaphores</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.134
</p>
</dd>
<dt>
sys_semop
</dt>
<dd>
<p>
  <em>sys_semop( int semid,  struct sembuf <strong>tsops,  unsigned nsops)</em><br>
 *XSI semaphore operations</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.136
</p>
</dd>
<dt>
sys_semtimedop
</dt>
<dd>
<p>
  <em>sys_semtimedop( int semid,  struct sembuf <strong>tsops,  unsigned nsops,  const struct timespec *timeout)</em><br>
 *System V semaphore operations</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.418
</p>
</dd>
<dt>
sys_sendfile
</dt>
<dd>
<p>
  <em>sys_sendfile( int out_fd,  int in_fd,  off_t <strong>offset,  size_t count)</em><br>
 *transfer data between file descriptors</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.85
</p>
</dd>
<dt>
sys_sendmmsg
</dt>
<dd>
<p>
  <em>sys_sendmmsg( int fd,  struct mmsghdr <strong>mmsg,  unsigned int vlen,  unsigned int flags)</em><br>
 *send multiple messages on a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.590
</p>
</dd>
<dt>
sys_sendmsg
</dt>
<dd>
<p>
  <em>sys_sendmsg( int fd,  struct msghdr <strong>msg,  unsigned flags)</em><br>
 *send a message on a socket using a message structure</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.97
</p>
</dd>
<dt>
sys_sendto
</dt>
<dd>
<p>
  <em>sys_sendto( int fd,  void <strong>buff,  size_t len,  unsigned flags,  struct sockaddr *addr,  int addr_len)</em><br>
 *send a message on a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.93
</p>
</dd>
<dt>
sys_set_mempolicy
</dt>
<dd>
<p>
  <em>sys_set_mempolicy( int mode,  unsigned long <strong>nmask,  unsigned long maxnode)</em><br>
 *set default NUMA memory policy for a thread and its children</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.452
</p>
</dd>
<dt>
sys_set_robust_list
</dt>
<dd>
<p>
  <em>sys_set_robust_list( struct robust_list_head <strong>head,  size_t len)</em><br>
 *get/set list of robust futexes</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.522
</p>
</dd>
<dt>
sys_set_tid_address
</dt>
<dd>
<p>
  <em>sys_set_tid_address( int <strong>tidptr)</em><br>
 *set pointer to thread ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.414
</p>
</dd>
<dt>
sys_setdomainname
</dt>
<dd>
<p>
  <em>sys_setdomainname( char <strong>name,  int len)</em><br>
 *get/set NIS domain name</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.346
</p>
</dd>
<dt>
sys_setfsgid
</dt>
<dd>
<p>
  <em>sys_setfsgid( gid_t gid)</em><br>
 <strong>set group identity used for filesystem checks</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.252
</p>
</dd>
<dt>
sys_setfsuid
</dt>
<dd>
<p>
  <em>sys_setfsuid( uid_t uid)</em><br>
 <strong>set user identity used for filesystem checks</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.250
</p>
</dd>
<dt>
sys_setgid
</dt>
<dd>
<p>
  <em>sys_setgid( gid_t gid)</em><br>
 <strong>set-group-ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.218
</p>
</dd>
<dt>
sys_setgroups
</dt>
<dd>
<p>
  <em>sys_setgroups( int gidsetsize,  gid_t <strong>grouplist)</em><br>
 *get/set list of supplementary group IDs</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.238
</p>
</dd>
<dt>
sys_sethostname
</dt>
<dd>
<p>
  <em>sys_sethostname( char <strong>name,  int len)</em><br>
 *get/set hostname</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.344
</p>
</dd>
<dt>
sys_setitimer
</dt>
<dd>
<p>
  <em>sys_setitimer( int which,  struct itimerval <strong>value,  struct itimerval *ovalue)</em><br>
 *set the value of an interval timer</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.81
</p>
</dd>
<dt>
sys_setns
</dt>
<dd>
<p>
  <em>sys_setns( int fd,  int nstype)</em><br>
 <strong>reassociate thread with a namespace</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.592
</p>
</dd>
<dt>
sys_setpgid
</dt>
<dd>
<p>
  <em>sys_setpgid( pid_t pid,  pid_t pgid)</em><br>
 <strong>set process group ID for job control</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.224
</p>
</dd>
<dt>
sys_setpriority
</dt>
<dd>
<p>
  <em>sys_setpriority( int which,  int who,  int niceval)</em><br>
 <strong>set the nice value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.286
</p>
</dd>
<dt>
sys_setregid
</dt>
<dd>
<p>
  <em>sys_setregid( gid_t rgid,  gid_t egid)</em><br>
 <strong>set real and effective group IDs</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.234
</p>
</dd>
<dt>
sys_setresgid
</dt>
<dd>
<p>
  <em>sys_setresgid( gid_t rgid,  gid_t egid,  gid_t sgid)</em><br>
 <strong>set real, effective and saved user or group ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.244
</p>
</dd>
<dt>
sys_setresuid
</dt>
<dd>
<p>
  <em>sys_setresuid( uid_t <strong>ruid,  uid_t *euid,  uid_t *suid)</em><br>
 *set real, effective and saved user or group ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.240
</p>
</dd>
<dt>
sys_setreuid
</dt>
<dd>
<p>
  <em>sys_setreuid( uid_t ruid,  uid_t euid)</em><br>
 <strong>set real and effective user IDs</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.232
</p>
</dd>
<dt>
sys_setrlimit
</dt>
<dd>
<p>
  <em>sys_setrlimit( unsigned int resource,  struct rlimit <strong>rlim)</em><br>
 *control maximum resource consumption</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.324
</p>
</dd>
<dt>
sys_setsid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_setsid,0)</em><br>
 <strong>create session and set process group ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.230
</p>
</dd>
<dt>
sys_setsockopt
</dt>
<dd>
<p>
  <em>sys_setsockopt( int fd,  int level,  int optname,  char <strong>optval,  int optlen)</em><br>
 *set the socket options</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.113
</p>
</dd>
<dt>
sys_settimeofday
</dt>
<dd>
<p>
  <em>sys_settimeofday( struct timeval <strong>tv,  struct timezone *tz)</em><br>
 *get / set time</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.332
</p>
</dd>
<dt>
sys_setuid
</dt>
<dd>
<p>
  <em>sys_setuid( uid_t uid)</em><br>
 <strong>set user ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.216
</p>
</dd>
<dt>
sys_setxattr
</dt>
<dd>
<p>
  <em>sys_setxattr( const char <strong>pathname,  const char *name,  const void *value, size_t size,  int flags)</em><br>
 *set an extended attribute value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.362
</p>
</dd>
<dt>
sys_shmat
</dt>
<dd>
<p>
  <em>sys_shmat( int shmid,  char <strong>shmaddr,  int shmflg)</em><br>
 *XSI shared memory attach operation</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.65
</p>
</dd>
<dt>
sys_shmctl
</dt>
<dd>
<p>
  <em>sys_shmctl( int shmid,  int cmd,  struct shmid_ds <strong>buf)</em><br>
 *XSI shared memory control operations</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.67
</p>
</dd>
<dt>
sys_shmdt
</dt>
<dd>
<p>
  <em>sys_shmdt( char <strong>shmaddr)</em><br>
 *XSI shared memory detach operation</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.140
</p>
</dd>
<dt>
sys_shmget
</dt>
<dd>
<p>
  <em>sys_shmget( key_t key,  size_t size,  int shmflg)</em><br>
 <strong>get an XSI shared memory segment</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.63
</p>
</dd>
<dt>
sys_shutdown
</dt>
<dd>
<p>
  <em>sys_shutdown( int fd,  int how)</em><br>
 <strong>shut down socket send and receive operations</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.101
</p>
</dd>
<dt>
sys_sigaltstack
</dt>
<dd>
<p>
  <em>sys_sigaltstack( const stack_t <strong>uss,  stack_t *uoss)</em><br>
 *set and get signal alternate stack context</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.268
</p>
</dd>
<dt>
sys_signalfd
</dt>
<dd>
<p>
  <em>sys_signalfd( int ufd,  sigset_t <strong>user_mask,  size_t sizemask)</em><br>
 *create a file descriptor for accepting signals</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.540
</p>
</dd>
<dt>
sys_signalfd4
</dt>
<dd>
<p>
  <em>sys_signalfd4( int ufd,  sigset_t <strong>user_mask,  size_t sizemask,  int flags)</em><br>
 *create a file descriptor for accepting signals</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.554
</p>
</dd>
<dt>
sys_socket
</dt>
<dd>
<p>
  <em>sys_socket( int family,  int type,  int protocol)</em><br>
 <strong>create an endpoint for communication</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.87
</p>
</dd>
<dt>
sys_socketpair
</dt>
<dd>
<p>
  <em>sys_socketpair( int family,  int type,  int protocol,  int <strong>usockvec)</em><br>
 *create a pair of connected sockets</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.111
</p>
</dd>
<dt>
sys_splice
</dt>
<dd>
<p>
  <em>sys_splice( int fd_in,  loff_t <strong>off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)</em><br>
 *splice data to/from a pipe</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.526
</p>
</dd>
<dt>
sys_stat
</dt>
<dd>
<p>
  <em>sys_stat( const char <strong>filename,  struct stat *statbuf)</em><br>
 *get file status</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.13
</p>
</dd>
<dt>
sys_statfs
</dt>
<dd>
<p>
  <em>sys_statfs( const char <strong>pathname,  struct statfs *buf)</em><br>
 *get filesystem statistics</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.278
</p>
</dd>
<dt>
sys_swapoff
</dt>
<dd>
<p>
  <em>sys_swapoff( const char <strong>specialfile)</em><br>
 *start/stop swapping to file/device</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.340
</p>
</dd>
<dt>
sys_swapon
</dt>
<dd>
<p>
  <em>sys_swapon( const char <strong>specialfile,  int swap_flags)</em><br>
 *start/stop swapping to file/device</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.338
</p>
</dd>
<dt>
sys_symlink
</dt>
<dd>
<p>
  <em>sys_symlink( const char <strong>oldname,  const char *newname)</em><br>
 *make a symbolic link relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.182
</p>
</dd>
<dt>
sys_symlinkat
</dt>
<dd>
<p>
  <em>sys_symlinkat( const char <strong>oldname,  int newfd,  const char *newname)</em><br>
 *make a new name for a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.508
</p>
</dd>
<dt>
sys_sync
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_sync,0)</em><br>
 <strong>schedule file system updates</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.328
</p>
</dd>
<dt>
sys_sync_file_range
</dt>
<dd>
<p>
  <em>sys_sync_file_range( long fd,  loff_t offset,  loff_t bytes,  long flags)</em><br>
 <strong>sync a file segment with disk</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.530
</p>
</dd>
<dt>
sys_syncfs
</dt>
<dd>
<p>
  <em>sys_syncfs( int fd)</em><br>
 <strong>commit filesystem caches to disk</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.588
</p>
</dd>
<dt>
sys_sysfs
</dt>
<dd>
<p>
  <em>sys_sysfs( int option,  unsigned long arg1,  unsigned long arg2)</em><br>
 <strong>get filesystem type information</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.282
</p>
</dd>
<dt>
sys_sysinfo
</dt>
<dd>
<p>
  <em>sys_sysinfo( struct sysinfo <strong>info)</em><br>
 *return system information</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.204
</p>
</dd>
<dt>
sys_syslog
</dt>
<dd>
<p>
  <em>sys_syslog( int type,  char <strong>buf,  int len)</em><br>
 *log a message</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.212
</p>
</dd>
<dt>
sys_tee
</dt>
<dd>
<p>
  <em>sys_tee( int fdin,  int fdout,  size_t len,  unsigned int flags)</em><br>
 <strong>duplicating pipe content</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.528
</p>
</dd>
<dt>
sys_tgkill
</dt>
<dd>
<p>
  <em>sys_tgkill( pid_t tgid,  pid_t pid,  int sig)</em><br>
 <strong>send a signal to a thread</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.446
</p>
</dd>
<dt>
sys_time
</dt>
<dd>
<p>
  <em>sys_time( time_t <strong>tloc)</em><br>
 *get time</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.388
</p>
</dd>
<dt>
sys_timer_create
</dt>
<dd>
<p>
  <em>sys_timer_create( const clockid_t which_clock,  struct sigevent <strong>timer_event_spec,  timer_t *created_timer_id)</em><br>
 *create a per-process timer</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.422
</p>
</dd>
<dt>
sys_timer_delete
</dt>
<dd>
<p>
  <em>sys_timer_delete( timer_t timer_id)</em><br>
 <strong>delete a per-process timer</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.430
</p>
</dd>
<dt>
sys_timer_getoverrun
</dt>
<dd>
<p>
  <em>sys_timer_getoverrun( timer_t timer_id)</em><br>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.428
</p>
</dd>
<dt>
sys_timer_gettime
</dt>
<dd>
<p>
  <em>sys_timer_gettime( timer_t timer_id,  struct itimerspec <strong>setting)</em><br>
 *arm/disarm and fetch</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.426
</p>
</dd>
<dt>
sys_timer_settime
</dt>
<dd>
<p>
  <em>sys_timer_settime( timer_t timer_id,  int flags,  const struct itimerspec <strong>new_setting,  struct itimerspec *old_setting)</em><br>
 *arm/disarm and fetch</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.424
</p>
</dd>
<dt>
sys_timerfd_create
</dt>
<dd>
<p>
  <em>sys_timerfd_create( int clockid,  int flags)</em><br>
 <strong>timerfd_create, timerfd_settime, timerfd_gettime \-</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.542
</p>
</dd>
<dt>
sys_timerfd_gettime
</dt>
<dd>
<p>
  <em>sys_timerfd_gettime( int ufd,  struct itimerspec <strong>otmr)</em><br>
 *timerfd_create, timerfd_settime, timerfd_gettime \-</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.550
</p>
</dd>
<dt>
sys_timerfd_settime
</dt>
<dd>
<p>
  <em>sys_timerfd_settime( int ufd,  int flags,  const struct itimerspec <strong>utmr,  struct itimerspec *otmr)</em><br>
 *timerfd_create, timerfd_settime, timerfd_gettime \-</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.548
</p>
</dd>
<dt>
sys_times
</dt>
<dd>
<p>
  <em>sys_times( struct sysinfo <strong>info)</em><br>
 *get process and waited-for child process times</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.206
</p>
</dd>
<dt>
sys_tkill
</dt>
<dd>
<p>
  <em>sys_tkill( pid_t pid,  int sig)</em><br>
 <strong>send a signal to a thread</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.386
</p>
</dd>
<dt>
sys_truncate
</dt>
<dd>
<p>
  <em>sys_truncate( const char <strong>path,  long length)</em><br>
 *truncate a file to a specified length</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.158
</p>
</dd>
<dt>
sys_umask
</dt>
<dd>
<p>
  <em>sys_umask( int mask)</em><br>
 <strong>set and get the file mode creation mask</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.196
</p>
</dd>
<dt>
sys_umount2
</dt>
<dd>
<p>
  <em>sys_umount2( const char <strong>target,  int flags)</em><br>
 *unmount filesystem</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.336
</p>
</dd>
<dt>
sys_uname
</dt>
<dd>
<p>
  <em>sys_uname( struct old_utsname <strong>name)</em><br>
 *get the name of the current system</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.132
</p>
</dd>
<dt>
sys_unlink
</dt>
<dd>
<p>
  <em>sys_unlink( const char <strong>pathname)</em><br>
 *remove a directory entry relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.180
</p>
</dd>
<dt>
sys_unlinkat
</dt>
<dd>
<p>
  <em>sys_unlinkat( int dfd,  const char <strong>pathname,  int flag)</em><br>
 *delete a name and possibly the file it refers to</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.502
</p>
</dd>
<dt>
sys_unshare
</dt>
<dd>
<p>
  <em>sys_unshare( unsigned long unshare_flags)</em><br>
 <strong>disassociate parts of the process execution context</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.520
</p>
</dd>
<dt>
sys_ustat
</dt>
<dd>
<p>
  <em>sys_ustat( unsigned dev,  struct ustat <strong>ubuf)</em><br>
 *get filesystem statistics</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.276
</p>
</dd>
<dt>
sys_utime
</dt>
<dd>
<p>
  <em>sys_utime( char <strong>filename,  struct utimbuf *times)</em><br>
 *set file access and modification times</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.270
</p>
</dd>
<dt>
sys_utimensat
</dt>
<dd>
<p>
  <em>sys_utimensat( int dfd,  const char <strong>filename,  struct timespec *utimes, int flags)</em><br>
 *set file access and modification times relative to directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.536
</p>
</dd>
<dt>
sys_utimes
</dt>
<dd>
<p>
  <em>sys_utimes( char <strong>filename,  struct timeval *utimes)</em><br>
 *change file last access and modification times</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.448
</p>
</dd>
<dt>
sys_vfork
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_vfork,0)</em><br>
 <strong>create a child process and block parent</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.121
</p>
</dd>
<dt>
sys_vhangup
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_vhangup,0)</em><br>
 <strong>virtually hangup the current terminal</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.310
</p>
</dd>
<dt>
sys_vmsplice
</dt>
<dd>
<p>
  <em>sys_vmsplice( int fd,  const struct iovec <strong>iov,  unsigned long nr_segs, unsigned int flags)</em><br>
 *splice user pages to/from a pipe</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.532
</p>
</dd>
<dt>
sys_wait4
</dt>
<dd>
<p>
  <em>sys_wait4( pid_t upid,  int <strong>stat_addr,  int options,  struct rusage *ru)</em><br>
 *wait for process to change state, BSD style</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.128
</p>
</dd>
<dt>
sys_waitid
</dt>
<dd>
<p>
  <em>sys_waitid( int which,  pid_t upid,  struct siginfo <strong>infop,  int options,  struct rusage *ru)</em><br>
 *wait for a child process to change state</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.470
</p>
</dd>
<dt>
sys_write
</dt>
<dd>
<p>
  <em>sys_write( unsigned int fd,  const char <strong>buf,  size_t count)</em><br>
 *write on a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.7
</p>
</dd>
<dt>
sys_writev
</dt>
<dd>
<p>
  <em>sys_writev( unsigned long fd,  const struct iovec <strong>vec,  unsigned long vlen)</em><br>
 *write a vector</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.45
</p>
</dd>
</dl>
<p></p>
<p></p>
<hr><p><small>
Last updated
 2021-10-09 15:11:48 UTC
</small></p>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="AsciiDoc 8.6.10">
<title> minilib reference</title>
</head>
<body>
<h1> minilib reference</h1>
<p>
</p>
<a name="preamble"></a>
<p>The given sizes are estimations, each function added as single function within
a binary that much bytes to the overall size.</p>
<p>It is however not possible to give exact numbers, these depend on how much the compiler
can optimize for each call. What is different each time, depending on the circumstances.</p>
<p>To complicate things more, some functions will be inlined, others will be reused.</p>
<p>And, the choosen linker script will have it&#8217;s (sometimes surprising) influence.</p>
<p>---</p>
<hr>
<h2><a name="_configuration"></a>1.  Configuration</h2>
<p>Before the include of minilib.h, the minilib has to be configured.</p>
<p>The proposed way is to use the supplied script mini-gcc,<br>
which translates config options to define flags,<br>
and pipes the minilib header to gcc.</p>
<p>The config file is a bash script and can be a separate file,
or within one of the source files.</p>
<p>Since it is a bash script, it is possible to e.g.<br>
source other files from within the configuration.</p>
<p>A simple example is given below:</p>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>#if 0  // has to be the first line
# mini_start is the start routine.
# Most possibly needed
mini_start

# define and compile puts
mini_puts

INCLUDESRC
# this is a comment.
# INCLUDESRC has to be defined for one sourcefile.
# without it only the defines, and no implementations are parsed.

# shrink the binary with tools/shrinkelf
SHRINKELF

# use the linker script onlytext
# meaning, only text and stack sections are loaded
LDSCRIPT onlytext

# return, and the #endif statement are the last lines of the config
return
#endif

int main(int argc, char *argv[] ){
    puts("Hello, world!");
                return(0);
}</code></pre>
</td></tr></table>
<p>Only functions defined are going to be built.</p>
<p>There are several examples given within the folder examples,<br>
the files within the folder test are there for regression tests,<br>
but might also be helpful.</p>
<p>To compile a c source file with embedded configuration (as in the example above),<br>
type <em>mini-gcc --config example.c -o example example.c</em>.<br>
(Shortcut <em>mini-gcc -mlc example.c</em>)</p>
<p>(mini-gcc needs to be in the standard search path)<br>
If you&#8217;d like to "install" the mini-gcc, simply copy the script mini-gcc into /usr/local/bin,<br>
or wherever your executables live and can be found.</p>
<p>The minilib itself, as well as the supllied linker scripts are embedded into mini-gcc,<br>
and extracted and piped to gcc on demand.</p>
<p>(There are compatibility headers provided, e.g. stdio.h;<br>
these are however not stable and will most probably not work.<br>
I&#8217;m going to update them, as soon other and more important things are finished.)</p>
<p>In addition to the switches, which are built of the function&#8217;s name and the prefix <em>mini_</em>;<br>
e.g. <em>mini_puts</em>, these switches are defined for the configuration of minilib:</p>
<dl>
<dt>
mini_start
</dt>
<dd>
<p>
        Built the start routine, which is needed for the execution of the binary.
</p>
</dd>
<dt>
mini_buf 512
</dt>
<dd>
<p>
        the buf size in Bytes (here 512Bytes), which is used by minilib for input/output functions,
        the globals and malloc/free.
        Uncomment this, if you do not need globals or functions,
        depending on the buffer.
</p>
</dd>
<dt>
globals_on_stack
</dt>
<dd>
<p>
  put the minibuf and all globals onto the stack
        (this enables to omit all sections besides text and stack of the binary,
        when nowhere else globals (ans static variables) are used,
        for aggressive size optimization)
        The address of the globals is going to be stored within a fixed cpu register. (r15 at amd64)
</p>
</dd>
<dt>
mini_syscalls
</dt>
<dd>
<p>
        define the syscall wrappers, starting with <em>sys_</em>
</p>
</dd>
<dt>
HEADERGUARDS
</dt>
<dd>
<p>
        define the headerguards, which hopefully prevent the inclusion
        of the standard library headers.
</p>
</dd>
<dt>
OPTFLAG -Os
</dt>
<dd>
<p>
  optimization Flag. Os,O1,O2 should be save. O3 causes sometimes troubles
</p>
<pre><code>e.g. OPTFLAG '-g -O0'
(compile with debug info)</code></pre>
</dd>
<dt>
STRIPFLAG
</dt>
<dd>
<p>
  stripflag ( defaults to -s)<br>
        Leaving <em>STRIPFLAG</em> alone removes the flag parameter from gcc&#8217;s commandline.
</p>
</dd>
<dt>
INCLUDESRC
</dt>
<dd>
<p>
  Build minilib with source.<br>
        Without this switch, only defines and declarations are built<br>
        When building with several object files, most probably you should<br>
        enable this flag only for one object file.<br>
        It&#8217;s also possible to pass the switch via a define flag to gcc.<br>
        (<em>-DINCLUDESRC</em>)
</p>
</dd>
<dt>
LDSCRIPT default
</dt>
<dd>
<p>
        The ldscript to use<br>
  Can be one of: default, onlytext, onlytext.tiny, textandbss<br>
  Defines, which executable sections are going to be built.<br>
  <strong>default</strong>: .text .data .rodata .bss (.stack)<br>
  <strong>textandbss</strong>: .text .bss (.stack)<br>
  <strong>onlytext</strong>: .text (.stack)<br>
        <strong>onlytext.tiny</strong>: .text (the stack is defined by the kernel, and made executable)<br>
           Despite general meaning, an executable stack isn&#8217;t harmful, and even widely used.
     It just is important (as always), to check user input against e.g. overflows.
</p>
</dd>
<dt>
SHRINKELF
</dt>
<dd>
<p>
  Shrink the compiled binary with shrinkelf.<br>
        Aggressively strip the elf headers.
</p>
</dd>
<dt>
DEBUG
</dt>
<dd>
<p>
  generate debug info (-O0 -g). Overwrites OPTFLAG, STRIPFLAG and SHRINKELF
</p>
</dd>
</dl>
<p>---</p>
<hr>
<h2><a name="_conversions"></a>2. conversions</h2>
<a name="_itobin"></a><dl>
<dt>
_itobin
</dt>
<dd>
<p>
  <em>int _itobin(int i, char*buf, int prec, int groups )</em><br>
Size: ~188B <a href="../src/itobin.c">../src/itobin.c</a> l.8
</p>
</dd>
<dt>
_itohex
</dt>
<dd>
<p>
  <em>int _itohex(int i,char* buf,int padding, int capitals)</em><br>
Size: ~250B <a href="../src/itohex.c">../src/itohex.c</a> l.6
</p>
</dd>
<dt>
atoi
</dt>
<dd>
<p>
  <em>int atoi(const char <strong>c)</em><br>
 *convert a string to an integer</strong>
Size: ~32B <a href="../src/atoi.c">../src/atoi.c</a> l.6 manpage: <a href="manpages/stdlib/atoi.3.rst">atoi</a><br>
</p>
</dd>
<dt>
atol
</dt>
<dd>
<p>
  <em>long atol(const char <strong>c)</em><br>
 *convert a string to a long integer</strong>
Size: ~108B <a href="../src/atoi.c">../src/atoi.c</a> l.43 manpage: <a href="manpages/stdlib/atol.3.rst">atol</a><br>
</p>
</dd>
<dt>
dtodec
</dt>
<dd>
<p>
  <em>int dtodec(double d, char* buf, int precision)</em><br>
 <strong>Defines:</strong> uitodec<br>
Size: ~760B <a href="../src/dtodec.c">../src/dtodec.c</a> l.10
</p>
</dd>
<dt>
itoHEX
</dt>
<dd>
<p>
  <em>int itoHEX(int i,char* buf,int padding)</em><br>
</p>
</dd>
</dl>
<a name="itoHEX"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>convert a number to hexadecimal representation with big capitals.
 the conversion assumes a size of 32bits for integers,
 negative values are represented as they are stored internally.
 ( -1 is 0xFFFFFFFF, -2 0xFFFFFFFE, ... )</code></pre>
</td></tr></table>
<p>Size: ~250B <a href="../src/itohex.c">../src/itohex.c</a> l.65</p>
<a name="itobin"></a><dl>
<dt>
itobin
</dt>
<dd>
<p>
  <em>#define itobin(A,B,&#8230;) _itobin(A,B,VARARG(SHIFT(<em>VA_ARGS</em>),0), VARARG(SHIFT(ARG( <em>VA_ARGS</em> )),32) )</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>convert a number to a binary representation.
 the conversion assumes a size of 32bits for integers,
 negative values are represented as they are stored internally.
 ( -1 is 11111111111111111111111111111111,
   -2    11111111111111111111111111111110, ...)</code></pre>
</td></tr></table>
<p><a href="../src/itobin.c">../src/itobin.c</a> l.46</p>
<a name="itodec"></a><dl>
<dt>
itodec
</dt>
<dd>
<p>
  <em>int itodec(int i, char <strong>buf, int prec, char limiter )</em><br>
 *Defines:</strong> uitodec<br>
Size: ~555B <a href="../src/itodec.c">../src/itodec.c</a> l.118
</p>
</dd>
<dt>
itohex
</dt>
<dd>
<p>
  <em>int itohex(int i,char* buf,int padding)</em><br>
</p>
</dd>
</dl>
<a name="itohex"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>convert a number to hexadecimal representation.
 the conversion assumes a size of 32bits for integers,
 negative values are represented as they are stored internally.
 ( -1 is 0xffffffff, -2 0xfffffffe, ... )</code></pre>
</td></tr></table>
<p>Size: ~247B <a href="../src/itohex.c">../src/itohex.c</a> l.53</p>
<a name="itooct"></a><dl>
<dt>
itooct
</dt>
<dd>
<p>
  <em>int itooct(int i, char *buf)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>convert int to octal
 return the number of chars written.</code></pre>
</td></tr></table>
<p><a href="../src/itooct.c">../src/itooct.c</a> l.4</p>
<a name="ltodec"></a><dl>
<dt>
ltodec
</dt>
<dd>
<p>
  <em>int ltodec(long i, char *buf, int prec, char limiter )</em><br>
Size: ~323B <a href="../src/ltodec.c">../src/ltodec.c</a> l.75
</p>
</dd>
<dt>
strtol
</dt>
<dd>
<p>
  <em>long int strtol(const char <strong>c, const char **endp, int base)</em><br>
 *convert a string to a long integer</strong>
</p>
</dd>
</dl>
<a name="strtol"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>conversion
 doesn't check for overflow(!)</code></pre>
</td></tr></table>
<p>Size: ~252B <a href="../src/strtol.c">../src/strtol.c</a> l.5 manpage: <a href="manpages/stdlib/strtol.3.rst">strtol</a><br></p>
<a name="uitodec"></a><dl>
<dt>
uitodec
</dt>
<dd>
<p>
  <em>int uitodec(unsigned int i, char *buf, int prec, char limiter )</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>convert int to string.
 prec: precision, e.g. 4=&gt; 0087</code></pre>
</td></tr></table>
<p><a href="../src/itodec.c">../src/itodec.c</a> l.8</p>
<a name="ultodec"></a><dl>
<dt>
ultodec
</dt>
<dd>
<p>
  <em>int ultodec(unsigned long ui, char *buf, int prec, char limiter )</em><br>
Size: ~293B <a href="../src/ltodec.c">../src/ltodec.c</a> l.6
</p>
</dd>
</dl>
<p>---</p>
<hr>
<h2><a name="_directories"></a>3. directories</h2>
<a name="alphasort"></a><dl>
<dt>
alphasort
</dt>
<dd>
<p>
  <em>int alphasort( const struct dirent<strong> de1, const struct dirent</strong> de2 )</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>Sort dirents by name.
 Deviating of the standard,
 the asciitables is used for the comparison
 (using strcmp)</code></pre>
</td></tr></table>
<p><a href="../src/dirent/alphasort.c">../src/dirent/alphasort.c</a> l.7 manpage: <a href="manpages/gen/scandir.3.rst">alphasort</a><br></p>
<a name="basename"></a><dl>
<dt>
basename
</dt>
<dd>
<p>
  <em>char <strong>basename(char *path)</em><br>
 *Defines:</strong> strlen<br>
 <strong>return the last component of a pathname</strong>
Size: ~151B <a href="../src/basename.c">../src/basename.c</a> l.29 manpage: <a href="manpages/gen/basename.3.rst">basename</a><br>
</p>
</dd>
<dt>
chdir
</dt>
<dd>
<p>
  <em>int chdir(const char* path)</em><br>
 <strong>change working directory</strong>
Size: ~47B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.111 manpage: <a href="manpages/sys/chdir.2.rst">chdir</a><br>
</p>
</dd>
<dt>
dirbuf
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<a name="dirbuf"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>the switch for defining the dirbuf.
 used internally</code></pre>
</td></tr></table>
<p><a href="../include/dirent.h">../include/dirent.h</a> l.7</p>
<a name="dirbufsize"></a><dl>
<dt>
dirbufsize
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
<dt>
dirfd
</dt>
<dd>
<p>
  <em>int dirfd(DIR <strong>d)</em><br>
 *extract the file descriptor used by a DIR stream</strong>
<a href="../src/dirent/dirfd.c">../src/dirent/dirfd.c</a> l.2 manpage: <a href="manpages/gen/directory.3.rst">dirfd</a><br>
</p>
</dd>
<dt>
dirname
</dt>
<dd>
<p>
  <em>char <strong>dirname(char *s)</em><br>
 *Defines:</strong> strlen<br>
 <strong>report the parent directory name of a file pathname</strong>
Size: ~179B <a href="../src/dirname.c">../src/dirname.c</a> l.8 manpage: <a href="manpages/gen/dirname.3.rst">dirname</a><br>
</p>
</dd>
<dt>
fstat
</dt>
<dd>
<p>
  <em>int fstat(int fd,struct stat* statbuf)</em><br>
 <strong>get file status</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.109 manpage: <a href="manpages/sys/stat.2.rst">fstat</a><br>
</p>
</dd>
<dt>
getcwd
</dt>
<dd>
<p>
  <em>int getcwd( char <strong>buf,  unsigned long size)</em><br>
 *get the pathname of the current working directory</strong>
Size: ~61B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.120 manpage: <a href="manpages/gen/getcwd.3.rst">getcwd</a><br>
</p>
</dd>
<dt>
getdents
</dt>
<dd>
<p>
  <em>int getdents( unsigned int fd, struct dirent <strong>direntry, unsigned int count )</em><br>
 *get directory entries</strong>
Size: ~65B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.104 manpage: <a href="manpages/sys/getdirentries.2.rst">getdents</a><br>
</p>
</dd>
<dt>
inotify_add_watch
</dt>
<dd>
<p>
  <em>int inotify_add_watch( int fd,  const char *pathname,  u32 mask)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.195
</p>
</dd>
<dt>
inotify_init
</dt>
<dd>
<p>
  <em>int DEF_syscall(inotify_init,0)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.194
</p>
</dd>
<dt>
inotify_init1
</dt>
<dd>
<p>
  <em>int inotify_init1( int flags)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.197
</p>
</dd>
<dt>
inotify_rm_watch
</dt>
<dd>
<p>
  <em>int inotify_rm_watch( int fd,  __s32 wd)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.196
</p>
</dd>
<dt>
mkdir
</dt>
<dd>
<p>
  <em>int mkdir( const char <strong>pathname, int mode)</em><br>
 *make a directory relative to directory file descriptor</strong>
Size: ~59B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.158 manpage: <a href="manpages/sys/mkdir.2.rst">mkdir</a><br>
</p>
</dd>
<dt>
opendir
</dt>
<dd>
<p>
  <em>DIR <strong>opendir(const char *name )</em><br>
 *Defines:</strong> close brk write dirbuf open<br>
 <strong>open directory associated with file descriptor</strong>
Size: ~281B <a href="../src/dirent/opendir.c">../src/dirent/opendir.c</a> l.24 manpage: <a href="manpages/gen/directory.3.rst">opendir</a><br>
</p>
</dd>
<dt>
opendirp
</dt>
<dd>
<p>
  <em>DIR <strong>opendirp(const char *name, DIR *dir)</em><br>
 *Defines:</strong> dirbuf open close brk<br>
<a href="../src/dirent/opendir.c">../src/dirent/opendir.c</a> l.10
</p>
</dd>
<dt>
readdir
</dt>
<dd>
<p>
  <em>struct dirent <strong>readdir(DIR *dir)</em><br>
 *Defines:</strong> getdents dirbuf<br>
 <strong>read a directory</strong>
</p>
</dd>
</dl>
<a name="readdir"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>read a directory.
 return the next dirent, or 0, if the end is reached.
 return 0 on error and set errno,
 if mini_errno is not defined, return -errno on error</code></pre>
</td></tr></table>
<p>Size: ~133B <a href="../src/dirent/readdir.c">../src/dirent/readdir.c</a> l.10 manpage: <a href="manpages/gen/directory.3.rst">readdir</a><br></p>
<a name="rewinddir"></a><dl>
<dt>
rewinddir
</dt>
<dd>
<p>
  <em>void rewinddir(DIR <strong>dir)</em><br>
 *reset the position of a directory stream to the beginning</strong>
Size: ~80B <a href="../src/dirent/rewinddir.c">../src/dirent/rewinddir.c</a> l.2 manpage: <a href="manpages/gen/directory.3.rst">rewinddir</a><br>
</p>
</dd>
<dt>
rmdir
</dt>
<dd>
<p>
  <em>int rmdir( const char <strong>pathname)</em><br>
 *remove a directory</strong>
Size: ~47B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.159 manpage: <a href="manpages/sys/rmdir.2.rst">rmdir</a><br>
</p>
</dd>
<dt>
scandir
</dt>
<dd>
<p>
  <em>int scandir(const char <strong>path, struct dirent <strong>listing[], int (*fp_select)(const struct dirent *),    int (*cmp)(const struct dirent </strong>, const struct dirent *</strong>))</em><br>
 <strong>Defines:</strong> sbrk seterrno qsort memcpy brk getbrk errno open write dirbuf<br>
 <strong>scan a directory</strong>
</p>
</dd>
</dl>
<a name="scandir"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>list files and dirs in a directory

 This implementation uses malloc_brk() for the dynamic allocation
 of the listing, and tries to do as less copies as possible.
 The dynamically allocated space for the result list (**listing[])
 is guaranteed to be at one continuous memory location.

 if the select callback is 0, meaning all entries should be returned,
 There are no copies done at all,
 besides the copying from kernelspace to userspace.

 To free the space, allocated for the listing,
 either call free_brk(),
 when no other allocations via malloc_brk took place.

 Or save the brk before you call scandir,
 and restore it after the call.
 (e.g.)
 long savebrk=getbrk();
 int ret=scandir(...);
 brk(savebrk);
 Freeing single list entries might give unexpected results.

 returns the number of the read entries,
 or the negative errno on error.</code></pre>
</td></tr></table>
<p><a href="../src/dirent/scandir.c">../src/dirent/scandir.c</a> l.35 manpage: <a href="manpages/gen/scandir.3.rst">scandir</a><br></p>
<a name="scandir_bufsize"></a><dl>
<dt>
scandir_bufsize
</dt>
<dd>
<p>
  <em>//#define mini_scandir_bufsize 4096</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>the increment of the buffer of scandir in bytes for memory allocations
 (default:4096)</code></pre>
</td></tr></table>
<p><a href="../src/dirent/scandir.c">../src/dirent/scandir.c</a> l.4</p>
<a name="seekdir"></a><dl>
<dt>
seekdir
</dt>
<dd>
<p>
  <em>void seekdir(DIR <strong>dir, long off)</em><br>
 *set the position of a directory stream</strong>
Size: ~100B <a href="../src/dirent/seekdir.c">../src/dirent/seekdir.c</a> l.2 manpage: <a href="manpages/gen/directory.3.rst">seekdir</a><br>
</p>
</dd>
<dt>
telldir
</dt>
<dd>
<p>
  <em>long telldir(DIR <strong>dir)</em><br>
 *current location of a named directory stream</strong>
Size: ~32B <a href="../src/dirent/telldir.c">../src/dirent/telldir.c</a> l.2 manpage: <a href="manpages/gen/directory.3.rst">telldir</a><br>
</p>
</dd>
</dl>
<p><a name="telldir"></a>---</p>
<hr>
<h2><a name="_errno"></a>4. errno</h2>
<a name="errno"></a><dl>
<dt>
errno
</dt>
<dd>
<p>
  <em>#ifdef mini_errno</em><br>
 <strong>error return value</strong>
</p>
</dd>
<dt>
errno_str
</dt>
<dd>
<p>
  <em>char *errno_str(int err)</em><br>
</p>
</dd>
</dl>
<a name="errno_str"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>convert errno to str, with 3 chars length
 ending the string (global)
 with two \0\0, when errno&lt;100
 errnum must be &lt;200.</code></pre>
</td></tr></table>
<p>Size: ~123B <a href="../src/errno_str.c">../src/errno_str.c</a> l.7</p>
<a name="exit_errno"></a><dl>
<dt>
exit_errno
</dt>
<dd>
<p>
  <em>void exit_errno( int errnum )</em><br>
 <strong>Defines:</strong> write execve errno_str exit<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>exit, and execute /bin/errno
 this is intended to give a error message for the
 given errno num.
 Instead of having the error messages compiled
 into each binary, they can stay within one executable, "errno"
 This spares about 4kB, but needs errno installed to /bin/errno
 It's the drawback of not having a shared library,
 where all executables would share the same errno messages
 in memory.
 On the other hand, a shared library would need to be installed
 as well.
 The supplied errno can be negative,
 the absolute value is supplied to errno.</code></pre>
</td></tr></table>
<p><a href="../src/exit_errno.c">../src/exit_errno.c</a> l.17</p>
<a name="perror"></a><dl>
<dt>
perror
</dt>
<dd>
<p>
  <em>void perror(const char <strong>msg)</em><br>
 *Defines:</strong> strerror errno fileno strlen write<br>
 <strong>write error messages to standard error</strong>
Size: ~329B <a href="../src/perror.c">../src/perror.c</a> l.4 manpage: <a href="manpages/string/strerror.3.rst">perror</a><br>
</p>
</dd>
<dt>
ret_errno
</dt>
<dd>
<p>
  <em>#ifdef mini_errno</em><br>
</p>
</dd>
</dl>
<a name="ret_errno"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>This macro expands to a return, and
 (when mini_errno is defined) returns -1 and sets errno,
 or returns the negative errno value.</code></pre>
</td></tr></table>
<p><a href="../include/ret_errno.h">../include/ret_errno.h</a> l.5</p>
<a name="seterrno"></a><dl>
<dt>
seterrno
</dt>
<dd>
<p>
  <em>#ifdef mini_errno</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>set errno, but only when errno is defined.</code></pre>
</td></tr></table>
<p><a href="../include/seterrno.h">../include/seterrno.h</a> l.3</p>
<a name="strerror"></a><dl>
<dt>
strerror
</dt>
<dd>
<p>
  <em>char* strerror( int errnum )</em><br>
<a href="../src/strerror.c">../src/strerror.c</a> l.7 manpage: <a href="manpages/string/string.3.rst">strerror</a><br>
</p>
</dd>
<dt>
verbose_errstr
</dt>
<dd>
<p>
  <em>const char* verbose_errstr(int num)</em><br>
</p>
</dd>
</dl>
<a name="verbose_errstr"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>verbose error (errno) string.
 this adds about 3.5kB to the compiled binary(!)</code></pre>
</td></tr></table>
<p><a href="../include/errstr.h">../include/errstr.h</a> l.8</p>
<a name="verbose_errstr2"></a><dl>
<dt>
verbose_errstr2
</dt>
<dd>
<p>
  <em>const char* verbose_errstr2(int num)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>verbose error (errno) string.
 this adds about 3.5kB to the compiled binary(!)
 Trying to shrink that here.</code></pre>
</td></tr></table>
<p><a href="../include/errstr2.h">../include/errstr2.h</a> l.11</p>
<p>---</p>
<hr>
<h2><a name="_files"></a>5. files</h2>
<a name="_fopen"></a><dl>
<dt>
_fopen
</dt>
<dd>
<p>
  <em>FILE <strong>_fopen(int fd, const char</strong> filename, const char* mode, FILE <strong>f)</em><br>
 *Defines:</strong> fileno open close<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>modes implemented: r, r+, w, w+, a, a+</code></pre>
</td></tr></table>
<p>Size: ~316B <a href="../src/fopen.c">../src/fopen.c</a> l.12</p>
<a name="access"></a><dl>
<dt>
access
</dt>
<dd>
<p>
  <em>int access( const char <strong>filename, int mode)</em><br>
 *determine accessibility of a file relative to directory file</strong>
Size: ~59B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.161 manpage: <a href="manpages/sys/access.2.rst">access</a><br>
</p>
</dd>
<dt>
chmod
</dt>
<dd>
<p>
  <em>int chmod( const char <strong>filename, mode_t mode)</em><br>
 *change mode of a file relative to directory file descriptor</strong>
Size: ~59B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.184 manpage: <a href="manpages/sys/chmod.2.rst">chmod</a><br>
</p>
</dd>
<dt>
chown
</dt>
<dd>
<p>
  <em>int chown( const char <strong>filename, uid_t user, gid_t group)</em><br>
 *change owner and group of a file relative to directory</strong>
Size: ~71B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.185 manpage: <a href="manpages/sys/chown.2.rst">chown</a><br>
</p>
</dd>
<dt>
close
</dt>
<dd>
<p>
  <em>int close( int fd )</em><br>
 <strong>close a file descriptor</strong>
Size: ~51B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.100 manpage: <a href="manpages/sys/close.2.rst">close</a><br>
</p>
</dd>
<dt>
closedir
</dt>
<dd>
<p>
  <em>int closedir(DIR <strong>dir)</em><br>
 *Defines:</strong> brk getbrk<br>
 <strong>close a directory stream</strong>
Size: ~323B <a href="../src/dirent/closedir.c">../src/dirent/closedir.c</a> l.6 manpage: <a href="manpages/gen/directory.3.rst">closedir</a><br>
</p>
</dd>
<dt>
creat
</dt>
<dd>
<p>
  <em>int volatile creat( const char <strong>s, int mode )</em><br>
 *Defines:</strong> open<br>
 <strong>create a new file or rewrite an existing one</strong>
Size: ~124B <a href="../src/open.c">../src/open.c</a> l.36 manpage: <a href="manpages/compat-43/creat.2.rst">creat</a><br>
</p>
</dd>
<dt>
dup
</dt>
<dd>
<p>
  <em>int dup(int fd)</em><br>
 <strong>duplicate an open file descriptor</strong>
Size: ~51B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.116 manpage: <a href="manpages/sys/dup.2.rst">dup</a><br>
</p>
</dd>
<dt>
dup2
</dt>
<dd>
<p>
  <em>int dup2(int oldfd, int newfd)</em><br>
 <strong>duplicate a file descriptor</strong>
Size: ~63B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.117 manpage: <a href="manpages/sys/dup.2.rst">dup2</a><br>
</p>
</dd>
<dt>
dup3
</dt>
<dd>
<p>
  <em>int dup3(int oldfd, int newfd, int flags)</em><br>
 <strong>duplicate a file descriptor</strong>
Size: ~75B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.118 manpage: <a href="manpages/gen/dup3.3.rst">dup3</a><br>
</p>
</dd>
<dt>
fchmod
</dt>
<dd>
<p>
  <em>int fchmod( unsigned int fd, mode_t mode)</em><br>
 <strong>change mode of a file</strong>
Size: ~63B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.114 manpage: <a href="manpages/sys/chmod.2.rst">fchmod</a><br>
</p>
</dd>
<dt>
fchown
</dt>
<dd>
<p>
  <em>int fchown( unsigned int fd, uid_t user, gid_t group)</em><br>
 <strong>change owner and group of a file</strong>
Size: ~75B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.113 manpage: <a href="manpages/sys/chown.2.rst">fchown</a><br>
</p>
</dd>
<dt>
fcntl
</dt>
<dd>
<p>
  <em>int fcntl( unsigned int fd, unsigned int cmd, unsigned long arg)</em><br>
 <strong>file control</strong>
Size: ~77B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.162 manpage: <a href="manpages/sys/fcntl.2.rst">fcntl</a><br>
</p>
</dd>
<dt>
fsync
</dt>
<dd>
<p>
  <em>int fsync(int a1 )</em><br>
 <strong>synchronize changes to a file</strong>
Size: ~51B <a href="../include/lseek.h">../include/lseek.h</a> l.22 manpage: <a href="manpages/sys/fsync.2.rst">fsync</a><br>
</p>
</dd>
<dt>
ftruncate
</dt>
<dd>
<p>
  <em>int ftruncate(unsigned int a1, unsigned int a2 )</em><br>
 <strong>truncate a file to a specified length</strong>
Size: ~63B <a href="../include/lseek.h">../include/lseek.h</a> l.21 manpage: <a href="manpages/sys/truncate.2.rst">ftruncate</a><br>
</p>
</dd>
<dt>
link
</dt>
<dd>
<p>
  <em>int link( const char <strong>oldname, const char *newname)</em><br>
 *link one file to another file relative to two directory</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.122 manpage: <a href="manpages/sys/link.2.rst">link</a><br>
</p>
</dd>
<dt>
lseek
</dt>
<dd>
<p>
  <em>int lseek(unsigned int a1, int a2, int a3 )</em><br>
 <strong>move the read/write file offset</strong>
Size: ~75B <a href="../include/lseek.h">../include/lseek.h</a> l.19 manpage: <a href="manpages/sys/lseek.2.rst">lseek</a><br>
</p>
</dd>
<dt>
open
</dt>
<dd>
<p>
  <em>int volatile open( const char <strong>s, int flags, &#8230; )</em><br>
 *open file relative to directory file descriptor</strong>
</p>
</dd>
</dl>
<a name="open"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>open or create a file.
 warning: when using the flag O_CREAT,
 file permission flags have to be given
 as third argument. Otherwise file permission
 flags will be random. (I still do not know, what
 the flag showing up as "-T" means..)</code></pre>
</td></tr></table>
<p>Size: ~124B <a href="../src/open.c">../src/open.c</a> l.19 manpage: <a href="manpages/sys/open.2.rst">open</a><br></p>
<a name="readahead"></a><dl>
<dt>
readahead
</dt>
<dd>
<p>
  <em>int readahead( int fd,  loff_t offset,  size_t count)</em><br>
 <strong>initiate file readahead into page cache</strong>
Size: ~79B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.210
</p>
</dd>
<dt>
rename
</dt>
<dd>
<p>
  <em>int rename( const char* oldpath, const char* newpath )</em><br>
 <strong>rename file relative to directory file descriptor</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.106 manpage: <a href="manpages/sys/rename.2.rst">rename</a><br>
</p>
</dd>
<dt>
select
</dt>
<dd>
<p>
  <em>int volatile  select(int fd, volatile fd_set* readfd, volatile fd_set <strong>writefd, volatile fd_set *exceptfd, volatile struct timeval *wait)</em><br>
 *synchronous I/O multiplexing</strong>
Size: ~138B <a href="../include/select.h">../include/select.h</a> l.9 manpage: <a href="manpages/sys/select.2.rst">select</a><br>
</p>
</dd>
<dt>
sendfile
</dt>
<dd>
<p>
  <em>int sendfile( int out_fd,  int in_fd,  off_t <strong>offset,  size_t count)</em><br>
 *transfer data between file descriptors</strong>
Size: ~142B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.165 manpage: <a href="manpages/sys/sendfile.2.rst">sendfile</a><br>
</p>
</dd>
<dt>
stat
</dt>
<dd>
<p>
  <em>int stat(const char* filename,struct stat* statbuf)</em><br>
 <strong>get file status</strong>
Size: ~49B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.110 manpage: <a href="manpages/sys/stat.2.rst">stat</a><br>
</p>
</dd>
<dt>
symlink
</dt>
<dd>
<p>
  <em>int symlink( const char <strong>oldname,  const char *newname)</em><br>
 *make a symbolic link relative to directory file descriptor</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.123 manpage: <a href="manpages/sys/symlink.2.rst">symlink</a><br>
</p>
</dd>
<dt>
umask
</dt>
<dd>
<p>
  <em>int umask( int mask)</em><br>
 <strong>set and get the file mode creation mask</strong>
Size: ~51B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.209 manpage: <a href="manpages/sys/umask.2.rst">umask</a><br>
</p>
</dd>
<dt>
unlink
</dt>
<dd>
<p>
  <em>int unlink( const char* path)</em><br>
 <strong>remove a directory entry relative to directory file descriptor</strong>
Size: ~47B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.107 manpage: <a href="manpages/sys/unlink.2.rst">unlink</a><br>
</p>
</dd>
</dl>
<p><a name="unlink"></a>---</p>
<hr>
<h2><a name="_input"></a>6. input</h2>
<a name="fgetc"></a><dl>
<dt>
fgetc
</dt>
<dd>
<p>
  <em>int fgetc(FILE <strong>F)</em><br>
 *Defines:</strong> fileno read<br>
 <strong>get a byte from a stream</strong>
Size: ~57B <a href="../include/fgetc.h">../include/fgetc.h</a> l.11 manpage: <a href="manpages/stdio/getc.3.rst">fgetc</a><br>
</p>
</dd>
<dt>
fgets
</dt>
<dd>
<p>
  <em>char* fgets(char <strong>buf, int size, FILE</strong> F)</em><br>
 <strong>Defines:</strong> read fileno<br>
 <strong>get a string from a stream</strong>
<a href="../src/fgets.c">../src/fgets.c</a> l.6 manpage: <a href="manpages/stdio/fgets.3.rst">fgets</a><br>
</p>
</dd>
<dt>
getc
</dt>
<dd>
<p>
  <em>#define getc(F) fgetc(F)</em><br>
 <strong>Defines:</strong> fileno read<br>
 <strong>get a byte from a stream</strong>
<a href="../include/fgetc.h">../include/fgetc.h</a> l.26 manpage: <a href="manpages/stdio/getc.3.rst">getc</a><br>
</p>
</dd>
<dt>
getchar
</dt>
<dd>
<p>
  <em>#define getchar() fgetc(0)</em><br>
 <strong>Defines:</strong> fileno read<br>
 <strong>get a byte from a</strong>
<a href="../include/fgetc.h">../include/fgetc.h</a> l.29 manpage: <a href="manpages/stdio/getc.3.rst">getchar</a><br>
</p>
</dd>
<dt>
gets
</dt>
<dd>
<p>
  <em>#define gets(F) fgets(F,0xfffffff,stdin)</em><br>
 <strong>Defines:</strong> fileno read<br>
 <strong>get a string from a</strong>
<a href="../src/fgets.c">../src/fgets.c</a> l.29 manpage: <a href="manpages/stdio/fgets.3.rst">gets</a><br>
</p>
</dd>
<dt>
read
</dt>
<dd>
<p>
  <em>int read( int fd, void <strong>buf, int len )</em><br>
 *read from a file</strong>
Size: ~62B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.101 manpage: <a href="manpages/sys/read.2.rst">read</a><br>
</p>
</dd>
<dt>
ungetc
</dt>
<dd>
<p>
  <em>int ungetc(int c, FILE <strong>F)</em><br>
 *push byte back into input stream</strong>
</p>
</dd>
</dl>
<a name="ungetc"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>pushes one char back to the stream.
 Overwrites a previously pushed char
 (conforming to the posix spec)</code></pre>
</td></tr></table>
<p>Size: ~66B <a href="../include/fgetc.h">../include/fgetc.h</a> l.35 manpage: <a href="manpages/stdio/ungetc.3.rst">ungetc</a><br></p>
<p>---</p>
<hr>
<h2><a name="_ipc"></a>7. ipc</h2>
<a name="kill"></a><dl>
<dt>
kill
</dt>
<dd>
<p>
  <em>int kill( pid_t pid,  int sig)</em><br>
 <strong>send a signal to a process or a group of processes</strong>
Size: ~63B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.129 manpage: <a href="manpages/sys/kill.2.rst">kill</a><br>
</p>
</dd>
<dt>
mkfifo
</dt>
<dd>
<p>
  <em>int mkfifo( const char* path, mode_t mode )</em><br>
 <strong>make a FIFO special file relative to directory file descriptor</strong>
Size: ~68B <a href="../include/mkfifo.h">../include/mkfifo.h</a> l.4 manpage: <a href="manpages/sys/mkfifo.2.rst">mkfifo</a><br>
</p>
</dd>
<dt>
pipe
</dt>
<dd>
<p>
  <em>int pipe( int <strong>filedes)</em><br>
 *create an interprocess channel</strong>
Size: ~41B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.208 manpage: <a href="manpages/sys/pipe.2.rst">pipe</a><br>
</p>
</dd>
<dt>
raise
</dt>
<dd>
<p>
  <em>int raise(int signr)</em><br>
 <strong>Defines:</strong> getpid<br>
 <strong>send a signal to the executing process</strong>
Size: ~68B <a href="../src/sigaction.c">../src/sigaction.c</a> l.135 manpage: <a href="manpages/gen/raise.3.rst">raise</a><br>
</p>
</dd>
<dt>
rt_sigaction
</dt>
<dd>
<p>
  <em>int rt_sigaction( int sig,  const struct sigaction <strong>act,  struct sigaction *oact,  size_t sigsetsize)</em><br>
 *examine and change a signal action</strong>
Size: ~132B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.138
</p>
</dd>
<dt>
rt_sigprocmask
</dt>
<dd>
<p>
  <em>int rt_sigprocmask( int how,  sigset_t <strong>nset,  sigset_t *oset,  size_t sigsetsize)</em><br>
 *examine and change blocked signals</strong>
Size: ~132B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.170
</p>
</dd>
<dt>
rt_sigreturn
</dt>
<dd>
<p>
  <em>int rt_sigreturn( unsigned long __unused)</em><br>
 <strong>return from signal handler and cleanup stack frame</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.139
</p>
</dd>
<dt>
sigaction
</dt>
<dd>
<p>
  <em>int volatile sigaction(int sig, const struct sigaction <strong>act, struct sigaction *oact)</em><br>
 *Defines:</strong> memcpy<br>
 <strong>examine and change a signal action</strong>
Size: ~215B <a href="../src/sigaction.c">../src/sigaction.c</a> l.107 manpage: <a href="manpages/sys/sigaction.2.rst">sigaction</a><br>
</p>
</dd>
<dt>
sigaddset
</dt>
<dd>
<p>
  <em>int sigaddset(sigset_t <strong>set, int sig)</em><br>
 *add a signal to a signal set</strong>
Size: ~85B <a href="../src/sigaction.c">../src/sigaction.c</a> l.34 manpage: <a href="manpages/gen/sigsetops.3.rst">sigaddset</a><br>
</p>
</dd>
<dt>
sigdelset
</dt>
<dd>
<p>
  <em>int sigdelset(sigset_t <strong>set, int sig)</em><br>
 *delete a signal from a signal set</strong>
Size: ~85B <a href="../src/sigaction.c">../src/sigaction.c</a> l.58 manpage: <a href="manpages/gen/sigsetops.3.rst">sigdelset</a><br>
</p>
</dd>
<dt>
sigemptyset
</dt>
<dd>
<p>
  <em>int sigemptyset(sigset_t <strong>set)</em><br>
 *initialize and empty a signal set</strong>
Size: ~41B <a href="../src/sigaction.c">../src/sigaction.c</a> l.7 manpage: <a href="manpages/gen/sigsetops.3.rst">sigemptyset</a><br>
</p>
</dd>
<dt>
sigfillset
</dt>
<dd>
<p>
  <em>int sigfillset(sigset_t <strong>set)</em><br>
 *initialize and fill a signal set</strong>
Size: ~41B <a href="../src/sigaction.c">../src/sigaction.c</a> l.20 manpage: <a href="manpages/gen/sigsetops.3.rst">sigfillset</a><br>
</p>
</dd>
<dt>
sigismember
</dt>
<dd>
<p>
  <em>int sigismember(sigset_t <strong>set, int sig)</em><br>
 *test for a signal in a signal set</strong>
Size: ~44B <a href="../src/sigaction.c">../src/sigaction.c</a> l.75 manpage: <a href="manpages/gen/sigsetops.3.rst">sigismember</a><br>
</p>
</dd>
<dt>
signal
</dt>
<dd>
<p>
  <em>sighandler_t signal(int sig, sighandler_t func )</em><br>
 <strong>Defines:</strong> write memcpy<br>
 <strong>signal management</strong>
Size: ~337B <a href="../src/signal.c">../src/signal.c</a> l.8 manpage: <a href="manpages/gen/signal.3.rst">signal</a><br>
</p>
</dd>
<dt>
sigprocmask
</dt>
<dd>
<p>
  <em>int sigprocmask(int how, const sigset_t <strong>set, sigset_t *oldset)</em><br>
 *examine and change blocked signals</strong>
Size: ~130B <a href="../src/sigaction.c">../src/sigaction.c</a> l.52 manpage: <a href="manpages/sys/sigprocmask.2.rst">sigprocmask</a><br>
</p>
</dd>
<dt>
wait
</dt>
<dd>
<p>
  <em>pid_t wait(int <strong>wstatus)</em><br>
 *Defines:</strong> wait4<br>
 <strong>wait for a child process to stop or terminate</strong>
Size: ~122B <a href="../src/wait.c">../src/wait.c</a> l.8 manpage: <a href="manpages/sys/wait.2.rst">wait</a><br>
</p>
</dd>
<dt>
wait4
</dt>
<dd>
<p>
  <em>int wait4( pid_t upid,  int <strong>stat_addr,  int options,  struct rusage *ru)</em><br>
 *wait for process to change state, BSD style</strong>
Size: ~133B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.160 manpage: <a href="manpages/sys/wait.2.rst">wait4</a><br>
</p>
</dd>
<dt>
waitpid
</dt>
<dd>
<p>
  <em>pid_t waitpid(pid_t pid, int <strong>wstatus, int options)</em><br>
 *Defines:</strong> wait4<br>
 <strong>wait for a child process to stop or terminate</strong>
Size: ~138B <a href="../src/wait.c">../src/wait.c</a> l.16 manpage: <a href="manpages/sys/wait.2.rst">waitpid</a><br>
</p>
</dd>
</dl>
<p><a name="waitpid"></a>---</p>
<hr>
<h2><a name="_math"></a>8. math</h2>
<a name="abs"></a><dl>
<dt>
abs
</dt>
<dd>
<p>
  <em>int abs(int i)</em><br>
 <strong>return an integer absolute value</strong>
<a href="../include/math.h">../include/math.h</a> l.25 manpage: <a href="manpages/stdlib/abs.3.rst">abs</a><br>
</p>
</dd>
<dt>
div
</dt>
<dd>
<p>
  <em>div_t div(int numerator, int denominator)</em><br>
 <strong>compute the quotient and remainder of an integer division</strong>
Size: ~84B <a href="../include/math.h">../include/math.h</a> l.8 manpage: <a href="manpages/stdlib/div.3.rst">div</a><br>
</p>
</dd>
<dt>
djb2_hash
</dt>
<dd>
<p>
  <em>unsigned long djb2_hash(const unsigned char *str)</em><br>
</p>
</dd>
</dl>
<a name="djb2_hash"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>hashes, from d.j.Bernstein
 (http://www.cse.yorku.ca/~oz/hash.html)
 I've tested djb2_hash, and it gives quite good results.
 But I'm sure, Bernstein did think and test his algorithm sincerely.
 When combining djb2_hash and sdbm_hash, the probability of collisions
 might tend to zero.
 Me I'm going this way. I guess. I might check djb2_hash for collisions within a space of around 8 digits.</code></pre>
</td></tr></table>
<p>Size: ~86B <a href="../src/hashes.c">../src/hashes.c</a> l.10</p>
<a name="labs"></a><dl>
<dt>
labs
</dt>
<dd>
<p>
  <em>long int labs(long int i)</em><br>
 <strong>return a long integer absolute value</strong>
Size: ~46B <a href="../include/math.h">../include/math.h</a> l.30 manpage: <a href="manpages/stdlib/labs.3.rst">labs</a><br>
</p>
</dd>
<dt>
ldiv
</dt>
<dd>
<p>
  <em>ldiv_t ldiv(long int numerator, long int denominator)</em><br>
 <strong>compute quotient and remainder of a long division</strong>
Size: ~82B <a href="../include/math.h">../include/math.h</a> l.16 manpage: <a href="manpages/stdlib/ldiv.3.rst">ldiv</a><br>
</p>
</dd>
<dt>
rand
</dt>
<dd>
<p>
  <em>unsigned int rand()</em><br>
Size: ~118B <a href="../src/rand.c">../src/rand.c</a> l.15 manpage: <a href="manpages/stdlib/rand.3.rst">rand</a><br>
</p>
</dd>
<dt>
sdbm_hash
</dt>
<dd>
<p>
  <em>unsigned long sdbm_hash(const unsigned char *str)</em><br>
Size: ~80B <a href="../src/hashes.c">../src/hashes.c</a> l.21
</p>
</dd>
<dt>
srand
</dt>
<dd>
<p>
  <em>void srand( unsigned int i )</em><br>
 <strong>pseudo-random number generator</strong>
Size: ~48B <a href="../src/rand.c">../src/rand.c</a> l.7 manpage: <a href="manpages/stdlib/rand.3.rst">srand</a><br>
</p>
</dd>
</dl>
<p><a name="srand"></a>---</p>
<hr>
<h2><a name="_memory"></a>9. memory</h2>
<a name="brk"></a><dl>
<dt>
brk
</dt>
<dd>
<p>
  <em>int brk( const void* addr )</em><br>
 <strong>change data segment size</strong>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>set the brk to addr
 return 0 on success.
 conformant brk, when mini_errno is defined return -1 and set errno.
 if errno isn't available,
 returns the negative errno value on error</code></pre>
</td></tr></table>
<p>Size: ~66B <a href="../src/brk.c">../src/brk.c</a> l.19 manpage: <a href="manpages/sys/brk.2.rst">brk</a><br></p>
<a name="free"></a><dl>
<dt>
free
</dt>
<dd>
<p>
  <em>void free(void <strong>p)</em><br>
 *Defines:</strong> getbrk brk<br>
 <strong>free allocated memory</strong>
Size: ~32B <a href="../src/malloc.c">../src/malloc.c</a> l.139 manpage: <a href="manpages/stdlib/memory.3.rst">free</a><br>
</p>
</dd>
<dt>
free_brk
</dt>
<dd>
<p>
  <em>int free_brk()</em><br>
</p>
</dd>
</dl>
<a name="free_brk"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>free all memory,
 which has been allocated with malloc_brk.
 Returns 0, if memory has been freed;
 1, when there hasn't been any memory allocations with
 malloc_brk before.
 Then brk() gives an error, return the return value of brk</code></pre>
</td></tr></table>
<p><a href="../src/malloc.c">../src/malloc.c</a> l.234</p>
<a name="getbrk"></a><dl>
<dt>
getbrk
</dt>
<dd>
<p>
  <em>long getbrk()</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>get the current brk
 does either a syscall to brk,
 or returns the globally saved var</code></pre>
</td></tr></table>
<p><a href="../src/brk.c">../src/brk.c</a> l.39</p>
<a name="malloc"></a><dl>
<dt>
malloc
</dt>
<dd>
<p>
  <em>void* malloc(int size)</em><br>
 <strong>Defines:</strong> brk<br>
 <strong>a memory allocator</strong>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>0
 Here we go.. with the .. well.
 Fastes and smallest malloc/free combi ever.
 Not the smartest.
 Since it isn't exactly a memory allocation,
 instead it (mis)uses the minilib buf.
 ;) 1024 Bytes should be enough for everyone.
  Ok. If you really do need more memory -
  rethink your design, increase mini_mbuf,
  or use a proper malloc implementation.

 Here we use mbuf from top to bottom as stack.
 64 Bytes are left at the bottom as reserve.
 Possibly we'd like to complain
 about the lack of memory, before we exit..

 ATM, the 'free' is really lazy.
 It free's memory, but a real 'free' is only commited,
 when all memory below a freed area is also freed.
 Since the target of minilib atm are tiny tools,
 this might be ok.
 ;) but, as I told before -
 probably you should look out for a proper malloc implementation.
 It depends on your needs.

 I'm not sure yet,
 whether another implementation of free would be useful at all.
 Overall, I'd really prefer keeping minilib tiny.

 Reusing sparse freed memory areas also leads
 to a whole bunch of complications.
 cache misses, searching complexity,
 storage overhead, potentially page faults,
 just to name a few.

 I'm not sure whether it's worth it.

 And the existing malloc implementations
 out there are countless.

 ;) It's sometimes smarter to stay special,
 although in this case this means the opposite.
 /misc

 The memory layout looks like this:
 mlgl-&gt;ibuf and mlgl-&gt;mbuf do point to the same address range.
 mlgl-&gt;ibuf is provided for alignment and faster access to the int values.

 flag prev free is the first bit in size. (0x8000, eq 1000 0000 0000 0000 binary when free),
 (mbufsize)
 ```
      size  data  size    mini_buf size
      8008dataxxxx0004data8000</code></pre>
</td></tr></table>
<p>Size: ~173B <a href="../src/malloc.c">../src/malloc.c</a> l.119 manpage: <a href="manpages/stdlib/memory.3.rst">malloc</a><br></p>
<a name="malloc_brk"></a><dl>
<dt>
malloc_brk
</dt>
<dd>
<p>
  <em>void* malloc_brk(int size)</em><br>
 <strong>Defines:</strong> sbrk<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>allocate via setting the brk
 free and realloc can be used normally.
 The intention of malloc_brk is for subsequent calls to realloc.
 The saved data has not to be copied,
 instead realloc just writes the new size and sets
 the brk accordingly.
 if the break is saved before one or more calls to malloc_brk,
 the allocated memory can also be free'd by setting the brk to the saved value
 with brk(saved_brk)
 free_brk() free's all memory, which has been allocated with malloc_brk</code></pre>
</td></tr></table>
<p><a href="../src/malloc.c">../src/malloc.c</a> l.206</p>
<a name="memcmp"></a><dl>
<dt>
memcmp
</dt>
<dd>
<p>
  <em>int memcmp(const void* c1,const void* c2,int len)</em><br>
 <strong>compare bytes in memory</strong>
Size: ~44B <a href="../src/strcmp.c">../src/strcmp.c</a> l.84 manpage: <a href="manpages/string/memcmp.3.rst">memcmp</a><br>
</p>
</dd>
<dt>
memcpy
</dt>
<dd>
<p>
  <em>void <strong>memcpy( void *d, const void *s, int n )</em><br>
 *copy bytes in memory</strong>
Size: ~84B <a href="../src/memcpy.c">../src/memcpy.c</a> l.6 manpage: <a href="manpages/string/memcpy.3.rst">memcpy</a><br>
</p>
</dd>
<dt>
memfd_create
</dt>
<dd>
<p>
  <em>int memfd_create( const char  <strong>uname_ptr,  unsigned int flags)</em><br>
 *create an anonymous file</strong>
Size: ~59B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.174
</p>
</dd>
<dt>
memfrob
</dt>
<dd>
<p>
  <em>void* memfrob(void* s, unsigned int len)</em><br>
 <strong>frobnicate (encrypt) a memory area</strong>
Size: ~78B <a href="../src/memfrob.c">../src/memfrob.c</a> l.3
</p>
</dd>
<dt>
memmove
</dt>
<dd>
<p>
  <em>void* memmove(void <strong>dest, const void *src, int n)</em><br>
 *copy bytes in memory with overlapping areas</strong>
Size: ~88B <a href="../src/memmove.c">../src/memmove.c</a> l.3 manpage: <a href="manpages/string/memmove.3.rst">memmove</a><br>
</p>
</dd>
<dt>
memset
</dt>
<dd>
<p>
  <em>void <strong>memset( void *s, int c, int n)</em><br>
 *set bytes in memory</strong>
Size: ~90B <a href="../src/memset.c">../src/memset.c</a> l.3 manpage: <a href="manpages/string/memset.3.rst">memset</a><br>
</p>
</dd>
<dt>
mmap
</dt>
<dd>
<p>
  <em>void*  mmap(void* addr,  size_t len,  int prot,  int flags,  int fd,  off_t off)</em><br>
 <strong>map pages of memory</strong>
</p>
</dd>
</dl>
<a name="mmap"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>mmap wrapper
 address length is rounded up to a multiple of pagesize (4096 Bytes here)
 for the description, please look up the according manpage
 errno is only set, when mini_errno is defined
 if not, on error the negative errno value is returned.
 (e.g. -22 for "invalid argument")</code></pre>
</td></tr></table>
<p>Size: ~197B <a href="../src/mmap.c">../src/mmap.c</a> l.8 manpage: <a href="manpages/sys/mmap.2.rst">mmap</a><br></p>
<a name="mprotect"></a><dl>
<dt>
mprotect
</dt>
<dd>
<p>
  <em>int mprotect( POINTER <strong>a1, POINTER a2, int a3 )</em><br>
 *set protection of memory mapping</strong>
Size: ~146B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.206 manpage: <a href="manpages/sys/mprotect.2.rst">mprotect</a><br>
</p>
</dd>
<dt>
mremap
</dt>
<dd>
<p>
  <em>void* volatile  mremap(void* addr, size_t old_len, size_t new_len, int flags, void* new_addr)</em><br>
 <strong>remap a virtual memory address</strong>
Size: ~162B <a href="../include/mremap.h">../include/mremap.h</a> l.4
</p>
</dd>
<dt>
munmap
</dt>
<dd>
<p>
  <em>int munmap( unsigned long addr,  size_t len)</em><br>
 <strong>unmap pages of memory</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.213 manpage: <a href="manpages/sys/munmap.2.rst">munmap</a><br>
</p>
</dd>
<dt>
realloc
</dt>
<dd>
<p>
  <em>void* realloc(void <strong>p, int size)</em><br>
 *Defines:</strong> getbrk brk<br>
 <strong>memory reallocator</strong>
Size: ~636B <a href="../src/malloc.c">../src/malloc.c</a> l.252 manpage: <a href="manpages/stdlib/memory.3.rst">realloc</a><br>
</p>
</dd>
<dt>
sbrk
</dt>
<dd>
<p>
  <em>void* sbrk(long incr)</em><br>
 <strong>change data segment size</strong>
</p>
</dd>
</dl>
<a name="sbrk"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>Set the new brk, increment/decrement by incr bytes.
 return the old brk on success.
 conformant sbrk, when mini_errno is defined
 if no errno is available,
 returns the negative errno value on error</code></pre>
</td></tr></table>
<p>Size: ~108B <a href="../src/brk.c">../src/brk.c</a> l.57 manpage: <a href="manpages/sys/brk.2.rst">sbrk</a><br></p>
<a name="splice"></a><dl>
<dt>
splice
</dt>
<dd>
<p>
  <em>int splice( int fd_in,  loff_t <strong>off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)</em><br>
 *splice data to/from a pipe</strong>
Size: ~178B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.179
</p>
</dd>
<dt>
swap
</dt>
<dd>
<p>
  <em>void swap(void* a, void* b,int size)</em><br>
</p>
</dd>
</dl>
<a name="swap"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>swap a with b, with 'size' bytes
 swaps integers and longs at once, when size eq sizeof(int/long)</code></pre>
</td></tr></table>
<p><a href="../src/qsort.c">../src/qsort.c</a> l.31</p>
<p>---</p>
<hr>
<h2><a name="_output"></a>10. output</h2>
<a name="_mprints"></a><dl>
<dt>
_mprints
</dt>
<dd>
<p>
  <em>#define _mprints(&#8230;) dprints(STDOUT_FILENO, <em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> write<br>
<a href="../src/prints.c">../src/prints.c</a> l.69
</p>
</dd>
<dt>
ansicolors
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<a name="ansicolors"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>defines for ansicolors at the console, 16 color mode
the names are:
 AC_NORM ( white text on black background)
 AC_BLACK
 AC_RED
 AC_GREEN
 AC_BROWN
 AC_BLUE
 AC_MAGENTA
 AC_MARINE (= AC_CYAN)
 AC_LGREY
 AC_WHITE
 AC_GREY
 AC_LRED
 AC_LGREEN
 AC_YELLOW
 AC_LBLUE
 AC_LMAGENTA
 AC_LMARINE (= AC_LCYAN)
 AC_LWHITE
 AC_BGBLACK
 AC_BGRED
 AC_BGGREEN
 AC_BGBROWN
 AC_BGBLUE
 AC_BGMAGENTA
 AC_BGMARINE
 AC_BGLGREY
 AC_BGWHITE

 AC_BOLD
 AC_FAINT
 AC_CURSIVE
 AC_UNDERLINE
 AC_LIGHTBG
 AC_BLINK
 AC_INVERTED
 AC_INVERSE

 ( Faint to inverse are not available at every terminal )</code></pre>
</td></tr></table>
<p><a href="../include/ansicolors.h">../include/ansicolors.h</a> l.45</p>
<a name="dprintf"></a><dl>
<dt>
dprintf
</dt>
<dd>
<p>
  <em>int dprintf( int fd, const char <strong>fmt, &#8230; )</em><br>
 *Defines:</strong> write<br>
 <strong>print formatted output</strong>
Size: ~818B <a href="../src/dprintf.c">../src/dprintf.c</a> l.5 manpage: <a href="manpages/stdio/printf.3.rst">dprintf</a><br>
</p>
</dd>
<dt>
dprints
</dt>
<dd>
<p>
  <em>int dprints(int fd, const char <strong>msg,&#8230;)</em><br>
 *Defines:</strong> write<br>
<a href="../src/prints.c">../src/prints.c</a> l.48
</p>
</dd>
<dt>
eprint
</dt>
<dd>
<p>
  <em>#define eprint(str) write(STDERR_FILENO,str,strlen(str))</em><br>
 <strong>Defines:</strong> write strlen<br>
</p>
</dd>
</dl>
<a name="eprint"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write str to stderr. Needs strlen</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.52</p>
<a name="eprintfs"></a><dl>
<dt>
eprintfs
</dt>
<dd>
<p>
  <em>#define eprintfs(fmt,&#8230;) fprintfs(stderr, fmt, <em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> write fileno strlen<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write fmt and arguments to stderr.
 only format %s and %c are recognized</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.100</p>
<a name="eprintl"></a><dl>
<dt>
eprintl
</dt>
<dd>
<p>
  <em>#define eprintl() write(STDERR_FILENO,"\n",1)</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write a newline to stderr</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.61</p>
<a name="eprints"></a><dl>
<dt>
eprints
</dt>
<dd>
<p>
  <em>#define eprints(&#8230;) dprints(STDERR_FILENO,<em>VA_ARGS</em>,0)</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>print the string(s) supplied as arg(s) to stdout
 this macro has an variable argument count.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.19</p>
<a name="eprintsl"></a><dl>
<dt>
eprintsl
</dt>
<dd>
<p>
  <em>#define eprintsl(&#8230;) dprints(STDERR_FILENO,<em>VA_ARGS</em>,"\n",0)</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>print the string(s) supplied as arg(s) and newline to stderr</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.41</p>
<a name="eputs"></a><dl>
<dt>
eputs
</dt>
<dd>
<p>
  <em>#define eputs(msg) ( eprint(msg) + eprintl() )</em><br>
 <strong>Defines:</strong> strlen write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write msg to stderr, append a newline. Needs strlen.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.71</p>
<a name="ewrites"></a><dl>
<dt>
ewrites
</dt>
<dd>
<p>
  <em>#define ewrites(str) write(STDERR_FILENO,str,sizeof(str))</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write the constant str to stderr. Computes length with sizeof(str) at compile time.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.82</p>
<a name="fprint"></a><dl>
<dt>
fprint
</dt>
<dd>
<p>
  <em>#define fprint(&#8230;) fprintf(<em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> fileno write<br>
<a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.95
</p>
</dd>
<dt>
fprintf
</dt>
<dd>
<p>
  <em>#define fprintf(stream,&#8230;)  write(fileno(stream),mlgl&#8594;mbuf,sprintf(mlgl&#8594;mbuf,<em>VA_ARGS</em>))</em><br>
 <strong>Defines:</strong> write fileno<br>
<a href="../src/sprintf.c">../src/sprintf.c</a> l.228 manpage: <a href="manpages/stdio/printf.3.rst">fprintf</a><br>
</p>
</dd>
<dt>
fprintfs
</dt>
<dd>
<p>
  <em>int fprintfs( FILE* F, char <strong>fmt, &#8230;)</em><br>
 *Defines:</strong> write strlen fileno<br>
</p>
</dd>
</dl>
<a name="fprintfs"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>prints formatted and unbuffered output to the stream F.
 only %s and %c are recognized.
 no mini_buf or globals are used, so using fprintfs instead of fprintf can save some sections / bytes.</code></pre>
</td></tr></table>
<p>Size: ~427B <a href="../src/fprintfs.c">../src/fprintfs.c</a> l.10</p>
<a name="fprints"></a><dl>
<dt>
fprints
</dt>
<dd>
<p>
  <em>#define fprints(F,&#8230;) dprints(fileno(F),<em>VA_ARGS</em>,0)</em><br>
 <strong>Defines:</strong> write strlen fileno<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>print the string(s) supplied as arg(s) to stream
 this macro has an variable argument count.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.27</p>
<a name="fputc"></a><dl>
<dt>
fputc
</dt>
<dd>
<p>
  <em>int volatile fputc(int c, FILE* F)</em><br>
 <strong>Defines:</strong> write fileno<br>
 <strong>put a byte on a stream</strong>
Size: ~64B <a href="../include/fputc.h">../include/fputc.h</a> l.10 manpage: <a href="manpages/stdio/putc.3.rst">fputc</a><br>
</p>
</dd>
<dt>
fwrite
</dt>
<dd>
<p>
  <em>size_t fwrite(const void <strong>ptr, size_t size, size_t nmemb, FILE *f)</em><br>
 *Defines:</strong> write<br>
 <strong>binary output</strong>
Size: ~117B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.106 manpage: <a href="manpages/stdio/fread.3.rst">fwrite</a><br>
</p>
</dd>
<dt>
fwrites
</dt>
<dd>
<p>
  <em>#define fwrites(fd,str) write(fd,str,sizeof(str))</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<a name="fwrites"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write the constant str to fd. Computes length with sizeof(str) at compile time.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.88</p>
<a name="group_print"></a><dl>
<dt>
group_print
</dt>
<dd>
<p>
  __<br>
 <strong>Defines:</strong> strlen fileno write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>enable print and related functions
 This switch enables strlen;
 but neither globals nor the mini_buf are used.</code></pre>
</td></tr></table>
<p><a href="../macros/defgroups.h">../macros/defgroups.h</a> l.13</p>
<a name="group_write"></a><dl>
<dt>
group_write
</dt>
<dd>
<p>
  __<br>
 <strong>Defines:</strong> write ewrite<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write, and related functions
 these functions do not depend on strlen,
 or any globals.</code></pre>
</td></tr></table>
<p><a href="../macros/defgroups.h">../macros/defgroups.h</a> l.23</p>
<a name="print"></a><dl>
<dt>
print
</dt>
<dd>
<p>
  <em>#define print(str) write(STDOUT_FILENO,str,strlen(str))</em><br>
 <strong>Defines:</strong> strlen write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write str to stdout. Needs strlen</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.48</p>
<a name="printf"></a><dl>
<dt>
printf
</dt>
<dd>
<p>
  <em>#define printf(&#8230;) fprintf(stdout,<em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> write fileno<br>
 <strong>print formatted output</strong>
<a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.91 manpage: <a href="manpages/stdio/printf.3.rst">printf</a><br>
</p>
</dd>
<dt>
printfs
</dt>
<dd>
<p>
  <em>#define printfs(fmt,&#8230;) fprintfs(stdout, fmt, <em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> fileno strlen write<br>
</p>
</dd>
</dl>
<a name="printfs"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write fmt and arguments to stdout.
 only format %s and %c are recognized</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.94</p>
<a name="printl"></a><dl>
<dt>
printl
</dt>
<dd>
<p>
  <em>#define printl() write(STDOUT_FILENO,"\n",1)</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write a newline to stdout</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.57</p>
<a name="prints"></a><dl>
<dt>
prints
</dt>
<dd>
<p>
  <em>#define prints(&#8230;) _mprints(<em>VA_ARGS</em>,0)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>print the string(s) supplied as arg(s) to stdout,
 this macro has an variable argument count.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.12</p>
<a name="printsl"></a><dl>
<dt>
printsl
</dt>
<dd>
<p>
  <em>#define printsl(&#8230;) _mprints(<em>VA_ARGS</em>,"\n",0)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>print the string(s) supplied as arg(s) and newline to stdout</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.35</p>
<a name="putc"></a><dl>
<dt>
putc
</dt>
<dd>
<p>
  <em>#define putc(c,stream) fputc(c,stream)</em><br>
 <strong>Defines:</strong> fileno write<br>
 <strong>put a byte on a stream</strong>
<a href="../include/fputc.h">../include/fputc.h</a> l.19 manpage: <a href="manpages/stdio/putc.3.rst">putc</a><br>
</p>
</dd>
<dt>
putchar
</dt>
<dd>
<p>
  <em>#define putchar(c) fputc(c,stdout)</em><br>
 <strong>Defines:</strong> write fileno<br>
 <strong>put a byte on a stdout stream</strong>
<a href="../include/fputc.h">../include/fputc.h</a> l.16 manpage: <a href="manpages/stdio/putc.3.rst">putchar</a><br>
</p>
</dd>
<dt>
puts
</dt>
<dd>
<p>
  <em>#define puts(msg) ( print(msg) + printl() )</em><br>
 <strong>Defines:</strong> strlen write<br>
 <strong>put a string on standard output</strong>
</p>
</dd>
</dl>
<a name="puts"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write msg to stdout, append a newline. Needs strlen.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.67 manpage: <a href="manpages/stdio/fputs.3.rst">puts</a><br></p>
<a name="shortcolornames"></a><dl>
<dt>
shortcolornames
</dt>
<dd>
<p>
  __<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>short ansi color names
 all colornames, without the praefix "AC_"</code></pre>
</td></tr></table>
<p><a href="../include/ansicolors.h">../include/ansicolors.h</a> l.103</p>
<a name="snprintf"></a><dl>
<dt>
snprintf
</dt>
<dd>
<p>
  <em>int snprintf( char <strong>buf, size_t size, const char *fmt, &#8230; )</em><br>
 *Defines:</strong> write<br>
 <strong>print formatted output</strong>
Size: ~738B <a href="../src/snprintf.c">../src/snprintf.c</a> l.5 manpage: <a href="manpages/stdio/printf.3.rst">snprintf</a><br>
</p>
</dd>
<dt>
vfprintf
</dt>
<dd>
<p>
  <em>#define vfprintf(&#8230;) fprintf(<em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> write fileno<br>
<a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.100 manpage: <a href="manpages/stdio/printf.3.rst">vfprintf</a><br>
</p>
</dd>
<dt>
vsnprintf
</dt>
<dd>
<p>
  <em>int vsnprintf(char <strong>buf, size_t size, const char</strong> fmt, va_list args )</em><br>
 <strong>Defines:</strong> write<br>
 <strong>format output of a stdarg argument list</strong>
</p>
</dd>
</dl>
<a name="vsnprintf"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>the function, translating the fmt of printf.
 warning - most possibly you'd like to define besides fprintf, or family,
 mini_itodec (%d conversion)
 mini_atoi is needed for grouping numbers</code></pre>
</td></tr></table>
<p>Size: ~590B <a href="../src/sprintf.c">../src/sprintf.c</a> l.41 manpage: <a href="manpages/stdio/printf.3.rst">vsnprintf</a><br></p>
<a name="vsprintf"></a><dl>
<dt>
vsprintf
</dt>
<dd>
<p>
  <em>int vsprintf( char *buf, const char *fmt, &#8230; )</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write fmt and arguments into buf
 calls vsnprintf,
 the size is limited to 4096 by default.</code></pre>
</td></tr></table>
<p><a href="../src/vsprintf.c">../src/vsprintf.c</a> l.9 manpage: <a href="manpages/stdio/printf.3.rst">vsprintf</a><br></p>
<a name="write"></a><dl>
<dt>
write
</dt>
<dd>
<p>
  <em>int write(int fd,const void <strong>buf, int len )</em><br>
 *write on a file</strong>
Size: ~65B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.102 manpage: <a href="manpages/sys/write.2.rst">write</a><br>
</p>
</dd>
<dt>
writes
</dt>
<dd>
<p>
  <em>#define writes(str) write(STDOUT_FILENO,str,sizeof(str))</em><br>
 <strong>Defines:</strong> write<br>
</p>
</dd>
</dl>
<a name="writes"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>write the constant str to stdout. Computes length with sizeof(str) at compile time.</code></pre>
</td></tr></table>
<p><a href="../include/prints.h">../include/prints.h</a> l.78</p>
<p>---</p>
<hr>
<h2><a name="_process"></a>11. process</h2>
<a name="abort"></a><dl>
<dt>
abort
</dt>
<dd>
<p>
  <em>void abort()</em><br>
 <strong>Defines:</strong> write memcpy getpid<br>
<a href="../src/abort.c">../src/abort.c</a> l.3 manpage: <a href="manpages/stdlib/abort.3.rst">abort</a><br>
</p>
</dd>
<dt>
atexit
</dt>
<dd>
<p>
  <em>int atexit( functionp* func )</em><br>
 <strong>Defines:</strong> globals<br>
</p>
</dd>
</dl>
<a name="atexit"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>register functions, which are callen on exit in reverse order
 the switch mini_atexit takes a optional number,
 which defines the maximum numbers of functions to be registered.
 (defaults to 8)</code></pre>
</td></tr></table>
<p><a href="../src/atexit.c">../src/atexit.c</a> l.7 manpage: <a href="manpages/stdlib/atexit.3.rst">atexit</a><br></p>
<a name="clone"></a><dl>
<dt>
clone
</dt>
<dd>
<p>
  <em>int clone( int clone_flags,  unsigned long stack,  void *parent_tid,  void *child_tid)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.200
</p>
</dd>
<dt>
clone_t
</dt>
<dd>
<p>
  <em>int clone_t(int flags)</em><br>
<a href="../include/clone.h">../include/clone.h</a> l.7
</p>
</dd>
<dt>
execl
</dt>
<dd>
<p>
  <em>int execl(const char <strong>pathname, const char</strong> arg0,&#8230; )</em><br>
 <strong>Defines:</strong> execve environ<br>
<a href="../src/execl.c">../src/execl.c</a> l.6 manpage: <a href="manpages/gen/exec.3.rst">execl</a><br>
</p>
</dd>
<dt>
execv
</dt>
<dd>
<p>
  <em>int execv(const char <strong>pathname, char *const argv[])</em><br>
 *Defines:</strong> environ execve<br>
 <strong>execute a file</strong>
Size: ~300B <a href="../src/execvp.c">../src/execvp.c</a> l.9 manpage: <a href="manpages/gen/exec.3.rst">execv</a><br>
</p>
</dd>
<dt>
execve
</dt>
<dd>
<p>
  <em>int execve( const char <strong>filename,  char</strong> const* argv, char* const* envp)</em><br>
 <strong>execute program</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.127 manpage: <a href="manpages/sys/execve.2.rst">execve</a><br>
</p>
</dd>
<dt>
execveat
</dt>
<dd>
<p>
  <em>int execveat( int dirfd, const char <strong>filename,  char</strong> const* argv, char* const* envp, int flags)</em><br>
 <strong>execute program relative to a directory file descriptor</strong>
Size: ~158B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.157
</p>
</dd>
<dt>
execvp
</dt>
<dd>
<p>
  <em>int execvp(const char <strong>file, char *const argv[])</em><br>
 *Defines:</strong> execve access environ<br>
 <strong>execute a file</strong>
Size: ~556B <a href="../src/execvp.c">../src/execvp.c</a> l.58 manpage: <a href="manpages/gen/exec.3.rst">execvp</a><br>
</p>
</dd>
<dt>
execvpe
</dt>
<dd>
<p>
  <em>int execvpe(const char <strong>file, char *const argv[], char *const envp[])</em><br>
 *Defines:</strong> execve environ access<br>
 <strong>execute a file</strong>
</p>
</dd>
</dl>
<a name="execvpe"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>When invoked with a filename, starting with "." or "/",
 interprets this as absolute path. (calls execve with the pathname)
 Looks for file in the PATH environment, othwerise.</code></pre>
</td></tr></table>
<p>Size: ~556B <a href="../src/execvp.c">../src/execvp.c</a> l.18</p>
<a name="fexecve"></a><dl>
<dt>
fexecve
</dt>
<dd>
<p>
  <em>int fexecve(int fd, char <strong>const argv[], char *const envp[])</em><br>
 *execute a file</strong>
Size: ~151B <a href="../include/fexecve.h">../include/fexecve.h</a> l.3 manpage: <a href="manpages/sys/execve.2.rst">fexecve</a><br>
</p>
</dd>
<dt>
fexecveat
</dt>
<dd>
<p>
  <em>int fexecveat(int fd, char *const argv[], char *const envp[])</em><br>
Size: ~151B <a href="../include/fexecveat.h">../include/fexecveat.h</a> l.3
</p>
</dd>
<dt>
fork
</dt>
<dd>
<p>
  <em>int DEF_syscall(fork,0)</em><br>
 <strong>create a new process</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.131 manpage: <a href="manpages/sys/fork.2.rst">fork</a><br>
</p>
</dd>
<dt>
getenv
</dt>
<dd>
<p>
  <em>char* getenv(const char* name)</em><br>
 <strong>Defines:</strong> environ<br>
 <strong>get value of an environment variable</strong>
Size: ~106B <a href="../src/getenv.c">../src/getenv.c</a> l.8 manpage: <a href="manpages/stdlib/getenv.3.rst">getenv</a><br>
</p>
</dd>
<dt>
getpgrp
</dt>
<dd>
<p>
  <em>int DEF_syscall(getpgrp,0)</em><br>
 <strong>get the process group ID of the calling process</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.190 manpage: <a href="manpages/sys/getpgrp.2.rst">getpgrp</a><br>
</p>
</dd>
<dt>
getpid
</dt>
<dd>
<p>
  <em>int DEF_syscall(getpid,0 )</em><br>
 <strong>get the process ID</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.145 manpage: <a href="manpages/sys/getpid.2.rst">getpid</a><br>
</p>
</dd>
<dt>
getppid
</dt>
<dd>
<p>
  <em>int DEF_syscall(getppid,0)</em><br>
 <strong>get the parent process ID</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.187 manpage: <a href="manpages/sys/getpid.2.rst">getppid</a><br>
</p>
</dd>
<dt>
setpgid
</dt>
<dd>
<p>
  <em>int setpgid( pid_t pid, pid_t pgid)</em><br>
 <strong>set process group ID for job control</strong>
Size: ~63B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.188 manpage: <a href="manpages/sys/setpgid.2.rst">setpgid</a><br>
</p>
</dd>
<dt>
setsid
</dt>
<dd>
<p>
  <em>int DEF_syscall(setsid,0 )</em><br>
 <strong>create session and set process group ID</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.146 manpage: <a href="manpages/sys/setsid.2.rst">setsid</a><br>
</p>
</dd>
<dt>
system
</dt>
<dd>
<p>
  <em>int system( const char* command )</em><br>
 <strong>Defines:</strong> write wait4 environ vfork execve<br>
 <strong>issue a command</strong>
Size: ~326B <a href="../src/system.c">../src/system.c</a> l.4 manpage: <a href="manpages/stdlib/system.3.rst">system</a><br>
</p>
</dd>
<dt>
vexec
</dt>
<dd>
<p>
  <em>int vexec( const char* path, char* const* argv, char* const* envp )</em><br>
 <strong>Defines:</strong> seterrno wait4<br>
</p>
</dd>
</dl>
<a name="vexec"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>execute a path, wait until the executed file exits.
 Deviating of system() an absolute pathname is taken.
 sets errno on error.</code></pre>
</td></tr></table>
<p><a href="../src/vexec.c">../src/vexec.c</a> l.6</p>
<a name="vexec_q"></a><dl>
<dt>
vexec_q
</dt>
<dd>
<p>
  <em>int vexec_q( const char* path, char* const* argv, char* const* envp )</em><br>
 <strong>Defines:</strong> seterrno<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>execute a path, wait until the executed file exits,
 do not write any output of the process. (close stdout)
 Deviating of system() an absolute pathname is taken.</code></pre>
</td></tr></table>
<p><a href="../src/vexec.c">../src/vexec.c</a> l.30</p>
<a name="vfork"></a><dl>
<dt>
vfork
</dt>
<dd>
<p>
  <em>int DEF_syscall(vfork,0)</em><br>
 <strong>create a child process and block parent</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.132 manpage: <a href="manpages/sys/vfork.2.rst">vfork</a><br>
</p>
</dd>
</dl>
<p>---</p>
<hr>
<h2><a name="_regex"></a>12. regex</h2>
<a name="ext_match"></a><dl>
<dt>
ext_match
</dt>
<dd>
<p>
  <em>int ext_match(char *text, const char *re, void(*p_match)(int number, char *pos,int len), int(*p_match_char)(int number, char *match_char), regex_match *st_match)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>regex engine
 This is somewhere between a fully fledged expression machine,
 and a simplicistic solution.
 The engine matches from left to right,
 no backtracking is done. (Besides the matching %'s,
 which are callen right to left)

 It is a compromise between performance, size
 and capabilities.
 The logic is different of a "regular" regular expression
 machine, but has advantages (and disadvantages).
 I'd say, the main advantage is the easiness of adding callbacks,
 and defining your own matching/logic within these.
 Performance might be better as well overall,
 but this depends also on the expressions.

 matches:

 * for every count of any char
 + for 1 or more chars
 ? for 1 char
 # for space or end of text (0)
 $ match end of text

 backslash: escape *,?,%,$,!,+,#,&amp; and backslash itself.
 !: invert the matching of the next character or character class


 predefined character classes:
 \d - digit
 \D - nondigit
 \s - space
 \S - nonspace
 \w - word character ( defined as ascii 32-126,160-255 )
 \W - nonword character ( defined as ascii 0-31,127-159 )


 [xyz]: character classes, here x,y or z
   the characters are matched literally, also \,*,?,+,..
   it is not possible to match the closing bracket (])
   within a character class


 %[1]..%[9]: matches like a '+',
  and calls the callback supplied as 3rd argument (when not null).
  the number past the %, e.g. %1, is optional,
  p_match will be callen with this number
  as first parameter.
  When not supplied, p_matched will be callen with
  the parameter 'number' set to 0.

  The matching is 'nongreedy'.
  It is possible to rewrite the string to match
  from within the p_matched callback.
  This will not have an effect onto the current matching,
  even if text is e.g. deleted by writing 0's.
  The matched positions are called in reverse order.
  (The last matched % in the regex calls p_match first,
  the first % in the regex from the left will be callen last)

 supply 0 for p_matched, when you do not need to extract matches.
 This will treat % in the regex like a *,
 a following digit (0..9) in the regex is ignored.
 if the 5th argument, a pointer to a regex_match struct,
 is supplied, it will be filled with the first match.
 (counting from left)


 &amp;[1] .. &amp;[9]
  "match" like a '?' and call p_match_char
  p_match_char has to return either RE_MATCH, RE_NOMATCH, RE_MATCHEND
  or a number of the count of chars, which have been matched.

  Therefore it is possible to e.g. rule your own
  character classes, defined at runtime,
  or do further tricks like changing the matched chars,
  match several chars, andsoon.
  When returning RE_NOMATCH,
  it is possible, the p_match and p_match_char callbacks are callen several times,
  but with different pos or len parameters.

  The matching works straight from left to right.
  So, a "*&amp;*" will call the callback &amp; for the first char.
  When returning RE_NOMATCH, the second char will be matched.
  Until either RE_MATCH is returned from the callback,
  or the last char has been matched.

  Matching several characters is also posssible from within the callback,
  the position within the text will be incremented by that number,
  you return from the callback.

  When returning RE_MATCHEND from the callback,
  the whole regular expression is aborted, and returns with matched;
  no matter, if there are chars left in the expression.


  The difference between % and &amp; is the logic.
  % matches nongreedy, and has to check therefore the right side of the star
  for its matching.
  Possibly this has to be repeated, when following chars do not match.

  &amp; is matched straight from left to right.
  Whatever number you return, the textpointer will be incremented by that value.
  However, a &amp; isn't expanded on it's own. ( what a % is ).
  e.g. "x%x" will match 'aa' in xaax, x&amp;x will match the whole expression
  only, when you return '2' from the callback.

  Performancewise, matching with &amp; is faster,
  since the % has on its right side to be matched
  with recursing calls of ext_match.

 When using closures for the callbacks, you will possibly have to
 enable an executable stack for the trampoline code
 of gcc. Here, gcc complains about that.
 For setting this bit, have a look into the ldscripts in the folder
 with the same name.

 supply 0 for p_match_char, when you don't need it.
 This will treat &amp; in the regex like ?,
 and match a following digit (0..9) in the text,
 a following digit (0..9) in the regex is ignored.

 -----
 In general, you have to somehow invert the logic of regular expressions
 when using ext_match.
 e.g. when matching the parameter 'runlevel=default' at the kernel's
 commandline, a working regular expression would be
 "runlevel=(\S*)". This could be written here as "*runlevel=%#".
 For matching e.g. numbers, you'd most possibly best of
 with writing your own &amp; callback.

 returns: 1 on match, 0 on no match
 ( RE_MATCH / RE_NOMATCH )

 if the pointer (argument 5) st_match is nonnull,
 the supplied struct regex_match will be set to the first matching '%' location;
 if there is no match, regex_match.len will be set to 0.
 The struct is defined as:
 typedef struct _regex_match { char* pos; int len; } regex_match;


 (memo) When the regex ist defined within C/cpp source code,
 a backslash has to be defined as double backslash.

 (note) - be careful when negating a following *, or ?.
  somehow - it is logical, but seems to me I overshoot a bit,
  tragically hit my own foot, and stumbled into a logical paradox.

  Negating EVERYTHING translates to true.
  However, since truth is negated as well, there's a problem,
  cause it's now 'false', but 'false' is true. This is very close
  to proving 42 is the answer. What is the escape velocity
  in km/s out of the solar system, btw.

  (I'm not kidding here. Just don't do a regex with !* or !?..
  And, please, do not ask me what is going to happen when the impossible
  gets possibilized. I have to point at the according sentences of the BSD license;//  there is NO WARRANTY for CONSEQUENTIAL DAMAGE, LOSS OF PROFIT, etc pp.)

  A "!+" will translate into nongreedy matching of any char, however;
  "%!+" will match with % everything but the last char;
  while "%+" matches with % only the first char.
  !+ basically sets the greedyness of the left * or % higher.</code></pre>
</td></tr></table>
<p><a href="../src/ext_match.c">../src/ext_match.c</a> l.165</p>
<a name="match"></a><dl>
<dt>
match
</dt>
<dd>
<p>
  <em>int match(char *text, const char *re, regex_match *st_match)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>regex engine
 little bit simpler version than ext_match.
 The engine matches from left to right,
 so no backtracking is done.
 It is a compromise between performance, size
 and capabilities.

 matches:

 * for every count of any char
 + for 1 or more chars
 ? for 1 char
 # for space or end of text (0)
 $ match end of text

 backslash: escape *,?,%,!,+,#,$ and backslash itself.
 ! : invert the matching of the next character or character class

 [xyz]: character classes, here x,y or z
   the characters are matched literally, also \,*,?,+,..
   it is not possible to match the closing bracket (])
   within a character class


 % : matches like a '+', and fills in argument 3,
 the regex_match struct, when the pointer is non null.
 The matching is 'nongreedy'.


 returns: 1 on match, 0 on no match
 ( RE_MATCH / RE_NOMATCH )

 if the pointer (argument 3) st_match is nonnull,
 the supplied struct regex_match will be set to the first matching '%' location;
 if there is no match, regex_match.len will be set to 0.
 The struct is defined as:
 typedef struct _regex_match { char* pos; int len; } regex_match;


 (memo) When the regex ist defined within C/cpp source code,
 a backslash has to be defined as double backslash.

 (note) - be careful when negating a following *, or ?.
  somehow - it is logical, but seems to me I overshoot a bit,
  and tapped into a logical paradox.
  Negating EVERYTHING translates to true.
  However, since truth is negated as,... well, there's a problem.

  (I'm not kidding here. Just don't do a regex with !* or !?..)

  A "!+" will translate into nongreedy matching of any char, however;
  "%!+" will match with % everything but the last char;
  while "%+" matches with % only the first char.
  !+ basically sets the greedyness of the left * or % higher.</code></pre>
</td></tr></table>
<p><a href="../src/match.c">../src/match.c</a> l.57</p>
<p>---</p>
<hr>
<h2><a name="_streams"></a>13. streams</h2>
<a name="clearerr"></a><dl>
<dt>
clearerr
</dt>
<dd>
<p>
  <em>void clearerr(FILE <strong>f)</em><br>
 *clear indicators on a stream</strong>
Size: ~36B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.198 manpage: <a href="manpages/stdio/ferror.3.rst">clearerr</a><br>
</p>
</dd>
<dt>
clearerror
</dt>
<dd>
<p>
  <em>void clearerror(FILE *f)</em><br>
Size: ~36B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.203
</p>
</dd>
<dt>
fclose
</dt>
<dd>
<p>
  <em>int  fclose( FILE* f )</em><br>
 <strong>Defines:</strong> close<br>
 <strong>close a stream</strong>
Size: ~40B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.65 manpage: <a href="manpages/stdio/fclose.3.rst">fclose</a><br>
</p>
</dd>
<dt>
fdopen
</dt>
<dd>
<p>
  <em>FILE <strong>fdopen(int fd, const char</strong> mode)</em><br>
 <strong>Defines:</strong> close open fileno<br>
 <strong>associate a stream with a file descriptor</strong>
</p>
</dd>
</dl>
<a name="fdopen"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>modes implemented: r, r+, w, w+, a, a+</code></pre>
</td></tr></table>
<p>Size: ~323B <a href="../src/fopen.c">../src/fopen.c</a> l.91 manpage: <a href="manpages/stdio/fopen.3.rst">fdopen</a><br></p>
<a name="feof"></a><dl>
<dt>
feof
</dt>
<dd>
<p>
  <em>int feof(FILE <strong>f)</em><br>
 *test end-of-file indicator on a stream</strong>
<a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.184 manpage: <a href="manpages/stdio/ferror.3.rst">feof</a><br>
</p>
</dd>
<dt>
ferror
</dt>
<dd>
<p>
  <em>int ferror(FILE <strong>f)</em><br>
 *test error indicator on a stream</strong>
Size: ~32B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.191 manpage: <a href="manpages/stdio/ferror.3.rst">ferror</a><br>
</p>
</dd>
<dt>
fflush
</dt>
<dd>
<p>
  <em>int  fflush( FILE <strong>F )</em><br>
 *flush a stream</strong>
</p>
</dd>
</dl>
<a name="fflush"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>This does nothing, since minilib doesn't provide buffered streams yet.In order to sync data to disc, please use fsync</code></pre>
</td></tr></table>
<p>Size: ~32B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.28 manpage: <a href="manpages/stdio/fflush.3.rst">fflush</a><br></p>
<a name="fgetpos"></a><dl>
<dt>
fgetpos
</dt>
<dd>
<p>
  <em>void fgetpos(FILE <strong>f, long *pos )</em><br>
 *Defines:</strong> lseek<br>
 <strong>get current file position information</strong>
Size: ~62B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.127 manpage: <a href="manpages/stdio/fseek.3.rst">fgetpos</a><br>
</p>
</dd>
<dt>
fileno
</dt>
<dd>
<p>
  <em>int fileno( FILE <strong>f )</em><br>
 *map a stream pointer to a file descriptor</strong>
</p>
</dd>
</dl>
<a name="fileno"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>Return the fd nummber of stdin,-out,-err.</code></pre>
</td></tr></table>
<p>Size: ~32B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.56 manpage: <a href="manpages/stdio/ferror.3.rst">fileno</a><br></p>
<a name="fopen"></a><dl>
<dt>
fopen
</dt>
<dd>
<p>
  <em>FILE <strong>fopen(const char</strong> filename, const char* mode)</em><br>
 <strong>Defines:</strong> open fileno close<br>
 <strong>open a stream</strong>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>modes implemented: r, r+, w, w+, a, a+</code></pre>
</td></tr></table>
<p>Size: ~324B <a href="../src/fopen.c">../src/fopen.c</a> l.81 manpage: <a href="manpages/stdio/fopen.3.rst">fopen</a><br></p>
<a name="fputs"></a><dl>
<dt>
fputs
</dt>
<dd>
<p>
  <em>int volatile fputs(const char <strong>c, FILE *F)</em><br>
 *Defines:</strong> write strlen fileno<br>
 <strong>put a string on a stream</strong>
Size: ~90B <a href="../include/fputs.h">../include/fputs.h</a> l.20 manpage: <a href="manpages/stdio/fputs.3.rst">fputs</a><br>
</p>
</dd>
<dt>
fread
</dt>
<dd>
<p>
  <em>size_t fread(void <strong>ptr, size_t size, size_t nmemb, FILE *f)</em><br>
 *Defines:</strong> read<br>
 <strong>binary input</strong>
Size: ~110B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.162 manpage: <a href="manpages/stdio/fread.3.rst">fread</a><br>
</p>
</dd>
<dt>
freopen
</dt>
<dd>
<p>
  <em>FILE <strong>freopen(const char</strong> filename, const char* mode, FILE <strong>F)</em><br>
 *Defines:</strong> fileno open close<br>
 <strong>open a stream</strong>
</p>
</dd>
</dl>
<a name="freopen"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>modes implemented: r, r+, w, w+, a, a+</code></pre>
</td></tr></table>
<p>Size: ~320B <a href="../src/fopen.c">../src/fopen.c</a> l.101 manpage: <a href="manpages/stdio/fopen.3.rst">freopen</a><br></p>
<a name="fseek"></a><dl>
<dt>
fseek
</dt>
<dd>
<p>
  <em>int fseek(FILE <strong>f, long offset, int whence )</em><br>
 *Defines:</strong> lseek<br>
 <strong>reposition a file-position indicator in a stream</strong>
Size: ~80B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.146 manpage: <a href="manpages/stdio/fseek.3.rst">fseek</a><br>
</p>
</dd>
<dt>
fsetpos
</dt>
<dd>
<p>
  <em>int fsetpos(FILE <strong>f, int pos )</em><br>
 *Defines:</strong> lseek<br>
 <strong>set current file position</strong>
Size: ~78B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.133 manpage: <a href="manpages/stdio/fseek.3.rst">fsetpos</a><br>
</p>
</dd>
<dt>
ftell
</dt>
<dd>
<p>
  <em>long ftell(FILE <strong>f)</em><br>
 *Defines:</strong> lseek<br>
 <strong>return a file offset in a stream</strong>
Size: ~53B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.121 manpage: <a href="manpages/stdio/fseek.3.rst">ftell</a><br>
</p>
</dd>
<dt>
rewind
</dt>
<dd>
<p>
  <em>void rewind( FILE <strong>f )</em><br>
 *Defines:</strong> lseek<br>
 <strong>reset the file position indicator in a stream</strong>
Size: ~58B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.156 manpage: <a href="manpages/stdio/fseek.3.rst">rewind</a><br>
</p>
</dd>
<dt>
setbuf
</dt>
<dd>
<p>
  <em>void setbuf(FILE <strong>stream, char *buf)</em><br>
 *assign buffering to a stream</strong>
</p>
</dd>
</dl>
<a name="setbuf"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>dummy function.
 There is no buffering implemented for the streams yet.</code></pre>
</td></tr></table>
<p>Size: ~32B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.211 manpage: <a href="manpages/stdio/setbuf.3.rst">setbuf</a><br></p>
<a name="setvbuf"></a><dl>
<dt>
setvbuf
</dt>
<dd>
<p>
  <em>int setvbuf(FILE <strong>stream, char *buf, int mode, size_t size)</em><br>
 *assign buffering to a stream</strong>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>dummy function</code></pre>
</td></tr></table>
<p>Size: ~58B <a href="../include/mini_fstream.h">../include/mini_fstream.h</a> l.216 manpage: <a href="manpages/stdio/setbuf.3.rst">setvbuf</a><br></p>
<p>---</p>
<hr>
<h2><a name="_strings"></a>14. strings</h2>
<a name="_strcasecmp"></a><dl>
<dt>
_strcasecmp
</dt>
<dd>
<p>
  <em>int _strcasecmp(const char*c1,const char*c2,int len)</em><br>
 <strong>Defines:</strong> tolower<br>
Size: ~44B <a href="../src/strcmp.c">../src/strcmp.c</a> l.27
</p>
</dd>
<dt>
_strcmp
</dt>
<dd>
<p>
  <em>int _strcmp(const char*c1,const char*c2,int len)</em><br>
Size: ~44B <a href="../src/strcmp.c">../src/strcmp.c</a> l.10
</p>
</dd>
<dt>
sprintf
</dt>
<dd>
<p>
  <em>#define sprintf(str,&#8230;) snprintf( str, 4096,  <em>VA_ARGS</em>)</em><br>
 <strong>Defines:</strong> write<br>
 <strong>print formatted output</strong>
<a href="../src/sprintf.c">../src/sprintf.c</a> l.26 manpage: <a href="manpages/stdio/printf.3.rst">sprintf</a><br>
</p>
</dd>
<dt>
strcasecmp
</dt>
<dd>
<p>
  <em>int strcasecmp(const char*c1,const char*c2)</em><br>
<a href="../src/strcmp.c">../src/strcmp.c</a> l.48 manpage: <a href="manpages/string/string.3.rst">strcasecmp</a><br>
</p>
</dd>
<dt>
strcat
</dt>
<dd>
<p>
  <em>char <strong>strcat(char *dest, const char *src )</em><br>
 *Defines:</strong> strlen<br>
 <strong>concatenate two strings</strong>
Size: ~126B <a href="../src/strcat.c">../src/strcat.c</a> l.7 manpage: <a href="manpages/string/string.3.rst">strcat</a><br>
</p>
</dd>
<dt>
strchr
</dt>
<dd>
<p>
  <em>char <strong>strchr(const char *s, int c)</em><br>
 *Defines:</strong> strchrnul<br>
 <strong>string scanning operation</strong>
Size: ~104B <a href="../src/strchr.c">../src/strchr.c</a> l.20 manpage: <a href="manpages/string/string.3.rst">strchr</a><br>
</p>
</dd>
<dt>
strchrnul
</dt>
<dd>
<p>
  <em>char <strong>strchrnul(const char *s, int c)</em><br>
 *locate character in string</strong>
Size: ~87B <a href="../src/strchr.c">../src/strchr.c</a> l.7 manpage: <a href="manpages/string/strchr.3.rst">strchrnul</a><br>
</p>
</dd>
<dt>
strcmp
</dt>
<dd>
<p>
  <em>int strcmp(const char*c1,const char*c2)</em><br>
 <strong>compare two strings</strong>
Size: ~32B <a href="../src/strcmp.c">../src/strcmp.c</a> l.67 manpage: <a href="manpages/string/string.3.rst">strcmp</a><br>
</p>
</dd>
<dt>
strcpy
</dt>
<dd>
<p>
  <em>char <strong>strcpy(char *dest, const char *src)</em><br>
 *copy a string and return a pointer to the end of the result</strong>
Size: ~84B <a href="../src/memcpy.c">../src/memcpy.c</a> l.17 manpage: <a href="manpages/string/string.3.rst">strcpy</a><br>
</p>
</dd>
<dt>
strdup
</dt>
<dd>
<p>
  <em>char <strong>strdup(const char *source)</em><br>
 *Defines:</strong> brk strlen strcpy<br>
 <strong>duplicate a specific number of bytes from a string</strong>
Size: ~258B <a href="../src/strdup.c">../src/strdup.c</a> l.7 manpage: <a href="manpages/string/strdup.3.rst">strdup</a><br>
</p>
</dd>
<dt>
strlen
</dt>
<dd>
<p>
  <em>int strlen(const char*str)</em><br>
 <strong>get length of fixed size string</strong>
Size: ~32B <a href="../src/strlen.c">../src/strlen.c</a> l.7 manpage: <a href="manpages/string/strlen.3.rst">strlen</a><br>
</p>
</dd>
<dt>
strncasecmp
</dt>
<dd>
<p>
  <em>int strncasecmp(const char*c1,const char*c2,int len)</em><br>
 <strong>case-insensitive string comparisons</strong>
<a href="../src/strcmp.c">../src/strcmp.c</a> l.56 manpage: <a href="manpages/string/string.3.rst">strncasecmp</a><br>
</p>
</dd>
<dt>
strncmp
</dt>
<dd>
<p>
  <em>int strncmp(const char*c1,const char*c2,int len)</em><br>
 <strong>compare part of two strings</strong>
Size: ~44B <a href="../src/strcmp.c">../src/strcmp.c</a> l.75 manpage: <a href="manpages/string/string.3.rst">strncmp</a><br>
</p>
</dd>
<dt>
strncpy
</dt>
<dd>
<p>
  <em>char <strong>strncpy(char *dest, const char *src, int n)</em><br>
 *Defines:</strong> memcpy<br>
 <strong>copy fixed length string, returning a pointer to the array end</strong>
Size: ~96B <a href="../src/memcpy.c">../src/memcpy.c</a> l.27 manpage: <a href="manpages/string/string.3.rst">strncpy</a><br>
</p>
</dd>
<dt>
strrchr
</dt>
<dd>
<p>
  <em>char <strong>strrchr(const char *s, int c)</em><br>
 *Defines:</strong> strchrnul<br>
 <strong>string scanning operation</strong>
Size: ~122B <a href="../src/strchr.c">../src/strchr.c</a> l.36 manpage: <a href="manpages/string/string.3.rst">strrchr</a><br>
</p>
</dd>
<dt>
strstr
</dt>
<dd>
<p>
  <em>char* strstr(const char <strong>big, const char *little)</em><br>
 *find a substring</strong>
Size: ~104B <a href="../src/strstr.c">../src/strstr.c</a> l.3 manpage: <a href="manpages/string/strstr.3.rst">strstr</a><br>
</p>
</dd>
</dl>
<p><a name="strstr"></a>---</p>
<hr>
<h2><a name="_system"></a>15. system</h2>
<a name="chroot"></a><dl>
<dt>
chroot
</dt>
<dd>
<p>
  <em>int chroot( const char <strong>filename)</em><br>
 *change root directory</strong>
Size: ~47B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.141 manpage: <a href="manpages/sys/chroot.2.rst">chroot</a><br>
</p>
</dd>
<dt>
getgid
</dt>
<dd>
<p>
  <em>int DEF_syscall(getgid,0)</em><br>
 <strong>get the real group ID</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.189 manpage: <a href="manpages/sys/getgid.2.rst">getgid</a><br>
</p>
</dd>
<dt>
getuid
</dt>
<dd>
<p>
  <em>int DEF_syscall(getuid,0)</em><br>
 <strong>get a real user ID</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.191 manpage: <a href="manpages/sys/getuid.2.rst">getuid</a><br>
</p>
</dd>
<dt>
ioctl
</dt>
<dd>
<p>
  <em>int volatile   ioctl( int fd, unsigned long int request, &#8230; )</em><br>
 <strong>control a STREAMS device (\fBSTREAMS\fP)</strong>
Size: ~319B <a href="../src/ioctl.c">../src/ioctl.c</a> l.11 manpage: <a href="manpages/sys/ioctl.2.rst">ioctl</a><br>
</p>
</dd>
<dt>
macro
</dt>
<dd>
<p>
  <em>void  optimization_fence(void*p){}</em><br>
Size: ~32B
</p>
</dd>
<dt>
mknod
</dt>
<dd>
<p>
  <em>int mknod( const char <strong>filename,  umode_t mode,  unsigned dev)</em><br>
 *make directory, special file, or regular file</strong>
Size: ~73B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.211 manpage: <a href="manpages/sys/mknod.2.rst">mknod</a><br>
</p>
</dd>
<dt>
mount
</dt>
<dd>
<p>
  <em>int mount( char <strong>dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)</em><br>
 *mount filesystem</strong>
Size: ~151B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.168 manpage: <a href="manpages/sys/mount.2.rst">mount</a><br>
</p>
</dd>
<dt>
pivot_root
</dt>
<dd>
<p>
  <em>int pivot_root( const char <strong>new_root,  const char *put_old)</em><br>
 *change the root mount</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.142
</p>
</dd>
<dt>
putenv
</dt>
<dd>
<p>
  <em>int putenv( char <strong>string )</em><br>
 *Defines:</strong> environ ret_errno<br>
</p>
</dd>
</dl>
<a name="putenv"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>put a string into the environmental vars
 the supplied string's pointer is put into the environmental array of pointers.
 Subsequent changes of the string therefore will change the environment,
 and the supplied string may not be deallocated.
 Returns:
 - 0 on success,
 - EINVAL: string was 0, didn't contain a '=', some other error</code></pre>
</td></tr></table>
<p><a href="../src/putenv.c">../src/putenv.c</a> l.10 manpage: <a href="manpages/stdlib/getenv.3.rst">putenv</a><br></p>
<a name="reboot"></a><dl>
<dt>
reboot
</dt>
<dd>
<p>
  <em>int reboot( int magic1,  int magic2,  unsigned int cmd,  void <strong>arg)</em><br>
 *reboot or enable/disable Ctrl-Alt-Del</strong>
Size: ~139B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.166 manpage: <a href="manpages/sys/reboot.2.rst">reboot</a><br>
</p>
</dd>
<dt>
setgid
</dt>
<dd>
<p>
  <em>int setgid( gid_t gid)</em><br>
 <strong>set-group-ID</strong>
Size: ~51B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.147 manpage: <a href="manpages/sys/setuid.2.rst">setgid</a><br>
</p>
</dd>
<dt>
setgroups
</dt>
<dd>
<p>
  <em>int setgroups( int gidsetsize,  gid_t *grouplist)</em><br>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.182 manpage: <a href="manpages/sys/setgroups.2.rst">setgroups</a><br>
</p>
</dd>
<dt>
setuid
</dt>
<dd>
<p>
  <em>int setuid( uid_t uid)</em><br>
 <strong>set user ID</strong>
Size: ~51B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.148 manpage: <a href="manpages/sys/setuid.2.rst">setuid</a><br>
</p>
</dd>
<dt>
sync
</dt>
<dd>
<p>
  <em>int DEF_syscall(sync,0)</em><br>
 <strong>schedule file system updates</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.124 manpage: <a href="manpages/sys/sync.2.rst">sync</a><br>
</p>
</dd>
<dt>
umount2
</dt>
<dd>
<p>
  <em>int umount2( const char <strong>mountpoint, int flags)</em><br>
 *unmount filesystem</strong>
Size: ~59B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.164
</p>
</dd>
<dt>
uname
</dt>
<dd>
<p>
  <em>int uname(struct old_utsname <strong>name )</em><br>
 *get the name of the current system</strong>
Size: ~41B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.152 manpage: <a href="manpages/gen/uname.3.rst">uname</a><br>
</p>
</dd>
</dl>
<p><a name="uname"></a>---</p>
<hr>
<h2><a name="_terminal"></a>16. terminal</h2>
<a name="grantpt"></a><dl>
<dt>
grantpt
</dt>
<dd>
<p>
  <em>int grantpt(int fd)</em><br>
 <strong>grant access to the slave pseudo-terminal device</strong>
Size: ~44B <a href="../src/pty.c">../src/pty.c</a> l.13 manpage: <a href="manpages/stdlib/ptsname.3.rst">grantpt</a><br>
</p>
</dd>
<dt>
isatty
</dt>
<dd>
<p>
  <em>int isatty(int fd)</em><br>
 <strong>Defines:</strong> ioctl<br>
 <strong>test for a terminal device</strong>
Size: ~325B <a href="../src/isatty.c">../src/isatty.c</a> l.7 manpage: <a href="manpages/gen/ttyname.3.rst">isatty</a><br>
</p>
</dd>
<dt>
nanosleep
</dt>
<dd>
<p>
  <em>int nanosleep( struct timespec <strong>rqtp, struct timespec *rmtp)</em><br>
 *high resolution sleep</strong>
Size: ~47B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.135 manpage: <a href="manpages/sys/nanosleep.2.rst">nanosleep</a><br>
</p>
</dd>
<dt>
posix_openpt
</dt>
<dd>
<p>
  <em>int posix_openpt(int flags)</em><br>
 <strong>Defines:</strong> open<br>
 <strong>open a pseudo-terminal device</strong>
Size: ~140B <a href="../src/pty.c">../src/pty.c</a> l.8 manpage: <a href="manpages/sys/posix_openpt.2.rst">posix_openpt</a><br>
</p>
</dd>
<dt>
ptsname
</dt>
<dd>
<p>
  <em>char <strong>ptsname(int fd)</em><br>
 *Defines:</strong> uitodec write open ioctl<br>
 <strong>get name of the slave pseudo-terminal device</strong>
Size: ~1767B <a href="../src/pty.c">../src/pty.c</a> l.40 manpage: <a href="manpages/stdlib/ptsname.3.rst">ptsname</a><br>
</p>
</dd>
<dt>
ptsname_r
</dt>
<dd>
<p>
  <em>int ptsname_r(int fd, char <strong>buf, size_t len)</em><br>
 *Defines:</strong> uitodec write open ioctl<br>
 <strong>get the name of the slave pseudoterminal</strong>
Size: ~1748B <a href="../src/pty.c">../src/pty.c</a> l.27
</p>
</dd>
<dt>
tcgetattr
</dt>
<dd>
<p>
  <em>int  tcgetattr(int fd, struct termios <strong>io)</em><br>
 *Defines:</strong> ioctl<br>
 <strong>get the parameters associated with the terminal</strong>
Size: ~300B <a href="../include/tcgetattr.h">../include/tcgetattr.h</a> l.21 manpage: <a href="manpages/gen/tcsetattr.3.rst">tcgetattr</a><br>
</p>
</dd>
<dt>
tcsetattr
</dt>
<dd>
<p>
  <em>int  tcsetattr(int fd, int opt, const struct termios <strong>io)</em><br>
 *Defines:</strong> ioctl<br>
 <strong>set the parameters associated with the terminal</strong>
Size: ~316B <a href="../include/tcsetattr.h">../include/tcsetattr.h</a> l.20 manpage: <a href="manpages/gen/tcsetattr.3.rst">tcsetattr</a><br>
</p>
</dd>
<dt>
unlockpt
</dt>
<dd>
<p>
  <em>int unlockpt(int fd)</em><br>
 <strong>Defines:</strong> ioctl<br>
 <strong>unlock a pseudo-terminal master/slave pair</strong>
Size: ~325B <a href="../src/pty.c">../src/pty.c</a> l.20 manpage: <a href="manpages/stdlib/ptsname.3.rst">unlockpt</a><br>
</p>
</dd>
<dt>
vhangup
</dt>
<dd>
<p>
  <em>int DEF_syscall(vhangup,0 )</em><br>
 <strong>virtually hangup the current terminal</strong>
<a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.150
</p>
</dd>
</dl>
<p><a name="vhangup"></a>---</p>
<hr>
<h2><a name="_time"></a>17. time</h2>
<a name="getitimer"></a><dl>
<dt>
getitimer
</dt>
<dd>
<p>
  <em>int getitimer( int which,  struct itimerval <strong>value)</em><br>
 *get and set value of interval timer</strong>
Size: ~53B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.216 manpage: <a href="manpages/sys/getitimer.2.rst">getitimer</a><br>
</p>
</dd>
<dt>
gettimeofday
</dt>
<dd>
<p>
  <em>int gettimeofday( struct timeval <strong>a1, struct timezone *a2)</em><br>
 *get the date and time</strong>
Size: ~47B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.136 manpage: <a href="manpages/sys/gettimeofday.2.rst">gettimeofday</a><br>
</p>
</dd>
<dt>
setitimer
</dt>
<dd>
<p>
  <em>int setitimer( int which,  struct itimerval <strong>value,  struct itimerval *ovalue)</em><br>
 *set the value of an interval timer</strong>
Size: ~56B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.215 manpage: <a href="manpages/sys/getitimer.2.rst">setitimer</a><br>
</p>
</dd>
<dt>
sleep
</dt>
<dd>
<p>
  <em>unsigned int volatile sleep(unsigned int seconds)</em><br>
 <strong>suspend execution for an interval of time</strong>
</p>
</dd>
</dl>
<a name="sleep"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>nonconformant sleep
 TODO: ignore blocked signals, sigchld</code></pre>
</td></tr></table>
<p>Size: ~123B <a href="../src/sleep.c">../src/sleep.c</a> l.10 manpage: <a href="manpages/gen/sleep.3.rst">sleep</a><br></p>
<a name="time"></a><dl>
<dt>
time
</dt>
<dd>
<p>
  <em>int time(unsigned int <strong>a1 )</em><br>
 *get time</strong>
Size: ~41B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.221 manpage: <a href="manpages/gen/time.3.rst">time</a><br>
</p>
</dd>
<dt>
usleep
</dt>
<dd>
<p>
  <em>unsigned int volatile usleep(unsigned int useconds)</em><br>
 <strong>suspend execution for microsecond intervals</strong>
</p>
</dd>
</dl>
<a name="usleep"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>nonconformant usleep.
 Sleep useconds.
 I just hope, noone relies on an exact sleep time.
 which isn't possible without a real time os, anyways.
 When for whatever reason you'd need nanoseconds exact times,
 best shot might be a spinloop, and looking for cpu ticks.

 TODO: ignore blocked signals, sigchld</code></pre>
</td></tr></table>
<p>Size: ~147B <a href="../src/sleep.c">../src/sleep.c</a> l.31 manpage: <a href="manpages/gen/usleep.3.rst">usleep</a><br></p>
<a name="utime"></a><dl>
<dt>
utime
</dt>
<dd>
<p>
  <em>int utime( const char <strong>filename, struct utimbuf *times)</em><br>
 *set file access and modification times</strong>
Size: ~49B <a href="../include/syscall_stubs.h">../include/syscall_stubs.h</a> l.186 manpage: <a href="manpages/gen/utime.3.rst">utime</a><br>
</p>
</dd>
</dl>
<p>---</p>
<hr>
<h2><a name="_unsorted"></a>18. unsorted</h2>
<a name="OPTFENCE"></a><dl>
<dt>
OPTFENCE
</dt>
<dd>
<p>
  <em>void  opt_fence(void*p,&#8230;)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>prevent gcc to optimize away registers and variables
 the macro OPTFENCE(...) can be invoked with any parameter.
 The parameters will get calculated, even if gcc doesn't recognize
 the use of the parameters, e.g. cause they are needed for an inlined asm syscall.

 The macro translates to an asm jmp and a function call to the function
 opt_fence, which is defined with the attribute "noipa" -
 (the compiler "forgets" the function body, so gcc is forced
 to generate all arguments for the function)
 The generated asm jump hops over the call to the function,
 but this gcc doesn't recognize.

 This generates some overhead,
 (a few (never reached) bytes for setting up the function call, and the jmp)
 but I didn't find any other solution,
 which gcc wouldn't cut for optimizations from time to time.
 (volatile, volatile asm, optimize attributes,
 andsoon have all shown up to be unreliable - sometimes(!)).

 Had some fun debugging these bugs, which naturally showed up only sometimes.
 (Many syscalls also work with scrambled arguments..)
 And, I believe it IS a compiler bug.
 Volatile should be volatile for sure, not only sometimes.
 I mean, why the heck do I write volatile??</code></pre>
</td></tr></table>
<p><a href="../include/syscall.h">../include/syscall.h</a> l.65</p>
<a name="def"></a><dl>
<dt>
def
</dt>
<dd>
<p>
  <em>#define SETOPT_short( opts, option ) (</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>Set a option flag(s) (bit(s))  manually.
                param options: e.g. just a, or ( a+h+l) to check for several flags at once</code></pre>
</td></tr></table>
<p><a href="../macros/getoptm.h">../macros/getoptm.h</a> l.52</p>
<a name="group_printf"></a><dl>
<dt>
group_printf
</dt>
<dd>
<p>
  <em>//</em><br>
 <strong>Defines:</strong> eprintf ltodec uitodec write fileno<br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>printf, eprintf, fprintf, itodec and ltodec (conversions %d %l),</code></pre>
</td></tr></table>
<p><a href="../macros/defgroups.h">../macros/defgroups.h</a> l.29</p>
<a name="optimization_fence"></a><dl>
<dt>
optimization_fence
</dt>
<dd>
<p>
  <em>void  optimization_fence(void*p)</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>prevent optimizations.
 cast a var to void*, and calling this,
 leaves the compiler unknown on what he can strip.
 (noipa) means the compiler doesn't know, what the function itself does.
 (the function does nothing, but don't tell that gcc, please..)
 therefore, everything used as parameter to this function,
 will be calculated, defined, and so on before.
 It's used for the globals,
 shich are pushed within _start onto the stack.
 since _start itself only provides a global pointer,
 and initialitzes some of the globals,
 but doesn't use them again,
 this construction is needed.
 more funnily, the function will never be called.
 It's past the asm inline syscall to exit.
 But again, luckily gcc doesn't know.
 All other options, like having the globals volatile,
 setting the optimization flag of _start to 0,
 having a volatile asm call with the globals as param, and so on,
 have been useless. All after all, seems to me, ai has it's restrictions.</code></pre>
</td></tr></table>
<p><a href="../include/minilib_global.h">../include/minilib_global.h</a> l.90</p>
<a name="qsort"></a><dl>
<dt>
qsort
</dt>
<dd>
<p>
  <em>void qsort(void  *base,      size_t nel,     size_t width,   int (*comp)(const void *, const void *))</em><br>
</p>
</dd>
</dl>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>(quick) shell sort routine
 following the tradition, this isn't exactly a quicksort algorithm,
 albite named quicksort.
 It is a shell sort implementation, originally done by Ray Gardner, 5/90;
 which in turn I did find within musl.</code></pre>
</td></tr></table>
<p><a href="../src/qsort.c">../src/qsort.c</a> l.57 manpage: <a href="manpages/stdlib/qsort.3.rst">qsort</a><br></p>
<p>---</p>
<hr>
<h2><a name="_x64_syscalls"></a>19. x64-syscalls</h2>
<a name="sys__sysctl"></a><dl>
<dt>
sys__sysctl
</dt>
<dd>
<p>
  <em>sys<em>sysctl( struct </em>sysctl_args <strong>args)</em><br>
 *read/write system parameters</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.315
</p>
</dd>
<dt>
sys_accept
</dt>
<dd>
<p>
  <em>sys_accept( int fd,  struct sockaddr <strong>upeersockaddr,  int *upeeraddrlen)</em><br>
 *accept a new connection on a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.91
</p>
</dd>
<dt>
sys_accept4
</dt>
<dd>
<p>
  <em>sys_accept4( int fd,  struct sockaddr <strong>upeer_sockaddr,  int *upeer_addrlen,  int flags)</em><br>
 *accept a connection on a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.551
</p>
</dd>
<dt>
sys_access
</dt>
<dd>
<p>
  <em>sys_access( const char <strong>filename,  int mode)</em><br>
 *determine accessibility of a file relative to directory file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.47
</p>
</dd>
<dt>
sys_acct
</dt>
<dd>
<p>
  <em>sys_acct( const char <strong>name)</em><br>
 *switch process accounting on or off</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.329
</p>
</dd>
<dt>
sys_add_key
</dt>
<dd>
<p>
  <em>sys_add_key( const char <strong>_type,  const char *_description,  const void *_payload,  size_t plen)</em><br>
 *add a key to the kernel&#8217;s key management facility</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.471
</p>
</dd>
<dt>
sys_adjtimex
</dt>
<dd>
<p>
  <em>sys_adjtimex( struct timex <strong>txc_p)</em><br>
 *tune kernel clock</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.321
</p>
</dd>
<dt>
sys_alarm
</dt>
<dd>
<p>
  <em>sys_alarm( unsigned int seconds)</em><br>
 <strong>schedule an alarm signal</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.79
</p>
</dd>
<dt>
sys_arch_prctl
</dt>
<dd>
<p>
  <em>sys_arch_prctl( struct task_struct <strong>task,  int code,  unsigned long *addr)</em><br>
 *set architecture-specific thread state</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.319
</p>
</dd>
<dt>
sys_bind
</dt>
<dd>
<p>
  <em>sys_bind( int fd,  struct sockaddr <strong>umyaddr,  int addrlen)</em><br>
 *bind a name to a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.103
</p>
</dd>
<dt>
sys_brk
</dt>
<dd>
<p>
  <em>long sys_brk(unsigned long addr)</em><br>
 <strong>change data segment size</strong>
</p>
</dd>
</dl>
<a name="sys_brk"></a>
<table border="0" bgcolor="#e8e8e8" width="100%" cellpadding="4"><tr><td>
<pre><code>the kernel syscall brk.</code></pre>
</td></tr></table>
<p><a href="../src/brk.c">../src/brk.c</a> l.6</p>
<a name="sys_capget"></a><dl>
<dt>
sys_capget
</dt>
<dd>
<p>
  <em>sys_capget( cap_user_header_t header,  cap_user_data_t dataptr)</em><br>
 <strong>set/get capabilities of thread(s)</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.255
</p>
</dd>
<dt>
sys_capset
</dt>
<dd>
<p>
  <em>sys_capset( cap_user_header_t header,  const cap_user_data_t data)</em><br>
 <strong>set/get capabilities of thread(s)</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.257
</p>
</dd>
<dt>
sys_chdir
</dt>
<dd>
<p>
  <em>sys_chdir( const char <strong>filename)</em><br>
 *change working directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.165
</p>
</dd>
<dt>
sys_chmod
</dt>
<dd>
<p>
  <em>sys_chmod( const char <strong>filename,  mode_t mode)</em><br>
 *change mode of a file relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.185
</p>
</dd>
<dt>
sys_chown
</dt>
<dd>
<p>
  <em>sys_chown( const char <strong>filename,  uid_t user,  gid_t group)</em><br>
 *change owner and group of a file relative to directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.189
</p>
</dd>
<dt>
sys_chroot
</dt>
<dd>
<p>
  <em>sys_chroot( const char <strong>filename)</em><br>
 *change root directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.325
</p>
</dd>
<dt>
sys_clock_adjtime
</dt>
<dd>
<p>
  <em>sys_clock_adjtime( clockid_t which_clock,  struct timex *tx)</em><br>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.585
</p>
</dd>
<dt>
sys_clock_getres
</dt>
<dd>
<p>
  <em>sys_clock_getres( const clockid_t which_clock,  struct timespec *tp)</em><br>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.435
</p>
</dd>
<dt>
sys_clock_gettime
</dt>
<dd>
<p>
  <em>sys_clock_gettime( const clockid_t which_clock,  struct timespec <strong>tp)</em><br>
 *clock and time functions</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.433
</p>
</dd>
<dt>
sys_clock_nanosleep
</dt>
<dd>
<p>
  <em>sys_clock_nanosleep( const clockid_t which_clock,  int flags,  const struct timespec <strong>rqtp,  struct timespec *rmtp)</em><br>
 *high resolution sleep with specifiable clock</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.437
</p>
</dd>
<dt>
sys_clock_settime
</dt>
<dd>
<p>
  <em>sys_clock_settime( const clockid_t which_clock,  const struct timespec <strong>tp)</em><br>
 *clock and timer functions</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.431
</p>
</dd>
<dt>
sys_clone
</dt>
<dd>
<p>
  <em>sys_clone( unsigned long clone_flags,  unsigned long newsp,  void <strong>parent_tid,  void *child_tid)</em><br>
 *create a child process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.117
</p>
</dd>
<dt>
sys_close
</dt>
<dd>
<p>
  <em>sys_close( unsigned int fd)</em><br>
 <strong>close a file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.11
</p>
</dd>
<dt>
sys_connect
</dt>
<dd>
<p>
  <em>sys_connect( int fd,  struct sockaddr <strong>uservaddr,  int addrlen)</em><br>
 *connect a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.89
</p>
</dd>
<dt>
sys_creat
</dt>
<dd>
<p>
  <em>sys_creat( const char <strong>pathname,  int mode)</em><br>
 *create a new file or rewrite an existing one</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.175
</p>
</dd>
<dt>
sys_delete_module
</dt>
<dd>
<p>
  <em>sys_delete_module( const char <strong>name_user,  unsigned int flags)</em><br>
 *unload a kernel module</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.353
</p>
</dd>
<dt>
sys_dup
</dt>
<dd>
<p>
  <em>sys_dup( unsigned int fildes)</em><br>
 <strong>duplicate an open file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.69
</p>
</dd>
<dt>
sys_dup2
</dt>
<dd>
<p>
  <em>sys_dup2( unsigned int oldfd,  unsigned int newfd)</em><br>
 <strong>duplicate a file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.71
</p>
</dd>
<dt>
sys_dup3
</dt>
<dd>
<p>
  <em>sys_dup3( unsigned int oldfd,  unsigned int newfd,  int flags)</em><br>
 <strong>duplicate a file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.559
</p>
</dd>
<dt>
sys_epoll_create
</dt>
<dd>
<p>
  <em>sys_epoll_create( int size)</em><br>
 <strong>open an epoll file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.407
</p>
</dd>
<dt>
sys_epoll_create1
</dt>
<dd>
<p>
  <em>sys_epoll_create1( int flags)</em><br>
 <strong>open an epoll file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.557
</p>
</dd>
<dt>
sys_epoll_ctl
</dt>
<dd>
<p>
  <em>sys_epoll_ctl( int epfd,  int op,  int fd,  struct epoll_event <strong>event)</em><br>
 *control interface for an epoll file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.443
</p>
</dd>
<dt>
sys_epoll_pwait
</dt>
<dd>
<p>
  <em>sys_epoll_pwait( int epfd,  struct epoll_event <strong>events,  int maxevents,  int timeout,  const sigset_t *sigmask,  size_t sigsetsize)</em><br>
 *wait for an I/O event on an epoll file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.537
</p>
</dd>
<dt>
sys_epoll_wait
</dt>
<dd>
<p>
  <em>sys_epoll_wait( int epfd,  struct epoll_event <strong>events,  int maxevents,  int timeout)</em><br>
 *wait for an I/O event on an epoll file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.441
</p>
</dd>
<dt>
sys_eventfd
</dt>
<dd>
<p>
  <em>sys_eventfd( unsigned int count)</em><br>
 <strong>create a file descriptor for event notification</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.543
</p>
</dd>
<dt>
sys_eventfd2
</dt>
<dd>
<p>
  <em>sys_eventfd2( unsigned int count,  int flags)</em><br>
 <strong>create a file descriptor for event notification</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.555
</p>
</dd>
<dt>
sys_execve
</dt>
<dd>
<p>
  <em>sys_execve( const char <strong>filename,  const char *const argv[],  const char *const envp[])</em><br>
 *execute program</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.123
</p>
</dd>
<dt>
sys_exit
</dt>
<dd>
<p>
  <em>sys_exit( int error_code)</em><br>
 <strong>terminate a process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.125 manpage: <a href="manpages/sys/_exit.2.rst">_exit</a><br>
</p>
</dd>
<dt>
sys_exit_group
</dt>
<dd>
<p>
  <em>sys_exit_group( int error_code)</em><br>
 <strong>exit all threads in a process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.439
</p>
</dd>
<dt>
sys_faccessat
</dt>
<dd>
<p>
  <em>sys_faccessat( int dfd,  const char <strong>filename,  int mode)</em><br>
 *determine accessibility of a file relative to directory file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.513
</p>
</dd>
<dt>
sys_fadvise64
</dt>
<dd>
<p>
  <em>sys_fadvise64( int fd,  loff_t offset,  size_t len,  int advice)</em><br>
 <strong>predeclare an access pattern for file data</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.419
</p>
</dd>
<dt>
sys_fallocate
</dt>
<dd>
<p>
  <em>sys_fallocate( long fd,  long mode,  loff_t offset,  loff_t len)</em><br>
 <strong>manipulate file space</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.545
</p>
</dd>
<dt>
sys_fanotify_init
</dt>
<dd>
<p>
  <em>sys_fanotify_init( unsigned int flags,  unsigned int event_f_flags)</em><br>
 <strong>create and initialize fanotify group</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.575
</p>
</dd>
<dt>
sys_fanotify_mark
</dt>
<dd>
<p>
  <em>sys_fanotify_mark( long fanotify_fd,  long flags,  __u64 mask,  long dfd, long pathname)</em><br>
 <strong>add, remove, or modify an fanotify mark on a filesystem</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.577
</p>
</dd>
<dt>
sys_fchdir
</dt>
<dd>
<p>
  <em>sys_fchdir( unsigned int fd)</em><br>
 <strong>change working directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.167
</p>
</dd>
<dt>
sys_fchmod
</dt>
<dd>
<p>
  <em>sys_fchmod( unsigned int fd,  mode_t mode)</em><br>
 <strong>change mode of a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.187
</p>
</dd>
<dt>
sys_fchmodat
</dt>
<dd>
<p>
  <em>sys_fchmodat( int dfd,  const char <strong>filename,  mode_t mode)</em><br>
 *change mode of a file relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.511
</p>
</dd>
<dt>
sys_fchown
</dt>
<dd>
<p>
  <em>sys_fchown( unsigned int fd,  uid_t user,  gid_t group)</em><br>
 <strong>change owner and group of a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.191
</p>
</dd>
<dt>
sys_fchownat
</dt>
<dd>
<p>
  <em>sys_fchownat( int dfd,  const char <strong>filename,  uid_t user,  gid_t group,  int flag)</em><br>
 *change owner and group of a file relative to directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.495
</p>
</dd>
<dt>
sys_fcntl
</dt>
<dd>
<p>
  <em>sys_fcntl( unsigned int fd,  unsigned int cmd,  unsigned long arg)</em><br>
 <strong>file control</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.149
</p>
</dd>
<dt>
sys_fdatasync
</dt>
<dd>
<p>
  <em>sys_fdatasync( unsigned int fd)</em><br>
 <strong>synchronize the data of a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.155
</p>
</dd>
<dt>
sys_fgetxattr
</dt>
<dd>
<p>
  <em>sys_fgetxattr( int fd,  const char <strong>name,  void *value,  size_t size)</em><br>
 *retrieve an extended attribute value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.371
</p>
</dd>
<dt>
sys_finit_module
</dt>
<dd>
<p>
  <em>sys_finit_module( int fd,  const char  <strong>uargs,  int flags)</em><br>
 *load a kernel module</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.601
</p>
</dd>
<dt>
sys_flistxattr
</dt>
<dd>
<p>
  <em>sys_flistxattr( int fd,  char <strong>list,  size_t size)</em><br>
 *list extended attribute names</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.377
</p>
</dd>
<dt>
sys_flock
</dt>
<dd>
<p>
  <em>sys_flock( unsigned int fd,  unsigned int cmd)</em><br>
 <strong>apply or remove an advisory lock on an open file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.151
</p>
</dd>
<dt>
sys_fork
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_fork,0)</em><br>
 <strong>create a new process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.119
</p>
</dd>
<dt>
sys_fremovexattr
</dt>
<dd>
<p>
  <em>sys_fremovexattr( int fd,  const char <strong>name)</em><br>
 *remove an extended attribute</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.383
</p>
</dd>
<dt>
sys_fsetxattr
</dt>
<dd>
<p>
  <em>sys_fsetxattr( int fd,  const char <strong>name,  const void *value,  size_t size, int flags)</em><br>
 *set an extended attribute value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.365
</p>
</dd>
<dt>
sys_fstat
</dt>
<dd>
<p>
  <em>sys_fstat( unsigned int fd,  struct stat <strong>statbuf)</em><br>
 *get file status</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.15
</p>
</dd>
<dt>
sys_fstatfs
</dt>
<dd>
<p>
  <em>sys_fstatfs( unsigned int fd,  struct statfs <strong>buf)</em><br>
 *get filesystem statistics</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.279
</p>
</dd>
<dt>
sys_fsync
</dt>
<dd>
<p>
  <em>sys_fsync( unsigned int fd)</em><br>
 <strong>synchronize changes to a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.153
</p>
</dd>
<dt>
sys_ftruncate
</dt>
<dd>
<p>
  <em>sys_ftruncate( unsigned int fd,  unsigned long length)</em><br>
 <strong>truncate a file to a specified length</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.159
</p>
</dd>
<dt>
sys_futex
</dt>
<dd>
<p>
  <em>sys_futex( u32 <strong>uaddr,  int op,  u32 val,  struct timespec *utime,  u32 *uaddr2,  u32 val3)</em><br>
 *fast user-space locking</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.389
</p>
</dd>
<dt>
sys_futimesat
</dt>
<dd>
<p>
  <em>sys_futimesat( int dfd,  const char <strong>filename,  struct timeval *utimes)</em><br>
 *change timestamps of a file relative to a directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.497
</p>
</dd>
<dt>
sys_get_mempolicy
</dt>
<dd>
<p>
  <em>sys_get_mempolicy( int <strong>policy,  unsigned long *nmask,  unsigned long maxnode,  unsigned long addr,  unsigned long flags)</em><br>
 *retrieve NUMA memory policy for a thread</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.453
</p>
</dd>
<dt>
sys_get_robust_list
</dt>
<dd>
<p>
  <em>sys_get_robust_list( int pid,  struct robust_list_head <strong>*head_ptr,  size_t *len_ptr)</em><br>
 *get/set list of robust futexes</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.523
</p>
</dd>
<dt>
sys_getcpu
</dt>
<dd>
<p>
  <em>sys_getcpu( unsigned <strong>cpup,  unsigned *nodep,  struct getcpu_cache *unused)</em><br>
 *determine CPU and NUMA node on which the calling thread is running</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.593
</p>
</dd>
<dt>
sys_getcwd
</dt>
<dd>
<p>
  <em>sys_getcwd( char <strong>buf,  unsigned long size)</em><br>
 *get the pathname of the current working directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.163
</p>
</dd>
<dt>
sys_getdents
</dt>
<dd>
<p>
  <em>sys_getdents( unsigned int fd,  struct linux_dirent <strong>dirent,  unsigned int count)</em><br>
 *get directory entries</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.161
</p>
</dd>
<dt>
sys_getdents64
</dt>
<dd>
<p>
  <em>sys_getdents64( unsigned int fd,  struct linux_dirent64 <strong>dirent,  unsigned int count)</em><br>
 *get directory entries</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.411
</p>
</dd>
<dt>
sys_getegid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_getegid,0)</em><br>
 <strong>get the effective group ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.221
</p>
</dd>
<dt>
sys_geteuid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_geteuid,0)</em><br>
 <strong>get the effective user ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.219
</p>
</dd>
<dt>
sys_getgid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_getgid,0)</em><br>
 <strong>get the real group ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.213
</p>
</dd>
<dt>
sys_getgroups
</dt>
<dd>
<p>
  <em>sys_getgroups( int gidsetsize,  gid_t <strong>grouplist)</em><br>
 *get supplementary group IDs</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.235
</p>
</dd>
<dt>
sys_getitimer
</dt>
<dd>
<p>
  <em>sys_getitimer( int which,  struct itimerval <strong>value)</em><br>
 *get and set value of interval timer</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.77
</p>
</dd>
<dt>
sys_getpeername
</dt>
<dd>
<p>
  <em>sys_getpeername( int fd,  struct sockaddr <strong>usockaddr,  int *usockaddr_len)</em><br>
 *get the name of the peer socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.109
</p>
</dd>
<dt>
sys_getpgid
</dt>
<dd>
<p>
  <em>sys_getpgid( pid_t pid)</em><br>
 <strong>get the process group ID for a process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.247
</p>
</dd>
<dt>
sys_getpgrp
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_getpgrp,0)</em><br>
 <strong>get the process group ID of the calling process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.227
</p>
</dd>
<dt>
sys_getpid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_getpid,0)</em><br>
 <strong>get the process ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.83
</p>
</dd>
<dt>
sys_getppid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_getppid,0)</em><br>
 <strong>get the parent process ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.225
</p>
</dd>
<dt>
sys_getpriority
</dt>
<dd>
<p>
  <em>sys_getpriority( int which,  int who)</em><br>
 <strong>get and set the nice value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.283
</p>
</dd>
<dt>
sys_getrandom
</dt>
<dd>
<p>
  <em>sys_getrandom( char  <strong>buf,  size_t count,  unsigned int flags)</em><br>
 *obtain a series of random bytes</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.611
</p>
</dd>
<dt>
sys_getresgid
</dt>
<dd>
<p>
  <em>sys_getresgid( gid_t <strong>rgid,  gid_t *egid,  gid_t *sgid)</em><br>
 *get real, effective and saved user/group IDs</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.245
</p>
</dd>
<dt>
sys_getresuid
</dt>
<dd>
<p>
  <em>sys_getresuid( uid_t <strong>ruid,  uid_t *euid,  uid_t *suid)</em><br>
 *get real, effective and saved user/group IDs</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.241
</p>
</dd>
<dt>
sys_getrlimit
</dt>
<dd>
<p>
  <em>sys_getrlimit( unsigned int resource,  struct rlimit <strong>rlim)</em><br>
 *control maximum resource consumption</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.199
</p>
</dd>
<dt>
sys_getrusage
</dt>
<dd>
<p>
  <em>sys_getrusage( int who,  struct rusage <strong>ru)</em><br>
 *get information about resource utilization</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.201
</p>
</dd>
<dt>
sys_getsid
</dt>
<dd>
<p>
  <em>sys_getsid( pid_t pid)</em><br>
 <strong>get the process group ID of a session leader</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.253
</p>
</dd>
<dt>
sys_getsockname
</dt>
<dd>
<p>
  <em>sys_getsockname( int fd,  struct sockaddr <strong>usockaddr,  int *usockaddr_len)</em><br>
 *get the socket name</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.107
</p>
</dd>
<dt>
sys_getsockopt
</dt>
<dd>
<p>
  <em>sys_getsockopt( int fd,  int level,  int optname,  char <strong>optval,  int *optlen)</em><br>
 *get the socket options</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.115
</p>
</dd>
<dt>
sys_gettid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_gettid,0)</em><br>
 <strong>get thread identification</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.357
</p>
</dd>
<dt>
sys_gettimeofday
</dt>
<dd>
<p>
  <em>sys_gettimeofday( struct timeval <strong>tv,  struct timezone *tz)</em><br>
 *get the date and time</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.197
</p>
</dd>
<dt>
sys_getuid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_getuid,0)</em><br>
 <strong>get a real user ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.209
</p>
</dd>
<dt>
sys_getxattr
</dt>
<dd>
<p>
  <em>sys_getxattr( const char <strong>pathname,  const char *name,  void *value,  size_t size)</em><br>
 *retrieve an extended attribute value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.367
</p>
</dd>
<dt>
sys_init_module
</dt>
<dd>
<p>
  <em>sys_init_module( void <strong>umod,  unsigned long len,  const char *uargs)</em><br>
 *load a kernel module</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.351
</p>
</dd>
<dt>
sys_inotify_add_watch
</dt>
<dd>
<p>
  <em>sys_inotify_add_watch( int fd,  const char <strong>pathname,  u32 mask)</em><br>
 *add a watch to an initialized inotify instance</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.483
</p>
</dd>
<dt>
sys_inotify_init
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_inotify_init,0)</em><br>
 <strong>initialize an inotify instance</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.481
</p>
</dd>
<dt>
sys_inotify_init1
</dt>
<dd>
<p>
  <em>sys_inotify_init1( int flags)</em><br>
 <strong>initialize an inotify instance</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.563
</p>
</dd>
<dt>
sys_inotify_rm_watch
</dt>
<dd>
<p>
  <em>sys_inotify_rm_watch( int fd,  __s32 wd)</em><br>
 <strong>remove an existing watch from an inotify instance</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.485
</p>
</dd>
<dt>
sys_io_cancel
</dt>
<dd>
<p>
  <em>sys_io_cancel( aio_context_t ctx_id,  struct iocb <strong>iocb,  struct io_event *result)</em><br>
 *cancel an outstanding asynchronous I/O operation</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.403
</p>
</dd>
<dt>
sys_io_destroy
</dt>
<dd>
<p>
  <em>sys_io_destroy( aio_context_t ctx)</em><br>
 <strong>destroy an asynchronous I/O context</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.397
</p>
</dd>
<dt>
sys_io_getevents
</dt>
<dd>
<p>
  <em>sys_io_getevents( aio_context_t ctx_id,  long min_nr,  long nr,  struct io_event <strong>events)</em><br>
 *read asynchronous I/O events from the completion queue</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.399
</p>
</dd>
<dt>
sys_io_setup
</dt>
<dd>
<p>
  <em>sys_io_setup( unsigned nr_events,  aio_context_t <strong>ctxp)</em><br>
 *create an asynchronous I/O context</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.395
</p>
</dd>
<dt>
sys_io_submit
</dt>
<dd>
<p>
  <em>sys_io_submit( aio_context_t ctx_id,  long nr,  struct iocb <strong>*iocbpp)</em><br>
 *submit asynchronous I/O blocks for processing</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.401
</p>
</dd>
<dt>
sys_ioctl
</dt>
<dd>
<p>
  <em>sys_ioctl( unsigned int fd,  unsigned int cmd,  unsigned long arg)</em><br>
 <strong>control a STREAMS device (\fBSTREAMS\fP)</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.37
</p>
</dd>
<dt>
sys_ioperm
</dt>
<dd>
<p>
  <em>sys_ioperm( unsigned long from,  unsigned long num,  int turn_on)</em><br>
 <strong>set port input/output permissions</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.349
</p>
</dd>
<dt>
sys_iopl
</dt>
<dd>
<p>
  <em>sys_iopl( unsigned int level,  struct pt_regs <strong>regs)</em><br>
 *change I/O privilege level</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.347
</p>
</dd>
<dt>
sys_ioprio_get
</dt>
<dd>
<p>
  <em>sys_ioprio_get( int which,  int who)</em><br>
 <strong>get/set I/O scheduling class and priority</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.479
</p>
</dd>
<dt>
sys_ioprio_set
</dt>
<dd>
<p>
  <em>sys_ioprio_set( int which,  int who,  int ioprio)</em><br>
 <strong>get/set I/O scheduling class and priority</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.477
</p>
</dd>
<dt>
sys_kcmp
</dt>
<dd>
<p>
  <em>sys_kcmp( pid_t pid1,  pid_t pid2,  int type,  unsigned long idx1,  unsigned long idx2)</em><br>
 <strong>compare two processes to determine if they share a kernel resource</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.599
</p>
</dd>
<dt>
sys_kexec_file_load
</dt>
<dd>
<p>
  <em>sys_kexec_file_load( int kernel_fd,  int initrd_fd,  unsigned long cmdline_len,  const char  <strong>cmdline_ptr,  unsigned long flags)</em><br>
 *load a new kernel for later execution</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.615
</p>
</dd>
<dt>
sys_kexec_load
</dt>
<dd>
<p>
  <em>sys_kexec_load( unsigned long entry,  unsigned long nr_segments,  struct kexec_segment <strong>segments,  unsigned long flags)</em><br>
 *load a new kernel for later execution</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.467
</p>
</dd>
<dt>
sys_keyctl
</dt>
<dd>
<p>
  <em>sys_keyctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)</em><br>
 <strong>key management function wrappers</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.475
</p>
</dd>
<dt>
sys_kill
</dt>
<dd>
<p>
  <em>sys_kill( pid_t pid,  int sig)</em><br>
 <strong>send a signal to a process or a group of processes</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.129
</p>
</dd>
<dt>
sys_lchown
</dt>
<dd>
<p>
  <em>sys_lchown( const char <strong>filename,  uid_t user,  gid_t group)</em><br>
 *change the owner and group of a symbolic link</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.193
</p>
</dd>
<dt>
sys_lgetxattr
</dt>
<dd>
<p>
  <em>sys_lgetxattr( const char <strong>pathname,  const char *name,  void *value,  size_t size)</em><br>
 *retrieve an extended attribute value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.369
</p>
</dd>
<dt>
sys_link
</dt>
<dd>
<p>
  <em>sys_link( const char <strong>oldname,  const char *newname)</em><br>
 *link one file to another file relative to two directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.177
</p>
</dd>
<dt>
sys_linkat
</dt>
<dd>
<p>
  <em>sys_linkat( int oldfd,  const char <strong>oldname,  int newfd,  const char *newname,  int flags)</em><br>
 *make a new name for a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.505
</p>
</dd>
<dt>
sys_listen
</dt>
<dd>
<p>
  <em>sys_listen( int fd,  int backlog)</em><br>
 <strong>listen for socket connections and limit the queue of incoming</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.105
</p>
</dd>
<dt>
sys_listxattr
</dt>
<dd>
<p>
  <em>sys_listxattr( const char <strong>pathname,  char *list,  size_t size)</em><br>
 *list extended attribute names</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.373
</p>
</dd>
<dt>
sys_llistxattr
</dt>
<dd>
<p>
  <em>sys_llistxattr( const char <strong>pathname,  char *list,  size_t size)</em><br>
 *list extended attribute names</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.375
</p>
</dd>
<dt>
sys_lookup_dcookie
</dt>
<dd>
<p>
  <em>sys_lookup_dcookie( u64 cookie64,  long buf,  long len)</em><br>
 <strong>return a directory entry&#8217;s path</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.405
</p>
</dd>
<dt>
sys_lremovexattr
</dt>
<dd>
<p>
  <em>sys_lremovexattr( const char <strong>pathname,  const char *name)</em><br>
 *remove an extended attribute</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.381
</p>
</dd>
<dt>
sys_lseek
</dt>
<dd>
<p>
  <em>sys_lseek( unsigned int fd,  off_t offset,  unsigned int origin)</em><br>
 <strong>move the read/write file offset</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.21
</p>
</dd>
<dt>
sys_lsetxattr
</dt>
<dd>
<p>
  <em>sys_lsetxattr( const char <strong>pathname,  const char *name,  const void *value, size_t size,  int flags)</em><br>
 *set an extended attribute value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.363
</p>
</dd>
<dt>
sys_lstat
</dt>
<dd>
<p>
  <em>sys_lstat( const char <strong>filename,  struct stat *statbuf)</em><br>
 *get file status</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.17
</p>
</dd>
<dt>
sys_madvise
</dt>
<dd>
<p>
  <em>sys_madvise( unsigned long start,  size_t len_in,  int behavior)</em><br>
 <strong>give advice about use of memory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.61
</p>
</dd>
<dt>
sys_mbind
</dt>
<dd>
<p>
  <em>sys_mbind( unsigned long start,  unsigned long len,  unsigned long mode,  unsigned long <strong>nmask,  unsigned long maxnode,  unsigned flags)</em><br>
 *set memory policy for a memory range</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.449
</p>
</dd>
<dt>
sys_memfd_create
</dt>
<dd>
<p>
  <em>sys_memfd_create( const char  <strong>uname_ptr,  unsigned int flags)</em><br>
 *create an anonymous file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.613
</p>
</dd>
<dt>
sys_migrate_pages
</dt>
<dd>
<p>
  <em>sys_migrate_pages( pid_t pid,  unsigned long maxnode,  const unsigned long <strong>old_nodes,  const unsigned long *new_nodes)</em><br>
 *move all pages in a process to another set of nodes</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.487
</p>
</dd>
<dt>
sys_mincore
</dt>
<dd>
<p>
  <em>sys_mincore( unsigned long start,  size_t len,  unsigned char <strong>vec)</em><br>
 *determine whether pages are resident in memory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.59
</p>
</dd>
<dt>
sys_mkdir
</dt>
<dd>
<p>
  <em>sys_mkdir( const char <strong>pathname,  int mode)</em><br>
 *make a directory relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.171
</p>
</dd>
<dt>
sys_mkdirat
</dt>
<dd>
<p>
  <em>sys_mkdirat( int dfd,  const char <strong>pathname,  int mode)</em><br>
 *create a directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.491
</p>
</dd>
<dt>
sys_mknod
</dt>
<dd>
<p>
  <em>sys_mknod( const char <strong>filename,  umode_t mode,  unsigned dev)</em><br>
 *make directory, special file, or regular file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.271
</p>
</dd>
<dt>
sys_mknodat
</dt>
<dd>
<p>
  <em>sys_mknodat( int dfd,  const char <strong>filename,  int mode,  unsigned dev)</em><br>
 *create a special or ordinary file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.493
</p>
</dd>
<dt>
sys_mlock
</dt>
<dd>
<p>
  <em>sys_mlock( unsigned long start,  size_t len)</em><br>
 <strong>lock or unlock a range of process address space</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.301
</p>
</dd>
<dt>
sys_mlockall
</dt>
<dd>
<p>
  <em>sys_mlockall( int flags)</em><br>
 <strong>lock/unlock the address space of a process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.305
</p>
</dd>
<dt>
sys_mmap
</dt>
<dd>
<p>
  <em>sys_mmap( unsigned long addr,  unsigned long len,  unsigned long prot,  unsigned long flags,  unsigned long fd,  unsigned long off)</em><br>
 <strong>map pages of memory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.23
</p>
</dd>
<dt>
sys_modify_ldt
</dt>
<dd>
<p>
  <em>sys_modify_ldt( int func,  void <strong>ptr,  unsigned long bytecount)</em><br>
 *get or set a per-process LDT entry</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.311
</p>
</dd>
<dt>
sys_mount
</dt>
<dd>
<p>
  <em>sys_mount( char <strong>dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)</em><br>
 *mount filesystem</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.333
</p>
</dd>
<dt>
sys_move_pages
</dt>
<dd>
<p>
  <em>sys_move_pages( pid_t pid,  unsigned long nr_pages,  const void <strong>pages[], const int *nodes,  int *status,  int flags)</em><br>
 *move individual pages of a process to another node</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.533
</p>
</dd>
<dt>
sys_mprotect
</dt>
<dd>
<p>
  <em>sys_mprotect( unsigned long start,  size_t len,  unsigned long prot)</em><br>
 <strong>set protection of memory mapping</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.25
</p>
</dd>
<dt>
sys_mq_getsetattr
</dt>
<dd>
<p>
  <em>sys_mq_getsetattr( mqd_t mqdes,  const struct mq_attr <strong>u_mqstat,  struct mq_attr *u_omqstat)</em><br>
 *get/set message queue attributes</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.465
</p>
</dd>
<dt>
sys_mq_notify
</dt>
<dd>
<p>
  <em>sys_mq_notify( mqd_t mqdes,  const struct sigevent <strong>u_notification)</em><br>
 *notify process that a message is available</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.463
</p>
</dd>
<dt>
sys_mq_open
</dt>
<dd>
<p>
  <em>sys_mq_open( const char <strong>u_name,  int oflag,  mode_t mode,  struct mq_attr *u_attr)</em><br>
 *open a message queue</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.455
</p>
</dd>
<dt>
sys_mq_timedreceive
</dt>
<dd>
<p>
  <em>sys_mq_timedreceive( mqd_t mqdes,  char <strong>u_msg_ptr,  size_t msg_len,  unsigned int *u_msg_prio,  const struct timespec *u_abs_timeout)</em><br>
 *receive a message from a message queue</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.461
</p>
</dd>
<dt>
sys_mq_timedsend
</dt>
<dd>
<p>
  <em>sys_mq_timedsend( mqd_t mqdes,  const char <strong>u_msg_ptr,  size_t msg_len,  unsigned int msg_prio,  const struct timespec *u_abs_timeout)</em><br>
 *send a message to a message queue</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.459
</p>
</dd>
<dt>
sys_mq_unlink
</dt>
<dd>
<p>
  <em>sys_mq_unlink( const char <strong>u_name)</em><br>
 *remove a message queue</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.457
</p>
</dd>
<dt>
sys_mremap
</dt>
<dd>
<p>
  <em>sys_mremap( unsigned long addr,  unsigned long old_len,  unsigned long new_len,  unsigned long flags,  unsigned long new_addr)</em><br>
 <strong>remap a virtual memory address</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.55
</p>
</dd>
<dt>
sys_msgctl
</dt>
<dd>
<p>
  <em>sys_msgctl( int msqid,  int cmd,  struct msqid_ds <strong>buf)</em><br>
 *XSI message control operations</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.147
</p>
</dd>
<dt>
sys_msgget
</dt>
<dd>
<p>
  <em>sys_msgget( key_t key,  int msgflg)</em><br>
 <strong>get the XSI message queue identifier</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.141
</p>
</dd>
<dt>
sys_msgrcv
</dt>
<dd>
<p>
  <em>sys_msgrcv( int msqid,  struct msgbuf <strong>msgp,  size_t msgsz,  long msgtyp,  int msgflg)</em><br>
 *XSI message receive operation</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.145
</p>
</dd>
<dt>
sys_msgsnd
</dt>
<dd>
<p>
  <em>sys_msgsnd( int msqid,  struct msgbuf <strong>msgp,  size_t msgsz,  int msgflg)</em><br>
 *XSI message send operation</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.143
</p>
</dd>
<dt>
sys_msync
</dt>
<dd>
<p>
  <em>sys_msync( unsigned long start,  size_t len,  int flags)</em><br>
 <strong>synchronize memory with physical storage</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.57
</p>
</dd>
<dt>
sys_munlock
</dt>
<dd>
<p>
  <em>sys_munlock( unsigned long start,  size_t len)</em><br>
 <strong>unlock a range of process address space</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.303
</p>
</dd>
<dt>
sys_munlockall
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_munlockall,0)</em><br>
 <strong>unlock the address space of a process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.307
</p>
</dd>
<dt>
sys_munmap
</dt>
<dd>
<p>
  <em>sys_munmap( unsigned long addr,  size_t len)</em><br>
 <strong>unmap pages of memory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.27
</p>
</dd>
<dt>
sys_name_to_handle_at
</dt>
<dd>
<p>
  <em>sys_name_to_handle_at( int dfd,  const char <strong>name,  struct file_handle *handle,  int *mnt_id,  int flag)</em><br>
 *obtain handle</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.581
</p>
</dd>
<dt>
sys_nanosleep
</dt>
<dd>
<p>
  <em>sys_nanosleep( struct timespec <strong>rqtp,  struct timespec *rmtp)</em><br>
 *high resolution sleep</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.75
</p>
</dd>
<dt>
sys_newfstatat
</dt>
<dd>
<p>
  <em>sys_newfstatat( int dfd,  const char <strong>filename,  struct stat *statbuf,  int flag)</em><br>
 *get file status</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.499
</p>
</dd>
<dt>
sys_open
</dt>
<dd>
<p>
  <em>sys_open( const char <strong>filename,  int flags,  int mode)</em><br>
 *open file relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.9
</p>
</dd>
<dt>
sys_open_by_handle_at
</dt>
<dd>
<p>
  <em>sys_open_by_handle_at( int dfd,  const char <strong>name,  struct file_handle *handle,  int *mnt_id,  int flags)</em><br>
 *obtain handle</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.583
</p>
</dd>
<dt>
sys_openat
</dt>
<dd>
<p>
  <em>sys_openat( int dfd,  const char <strong>filename,  int flags,  int mode)</em><br>
 *open file relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.489
</p>
</dd>
<dt>
sys_pause
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_pause,0)</em><br>
 <strong>suspend the thread until a signal is received</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.73
</p>
</dd>
<dt>
sys_perf_event_open
</dt>
<dd>
<p>
  <em>sys_perf_event_open( struct perf_event_attr <strong>attr_uptr,  pid_t pid,  int cpu,  int group_fd,  unsigned long flags)</em><br>
 *set up performance monitoring</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.571
</p>
</dd>
<dt>
sys_personality
</dt>
<dd>
<p>
  <em>sys_personality( unsigned int personality)</em><br>
 <strong>set the process execution domain</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.273
</p>
</dd>
<dt>
sys_pipe
</dt>
<dd>
<p>
  <em>sys_pipe( int <strong>filedes)</em><br>
 *create an interprocess channel</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.49
</p>
</dd>
<dt>
sys_pipe2
</dt>
<dd>
<p>
  <em>sys_pipe2( int <strong>filedes,  int flags)</em><br>
 *create pipe</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.561
</p>
</dd>
<dt>
sys_pivot_root
</dt>
<dd>
<p>
  <em>sys_pivot_root( const char <strong>new_root,  const char *put_old)</em><br>
 *change the root mount</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.313
</p>
</dd>
<dt>
sys_poll
</dt>
<dd>
<p>
  <em>sys_poll( struct poll_fd <strong>ufds,  unsigned int nfds,  long timeout_msecs)</em><br>
 *input/output multiplexing</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.19
</p>
</dd>
<dt>
sys_ppoll
</dt>
<dd>
<p>
  <em>sys_ppoll( struct pollfd <strong>ufds,  unsigned int nfds,  struct timespec *tsp,  const sigset_t *sigmask,  size_t sigsetsize)</em><br>
 *wait for some event on a file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.517
</p>
</dd>
<dt>
sys_prctl
</dt>
<dd>
<p>
  <em>sys_prctl( int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)</em><br>
 <strong>operations on a process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.317
</p>
</dd>
<dt>
sys_pread64
</dt>
<dd>
<p>
  <em>sys_pread64( unsigned long fd,  char <strong>buf,  size_t count,  loff_t pos)</em><br>
 *read from or write to a file descriptor at a given offset</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.39
</p>
</dd>
<dt>
sys_preadv
</dt>
<dd>
<p>
  <em>sys_preadv( unsigned long fd,  const struct iovec <strong>vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)</em><br>
 *read or write data into multiple buffers</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.565
</p>
</dd>
<dt>
sys_prlimit64
</dt>
<dd>
<p>
  <em>sys_prlimit64( pid_t pid,  unsigned int resource,  const struct rlimit64 <strong>new_rlim,  struct rlimit64 *old_rlim)</em><br>
 *get/set resource limits</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.579
</p>
</dd>
<dt>
sys_process_vm_readv
</dt>
<dd>
<p>
  <em>sys_process_vm_readv( pid_t pid,  const struct iovec <strong>lvec,  unsigned long liovcnt,  const struct iovec *rvec,  unsigned long riovcnt,  unsigned long flags)</em><br>
 *transfer data between process address spaces</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.595
</p>
</dd>
<dt>
sys_process_vm_writev
</dt>
<dd>
<p>
  <em>sys_process_vm_writev( pid_t pid,  const struct iovec <strong>lvec,  unsigned long liovcnt,  const struct iovcc *rvec,  unsigned long riovcnt,  unsigned long flags)</em><br>
 *transfer data between process address spaces</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.597
</p>
</dd>
<dt>
sys_pselect6
</dt>
<dd>
<p>
  <em>sys_pselect6( int n,  fd_set <strong>inp,  fd_set *outp,  fd_set *exp,  struct timespec *tsp,  void *sig)</em><br>
 *select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO \-</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.515
</p>
</dd>
<dt>
sys_ptrace
</dt>
<dd>
<p>
  <em>sys_ptrace( long request,  long pid,  unsigned long addr,  unsigned long data)</em><br>
 <strong>process trace</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.207
</p>
</dd>
<dt>
sys_pwrite64
</dt>
<dd>
<p>
  <em>sys_pwrite64( unsigned int fd,  const char <strong>buf,  size_t count,  loff_t pos)</em><br>
 *read from or write to a file descriptor at a given offset</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.41
</p>
</dd>
<dt>
sys_pwritev
</dt>
<dd>
<p>
  <em>sys_pwritev( unsigned long fd,  const struct iovec <strong>vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)</em><br>
 *read or write data into multiple buffers</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.567
</p>
</dd>
<dt>
sys_quotactl
</dt>
<dd>
<p>
  <em>sys_quotactl( unsigned int cmd,  const char <strong>special,  qid_t id,  void *addr)</em><br>
 *manipulate disk quotas</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.355
</p>
</dd>
<dt>
sys_read
</dt>
<dd>
<p>
  <em>sys_read( unsigned int fd,  char <strong>buf,  size_t count)</em><br>
 *read from a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.5
</p>
</dd>
<dt>
sys_readahead
</dt>
<dd>
<p>
  <em>sys_readahead( int fd,  loff_t offset,  size_t count)</em><br>
 <strong>initiate file readahead into page cache</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.359
</p>
</dd>
<dt>
sys_readlink
</dt>
<dd>
<p>
  <em>sys_readlink( const char <strong>path,  char *buf,  int bufsiz)</em><br>
 *read the contents of a symbolic link</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.183
</p>
</dd>
<dt>
sys_readlinkat
</dt>
<dd>
<p>
  <em>sys_readlinkat( int dfd,  const char <strong>pathname,  char *buf,  int bufsiz)</em><br>
 *read value of a symbolic link</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.509
</p>
</dd>
<dt>
sys_readv
</dt>
<dd>
<p>
  <em>sys_readv( unsigned long fd,  const struct iovec <strong>vec,  unsigned long vlen)</em><br>
 *read a vector</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.43
</p>
</dd>
<dt>
sys_reboot
</dt>
<dd>
<p>
  <em>sys_reboot( int magic1,  int magic2,  unsigned int cmd,  void <strong>arg)</em><br>
 *reboot or enable/disable Ctrl-Alt-Del</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.341
</p>
</dd>
<dt>
sys_recvfrom
</dt>
<dd>
<p>
  <em>sys_recvfrom( int fd,  void <strong>ubuf,  size_t size,  unsigned flags,  struct sockaddr *addr,  int *addr_len)</em><br>
 *receive a message from a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.95
</p>
</dd>
<dt>
sys_recvmmsg
</dt>
<dd>
<p>
  <em>sys_recvmmsg( int fd,  struct msghdr <strong>mmsg,  unsigned int vlen,  unsigned int flags,  struct timespec *timeout)</em><br>
 *receive multiple messages on a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.573
</p>
</dd>
<dt>
sys_recvmsg
</dt>
<dd>
<p>
  <em>sys_recvmsg( int fd,  struct msghdr <strong>msg,  unsigned int flags)</em><br>
 *receive a message from a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.99
</p>
</dd>
<dt>
sys_remap_file_pages
</dt>
<dd>
<p>
  <em>sys_remap_file_pages( unsigned long start,  unsigned long size,  unsigned long prot,  unsigned long pgoff,  unsigned long flags)</em><br>
 <strong>create a nonlinear file mapping</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.409
</p>
</dd>
<dt>
sys_removexattr
</dt>
<dd>
<p>
  <em>sys_removexattr( const char <strong>pathname,  const char *name)</em><br>
 *remove an extended attribute</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.379
</p>
</dd>
<dt>
sys_rename
</dt>
<dd>
<p>
  <em>sys_rename( const char <strong>oldname,  const char *newname)</em><br>
 *rename file relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.169
</p>
</dd>
<dt>
sys_renameat
</dt>
<dd>
<p>
  <em>sys_renameat( int oldfd,  const char <strong>oldname,  int newfd,  const char *newname)</em><br>
 *change the name or location of a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.503
</p>
</dd>
<dt>
sys_renameat2
</dt>
<dd>
<p>
  <em>sys_renameat2( int olddfd,  const char  <strong>oldname,  int newdfd,  const char  *newname,  unsigned int flags)</em><br>
 *change the name or location of a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.607
</p>
</dd>
<dt>
sys_request_key
</dt>
<dd>
<p>
  <em>sys_request_key( const char <strong>_type,  const char *_description,  const char *_callout_info,  key_serial_t destringid)</em><br>
 *request a key from the kernel&#8217;s key management facility</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.473
</p>
</dd>
<dt>
sys_restart_syscall
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_restart_syscall,0)</em><br>
 <strong>restart a system call after interruption by a stop signal</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.415
</p>
</dd>
<dt>
sys_rmdir
</dt>
<dd>
<p>
  <em>sys_rmdir( const char <strong>pathname)</em><br>
 *remove a directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.173
</p>
</dd>
<dt>
sys_rt_sigaction
</dt>
<dd>
<p>
  <em>sys_rt_sigaction( int sig,  const struct sigaction <strong>act,  struct sigaction *oact,  size_t sigsetsize)</em><br>
 *examine and change a signal action</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.31
</p>
</dd>
<dt>
sys_rt_sigpending
</dt>
<dd>
<p>
  <em>sys_rt_sigpending( sigset_t <strong>set,  size_t sigsetsize)</em><br>
 *examine pending signals</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.259
</p>
</dd>
<dt>
sys_rt_sigprocmask
</dt>
<dd>
<p>
  <em>sys_rt_sigprocmask( int how,  sigset_t <strong>nset,  sigset_t *oset,  size_t sigsetsize)</em><br>
 *examine and change blocked signals</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.33
</p>
</dd>
<dt>
sys_rt_sigqueueinfo
</dt>
<dd>
<p>
  <em>sys_rt_sigqueueinfo( pid_t pid,  int sig,  siginfo_t <strong>uinfo)</em><br>
 *queue a signal and data</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.263
</p>
</dd>
<dt>
sys_rt_sigreturn
</dt>
<dd>
<p>
  <em>sys_rt_sigreturn( unsigned long __unused)</em><br>
 <strong>return from signal handler and cleanup stack frame</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.35
</p>
</dd>
<dt>
sys_rt_sigsuspend
</dt>
<dd>
<p>
  <em>sys_rt_sigsuspend( sigset_t <strong>unewset,  size_t sigsetsize)</em><br>
 *wait for a signal</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.265
</p>
</dd>
<dt>
sys_rt_sigtimedwait
</dt>
<dd>
<p>
  <em>sys_rt_sigtimedwait( const sigset_t <strong>uthese,  siginfo_t *uinfo,  const struct timespec *uts,  size_t sigsetsize)</em><br>
 *synchronously wait</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.261
</p>
</dd>
<dt>
sys_rt_tgsigqueueinfo
</dt>
<dd>
<p>
  <em>sys_rt_tgsigqueueinfo( pid_t tgid,  pid_t pid,  int sig,  siginfo_t <strong>uinfo)</em><br>
 *queue a signal and data</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.569
</p>
</dd>
<dt>
sys_sched_get_priority_max
</dt>
<dd>
<p>
  <em>sys_sched_get_priority_max( int policy)</em><br>
 <strong>get priority limits</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.295
</p>
</dd>
<dt>
sys_sched_get_priority_min
</dt>
<dd>
<p>
  <em>sys_sched_get_priority_min( int policy)</em><br>
 <strong>get static priority range</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.297
</p>
</dd>
<dt>
sys_sched_getaffinity
</dt>
<dd>
<p>
  <em>sys_sched_getaffinity( pid_t pid,  unsigned int len,  unsigned long <strong>user_mask_ptr)</em><br>
 *set and get a thread&#8217;s CPU affinity mask</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.393
</p>
</dd>
<dt>
sys_sched_getattr
</dt>
<dd>
<p>
  <em>sys_sched_getattr( pid_t pid,  struct sched_attr  <strong>attr,  unsigned int size,  unsigned int flags)</em><br>
 *sched_setattr, sched_getattr \-</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.605
</p>
</dd>
<dt>
sys_sched_getparam
</dt>
<dd>
<p>
  <em>sys_sched_getparam( pid_t pid,  struct sched_param <strong>param)</em><br>
 *get scheduling parameters</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.289
</p>
</dd>
<dt>
sys_sched_getscheduler
</dt>
<dd>
<p>
  <em>sys_sched_getscheduler( pid_t pid)</em><br>
 <strong>get scheduling policy</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.293
</p>
</dd>
<dt>
sys_sched_rr_get_interval
</dt>
<dd>
<p>
  <em>sys_sched_rr_get_interval( pid_t pid,  struct timespec <strong>interval)</em><br>
 *get execution time limits</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.299
</p>
</dd>
<dt>
sys_sched_setaffinity
</dt>
<dd>
<p>
  <em>sys_sched_setaffinity( pid_t pid,  unsigned int len,  unsigned long <strong>user_mask_ptr)</em><br>
 *set and get a thread&#8217;s CPU affinity mask</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.391
</p>
</dd>
<dt>
sys_sched_setattr
</dt>
<dd>
<p>
  <em>sys_sched_setattr( pid_t pid,  struct sched_attr  <strong>attr,  unsigned int flags)</em><br>
 *sched_setattr, sched_getattr \-</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.603
</p>
</dd>
<dt>
sys_sched_setparam
</dt>
<dd>
<p>
  <em>sys_sched_setparam( pid_t pid,  struct sched_param <strong>param)</em><br>
 *set scheduling parameters</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.287
</p>
</dd>
<dt>
sys_sched_setscheduler
</dt>
<dd>
<p>
  <em>sys_sched_setscheduler( pid_t pid,  int policy,  struct sched_param <strong>param)</em><br>
 *set scheduling policy and parameters</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.291
</p>
</dd>
<dt>
sys_sched_yield
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_sched_yield,0)</em><br>
 <strong>yield the processor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.53
</p>
</dd>
<dt>
sys_seccomp
</dt>
<dd>
<p>
  <em>sys_seccomp( unsigned int op,  unsigned int flags,  const char  <strong>uargs)</em><br>
 *operate on Secure Computing state of the process</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.609
</p>
</dd>
<dt>
sys_select
</dt>
<dd>
<p>
  <em>sys_select( int n,  fd_set <strong>inp,  fd_set *outp,  fd_set *exp,  struct timeval *tvp)</em><br>
 *synchronous I/O multiplexing</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.51
</p>
</dd>
<dt>
sys_semctl
</dt>
<dd>
<p>
  <em>sys_semctl( int semid,  int semnum,  int cmd,  semun_u arg)</em><br>
 <strong>XSI semaphore control operations</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.137
</p>
</dd>
<dt>
sys_semget
</dt>
<dd>
<p>
  <em>sys_semget( key_t key,  int nsems,  int semflg)</em><br>
 <strong>get set of XSI semaphores</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.133
</p>
</dd>
<dt>
sys_semop
</dt>
<dd>
<p>
  <em>sys_semop( int semid,  struct sembuf <strong>tsops,  unsigned nsops)</em><br>
 *XSI semaphore operations</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.135
</p>
</dd>
<dt>
sys_semtimedop
</dt>
<dd>
<p>
  <em>sys_semtimedop( int semid,  struct sembuf <strong>tsops,  unsigned nsops,  const struct timespec *timeout)</em><br>
 *System V semaphore operations</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.417
</p>
</dd>
<dt>
sys_sendfile
</dt>
<dd>
<p>
  <em>sys_sendfile( int out_fd,  int in_fd,  off_t <strong>offset,  size_t count)</em><br>
 *transfer data between file descriptors</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.85
</p>
</dd>
<dt>
sys_sendmmsg
</dt>
<dd>
<p>
  <em>sys_sendmmsg( int fd,  struct mmsghdr <strong>mmsg,  unsigned int vlen,  unsigned int flags)</em><br>
 *send multiple messages on a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.589
</p>
</dd>
<dt>
sys_sendmsg
</dt>
<dd>
<p>
  <em>sys_sendmsg( int fd,  struct msghdr <strong>msg,  unsigned flags)</em><br>
 *send a message on a socket using a message structure</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.97
</p>
</dd>
<dt>
sys_sendto
</dt>
<dd>
<p>
  <em>sys_sendto( int fd,  void <strong>buff,  size_t len,  unsigned flags,  struct sockaddr *addr,  int addr_len)</em><br>
 *send a message on a socket</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.93
</p>
</dd>
<dt>
sys_set_mempolicy
</dt>
<dd>
<p>
  <em>sys_set_mempolicy( int mode,  unsigned long <strong>nmask,  unsigned long maxnode)</em><br>
 *set default NUMA memory policy for a thread and its children</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.451
</p>
</dd>
<dt>
sys_set_robust_list
</dt>
<dd>
<p>
  <em>sys_set_robust_list( struct robust_list_head <strong>head,  size_t len)</em><br>
 *get/set list of robust futexes</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.521
</p>
</dd>
<dt>
sys_set_tid_address
</dt>
<dd>
<p>
  <em>sys_set_tid_address( int <strong>tidptr)</em><br>
 *set pointer to thread ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.413
</p>
</dd>
<dt>
sys_setdomainname
</dt>
<dd>
<p>
  <em>sys_setdomainname( char <strong>name,  int len)</em><br>
 *get/set NIS domain name</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.345
</p>
</dd>
<dt>
sys_setfsgid
</dt>
<dd>
<p>
  <em>sys_setfsgid( gid_t gid)</em><br>
 <strong>set group identity used for filesystem checks</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.251
</p>
</dd>
<dt>
sys_setfsuid
</dt>
<dd>
<p>
  <em>sys_setfsuid( uid_t uid)</em><br>
 <strong>set user identity used for filesystem checks</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.249
</p>
</dd>
<dt>
sys_setgid
</dt>
<dd>
<p>
  <em>sys_setgid( gid_t gid)</em><br>
 <strong>set-group-ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.217
</p>
</dd>
<dt>
sys_setgroups
</dt>
<dd>
<p>
  <em>sys_setgroups( int gidsetsize,  gid_t <strong>grouplist)</em><br>
 *get/set list of supplementary group IDs</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.237
</p>
</dd>
<dt>
sys_sethostname
</dt>
<dd>
<p>
  <em>sys_sethostname( char <strong>name,  int len)</em><br>
 *get/set hostname</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.343
</p>
</dd>
<dt>
sys_setitimer
</dt>
<dd>
<p>
  <em>sys_setitimer( int which,  struct itimerval <strong>value,  struct itimerval *ovalue)</em><br>
 *set the value of an interval timer</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.81
</p>
</dd>
<dt>
sys_setns
</dt>
<dd>
<p>
  <em>sys_setns( int fd,  int nstype)</em><br>
 <strong>reassociate thread with a namespace</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.591
</p>
</dd>
<dt>
sys_setpgid
</dt>
<dd>
<p>
  <em>sys_setpgid( pid_t pid,  pid_t pgid)</em><br>
 <strong>set process group ID for job control</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.223
</p>
</dd>
<dt>
sys_setpriority
</dt>
<dd>
<p>
  <em>sys_setpriority( int which,  int who,  int niceval)</em><br>
 <strong>set the nice value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.285
</p>
</dd>
<dt>
sys_setregid
</dt>
<dd>
<p>
  <em>sys_setregid( gid_t rgid,  gid_t egid)</em><br>
 <strong>set real and effective group IDs</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.233
</p>
</dd>
<dt>
sys_setresgid
</dt>
<dd>
<p>
  <em>sys_setresgid( gid_t rgid,  gid_t egid,  gid_t sgid)</em><br>
 <strong>set real, effective and saved user or group ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.243
</p>
</dd>
<dt>
sys_setresuid
</dt>
<dd>
<p>
  <em>sys_setresuid( uid_t <strong>ruid,  uid_t *euid,  uid_t *suid)</em><br>
 *set real, effective and saved user or group ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.239
</p>
</dd>
<dt>
sys_setreuid
</dt>
<dd>
<p>
  <em>sys_setreuid( uid_t ruid,  uid_t euid)</em><br>
 <strong>set real and effective user IDs</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.231
</p>
</dd>
<dt>
sys_setrlimit
</dt>
<dd>
<p>
  <em>sys_setrlimit( unsigned int resource,  struct rlimit <strong>rlim)</em><br>
 *control maximum resource consumption</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.323
</p>
</dd>
<dt>
sys_setsid
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_setsid,0)</em><br>
 <strong>create session and set process group ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.229
</p>
</dd>
<dt>
sys_setsockopt
</dt>
<dd>
<p>
  <em>sys_setsockopt( int fd,  int level,  int optname,  char <strong>optval,  int optlen)</em><br>
 *set the socket options</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.113
</p>
</dd>
<dt>
sys_settimeofday
</dt>
<dd>
<p>
  <em>sys_settimeofday( struct timeval <strong>tv,  struct timezone *tz)</em><br>
 *get / set time</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.331
</p>
</dd>
<dt>
sys_setuid
</dt>
<dd>
<p>
  <em>sys_setuid( uid_t uid)</em><br>
 <strong>set user ID</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.215
</p>
</dd>
<dt>
sys_setxattr
</dt>
<dd>
<p>
  <em>sys_setxattr( const char <strong>pathname,  const char *name,  const void *value, size_t size,  int flags)</em><br>
 *set an extended attribute value</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.361
</p>
</dd>
<dt>
sys_shmat
</dt>
<dd>
<p>
  <em>sys_shmat( int shmid,  char <strong>shmaddr,  int shmflg)</em><br>
 *XSI shared memory attach operation</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.65
</p>
</dd>
<dt>
sys_shmctl
</dt>
<dd>
<p>
  <em>sys_shmctl( int shmid,  int cmd,  struct shmid_ds <strong>buf)</em><br>
 *XSI shared memory control operations</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.67
</p>
</dd>
<dt>
sys_shmdt
</dt>
<dd>
<p>
  <em>sys_shmdt( char <strong>shmaddr)</em><br>
 *XSI shared memory detach operation</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.139
</p>
</dd>
<dt>
sys_shmget
</dt>
<dd>
<p>
  <em>sys_shmget( key_t key,  size_t size,  int shmflg)</em><br>
 <strong>get an XSI shared memory segment</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.63
</p>
</dd>
<dt>
sys_shutdown
</dt>
<dd>
<p>
  <em>sys_shutdown( int fd,  int how)</em><br>
 <strong>shut down socket send and receive operations</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.101
</p>
</dd>
<dt>
sys_sigaltstack
</dt>
<dd>
<p>
  <em>sys_sigaltstack( const stack_t <strong>uss,  stack_t *uoss)</em><br>
 *set and get signal alternate stack context</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.267
</p>
</dd>
<dt>
sys_signalfd
</dt>
<dd>
<p>
  <em>sys_signalfd( int ufd,  sigset_t <strong>user_mask,  size_t sizemask)</em><br>
 *create a file descriptor for accepting signals</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.539
</p>
</dd>
<dt>
sys_signalfd4
</dt>
<dd>
<p>
  <em>sys_signalfd4( int ufd,  sigset_t <strong>user_mask,  size_t sizemask,  int flags)</em><br>
 *create a file descriptor for accepting signals</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.553
</p>
</dd>
<dt>
sys_socket
</dt>
<dd>
<p>
  <em>sys_socket( int family,  int type,  int protocol)</em><br>
 <strong>create an endpoint for communication</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.87
</p>
</dd>
<dt>
sys_socketpair
</dt>
<dd>
<p>
  <em>sys_socketpair( int family,  int type,  int protocol,  int <strong>usockvec)</em><br>
 *create a pair of connected sockets</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.111
</p>
</dd>
<dt>
sys_splice
</dt>
<dd>
<p>
  <em>sys_splice( int fd_in,  loff_t <strong>off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)</em><br>
 *splice data to/from a pipe</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.525
</p>
</dd>
<dt>
sys_stat
</dt>
<dd>
<p>
  <em>sys_stat( const char <strong>filename,  struct stat *statbuf)</em><br>
 *get file status</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.13
</p>
</dd>
<dt>
sys_statfs
</dt>
<dd>
<p>
  <em>sys_statfs( const char <strong>pathname,  struct statfs *buf)</em><br>
 *get filesystem statistics</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.277
</p>
</dd>
<dt>
sys_swapoff
</dt>
<dd>
<p>
  <em>sys_swapoff( const char <strong>specialfile)</em><br>
 *start/stop swapping to file/device</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.339
</p>
</dd>
<dt>
sys_swapon
</dt>
<dd>
<p>
  <em>sys_swapon( const char <strong>specialfile,  int swap_flags)</em><br>
 *start/stop swapping to file/device</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.337
</p>
</dd>
<dt>
sys_symlink
</dt>
<dd>
<p>
  <em>sys_symlink( const char <strong>oldname,  const char *newname)</em><br>
 *make a symbolic link relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.181
</p>
</dd>
<dt>
sys_symlinkat
</dt>
<dd>
<p>
  <em>sys_symlinkat( const char <strong>oldname,  int newfd,  const char *newname)</em><br>
 *make a new name for a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.507
</p>
</dd>
<dt>
sys_sync
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_sync,0)</em><br>
 <strong>schedule file system updates</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.327
</p>
</dd>
<dt>
sys_sync_file_range
</dt>
<dd>
<p>
  <em>sys_sync_file_range( long fd,  loff_t offset,  loff_t bytes,  long flags)</em><br>
 <strong>sync a file segment with disk</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.529
</p>
</dd>
<dt>
sys_syncfs
</dt>
<dd>
<p>
  <em>sys_syncfs( int fd)</em><br>
 <strong>commit filesystem caches to disk</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.587
</p>
</dd>
<dt>
sys_sysfs
</dt>
<dd>
<p>
  <em>sys_sysfs( int option,  unsigned long arg1,  unsigned long arg2)</em><br>
 <strong>get filesystem type information</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.281
</p>
</dd>
<dt>
sys_sysinfo
</dt>
<dd>
<p>
  <em>sys_sysinfo( struct sysinfo <strong>info)</em><br>
 *return system information</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.203
</p>
</dd>
<dt>
sys_syslog
</dt>
<dd>
<p>
  <em>sys_syslog( int type,  char <strong>buf,  int len)</em><br>
 *log a message</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.211
</p>
</dd>
<dt>
sys_tee
</dt>
<dd>
<p>
  <em>sys_tee( int fdin,  int fdout,  size_t len,  unsigned int flags)</em><br>
 <strong>duplicating pipe content</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.527
</p>
</dd>
<dt>
sys_tgkill
</dt>
<dd>
<p>
  <em>sys_tgkill( pid_t tgid,  pid_t pid,  int sig)</em><br>
 <strong>send a signal to a thread</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.445
</p>
</dd>
<dt>
sys_time
</dt>
<dd>
<p>
  <em>sys_time( time_t <strong>tloc)</em><br>
 *get time</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.387
</p>
</dd>
<dt>
sys_timer_create
</dt>
<dd>
<p>
  <em>sys_timer_create( const clockid_t which_clock,  struct sigevent <strong>timer_event_spec,  timer_t *created_timer_id)</em><br>
 *create a per-process timer</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.421
</p>
</dd>
<dt>
sys_timer_delete
</dt>
<dd>
<p>
  <em>sys_timer_delete( timer_t timer_id)</em><br>
 <strong>delete a per-process timer</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.429
</p>
</dd>
<dt>
sys_timer_getoverrun
</dt>
<dd>
<p>
  <em>sys_timer_getoverrun( timer_t timer_id)</em><br>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.427
</p>
</dd>
<dt>
sys_timer_gettime
</dt>
<dd>
<p>
  <em>sys_timer_gettime( timer_t timer_id,  struct itimerspec <strong>setting)</em><br>
 *arm/disarm and fetch</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.425
</p>
</dd>
<dt>
sys_timer_settime
</dt>
<dd>
<p>
  <em>sys_timer_settime( timer_t timer_id,  int flags,  const struct itimerspec <strong>new_setting,  struct itimerspec *old_setting)</em><br>
 *arm/disarm and fetch</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.423
</p>
</dd>
<dt>
sys_timerfd_create
</dt>
<dd>
<p>
  <em>sys_timerfd_create( int clockid,  int flags)</em><br>
 <strong>timerfd_create, timerfd_settime, timerfd_gettime \-</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.541
</p>
</dd>
<dt>
sys_timerfd_gettime
</dt>
<dd>
<p>
  <em>sys_timerfd_gettime( int ufd,  struct itimerspec <strong>otmr)</em><br>
 *timerfd_create, timerfd_settime, timerfd_gettime \-</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.549
</p>
</dd>
<dt>
sys_timerfd_settime
</dt>
<dd>
<p>
  <em>sys_timerfd_settime( int ufd,  int flags,  const struct itimerspec <strong>utmr,  struct itimerspec *otmr)</em><br>
 *timerfd_create, timerfd_settime, timerfd_gettime \-</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.547
</p>
</dd>
<dt>
sys_times
</dt>
<dd>
<p>
  <em>sys_times( struct sysinfo <strong>info)</em><br>
 *get process and waited-for child process times</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.205
</p>
</dd>
<dt>
sys_tkill
</dt>
<dd>
<p>
  <em>sys_tkill( pid_t pid,  int sig)</em><br>
 <strong>send a signal to a thread</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.385
</p>
</dd>
<dt>
sys_truncate
</dt>
<dd>
<p>
  <em>sys_truncate( const char <strong>path,  long length)</em><br>
 *truncate a file to a specified length</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.157
</p>
</dd>
<dt>
sys_umask
</dt>
<dd>
<p>
  <em>sys_umask( int mask)</em><br>
 <strong>set and get the file mode creation mask</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.195
</p>
</dd>
<dt>
sys_umount2
</dt>
<dd>
<p>
  <em>sys_umount2( const char <strong>target,  int flags)</em><br>
 *unmount filesystem</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.335
</p>
</dd>
<dt>
sys_uname
</dt>
<dd>
<p>
  <em>sys_uname( struct old_utsname <strong>name)</em><br>
 *get the name of the current system</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.131
</p>
</dd>
<dt>
sys_unlink
</dt>
<dd>
<p>
  <em>sys_unlink( const char <strong>pathname)</em><br>
 *remove a directory entry relative to directory file descriptor</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.179
</p>
</dd>
<dt>
sys_unlinkat
</dt>
<dd>
<p>
  <em>sys_unlinkat( int dfd,  const char <strong>pathname,  int flag)</em><br>
 *delete a name and possibly the file it refers to</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.501
</p>
</dd>
<dt>
sys_unshare
</dt>
<dd>
<p>
  <em>sys_unshare( unsigned long unshare_flags)</em><br>
 <strong>disassociate parts of the process execution context</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.519
</p>
</dd>
<dt>
sys_ustat
</dt>
<dd>
<p>
  <em>sys_ustat( unsigned dev,  struct ustat <strong>ubuf)</em><br>
 *get filesystem statistics</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.275
</p>
</dd>
<dt>
sys_utime
</dt>
<dd>
<p>
  <em>sys_utime( char <strong>filename,  struct utimbuf *times)</em><br>
 *set file access and modification times</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.269
</p>
</dd>
<dt>
sys_utimensat
</dt>
<dd>
<p>
  <em>sys_utimensat( int dfd,  const char <strong>filename,  struct timespec *utimes, int flags)</em><br>
 *set file access and modification times relative to directory</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.535
</p>
</dd>
<dt>
sys_utimes
</dt>
<dd>
<p>
  <em>sys_utimes( char <strong>filename,  struct timeval *utimes)</em><br>
 *change file last access and modification times</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.447
</p>
</dd>
<dt>
sys_vfork
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_vfork,0)</em><br>
 <strong>create a child process and block parent</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.121
</p>
</dd>
<dt>
sys_vhangup
</dt>
<dd>
<p>
  <em>sysSYSDEF_syscall(_vhangup,0)</em><br>
 <strong>virtually hangup the current terminal</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.309
</p>
</dd>
<dt>
sys_vmsplice
</dt>
<dd>
<p>
  <em>sys_vmsplice( int fd,  const struct iovec <strong>iov,  unsigned long nr_segs, unsigned int flags)</em><br>
 *splice user pages to/from a pipe</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.531
</p>
</dd>
<dt>
sys_wait4
</dt>
<dd>
<p>
  <em>sys_wait4( pid_t upid,  int <strong>stat_addr,  int options,  struct rusage *ru)</em><br>
 *wait for process to change state, BSD style</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.127
</p>
</dd>
<dt>
sys_waitid
</dt>
<dd>
<p>
  <em>sys_waitid( int which,  pid_t upid,  struct siginfo <strong>infop,  int options,  struct rusage *ru)</em><br>
 *wait for a child process to change state</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.469
</p>
</dd>
<dt>
sys_write
</dt>
<dd>
<p>
  <em>sys_write( unsigned int fd,  const char <strong>buf,  size_t count)</em><br>
 *write on a file</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.7
</p>
</dd>
<dt>
sys_writev
</dt>
<dd>
<p>
  <em>sys_writev( unsigned long fd,  const struct iovec <strong>vec,  unsigned long vlen)</em><br>
 *write a vector</strong>
<a href="../include/syscalls_x64.h">../include/syscalls_x64.h</a> l.45
</p>
</dd>
</dl>
<p></p>
<p></p>
<hr><p><small>
Last updated
 2020-07-31 13:42:53 CEST
</small></p>
</body>
</html>

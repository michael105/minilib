#if 0
ifdef UNDEF

Copyright (c) 2012-2020, Michael (Misc) Myer 
(misc.myer@zoho.com, www.github.com/michael105)
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright notice,
   the file NOTICE, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
   the file NOTICE, this list of conditions and the following disclaimer in 
   the documentation and/or other materials provided with the distribution.
 * Neither the name of the minilib nor the
   names of its contributors may be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Michael Myer BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

endif
#endif
#ifndef minilibcompiled_h
#define minilibcompiled_h

/* This file is part of minilib, (c) 2012-2020 Michael Misc Myer.
misc.myer@zoho.com / www.github.com/michael105
Licensed under the terms of the BSD 3-clause License.
Please see the files LICENSE and NOTICE for the exact conditions. 

The lines below are generated by 'make header'. 

*/


/* templates/minilib.h.top */

#ifndef LDSCRIPT


#ifndef included_minilib_h
#define included_minilib_h

/* templates/header.in */


#ifndef mini_INCLUDESRC
#ifdef INCLUDESRC
#define mini_INCLUDESRC
#endif
#endif


#ifdef HEADERGUARDS
#ifndef mini_HEADERGUARDS
#define mini_HEADERGUARDS
#endif
#endif


#ifdef HEADERGUARDS
#ifndef headerguards_h
#define headerguards_h

// prevent standard headers from being compiled

#define included_ctype_h
#define included_declarations_h
#define included_fcntl_h
#define included_ioctl_h
#define included_miniaddons_h
#define included_stdio_h
#define included_stdlib_h
#define included_string_h
#define included_time_h
#define included_unistd_h


#define _AIO_H
#define _ALIASES_H
#define _ARGP_H
#define _ARGZ_H
#define _ARPA_FTP_H
#define _ARPA_INET_H
#define _ARPA_NAMESER_H
#define _ARPA_TELNET_H
#define _ARPA_TFTP_H
#define _AR_H
#define _BITS_BYTESWAP_H
#define _BITS_CPU_SET_H
#define _BITS_ERRNO_H
#define _BITS_FLOATN_COMMON_H
#define _BITS_FLOATN_H
#define _BITS_IPCTYPES_H
#define _BITS_LIBM_SIMD_DECL_STUBS_H
#define _BITS_LOCALE_H
#define _BITS_PTHREADTYPES_ARCH_H
#define _BITS_PTHREADTYPES_COMMON_H
#define _BITS_SCHED_H
#define _BITS_SETJMP_H
#define _BITS_SIGACTION_H
#define _BITS_SIGCONTEXT_H
#define _BITS_SIGEVENT_CONSTS_H
#define _BITS_SIGINFO_ARCH_H
#define _BITS_SIGINFO_CONSTS_ARCH_H
#define _BITS_SIGINFO_CONSTS_H
#define _BITS_SIGNUM_H
#define _BITS_SIGSTACK_H
#define _BITS_SIGTHREAD_H
#define _BITS_SOCKADDR_H
#define _BITS_SS_FLAGS_H
#define _BITS_STAT_H
#define _BITS_STDINT_INTN_H
#define _BITS_STDINT_UINTN_H
#define _BITS_STDIO2_H
#define _BITS_STDIO_H
#define _BITS_STDIO_LIM_H
#define _BITS_STRING_FORTIFIED_H
#define _BITS_STROPTS_H
#define _BITS_SYSLOG_PATH_H
#define _BITS_SYSMACROS_H
#define _BITS_TIME_H
#define _BITS_TYPES_H
#define _BITS_TYPES_LOCALE_T_H
#define _BITS_TYPES_STRUCT_SCH
#define _BITS_TYPES___LOCALE_T_H
#define _BITS_UINTN_IDENTITY_H
#define _BITS_UIO_EXT_H
#define _BITS_UIO_LIM_H
#define _BITS_WCHAR_H
#define _BITS_WCTYPE_WCHAR_H
#define _BITS_XTITYPES_H
#define _BYTESWAP_H
#define _COMPLEX_H
#define _CPIO_H
#define _CRYPT_H
//#define _DIRENT_H
#define _DLFCN_H
//#define _ELF_H
//#define _ENDIAN_H
#define _ENVZ_H
#define _ERROR_H
#define _EXECINFO_H
#define _FCNTL_H
#define _FEATURES_H
#define _FENV_H
#define _FPU_CONTROL_H
#define _FSTAB_H
#define _FTW_H
#define _GCONV_H
#define _GETOPT_CORE_H
#define _GETOPT_EXT_H
#define _GETOPT_H
#define _GETOPT_POSIX_H
#define _GNU_LIBC_VERSION_H
#define _GNU_VERSIONS_H
#define _GSHADOW_H
#define _ICONV_H
#define _IEEE754_H
#define _IFADDRS_H
#define _INTTYPES_H
#define _IP_VH
#define _LANGINFO_H
#define _LIBC_LIMITS_H
#define _LIBGEN_H
#define _LIBINTL_H
#define _LINK_H
#define _LINUX_KERNEL_H
#define _LINUX_LIST_H
#define _LINUX_LOOP_H
#define _LINUX_TYPES_H
#define _MALLOC_H
#define _MATH_H
#define _MCHECK_H
#define _MONETARY_H
#define _MQUEUE_H
#define _NETASH_ASH_H
#define _NETATALK_AT_H
#define _NETAX25_AX25_H
#define _NETDB_H
#define _NETECONET_EC_H
#define _NETINET_ETHER_H
#define _NETINET_ICMP6_H
#define _NETINET_IF_FDDI_H
#define _NETINET_IF_TR_H
#define _NETINET_IGMP_H
#define _NETINET_IN_H
#define _NETINET_IN_SYSTM_H
#define _NETINET_IP6_H
#define _NETINET_TCP_H
#define _NETROM_NETROM_H
#define _NETROSE_ROSE_H
#define _NET_IF_ARP_H
#define _NET_IF_H
#define _NET_IF_SHAPER_H
#define _NET_IF_SLIP_H
#define _NET_PPP_DEFS_H
#define _NET_ROUTE_H
#define _NL_TYPES_H
#define _NSS_H
#define _OBSTACK_H
#define _PATH
#define _PATHS_H
#define _PRINTF_H
#define _PROC_SERVICE_H
#define _PROFIL_H
#define _PROTOCOLS_ROUTED_H
#define _PROTOCOLS_RWHOD_H
#define _PROTOCOLS_TALKD_H
#define _PTHREAD_H
#define _PTY_H
#define _REGEXP_H
#define _REGEX_H
#define _RESOLV_H
#define _RE_COMP_H
#define _RPC_NETDB_H
#define _SCHED_H
#define _SCSI_IOCTL_H
#define _SCSI_SCSI_H
#define _SCSI_SG_H
#define _SEARCH_H
#define _SEMAPHORE_H
#define _SETJMP_H
#define _SHADOW_H
#define _SIGNAL_H
//#define _STDINT_H
#define _STDIO_EXT_H
#define _STDIO_H
#define _STDLIB_H
#define _STRING_H
#define _STROPTS_H
#define _SYSCALL_H
#define _SYS_ACCT_H
#define _SYS_AUXV_H
#define _SYS_DEBUGREG_H
#define _SYS_ELF_H
#define _SYS_FSUID_H
#define _SYS_GMON_OUT_H
#define _SYS_IOCTL_H
#define _SYS_IPC_H
#define _SYS_KD_H
#define _SYS_MMAN_H
#define _SYS_MOUNT_H
#define _SYS_MSG_H
#define _SYS_MTIO_H
#define _SYS_PARAM_H
#define _SYS_PCI_H
#define _SYS_PERM_H
#define _SYS_PERSONALITY_H
#define _SYS_POLL_H
#define _SYS_PRCTL_H
#define _SYS_PROCFS_H
#define _SYS_PTRACE_H
#define _SYS_QUOTA_H
#define _SYS_RANDOM_H
#define _SYS_RAW_H
#define _SYS_REBOOT_H
#define _SYS_REG_H
#define _SYS_RESOURCE_H
#define _SYS_SELECT_H
#define _SYS_SEM_H
#define _SYS_SENDFILE_H
#define _SYS_SHM_H
#define _SYS_SOCKET_H
#define _SYS_STATFS_H
#define _SYS_STATVFS_H
//#define _SYS_STAT_H
#define _SYS_SWAP_H
#define _SYS_SYSINFO_H
#define _SYS_SYSLOG_H
#define _SYS_SYSMACROS_H
//#define _SYS_TERMIOS_H
#define _SYS_TIMEB_H
#define _SYS_TIME_H
#define _SYS_TTYCHARS_H
#define _SYS_TTYDEFAULTS_H
#define _SYS_UCONTEXT_H
#define _SYS_UIO_H
#define _SYS_USER_H
//#define _SYS_UTSNAME_H
#define _SYS_VLIMIT_H
#define _SYS_VM86_H
#define _SYS_VTIMES_H
#define _SYS_XATTR_H
#define _SYS_WAIT_H
//#define _TERMIOS_H
#define _TGMATH_H
#define _THREADS_H
#define _THREAD_DB_H
#define _THREAD_SHARED_TYPES_H
#define _TIME_H
#define _UCHAR_H
#define _UCONTEXT_H
#define _ULIMIT_H
#define _UNISTD_H
#define _UTIME_H
#define _UTMPX_H
#define _UTMP_H
#define _UTSNAME_MACHINE_LENGTH
#define _UTSNAME_NODENAME_LENGTH
#define _UTSNAME_RELEASE_LENGTH
#define _UTSNAME_SYSNAME_LENGTH
#define _UTSNAME_VERSION_LENGTH
#define _WCHAR_H
#define _WCTYPE_H
#define _XOPEN_LIM_H
#define __A_OUT_GNU_H
#define __BITS_SOCKET_H
#define __FMTMSG_H
#define __GLIBC_INTERNAL_STARTING_H
#define __GNU_LIB_NAMES_H
#define __IF_PACKET_H
#define __LINUX_COMPILER_H
#define __NETINET_IF_ETHER_H
#define __NETINET_IP_H
#define __NETINET_IP_ICMP_H
#define __NETINET_UDP_H
#define __NETIPX_IPX_H
#define __NETIUCV_IUCV_H
#define __NETPACKET_PACKET_H
#define __NET_ETHERNET_H
#define __NET_IF_PPP_H
#define __NO_MATH
#define __O_PATH
#define __PTHREAD_RWLOCK_INT_FLAGS_SH
#define __SI_ERRNO_TH
#define __SI_H




#endif
#endif

//#define mini_start
//#define mini_exit

// source: musl
#ifndef mini_alltypes_h
#define mini_alltypes_h


#ifndef timevaldefined
#define timevaldefined
typedef long time_t;
typedef long suseconds_t;
typedef unsigned useconds_t;
struct timeval { time_t tv_sec; suseconds_t tv_usec; };
#endif



#define _Addr long
#define _Int64 long
#define _Reg long

#ifndef size_t
#define size_t long
#endif

#ifndef uchar
typedef unsigned char uchar;
#endif

//typedef __builtin_va_list va_list;

//typedef __builtin_va_list __isoc_va_list;

typedef int wchar_t;

typedef long double double_t;

typedef float float_t;

typedef struct { long long __ll; long double __ld; } max_align_t;


typedef struct { union { int __i[14]; volatile int __vi[14]; unsigned long __s[7]; } __u; } pthread_attr_t;

typedef struct { union { int __i[10]; volatile int __vi[10]; volatile void *volatile __p[5]; } __u; } pthread_mutex_t;

typedef struct { union { int __i[10]; volatile int __vi[10]; volatile void *volatile __p[5]; } __u; } mtx_t;

typedef struct { union { int __i[12]; volatile int __vi[12]; void *__p[6]; } __u; } pthread_cond_t;

typedef struct { union { int __i[12]; volatile int __vi[12]; void *__p[6]; } __u; } cnd_t;

typedef struct { union { int __i[14]; volatile int __vi[14]; void *__p[7]; } __u; } pthread_rwlock_t;

typedef struct { union { int __i[8]; volatile int __vi[8]; void *__p[4]; } __u; } pthread_barrier_t;

//typedef unsigned _Addr size_t;
//#define __DEFINED_size_t

typedef unsigned _Addr uintptr_t;

typedef _Addr ptrdiff_t;

typedef _Addr ssize_t;

typedef _Addr intptr_t;

typedef _Addr regoff_t;

typedef _Reg register_t;

typedef signed char     int8_t;

typedef signed short    int16_t;

typedef signed int      int32_t;

typedef signed _Int64   int64_t;

typedef signed _Int64   intmax_t;

typedef unsigned char   uint8_t;

typedef unsigned short  uint16_t;

typedef unsigned int    uint32_t;

typedef unsigned _Int64 uint64_t;

typedef unsigned _Int64 u_int64_t;

typedef unsigned _Int64 uintmax_t;

typedef unsigned mode_t;

typedef unsigned _Reg nlink_t;

typedef _Int64 off_t;

typedef unsigned _Int64 ino_t;

typedef unsigned _Int64 dev_t;

typedef long blksize_t;

typedef _Int64 blkcnt_t;

typedef unsigned _Int64 fsblkcnt_t;

typedef unsigned _Int64 fsfilcnt_t;

typedef unsigned wint_t;

typedef unsigned long wctype_t;

typedef void * timer_t;

typedef int clockid_t;

typedef long clock_t;

//struct timeval { time_t tv_sec; suseconds_t tv_usec; };

struct timespec { time_t tv_sec; long tv_nsec; };

typedef int pid_t;

typedef unsigned id_t;

typedef unsigned uid_t;

typedef unsigned gid_t;

typedef int key_t;

//typedef unsigned useconds_t;

//typedef struct _IO_FILE FILE;

typedef struct __mbstate_t { unsigned __opaque1, __opaque2; } mbstate_t;

typedef struct __locale_struct * locale_t;

typedef struct __sigset_t { unsigned long __bits[128/sizeof(long)]; } sigset_t;

struct iovec { void *iov_base; size_t iov_len; };

typedef unsigned socklen_t;

typedef unsigned short sa_family_t;

#undef _Addr
#undef _Int64
#undef _Reg

#endif

#ifndef globaldefs_h
#define globaldefs_h

// definitions

#ifdef X64
#define POINTER unsigned long int
#else
#define POINTER unsigned int
#endif

#ifndef uint32_t
#define uint32_t uint
#endif

#ifndef uint8_t
#define uint8_t uchar
#endif

#ifndef size_t
#define size_t long
#endif

#define PATH_MAX 4096

#define FOPEN_MAX 16

#ifndef SEEK_SET
#define SEEK_SET        0       /* seek relative to beginning of file */
#define SEEK_CUR        1       /* seek relative to current file position */
#define SEEK_END        2       /* seek relative to end of file */
#define SEEK_MAX        SEEK_END
#endif


#define mini_FOPEN_MAX 16

#ifndef NULL
#define NULL 0
#endif
#ifndef timevaldefined
#define timevaldefined
typedef long time_t;
typedef long suseconds_t;
typedef unsigned useconds_t;
struct timeval { time_t tv_sec; suseconds_t tv_usec; };
#endif

#define BUFSIZ 1024


//+def
typedef int FILE;

#if 0
// thats the old masks/flags.
// possibly better change the fd/FILE len to long
// not sure about that.
// but the hard kernel limit on open fd's is
// about 17 bits here. so. might be ok.
// feeling a bit uncomfortable with that decision,
// however.
#define FEOF_FLAG 0x80000000
#define ERR_FLAG 0x40000000
#define FLAG_MASK 0xc0000000
#define FD_MASK 0x3fffffff
#else

#define FEOF_FLAG 0x800000
#define ERR_FLAG 0x400000
#define FLAG_MASK 0xc00000
#define FD_MASK 0x3fffff
#define UNGETC_MASK 0xff000000

#endif

#ifdef X64
typedef union { FILE *F; int i, fd;} mfl_union;
#else
//typedef union { FILE *F; int fd;} mfl_union;
#warning checkme
#warning typedef union { FILE *F; int fd;} mfl_union;
#endif
//(untested for x32) better commenting this out for now.
//Might be better to find later
//also: endiannes. problem: ungetc. (in fgetc.h)

#define EOF (-1)

#ifdef mini_buf
#ifndef stdin
#define stdin &ml.stream[0]
#endif
#ifndef stdout
#define stdout &ml.stream[1]
#endif
#ifndef stderr
#define stderr &ml.stream[2]
#endif
#else 
// no minibuf -> no stream descriptors.
#ifndef stdin
#define stdin (int*)0
#endif
#ifndef stdout
#define stdout (int*)1
#endif
#ifndef stderr
#define stderr (int*)2
#endif
#endif

// TODO: ifdef mini_buf -> get ml.stream->fd
#ifndef STDIN_FILENO
#define STDIN_FILENO 0
#define STDOUT_FILENO 1
#define STDERR_FILENO 2
#endif

// source: musl
#ifndef mini_alltypes_h
#define mini_alltypes_h


#ifndef timevaldefined
#define timevaldefined
typedef long time_t;
typedef long suseconds_t;
typedef unsigned useconds_t;
struct timeval { time_t tv_sec; suseconds_t tv_usec; };
#endif



#define _Addr long
#define _Int64 long
#define _Reg long

#ifndef size_t
#define size_t long
#endif

#ifndef uchar
typedef unsigned char uchar;
#endif

//typedef __builtin_va_list va_list;

//typedef __builtin_va_list __isoc_va_list;

typedef int wchar_t;

typedef long double double_t;

typedef float float_t;

typedef struct { long long __ll; long double __ld; } max_align_t;


typedef struct { union { int __i[14]; volatile int __vi[14]; unsigned long __s[7]; } __u; } pthread_attr_t;

typedef struct { union { int __i[10]; volatile int __vi[10]; volatile void *volatile __p[5]; } __u; } pthread_mutex_t;

typedef struct { union { int __i[10]; volatile int __vi[10]; volatile void *volatile __p[5]; } __u; } mtx_t;

typedef struct { union { int __i[12]; volatile int __vi[12]; void *__p[6]; } __u; } pthread_cond_t;

typedef struct { union { int __i[12]; volatile int __vi[12]; void *__p[6]; } __u; } cnd_t;

typedef struct { union { int __i[14]; volatile int __vi[14]; void *__p[7]; } __u; } pthread_rwlock_t;

typedef struct { union { int __i[8]; volatile int __vi[8]; void *__p[4]; } __u; } pthread_barrier_t;

//typedef unsigned _Addr size_t;
//#define __DEFINED_size_t

typedef unsigned _Addr uintptr_t;

typedef _Addr ptrdiff_t;

typedef _Addr ssize_t;

typedef _Addr intptr_t;

typedef _Addr regoff_t;

typedef _Reg register_t;

typedef signed char     int8_t;

typedef signed short    int16_t;

typedef signed int      int32_t;

typedef signed _Int64   int64_t;

typedef signed _Int64   intmax_t;

typedef unsigned char   uint8_t;

typedef unsigned short  uint16_t;

typedef unsigned int    uint32_t;

typedef unsigned _Int64 uint64_t;

typedef unsigned _Int64 u_int64_t;

typedef unsigned _Int64 uintmax_t;

typedef unsigned mode_t;

typedef unsigned _Reg nlink_t;

typedef _Int64 off_t;

typedef unsigned _Int64 ino_t;

typedef unsigned _Int64 dev_t;

typedef long blksize_t;

typedef _Int64 blkcnt_t;

typedef unsigned _Int64 fsblkcnt_t;

typedef unsigned _Int64 fsfilcnt_t;

typedef unsigned wint_t;

typedef unsigned long wctype_t;

typedef void * timer_t;

typedef int clockid_t;

typedef long clock_t;

//struct timeval { time_t tv_sec; suseconds_t tv_usec; };

struct timespec { time_t tv_sec; long tv_nsec; };

typedef int pid_t;

typedef unsigned id_t;

typedef unsigned uid_t;

typedef unsigned gid_t;

typedef int key_t;

//typedef unsigned useconds_t;

//typedef struct _IO_FILE FILE;

typedef struct __mbstate_t { unsigned __opaque1, __opaque2; } mbstate_t;

typedef struct __locale_struct * locale_t;

typedef struct __sigset_t { unsigned long __bits[128/sizeof(long)]; } sigset_t;

struct iovec { void *iov_base; size_t iov_len; };

typedef unsigned socklen_t;

typedef unsigned short sa_family_t;

#undef _Addr
#undef _Int64
#undef _Reg

#endif

#ifndef ioctl_h
#define ioctl_h
// source: musl
#define _IOC(a,b,c,d) ( ((a)<<30) | ((b)<<8) | (c) | ((d)<<16) )
#define _IOC_NONE  0U
#define _IOC_WRITE 1U
#define _IOC_READ  2U

#define _IO(a,b) _IOC(_IOC_NONE,(a),(b),0)
#define _IOW(a,b,c) _IOC(_IOC_WRITE,(a),(b),sizeof(c))
#define _IOR(a,b,c) _IOC(_IOC_READ,(a),(b),sizeof(c))
#define _IOWR(a,b,c) _IOC(_IOC_READ|_IOC_WRITE,(a),(b),sizeof(c))

#define TCGETS		0x5401
#define TCSETS		0x5402
#define TCSETSW		0x5403
#define TCSETSF		0x5404
#define TCGETA		0x5405
#define TCSETA		0x5406
#define TCSETAW		0x5407
#define TCSETAF		0x5408
#define TCSBRK		0x5409
#define TCXONC		0x540A
#define TCFLSH		0x540B
#define TIOCEXCL	0x540C
#define TIOCNXCL	0x540D
#define TIOCSCTTY	0x540E
#define TIOCGPGRP	0x540F
#define TIOCSPGRP	0x5410
#define TIOCOUTQ	0x5411
#define TIOCSTI		0x5412
#define TIOCGWINSZ	0x5413
#define TIOCSWINSZ	0x5414
#define TIOCMGET	0x5415
#define TIOCMBIS	0x5416
#define TIOCMBIC	0x5417
#define TIOCMSET	0x5418
#define TIOCGSOFTCAR	0x5419
#define TIOCSSOFTCAR	0x541A
#define FIONREAD	0x541B
#define TIOCINQ		FIONREAD
#define TIOCLINUX	0x541C
#define TIOCCONS	0x541D
#define TIOCGSERIAL	0x541E
#define TIOCSSERIAL	0x541F
#define TIOCPKT		0x5420
#define FIONBIO		0x5421
#define TIOCNOTTY	0x5422
#define TIOCSETD	0x5423
#define TIOCGETD	0x5424
#define TCSBRKP		0x5425
#define TIOCSBRK	0x5427
#define TIOCCBRK	0x5428
#define TIOCGSID	0x5429
#define TIOCGRS485	0x542E
#define TIOCSRS485	0x542F
#define TIOCGPTN	0x80045430
#define TIOCSPTLCK	0x40045431
#define TIOCGDEV	0x80045432
#define TCGETX		0x5432
#define TCSETX		0x5433
#define TCSETXF		0x5434
#define TCSETXW		0x5435
#define TIOCSIG		0x40045436
#define TIOCVHANGUP	0x5437
#define TIOCGPKT	0x80045438
#define TIOCGPTLCK	0x80045439
#define TIOCGEXCL	0x80045440
#define TIOCGPTPEER	0x5441

#define FIONCLEX	0x5450
#define FIOCLEX		0x5451
#define FIOASYNC	0x5452
#define TIOCSERCONFIG	0x5453
#define TIOCSERGWILD	0x5454
#define TIOCSERSWILD	0x5455
#define TIOCGLCKTRMIOS	0x5456
#define TIOCSLCKTRMIOS	0x5457
#define TIOCSERGSTRUCT	0x5458
#define TIOCSERGETLSR   0x5459
#define TIOCSERGETMULTI 0x545A
#define TIOCSERSETMULTI 0x545B

#define TIOCMIWAIT	0x545C
#define TIOCGICOUNT	0x545D
#define FIOQSIZE	0x5460

#define TIOCPKT_DATA		 0
#define TIOCPKT_FLUSHREAD	 1
#define TIOCPKT_FLUSHWRITE	 2
#define TIOCPKT_STOP		 4
#define TIOCPKT_START		 8
#define TIOCPKT_NOSTOP		16
#define TIOCPKT_DOSTOP		32
#define TIOCPKT_IOCTL		64

#define TIOCSER_TEMT    0x01

struct winsize {
	unsigned short ws_row;
	unsigned short ws_col;
	unsigned short ws_xpixel;
	unsigned short ws_ypixel;
};

#define TIOCM_LE        0x001
#define TIOCM_DTR       0x002
#define TIOCM_RTS       0x004
#define TIOCM_ST        0x008
#define TIOCM_SR        0x010
#define TIOCM_CTS       0x020
#define TIOCM_CAR       0x040
#define TIOCM_RNG       0x080
#define TIOCM_DSR       0x100
#define TIOCM_CD        TIOCM_CAR
#define TIOCM_RI        TIOCM_RNG
#define TIOCM_OUT1      0x2000
#define TIOCM_OUT2      0x4000
#define TIOCM_LOOP      0x8000

#define N_TTY           0
#define N_SLIP          1
#define N_MOUSE         2
#define N_PPP           3
#define N_STRIP         4
#define N_AX25          5
#define N_X25           6
#define N_6PACK         7
#define N_MASC          8
#define N_R3964         9
#define N_PROFIBUS_FDL  10
#define N_IRDA          11
#define N_SMSBLOCK      12
#define N_HDLC          13
#define N_SYNC_PPP      14
#define N_HCI           15

#define FIOSETOWN       0x8901
#define SIOCSPGRP       0x8902
#define FIOGETOWN       0x8903
#define SIOCGPGRP       0x8904
#define SIOCATMARK      0x8905
#define SIOCGSTAMP      0x8906
#define SIOCGSTAMPNS    0x8907

#define SIOCADDRT       0x890B
#define SIOCDELRT       0x890C
#define SIOCRTMSG       0x890D

#define SIOCGIFNAME     0x8910
#define SIOCSIFLINK     0x8911
#define SIOCGIFCONF     0x8912
#define SIOCGIFFLAGS    0x8913
#define SIOCSIFFLAGS    0x8914
#define SIOCGIFADDR     0x8915
#define SIOCSIFADDR     0x8916
#define SIOCGIFDSTADDR  0x8917
#define SIOCSIFDSTADDR  0x8918
#define SIOCGIFBRDADDR  0x8919
#define SIOCSIFBRDADDR  0x891a
#define SIOCGIFNETMASK  0x891b
#define SIOCSIFNETMASK  0x891c
#define SIOCGIFMETRIC   0x891d
#define SIOCSIFMETRIC   0x891e
#define SIOCGIFMEM      0x891f
#define SIOCSIFMEM      0x8920
#define SIOCGIFMTU      0x8921
#define SIOCSIFMTU      0x8922
#define SIOCSIFNAME     0x8923
#define SIOCSIFHWADDR   0x8924
#define SIOCGIFENCAP    0x8925
#define SIOCSIFENCAP    0x8926
#define SIOCGIFHWADDR   0x8927
#define SIOCGIFSLAVE    0x8929
#define SIOCSIFSLAVE    0x8930
#define SIOCADDMULTI    0x8931
#define SIOCDELMULTI    0x8932
#define SIOCGIFINDEX    0x8933
#define SIOGIFINDEX     SIOCGIFINDEX
#define SIOCSIFPFLAGS   0x8934
#define SIOCGIFPFLAGS   0x8935
#define SIOCDIFADDR     0x8936
#define SIOCSIFHWBROADCAST 0x8937
#define SIOCGIFCOUNT    0x8938

#define SIOCGIFBR       0x8940
#define SIOCSIFBR       0x8941

#define SIOCGIFTXQLEN   0x8942
#define SIOCSIFTXQLEN   0x8943

#define SIOCDARP        0x8953
#define SIOCGARP        0x8954
#define SIOCSARP        0x8955

#define SIOCDRARP       0x8960
#define SIOCGRARP       0x8961
#define SIOCSRARP       0x8962

#define SIOCGIFMAP      0x8970
#define SIOCSIFMAP      0x8971

#define SIOCADDDLCI     0x8980
#define SIOCDELDLCI     0x8981

#define SIOCDEVPRIVATE		0x89F0
#define SIOCPROTOPRIVATE	0x89E0

//#include <bits/ioctl_fix.h>
#endif
/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
#ifndef _LINUX_UTSNAME_H
#define _LINUX_UTSNAME_H

#define __OLD_UTS_LEN 8

struct oldold_utsname {
        char sysname[9];
        char nodename[9];
        char release[9];
        char version[9];
        char machine[9];
};

#define __NEW_UTS_LEN 64

struct old_utsname {
        char sysname[65];
        char nodename[65];
        char release[65];
        char version[65];
        char machine[65];
};

struct new_utsname {
        char sysname[__NEW_UTS_LEN + 1];
        char nodename[__NEW_UTS_LEN + 1];
        char release[__NEW_UTS_LEN + 1];
        char version[__NEW_UTS_LEN + 1];
        char machine[__NEW_UTS_LEN + 1];
        char domainname[__NEW_UTS_LEN + 1];
};


#endif /* _LINUX_UTSNAME_H */

#ifndef	_TERMIOS_H
#define	_TERMIOS_H

#ifdef __cplusplus
extern "C" {
#endif

// just a placeholder

#define __NEED_pid_t

//#include <bits/alltypes.h>

typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;

#define NCCS 32

// source: musl
#ifndef termios_xxxxx
#define termios_xxxxx
struct termios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[NCCS];
	speed_t __c_ispeed;
	speed_t __c_ospeed;
};

// the old termio struct
#define NCC 8
struct termio
{
		unsigned short int c_iflag;   /* input mode flags */
		unsigned short int c_oflag;   /* output mode flags */
		unsigned short int c_cflag;   /* control mode flags */
		unsigned short int c_lflag;   /* local mode flags */
		unsigned char c_line;   /* line discipline */
		unsigned char c_cc[NCC];    /* control characters */
};




#define VINTR     0
#define VQUIT     1
#define VERASE    2
#define VKILL     3
#define VEOF      4
#define VTIME     5
#define VMIN      6
#define VSWTC     7
#define VSTART    8
#define VSTOP     9
#define VSUSP    10
#define VEOL     11
#define VREPRINT 12
#define VDISCARD 13
#define VWERASE  14
#define VLNEXT   15
#define VEOL2    16

#define IGNBRK  0000001
#define BRKINT  0000002
#define IGNPAR  0000004
#define PARMRK  0000010
#define INPCK   0000020
#define ISTRIP  0000040
#define INLCR   0000100
#define IGNCR   0000200
#define ICRNL   0000400
#define IUCLC   0001000
#define IXON    0002000
#define IXANY   0004000
#define IXOFF   0010000
#define IMAXBEL 0020000
#define IUTF8   0040000

#define OPOST  0000001
#define OLCUC  0000002
#define ONLCR  0000004
#define OCRNL  0000010
#define ONOCR  0000020
#define ONLRET 0000040
#define OFILL  0000100
#define OFDEL  0000200
#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE) || defined(_XOPEN_SOURCE)
#define NLDLY  0000400
#define NL0    0000000
#define NL1    0000400
#define CRDLY  0003000
#define CR0    0000000
#define CR1    0001000
#define CR2    0002000
#define CR3    0003000
#define TABDLY 0014000
#define TAB0   0000000
#define TAB1   0004000
#define TAB2   0010000
#define TAB3   0014000
#define BSDLY  0020000
#define BS0    0000000
#define BS1    0020000
#define FFDLY  0100000
#define FF0    0000000
#define FF1    0100000
#endif

#define VTDLY  0040000
#define VT0    0000000
#define VT1    0040000

#define B0       0000000
#define B50      0000001
#define B75      0000002
#define B110     0000003
#define B134     0000004
#define B150     0000005
#define B200     0000006
#define B300     0000007
#define B600     0000010
#define B1200    0000011
#define B1800    0000012
#define B2400    0000013
#define B4800    0000014
#define B9600    0000015
#define B19200   0000016
#define B38400   0000017

#define B57600   0010001
#define B115200  0010002
#define B230400  0010003
#define B460800  0010004
#define B500000  0010005
#define B576000  0010006
#define B921600  0010007
#define B1000000 0010010
#define B1152000 0010011
#define B1500000 0010012
#define B2000000 0010013
#define B2500000 0010014
#define B3000000 0010015
#define B3500000 0010016
#define B4000000 0010017

#define CSIZE  0000060
#define CS5    0000000
#define CS6    0000020
#define CS7    0000040
#define CS8    0000060
#define CSTOPB 0000100
#define CREAD  0000200
#define PARENB 0000400
#define PARODD 0001000
#define HUPCL  0002000
#define CLOCAL 0004000

#define ISIG   0000001
#define ICANON 0000002
#define ECHO   0000010
#define ECHOE  0000020
#define ECHOK  0000040
#define ECHONL 0000100
#define NOFLSH 0000200
#define TOSTOP 0000400
#define IEXTEN 0100000

#define TCOOFF 0
#define TCOON  1
#define TCIOFF 2
#define TCION  3

#define TCIFLUSH  0
#define TCOFLUSH  1
#define TCIOFLUSH 2

#define TCSANOW   0
#define TCSADRAIN 1
#define TCSAFLUSH 2

#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
#define EXTA    0000016
#define EXTB    0000017
#define CBAUD   0010017
#define CBAUDEX 0010000
#define CIBAUD  002003600000
#define CMSPAR  010000000000
#define CRTSCTS 020000000000

#define XCASE   0000004
#define ECHOCTL 0001000
#define ECHOPRT 0002000
#define ECHOKE  0004000
#define FLUSHO  0010000
#define PENDIN  0040000
#define EXTPROC 0200000

#define XTABS  0014000
#endif
#endif

speed_t cfgetospeed (const struct termios *);
speed_t cfgetispeed (const struct termios *);
int cfsetospeed (struct termios *, speed_t);
int cfsetispeed (struct termios *, speed_t);

static inline int tcgetattr (int, struct termios *);
static inline int tcsetattr (int, int, const struct termios *);

int tcsendbreak (int, int);
int tcdrain (int);
int tcflush (int, int);
int tcflow (int, int);

pid_t tcgetsid (int);

#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
void cfmakeraw(struct termios *);
int cfsetspeed(struct termios *, speed_t);
#endif

#ifdef __cplusplus
}
#endif

#endif

typedef void (*sighandler_t)(int);

#ifdef mini_ioctl
int ioctl( int fd, unsigned long int request, ... );
#endif

// from musl
#define FD_SETSIZE 1024

		typedef unsigned long fd_mask;

		typedef struct
		{
				  unsigned long fds_bits[FD_SETSIZE / 8 / sizeof(long)];
		} fd_set;


#define FD_ZERO(s) do { int __i; unsigned long *__b=(s)->fds_bits; for(__i=sizeof (fd_set)/sizeof (long); __i; __i--) *__b++=0; } while(0)
#define FD_SET(d, s)   ((s)->fds_bits[(d)/(8*sizeof(long))] |= (1UL<<((d)%(8*sizeof(long)))))
#define FD_CLR(d, s)   ((s)->fds_bits[(d)/(8*sizeof(long))] &= ~(1UL<<((d)%(8*sizeof(long)))))
#define FD_ISSET(d, s) !!((s)->fds_bits[(d)/(8*sizeof(long))] & (1UL<<((d)%(8*sizeof(long)))))

// end of musl 

#define LOGIN_NAME_MAX 256
#define HOST_NAME_MAX 64

#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1

#define F_OK 0
#define X_OK 1
#define W_OK 2
#define R_OK 4



#endif
#ifndef minilib_global_h
#define minilib_global_h

// Don't like this pattern.
// Will most likely "bloat" minilib.
// But other options do not seem sensible.

//#ifndef mini_buf
//#warning defining mini_buf
//#define mini_buf 1024
//#endif

#ifdef mini_buf


typedef struct {
		int align;
		int srand;	
		int pstream;
		int mbufsize;
		int stream[mini_FOPEN_MAX];
		union {
				int ibuf[mini_buf>>2];
				char mbuf[mini_buf];
		};
} minilib_globals;

extern minilib_globals ml;
#else

//#warning no mini_buf

#endif

#ifdef mini_getenv
//+doc pointer to env, when mini_getenv is defined.
char **mini_env;
#endif


#endif
#ifndef mini_timeval_h
#define mini_timeval_h
#ifndef type_t_h
#define type_t_h
typedef long time_t;
#endif

#ifndef timevaldefined
#define timevaldefined
typedef long time_t;
typedef long suseconds_t;
typedef unsigned useconds_t;
struct timeval { time_t tv_sec; suseconds_t tv_usec; };
#endif


struct timezone {
		int     tz_minuteswest; /*	minutes	west of	Greenwich */
		int     tz_dsttime;     /*	type of	dst correction */
};
#endif
#ifndef	_DIRENT_H
#define	_DIRENT_H

#ifdef __cplusplus
extern "C" {
#endif


#define __NEED_ino_t
#define __NEED_off_t
#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
#define __NEED_size_t
#endif


struct __dirstream
{
	off_t tell;
	int fd;
	int buf_pos;
	int buf_end;
	volatile int lock[1];
	/* Any changes to this struct must preserve the property:
	 * offsetof(struct __dirent, buf) % sizeof(off_t) == 0 */
	char buf[2048];
};
typedef struct __dirstream DIR;

#define _DIRENT_HAVE_D_RECLEN
#define _DIRENT_HAVE_D_OFF
#define _DIRENT_HAVE_D_TYPE

struct dirent {
	ino_t d_ino;
	off_t d_off;
	unsigned short d_reclen;
	//unsigned char d_type;
	char d_name[256];
};

#define d_fileno d_ino
#if 0
int            closedir(DIR *);
DIR           *fdopendir(int);
DIR           *opendir(const char *);
struct dirent *readdir(DIR *);
int            readdir_r(DIR *__restrict, struct dirent *__restrict, struct dirent **__restrict);
void           rewinddir(DIR *);
int            dirfd(DIR *);

int alphasort(const struct dirent **, const struct dirent **);
int scandir(const char *, struct dirent ***, int (*)(const struct dirent *), int (*)(const struct dirent **, const struct dirent **));

#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
void           seekdir(DIR *, long);
long           telldir(DIR *);
#endif
#endif

#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
#define DT_UNKNOWN 0
#define DT_FIFO 1
#define DT_CHR 2
#define DT_DIR 4
#define DT_BLK 6
#define DT_REG 8
#define DT_LNK 10
#define DT_SOCK 12
#define DT_WHT 14
#define IFTODT(x) ((x)>>12 & 017)
#define DTTOIF(x) ((x)<<12)
int getdents(int, struct dirent *, size_t);
#endif

#ifdef _GNU_SOURCE
int versionsort(const struct dirent **, const struct dirent **);
#endif

#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
#define dirent64 dirent
#define readdir64 readdir
#define readdir64_r readdir_r
#define scandir64 scandir
#define alphasort64 alphasort
#define versionsort64 versionsort
#define off64_t off_t
#define ino64_t ino_t
#define getdents64 getdents
#endif

#ifdef __cplusplus
}
#endif

#endif
#ifndef bits_signal_h
#define bits_signal_h

#define SA_NOCLDSTOP  1
#define SA_NOCLDWAIT  2
#define SA_SIGINFO    4
#define SA_ONSTACK    0x08000000
#define SA_RESTART    0x10000000
#define SA_NODEFER    0x40000000
#define SA_RESETHAND  0x80000000
#define SA_RESTORER   0x04000000



#define _NSIG 65

#define SIGHUP    1
#define SIGINT    2
#define SIGQUIT   3
#define SIGILL    4
#define SIGTRAP   5
#define SIGABRT   6
#define SIGIOT    SIGABRT
#define SIGBUS    7
#define SIGFPE    8
#define SIGKILL   9
#define SIGUSR1   10
#define SIGSEGV   11
#define SIGUSR2   12
#define SIGPIPE   13
#define SIGALRM   14
#define SIGTERM   15
#define SIGSTKFLT 16
#define SIGCHLD   17
#define SIGCONT   18
#define SIGSTOP   19
#define SIGTSTP   20
#define SIGTTIN   21
#define SIGTTOU   22
#define SIGURG    23
#define SIGXCPU   24
#define SIGXFSZ   25
#define SIGVTALRM 26
#define SIGPROF   27
#define SIGWINCH  28
#define SIGIO     29
#define SIGPOLL   29
#define SIGPWR    30
#define SIGSYS    31
#define SIGUNUSED SIGSYS



#endif

/* File types.  */
#define	S_IFDIR	0040000	/* Directory.  */
#define	S_IFCHR	0020000	/* Character device.  */
#define	S_IFBLK	0060000	/* Block device.  */
#define	S_IFREG	0100000	/* Regular file.  */
#define	S_IFIFO	0010000	/* FIFO.  */
#define	S_IFLNK	0120000	/* Symbolic link.  */
#define	S_IFSOCK	0140000	/* Socket.  */

/* Protection bits.  */
#define	S_ISUID	04000	/* Set user ID on execution.  */
#define	S_ISGID	02000	/* Set group ID on execution.  */
#define	S_ISVTX	01000	/* Save swapped text after use (sticky).  */
#define	S_IREAD	0400	/* Read by owner.  */
#define	S_IWRITE	0200	/* Write by owner.  */
#define	S_IEXEC	0100	/* Execute by owner.  */

#ifndef signal_h
#define signal_h

// musl
// nasty stuff

#define SIG_ERR  ((void (*)(int))-1)
#define SIG_DFL  ((void (*)(int)) 0)
#define SIG_IGN  ((void (*)(int)) 1)



union sigval {
	int sival_int;
	void *sival_ptr;
};



typedef struct {
#ifdef __SI_SWAP_ERRNO_CODE
	int si_signo, si_code, si_errno;
#else
	int si_signo, si_errno, si_code;
#endif
	union {
		char __pad[128 - 2*sizeof(int) - sizeof(long)];
		struct {
			union {
				struct {
					pid_t si_pid;
					uid_t si_uid;
				} __piduid;
				struct {
					int si_timerid;
					int si_overrun;
				} __timer;
			} __first;
			union {
				union sigval si_value;
				struct {
					int si_status;
					clock_t si_utime, si_stime;
				} __sigchld;
			} __second;
		} __si_common;
		struct {
			void *si_addr;
			short si_addr_lsb;
			union {
				struct {
					void *si_lower;
					void *si_upper;
				} __addr_bnd;
				unsigned si_pkey;
			} __first;
		} __sigfault;
		struct {
			long si_band;
			int si_fd;
		} __sigpoll;
		struct {
			void *si_call_addr;
			int si_syscall;
			unsigned si_arch;
		} __sigsys;
	} __si_fields;
} siginfo_t;



struct sigaction {
		void     (*sa_handler)(int);
		void     (*sa_sigaction)(int, siginfo_t *, void *);
		sigset_t   sa_mask;
		int        sa_flags;
		void     (*sa_restorer)(void);
};





#endif
#ifndef	_CTYPE_H
#define	_CTYPE_H

#ifdef __cplusplus
extern "C" {
#endif




int   isalnum_l(int, locale_t);
int   isalpha_l(int, locale_t);
int   isblank_l(int, locale_t);
int   iscntrl_l(int, locale_t);
int   isdigit_l(int, locale_t);
int   isgraph_l(int, locale_t);
int   islower_l(int, locale_t);
int   isprint_l(int, locale_t);
int   ispunct_l(int, locale_t);
int   isspace_l(int, locale_t);
int   isupper_l(int, locale_t);
int   isxdigit_l(int, locale_t);
int   tolower_l(int, locale_t);
int   toupper_l(int, locale_t);

#ifdef __cplusplus
}
#endif

#endif
#ifndef ctype_h
#define ctype_h

//+header ctype.h
//+inc
//+def
static __inline int __isspace(int _c)
{
	return _c == ' ' || (unsigned)_c-'\t' < 5;
}

//+nop 
#define isalpha(a) (0 ? 1 : (((unsigned)(a)|32)-'a') < 26)
//+nop 
#define isdigit(a) (0 ? 1 : ((unsigned)(a)-'0') < 10)
//+nop 
#define islower(a) (0 ? 1 : ((unsigned)(a)-'a') < 26)
//+nop 
#define isupper(a) (0 ? 1 : ((unsigned)(a)-'A') < 26)
//+nop 
//#define isprint(a) (0 ? 1 : ((unsigned)(a)-(0x20)) < 0x5f)
//+nop 
#define isgraph(a) (0 ? 1 : ((unsigned)(a)-0x21) < 0x5e)
//+nop 
#define isspace(a) __isspace(a)


//+nop 
#define _tolower(a) ((a)|0x20)
//+nop 
#define tolower(a) ((a)|0x20)
//+nop 
#define _toupper(a) ((a)&0x5f)
//+nop 
#define toupper(a) ((a)&0x5f)
//+nop 
#define isascii(a) (0 ? isascii(a) : (unsigned)(a) < 128)




#endif
#ifndef minilib_syscall_h
#define minilib_syscall_h

#ifdef mini_vsyscalls
extern int __mini_vsys;
#endif


//extern int sysret;
#ifdef mini_errno
extern int errno;
#endif

#ifdef OSX

#define NCONST 0x2000000
#define SCALL(call) SYS_##call
#define __SYSCALL(call) SYS##call
#ifndef _ASM_X86_UNISTD_64_H
#define _ASM_X86_UNISTD_64_H 1

#define __NR_read 0
#define __NR_write 1
#define __NR_open 2
#define __NR_close 3
#define __NR_stat 4
#define __NR_fstat 5
#define __NR_lstat 6
#define __NR_poll 7
#define __NR_lseek 8
#define __NR_mmap 9
#define __NR_mprotect 10
#define __NR_munmap 11
#define __NR_brk 12
#define __NR_rt_sigaction 13
#define __NR_rt_sigprocmask 14
#define __NR_rt_sigreturn 15
#define __NR_ioctl 16
#define __NR_pread64 17
#define __NR_pwrite64 18
#define __NR_readv 19
#define __NR_writev 20
#define __NR_access 21
#define __NR_pipe 22
#define __NR_select 23
#define __NR_sched_yield 24
#define __NR_mremap 25
#define __NR_msync 26
#define __NR_mincore 27
#define __NR_madvise 28
#define __NR_shmget 29
#define __NR_shmat 30
#define __NR_shmctl 31
#define __NR_dup 32
#define __NR_dup2 33
#define __NR_pause 34
#define __NR_nanosleep 35
#define __NR_getitimer 36
#define __NR_alarm 37
#define __NR_setitimer 38
#define __NR_getpid 39
#define __NR_sendfile 40
#define __NR_socket 41
#define __NR_connect 42
#define __NR_accept 43
#define __NR_sendto 44
#define __NR_recvfrom 45
#define __NR_sendmsg 46
#define __NR_recvmsg 47
#define __NR_shutdown 48
#define __NR_bind 49
#define __NR_listen 50
#define __NR_getsockname 51
#define __NR_getpeername 52
#define __NR_socketpair 53
#define __NR_setsockopt 54
#define __NR_getsockopt 55
#define __NR_clone 56
#define __NR_fork 57
#define __NR_vfork 58
#define __NR_execve 59
#define __NR_exit 60
#define __NR_wait4 61
#define __NR_kill 62
#define __NR_uname 63
#define __NR_semget 64
#define __NR_semop 65
#define __NR_semctl 66
#define __NR_shmdt 67
#define __NR_msgget 68
#define __NR_msgsnd 69
#define __NR_msgrcv 70
#define __NR_msgctl 71
#define __NR_fcntl 72
#define __NR_flock 73
#define __NR_fsync 74
#define __NR_fdatasync 75
#define __NR_truncate 76
#define __NR_ftruncate 77
#define __NR_getdents 78
#define __NR_getcwd 79
#define __NR_chdir 80
#define __NR_fchdir 81
#define __NR_rename 82
#define __NR_mkdir 83
#define __NR_rmdir 84
#define __NR_creat 85
#define __NR_link 86
#define __NR_unlink 87
#define __NR_symlink 88
#define __NR_readlink 89
#define __NR_chmod 90
#define __NR_fchmod 91
#define __NR_chown 92
#define __NR_fchown 93
#define __NR_lchown 94
#define __NR_umask 95
#define __NR_gettimeofday 96
#define __NR_getrlimit 97
#define __NR_getrusage 98
#define __NR_sysinfo 99
#define __NR_times 100
#define __NR_ptrace 101
#define __NR_getuid 102
#define __NR_syslog 103
#define __NR_getgid 104
#define __NR_setuid 105
#define __NR_setgid 106
#define __NR_geteuid 107
#define __NR_getegid 108
#define __NR_setpgid 109
#define __NR_getppid 110
#define __NR_getpgrp 111
#define __NR_setsid 112
#define __NR_setreuid 113
#define __NR_setregid 114
#define __NR_getgroups 115
#define __NR_setgroups 116
#define __NR_setresuid 117
#define __NR_getresuid 118
#define __NR_setresgid 119
#define __NR_getresgid 120
#define __NR_getpgid 121
#define __NR_setfsuid 122
#define __NR_setfsgid 123
#define __NR_getsid 124
#define __NR_capget 125
#define __NR_capset 126
#define __NR_rt_sigpending 127
#define __NR_rt_sigtimedwait 128
#define __NR_rt_sigqueueinfo 129
#define __NR_rt_sigsuspend 130
#define __NR_sigaltstack 131
#define __NR_utime 132
#define __NR_mknod 133
#define __NR_uselib 134
#define __NR_personality 135
#define __NR_ustat 136
#define __NR_statfs 137
#define __NR_fstatfs 138
#define __NR_sysfs 139
#define __NR_getpriority 140
#define __NR_setpriority 141
#define __NR_sched_setparam 142
#define __NR_sched_getparam 143
#define __NR_sched_setscheduler 144
#define __NR_sched_getscheduler 145
#define __NR_sched_get_priority_max 146
#define __NR_sched_get_priority_min 147
#define __NR_sched_rr_get_interval 148
#define __NR_mlock 149
#define __NR_munlock 150
#define __NR_mlockall 151
#define __NR_munlockall 152
#define __NR_vhangup 153
#define __NR_modify_ldt 154
#define __NR_pivot_root 155
#define __NR__sysctl 156
#define __NR_prctl 157
#define __NR_arch_prctl 158
#define __NR_adjtimex 159
#define __NR_setrlimit 160
#define __NR_chroot 161
#define __NR_sync 162
#define __NR_acct 163
#define __NR_settimeofday 164
#define __NR_mount 165
#define __NR_umount2 166
#define __NR_swapon 167
#define __NR_swapoff 168
#define __NR_reboot 169
#define __NR_sethostname 170
#define __NR_setdomainname 171
#define __NR_iopl 172
#define __NR_ioperm 173
#define __NR_create_module 174
#define __NR_init_module 175
#define __NR_delete_module 176
#define __NR_get_kernel_syms 177
#define __NR_query_module 178
#define __NR_quotactl 179
#define __NR_nfsservctl 180
#define __NR_getpmsg 181
#define __NR_putpmsg 182
#define __NR_afs_syscall 183
#define __NR_tuxcall 184
#define __NR_security 185
#define __NR_gettid 186
#define __NR_readahead 187
#define __NR_setxattr 188
#define __NR_lsetxattr 189
#define __NR_fsetxattr 190
#define __NR_getxattr 191
#define __NR_lgetxattr 192
#define __NR_fgetxattr 193
#define __NR_listxattr 194
#define __NR_llistxattr 195
#define __NR_flistxattr 196
#define __NR_removexattr 197
#define __NR_lremovexattr 198
#define __NR_fremovexattr 199
#define __NR_tkill 200
#define __NR_time 201
#define __NR_futex 202
#define __NR_sched_setaffinity 203
#define __NR_sched_getaffinity 204
#define __NR_set_thread_area 205
#define __NR_io_setup 206
#define __NR_io_destroy 207
#define __NR_io_getevents 208
#define __NR_io_submit 209
#define __NR_io_cancel 210
#define __NR_get_thread_area 211
#define __NR_lookup_dcookie 212
#define __NR_epoll_create 213
#define __NR_epoll_ctl_old 214
#define __NR_epoll_wait_old 215
#define __NR_remap_file_pages 216
#define __NR_getdents64 217
#define __NR_set_tid_address 218
#define __NR_restart_syscall 219
#define __NR_semtimedop 220
#define __NR_fadvise64 221
#define __NR_timer_create 222
#define __NR_timer_settime 223
#define __NR_timer_gettime 224
#define __NR_timer_getoverrun 225
#define __NR_timer_delete 226
#define __NR_clock_settime 227
#define __NR_clock_gettime 228
#define __NR_clock_getres 229
#define __NR_clock_nanosleep 230
#define __NR_exit_group 231
#define __NR_epoll_wait 232
#define __NR_epoll_ctl 233
#define __NR_tgkill 234
#define __NR_utimes 235
#define __NR_vserver 236
#define __NR_mbind 237
#define __NR_set_mempolicy 238
#define __NR_get_mempolicy 239
#define __NR_mq_open 240
#define __NR_mq_unlink 241
#define __NR_mq_timedsend 242
#define __NR_mq_timedreceive 243
#define __NR_mq_notify 244
#define __NR_mq_getsetattr 245
#define __NR_kexec_load 246
#define __NR_waitid 247
#define __NR_add_key 248
#define __NR_request_key 249
#define __NR_keyctl 250
#define __NR_ioprio_set 251
#define __NR_ioprio_get 252
#define __NR_inotify_init 253
#define __NR_inotify_add_watch 254
#define __NR_inotify_rm_watch 255
#define __NR_migrate_pages 256
#define __NR_openat 257
#define __NR_mkdirat 258
#define __NR_mknodat 259
#define __NR_fchownat 260
#define __NR_futimesat 261
#define __NR_newfstatat 262
#define __NR_unlinkat 263
#define __NR_renameat 264
#define __NR_linkat 265
#define __NR_symlinkat 266
#define __NR_readlinkat 267
#define __NR_fchmodat 268
#define __NR_faccessat 269
#define __NR_pselect6 270
#define __NR_ppoll 271
#define __NR_unshare 272
#define __NR_set_robust_list 273
#define __NR_get_robust_list 274
#define __NR_splice 275
#define __NR_tee 276
#define __NR_sync_file_range 277
#define __NR_vmsplice 278
#define __NR_move_pages 279
#define __NR_utimensat 280
#define __NR_epoll_pwait 281
#define __NR_signalfd 282
#define __NR_timerfd_create 283
#define __NR_eventfd 284
#define __NR_fallocate 285
#define __NR_timerfd_settime 286
#define __NR_timerfd_gettime 287
#define __NR_accept4 288
#define __NR_signalfd4 289
#define __NR_eventfd2 290
#define __NR_epoll_create1 291
#define __NR_dup3 292
#define __NR_pipe2 293
#define __NR_inotify_init1 294
#define __NR_preadv 295
#define __NR_pwritev 296
#define __NR_rt_tgsigqueueinfo 297
#define __NR_perf_event_open 298
#define __NR_recvmmsg 299
#define __NR_fanotify_init 300
#define __NR_fanotify_mark 301
#define __NR_prlimit64 302
#define __NR_name_to_handle_at 303
#define __NR_open_by_handle_at 304
#define __NR_clock_adjtime 305
#define __NR_syncfs 306
#define __NR_sendmmsg 307
#define __NR_setns 308
#define __NR_getcpu 309
#define __NR_process_vm_readv 310
#define __NR_process_vm_writev 311
#define __NR_kcmp 312
#define __NR_finit_module 313
#define __NR_sched_setattr 314
#define __NR_sched_getattr 315
#define __NR_renameat2 316
#define __NR_seccomp 317
#define __NR_getrandom 318
#define __NR_memfd_create 319
#define __NR_kexec_file_load 320
#define __NR_bpf 321
#define __NR_execveat 322
#define __NR_userfaultfd 323
#define __NR_membarrier 324
#define __NR_mlock2 325
#define __NR_copy_file_range 326
#define __NR_preadv2 327
#define __NR_pwritev2 328
#define __NR_pkey_mprotect 329
#define __NR_pkey_alloc 330
#define __NR_pkey_free 331
#define __NR_statx 332

#endif /* _ASM_X86_UNISTD_64_H */

#else

#define NCONST 0
#define SCALL(call) __NR_##call
#define __SYSCALL(call) __NR##call

#ifdef X64
#else
#ifndef _ASM_X86_UNISTD_32_H
#define _ASM_X86_UNISTD_32_H

/*
 * This file contains the system call numbers.
 */

#define __NR_restart_syscall      0
#define __NR_exit		  1
#define __NR_fork		  2
#define __NR_read		  3
#define __NR_write		  4
#define __NR_open		  5
#define __NR_close		  6
#define __NR_waitpid		  7
#define __NR_creat		  8
#define __NR_link		  9
#define __NR_unlink		 10
#define __NR_execve		 11
#define __NR_chdir		 12
#define __NR_time		 13
#define __NR_mknod		 14
#define __NR_chmod		 15
#define __NR_lchown		 16
#define __NR_break		 17
#define __NR_oldstat		 18
#define __NR_lseek		 19
#define __NR_getpid		 20
#define __NR_mount		 21
#define __NR_umount		 22
#define __NR_setuid		 23
#define __NR_getuid		 24
#define __NR_stime		 25
#define __NR_ptrace		 26
#define __NR_alarm		 27
#define __NR_oldfstat		 28
#define __NR_pause		 29
#define __NR_utime		 30
#define __NR_stty		 31
#define __NR_gtty		 32
#define __NR_access		 33
#define __NR_nice		 34
#define __NR_ftime		 35
#define __NR_sync		 36
#define __NR_kill		 37
#define __NR_rename		 38
#define __NR_mkdir		 39
#define __NR_rmdir		 40
#define __NR_dup		 41
#define __NR_pipe		 42
#define __NR_times		 43
#define __NR_prof		 44
#define __NR_brk		 45
#define __NR_setgid		 46
#define __NR_getgid		 47
#define __NR_signal		 48
#define __NR_geteuid		 49
#define __NR_getegid		 50
#define __NR_acct		 51
#define __NR_umount2		 52
#define __NR_lock		 53
#define __NR_ioctl		 54
#define __NR_fcntl		 55
#define __NR_mpx		 56
#define __NR_setpgid		 57
#define __NR_ulimit		 58
#define __NR_oldolduname	 59
#define __NR_umask		 60
#define __NR_chroot		 61
#define __NR_ustat		 62
#define __NR_dup2		 63
#define __NR_getppid		 64
#define __NR_getpgrp		 65
#define __NR_setsid		 66
#define __NR_sigaction		 67
#define __NR_sgetmask		 68
#define __NR_ssetmask		 69
#define __NR_setreuid		 70
#define __NR_setregid		 71
#define __NR_sigsuspend		 72
#define __NR_sigpending		 73
#define __NR_sethostname	 74
#define __NR_setrlimit		 75
#define __NR_getrlimit		 76   /* Back compatible 2Gig limited rlimit */
#define __NR_getrusage		 77
#define __NR_gettimeofday	 78
#define __NR_settimeofday	 79
#define __NR_getgroups		 80
#define __NR_setgroups		 81
#define __NR_select		 82
#define __NR_symlink		 83
#define __NR_oldlstat		 84
#define __NR_readlink		 85
#define __NR_uselib		 86
#define __NR_swapon		 87
#define __NR_reboot		 88
#define __NR_readdir		 89
#define __NR_mmap		 90
#define __NR_munmap		 91
#define __NR_truncate		 92
#define __NR_ftruncate		 93
#define __NR_fchmod		 94
#define __NR_fchown		 95
#define __NR_getpriority	 96
#define __NR_setpriority	 97
#define __NR_profil		 98
#define __NR_statfs		 99
#define __NR_fstatfs		100
#define __NR_ioperm		101
#define __NR_socketcall		102
#define __NR_syslog		103
#define __NR_setitimer		104
#define __NR_getitimer		105
#define __NR_stat		106
#define __NR_lstat		107
#define __NR_fstat		108
#define __NR_olduname		109
#define __NR_iopl		110
#define __NR_vhangup		111
#define __NR_idle		112
#define __NR_vm86old		113
#define __NR_wait4		114
#define __NR_swapoff		115
#define __NR_sysinfo		116
#define __NR_ipc		117
#define __NR_fsync		118
#define __NR_sigreturn		119
#define __NR_clone		120
#define __NR_setdomainname	121
#define __NR_uname		122
#define __NR_modify_ldt		123
#define __NR_adjtimex		124
#define __NR_mprotect		125
#define __NR_sigprocmask	126
#define __NR_create_module	127
#define __NR_init_module	128
#define __NR_delete_module	129
#define __NR_get_kernel_syms	130
#define __NR_quotactl		131
#define __NR_getpgid		132
#define __NR_fchdir		133
#define __NR_bdflush		134
#define __NR_sysfs		135
#define __NR_personality	136
#define __NR_afs_syscall	137 /* Syscall for Andrew File System */
#define __NR_setfsuid		138
#define __NR_setfsgid		139
#define __NR__llseek		140
#define __NR_getdents		141
#define __NR__newselect		142
#define __NR_flock		143
#define __NR_msync		144
#define __NR_readv		145
#define __NR_writev		146
#define __NR_getsid		147
#define __NR_fdatasync		148
#define __NR__sysctl		149
#define __NR_mlock		150
#define __NR_munlock		151
#define __NR_mlockall		152
#define __NR_munlockall		153
#define __NR_sched_setparam		154
#define __NR_sched_getparam		155
#define __NR_sched_setscheduler		156
#define __NR_sched_getscheduler		157
#define __NR_sched_yield		158
#define __NR_sched_get_priority_max	159
#define __NR_sched_get_priority_min	160
#define __NR_sched_rr_get_interval	161
#define __NR_nanosleep		162
#define __NR_mremap		163
#define __NR_setresuid		164
#define __NR_getresuid		165
#define __NR_vm86		166
#define __NR_query_module	167
#define __NR_poll		168
#define __NR_nfsservctl		169
#define __NR_setresgid		170
#define __NR_getresgid		171
#define __NR_prctl              172
#define __NR_rt_sigreturn	173
#define __NR_rt_sigaction	174
#define __NR_rt_sigprocmask	175
#define __NR_rt_sigpending	176
#define __NR_rt_sigtimedwait	177
#define __NR_rt_sigqueueinfo	178
#define __NR_rt_sigsuspend	179
#define __NR_pread64		180
#define __NR_pwrite64		181
#define __NR_chown		182
#define __NR_getcwd		183
#define __NR_capget		184
#define __NR_capset		185
#define __NR_sigaltstack	186
#define __NR_sendfile		187
#define __NR_getpmsg		188	/* some people actually want streams */
#define __NR_putpmsg		189	/* some people actually want streams */
#define __NR_vfork		190
#define __NR_ugetrlimit		191	/* SuS compliant getrlimit */
#define __NR_mmap2		192
#define __NR_truncate64		193
#define __NR_ftruncate64	194
#define __NR_stat64		195
#define __NR_lstat64		196
#define __NR_fstat64		197
#define __NR_lchown32		198
#define __NR_getuid32		199
#define __NR_getgid32		200
#define __NR_geteuid32		201
#define __NR_getegid32		202
#define __NR_setreuid32		203
#define __NR_setregid32		204
#define __NR_getgroups32	205
#define __NR_setgroups32	206
#define __NR_fchown32		207
#define __NR_setresuid32	208
#define __NR_getresuid32	209
#define __NR_setresgid32	210
#define __NR_getresgid32	211
#define __NR_chown32		212
#define __NR_setuid32		213
#define __NR_setgid32		214
#define __NR_setfsuid32		215
#define __NR_setfsgid32		216
#define __NR_pivot_root		217
#define __NR_mincore		218
#define __NR_madvise		219
#define __NR_madvise1		219	/* delete when C lib stub is removed */
#define __NR_getdents64		220
#define __NR_fcntl64		221
/* 223 is unused */
#define __NR_gettid		224
#define __NR_readahead		225
#define __NR_setxattr		226
#define __NR_lsetxattr		227
#define __NR_fsetxattr		228
#define __NR_getxattr		229
#define __NR_lgetxattr		230
#define __NR_fgetxattr		231
#define __NR_listxattr		232
#define __NR_llistxattr		233
#define __NR_flistxattr		234
#define __NR_removexattr	235
#define __NR_lremovexattr	236
#define __NR_fremovexattr	237
#define __NR_tkill		238
#define __NR_sendfile64		239
#define __NR_futex		240
#define __NR_sched_setaffinity	241
#define __NR_sched_getaffinity	242
#define __NR_set_thread_area	243
#define __NR_get_thread_area	244
#define __NR_io_setup		245
#define __NR_io_destroy		246
#define __NR_io_getevents	247
#define __NR_io_submit		248
#define __NR_io_cancel		249
#define __NR_fadvise64		250
/* 251 is available for reuse (was briefly sys_set_zone_reclaim) */
#define __NR_exit_group		252
#define __NR_lookup_dcookie	253
#define __NR_epoll_create	254
#define __NR_epoll_ctl		255
#define __NR_epoll_wait		256
#define __NR_remap_file_pages	257
#define __NR_set_tid_address	258
#define __NR_timer_create	259
#define __NR_timer_settime	(__NR_timer_create+1)
#define __NR_timer_gettime	(__NR_timer_create+2)
#define __NR_timer_getoverrun	(__NR_timer_create+3)
#define __NR_timer_delete	(__NR_timer_create+4)
#define __NR_clock_settime	(__NR_timer_create+5)
#define __NR_clock_gettime	(__NR_timer_create+6)
#define __NR_clock_getres	(__NR_timer_create+7)
#define __NR_clock_nanosleep	(__NR_timer_create+8)
#define __NR_statfs64		268
#define __NR_fstatfs64		269
#define __NR_tgkill		270
#define __NR_utimes		271
#define __NR_fadvise64_64	272
#define __NR_vserver		273
#define __NR_mbind		274
#define __NR_get_mempolicy	275
#define __NR_set_mempolicy	276
#define __NR_mq_open 		277
#define __NR_mq_unlink		(__NR_mq_open+1)
#define __NR_mq_timedsend	(__NR_mq_open+2)
#define __NR_mq_timedreceive	(__NR_mq_open+3)
#define __NR_mq_notify		(__NR_mq_open+4)
#define __NR_mq_getsetattr	(__NR_mq_open+5)
#define __NR_kexec_load		283
#define __NR_waitid		284
/* #define __NR_sys_setaltroot	285 */
#define __NR_add_key		286
#define __NR_request_key	287
#define __NR_keyctl		288
#define __NR_ioprio_set		289
#define __NR_ioprio_get		290
#define __NR_inotify_init	291
#define __NR_inotify_add_watch	292
#define __NR_inotify_rm_watch	293
#define __NR_migrate_pages	294
#define __NR_openat		295
#define __NR_mkdirat		296
#define __NR_mknodat		297
#define __NR_fchownat		298
#define __NR_futimesat		299
#define __NR_fstatat64		300
#define __NR_unlinkat		301
#define __NR_renameat		302
#define __NR_linkat		303
#define __NR_symlinkat		304
#define __NR_readlinkat		305
#define __NR_fchmodat		306
#define __NR_faccessat		307
#define __NR_pselect6		308
#define __NR_ppoll		309
#define __NR_unshare		310
#define __NR_set_robust_list	311
#define __NR_get_robust_list	312
#define __NR_splice		313
#define __NR_sync_file_range	314
#define __NR_tee		315
#define __NR_vmsplice		316
#define __NR_move_pages		317
#define __NR_getcpu		318
#define __NR_epoll_pwait	319
#define __NR_utimensat		320
#define __NR_signalfd		321
#define __NR_timerfd_create	322
#define __NR_eventfd		323
#define __NR_fallocate		324
#define __NR_timerfd_settime	325
#define __NR_timerfd_gettime	326
#define __NR_signalfd4		327
#define __NR_eventfd2		328
#define __NR_epoll_create1	329
#define __NR_dup3		330
#define __NR_pipe2		331
#define __NR_inotify_init1	332
#define __NR_preadv		333
#define __NR_pwritev		334
#define __NR_rt_tgsigqueueinfo	335
#define __NR_perf_event_open	336
#define __NR_recvmmsg		337
#define __NR_fanotify_init	338
#define __NR_fanotify_mark	339
#define __NR_prlimit64		340

#endif /* _ASM_X86_UNISTD_32_H */
#endif

#endif


// syscall table at: /usr/src/linux/include/linux/syscalls.h. 
// table, ordered: /usr/src/linux/arch/x86/syscalls/syscall_32.tbl

// defining sycalls as static inline has these advantages:
// -not compiled, if not used
// -optimization can take place, gcc (4.4.5, at least) doesn't use the stack at all.
// since the syscall parameters have to be placed into registers,
// using functions would mean push and pop every parameter.
// even with -O (lowest Optimization) gcc handles putting the parameters into the right registers fine.
// so static inline even results often in smaller codesize than not inlining.
//

//#define __callend : "rcx" )

// Seems linux x86_64 has same convention as osx darwin
#ifdef X64

// memory clobber is needed, gcc optimizes syscalls very likely away without
#define __callend : "memory","rcx", "r11" )
//(also osx)
#define __SYSCALL_ASM(ret,call) asm volatile ("syscall" : "=a" (ret)  : "a" ( (call | NCONST ) )
#else
#ifdef mini_vsyscalls
#define __SYSCALL_ASM(ret,call) asm volatile ("call *__mini_vsys" : "=a" (ret)  : "a" (call)
#else
//linux32bit
// memory clobber is needed, gcc optimizes syscalls very likely away without
#define __callend : "memory" )
#define __SYSCALL_ASM(ret,call) asm volatile ("int $0x80" : "=a" (ret)  : "a" (call)
#endif
#endif

#ifdef X64 
	// also osx
#define syscall1(ret,call,a1) __SYSCALL_ASM(ret,call) , "D" (a1) __callend
#define syscall2(ret,call,a1,a2) __SYSCALL_ASM(ret,call) , "D" (a1), "S" (a2) __callend
#define syscall3(ret,call,a1,a2,a3) __SYSCALL_ASM(ret,call) , "D" (a1), "S" (a2), "d" (a3) __callend
//#warning seems register ecx has been replaced with r10, but cannot say for sure. Tests needed.
//#warning Yes. Todo: change macros accordingly. Also better copy flags. or not? ALso a question of an unneccessary instruction. 

#define syscall4(ret,call,a1,a2,a3,a4) register long int r10 asm ("r10") = a4 ; __SYSCALL_ASM(ret,call) , "D" (a1), "S" (a2), "d" (a3), "r" (r10) __callend
//#define syscall4(ret,call,a1,a2,a3,a4) __SYSCALL_ASM(ret,call) , "D" (a1), "S" (a2), "d" (a3), "c" (a4) __callend
#define syscall5(ret,call,a1,a2,a3,a4,a5) register long int r10 asm ("r10") = a4 ; register long int r8 asm ("r8") = a5 ; __SYSCALL_ASM(ret,call) , "D" (a1), "S" (a2), "d" (a3), "r" (r10), "r" (r8) __callend
#define syscall6(ret,call,a1,a2,a3,a4,a5,a6) register long int r10 asm ("r10") = a4 ; register long int r8 asm ("r8") = a5 ; register long int r9 asm ("r9") = a6; __SYSCALL_ASM(ret,call) , "D" (a1), "S" (a2), "d" (a3), "r" (r10), "r" (r8), "r" (r9) __callend


// save value in (temporary) var sysret.
// return -1 if an error occured, set errno.
#define syscall0_ret(call) __SYSCALL_ASM(sysret,call) 
#define syscall1_ret(call) syscall0_ret(call) , "D" (a1) 
#define syscall2_ret(call) syscall1_ret(call) , "S" (a2) 
#define syscall3_ret(call) syscall2_ret(call) , "d" (a3) 
#define syscall4_ret(call) register long int r10 asm("r10")= a4; syscall3_ret(call) , "r" (r10)
#define syscall5_ret(call) register long int r10 asm("r10")= a4; register long int r8 asm("r8")= a5 ; syscall3_ret(call) , "r" (r8) 
#define syscall6_ret(call) register long int r10 asm("r10")= a4; register long int r8 asm("r8")= a5 ; register long int r9 asm("r9")=a6; syscall3_ret(call) , "r" (r8) 
// r9: 6th param..

#else

//linux

#ifndef X64
//linux 32bit

#define syscall1(ret,call,a1) __SYSCALL_ASM(ret,call) , "b" (a1) __callend
#define syscall2(ret,call,a1,a2) __SYSCALL_ASM(ret,call) , "b" (a1), "c" (a2) __callend
#define syscall3(ret,call,a1,a2,a3) __SYSCALL_ASM(ret,call) , "b" (a1), "c" (a2), "d" (a3) __callend
#define syscall4(ret,call,a1,a2,a3,a4) __SYSCALL_ASM(ret,call) , "b" (a1), "c" (a2), "d" (a3), "S" (a4) __callend
#define syscall5(ret,call,a1,a2,a3,a4,a5) __SYSCALL_ASM(ret,call) , "b" (a1), "c" (a2), "d" (a3), "S" (a4), "D" (a5) __callend


// save value in (temporary) var sysret.
// return -1 if an error occured, set errno.
#define syscall0_ret(call) __SYSCALL_ASM(sysret,call) 
#define syscall1_ret(call) syscall0_ret(call) , "b" (a1) 
#define syscall2_ret(call) syscall1_ret(call) , "c" (a2) 
#define syscall3_ret(call) syscall2_ret(call) , "d" (a3) 
#define syscall4_ret(call) syscall3_ret(call) , "S" (a4)
#define syscall5_ret(call) syscall4_ret(call) , "D" (a5) 

#else
// linux 86_X64
#define syscall1(ret,call,a1) __SYSCALL_ASM(ret,call) , "b" (a1) __callend
#define syscall2(ret,call,a1,a2) __SYSCALL_ASM(ret,call) , "b" (a1), "c" (a2) __callend
#define syscall3(ret,call,a1,a2,a3) __SYSCALL_ASM(ret,call) , "b" (a1), "c" (a2), "d" (a3) __callend
#define syscall4(ret,call,a1,a2,a3,a4) __SYSCALL_ASM(ret,call) , "b" (a1), "c" (a2), "d" (a3), "S" (a4) __callend
#define syscall5(ret,call,a1,a2,a3,a4,a5) __SYSCALL_ASM(ret,call) , "b" (a1), "c" (a2), "d" (a3), "S" (a4), "D" (a5) __callend


// save value in (temporary) var sysret.
// return -1 if an error occured, set errno.
#define syscall0_ret(call) __SYSCALL_ASM(sysret,call) 
#define syscall1_ret(call) syscall0_ret(call) , "b" (a1) 
#define syscall2_ret(call) syscall1_ret(call) , "c" (a2) 
#define syscall3_ret(call) syscall2_ret(call) , "d" (a3) 
#define syscall4_ret(call) syscall3_ret(call) , "S" (a4)
#define syscall5_ret(call) syscall4_ret(call) , "D" (a5) 
#define syscall6_ret(call) syscall5_ret(call) , "r10" (a6) 

#endif

#endif


// args: count of parameters, syscall number, [parameters...]
#define __DO_syscall(n,...) syscall##n##_ret( __VA_ARGS__ ) __callend

// args: name (e.g. getpid), count of args, arguments (e.g. int* a1, char *a2).
// arguments must be named a1,a2,...

#ifdef mini_errno
#define REAL_define_syscall( name, argcount, ... ) inline \
		int volatile __attribute__((always_inline)) name( __VA_ARGS__ ){\
				int sysret;\
				__DO_syscall( argcount, (SCALL(name) | NCONST ) );\
				if ( sysret<0){\
						errno = -sysret;\
						return(-1);}\
				return(sysret);\
		}
#else
#define REAL_define_syscall( name, argcount, ... ) inline \
		int volatile __attribute__((always_inline)) name( __VA_ARGS__ ){\
				int sysret;\
				__DO_syscall( argcount, ( SCALL(name) | NCONST ) );\
				return( (sysret<0) ? -1 : sysret );\
		}
#endif


#if 0
#ifdef mini_errno
#define SYSREAL_define_syscall( name, argcount, ... ) inline \
		int volatile __attribute__((always_inline)) sys##name( __VA_ARGS__ ){\
				int sysret;\
				__DO_syscall( argcount, (__SYSCALL(name) | NCONST ) );\
				if ( sysret<0){\
						errno = -sysret;\
						return(-1);}\
				return(sysret);\
		}
#else
#define SYSREAL_define_syscall( name, argcount, ... ) inline \
		int volatile __attribute__((always_inline)) sys##name( __VA_ARGS__ ){\
				int sysret;\
				__DO_syscall( argcount, ( __SYSCALL(name) | NCONST ) );\
				return( (sysret<0) ? -1 : sysret );\
		}
#endif
#else

#define SYSREAL_define_syscall( name, argcount, ... )

#endif

//return( (sysret<0) ? -1 : sysret ); (no errno) : ok. not added anything to the final size

/*
				if ( sysret<0){\
						errno = -sysret;\
						return(-1);}\
				return(sysret);\
		}
		*/

// global sysret: +34 bytes (??)

// errno = (sysret<0) ? 0 : sysret;\ + 42 bytes..

/* (+64bytes) /+38 bytes with local sysret
				if ( sysret<0){\
						errno = -sysret;\
						return(-1);}\
				return(sysret);\
		}\
		*/

// args: name (e.g. getpid), argument to return, count of args, arguments (e.g. int* a1, char *a2).
// arguments must be named a1,a2,...
#define REAL_define_syscallret( name, ret, argcount, ... ) inline \
		int volatile __attribute__((always_inline)) name( __VA_ARGS__ ){\
				__DO_syscall( argcount, SCALL(name));\
				if ( sysret<0 ){\
						errno = -sysret;\
						return(-1);}\
				return(ret);\
		}\


#define DEF_syscall(...) 
#define DEF_syscallret(...) 



//#define __DEF_SYSCALL(count) extern int __attribute__((always_inline,optimize("0"))) 

#if 0 

#define __SYSCALL_ASMret(call) asm volatile ("mov %1,%%eax\n\tint $0x80" : "=a" (sysret)  : "g" (call)

#define syscall0_ret(call,unused) __SYSCALL_ASMret(call) )
#define syscall1_ret(call,a1) __SYSCALL_ASMret(call) , "b" (a1) )
#define syscall2_ret(call,a1,a2) __SYSCALL_ASMret(call) , "b" (a1), "c" (a2) )
#define syscall3_ret(call,a1,a2,a3) __SYSCALL_ASMret(call) , "b" (a1), "c" (a2), "d" (a3) )
#define syscall4_ret(call,a1,a2,a3,a4) __SYSCALL_ASMret(call) , "b" (a1), "c" (a2), "d" (a3), "S" (a4))
#define syscall5_ret(call,a1,a2,a3,a4,a5) __SYSCALL_ASMret(call) , "b" (a1), "c" (a2), "d" (a3), "S" (a4), "D" (a5) )

// args: count of parameters, syscall number, [parameters...]
#define __DO_syscall(n,...) syscall##n##_ret( __VA_ARGS__ )

// args: name (e.g. getpid), count of args, arguments (e.g. int* a1, char *a2).
#define DEF_syscall( name, argcount, ... ) static inline \
		int __attribute__((always_inline)) name( __VA_ARGS__ ){\
				__DO_syscall( argcount, __NR_##name , __VA_ARGS__ );\
				if ( sysret<0 )\
						errno = -sysret;\
				return(sysret);\
		}\





wantbugs_by_optimizing
#define __SYSCALL_asm(ret) asm volatile ("int $0x80" : "=a" (ret)  : "0" (call),

#define __SYSCALL_CONSTRAINTS_1 "b" (a1)
#define __SYSCALL_CONSTRAINTS_2 __SYSCALL_CONSTRAINTS_1, "c" (a2)
#define __SYSCALL_CONSTRAINTS_3 __SYSCALL_CONSTRAINTS_2, "d" (a3)
#define __SYSCALL_CONSTRAINTS_4 __SYSCALL_CONSTRAINTS_3, "S" (a4)
#define __SYSCALL_CONSTRAINTS_5 __SYSCALL_CONSTRAINTS_4, "D" (a5)

#define __SYSCALL_ARGS1 int a1
#define __SYSCALL_ARGS2 __SYSCALL_ARGS1, int a2
#define __SYSCALL_ARGS3 __SYSCALL_ARGS2, int a3
#define __SYSCALL_ARGS4 __SYSCALL_ARGS3, int a4
#define __SYSCALL_ARGS5 __SYSCALL_ARGS4, int a5
#define __SYSCALL_ARGS6 __SYSCALL_ARGS5, int a6


				
#define __DEF_SYSCALL(count) extern int \
		__syscall ## count \
				( int call, __SYSCALL_ARGS ## count );


#define __IMPL_SYSCALL(count) int \
		__syscall ## count \
				( int call, __SYSCALL_ARGS ## count ){\
		__SYSCALL_asm(call)  __SYSCALL_CONSTRAINTS_ ##count );\
		return(call);\
}

__DEF_SYSCALL(1)
__DEF_SYSCALL(2)
__DEF_SYSCALL(3)
__DEF_SYSCALL(4)
__DEF_SYSCALL(5)


#define syscall1(call,a) __syscall1((int)call,(int)a)
#define syscall2(call,a,b) __syscall2(call,(int)a,(int)b)
#define syscall3(call,a,b,c) __syscall3(call,(int)a,(int)b,(int)c)
#define syscall4(call,a,b,c,d) __syscall4(call,(int)a,(int)b,(int)c,(int)d)
//#define syscall5(call,a,b,c,d,e) __syscall5(call,(int)a,(int)b,(int)c,(int)d,(int)e)
#define syscall6(call,a,b,c,d,e,f) __syscall6(call,(int)a,(int)b,(int)c,(int)d,(int)e,(int)f)

	/*
static inline int __attribute__((always_inline)) __syscall6(int call, __SYSCALL_ARGS6 ){
		int ret;
		asm volatile ("push %%ebp\n\tmov %1,%%ebp\n\t int $0x80\n\tpop %%ebp" \
												 : "=a" (ret) : "g" (a6), "a" (call) __SYSCALL_CONSTRAINTS_5 );
		return(ret);
}
*/

#endif

#endif
#ifndef _ASM_X86_UNISTD_64_H
#define _ASM_X86_UNISTD_64_H 1

#define __NR_read 0
#define __NR_write 1
#define __NR_open 2
#define __NR_close 3
#define __NR_stat 4
#define __NR_fstat 5
#define __NR_lstat 6
#define __NR_poll 7
#define __NR_lseek 8
#define __NR_mmap 9
#define __NR_mprotect 10
#define __NR_munmap 11
#define __NR_brk 12
#define __NR_rt_sigaction 13
#define __NR_rt_sigprocmask 14
#define __NR_rt_sigreturn 15
#define __NR_ioctl 16
#define __NR_pread64 17
#define __NR_pwrite64 18
#define __NR_readv 19
#define __NR_writev 20
#define __NR_access 21
#define __NR_pipe 22
#define __NR_select 23
#define __NR_sched_yield 24
#define __NR_mremap 25
#define __NR_msync 26
#define __NR_mincore 27
#define __NR_madvise 28
#define __NR_shmget 29
#define __NR_shmat 30
#define __NR_shmctl 31
#define __NR_dup 32
#define __NR_dup2 33
#define __NR_pause 34
#define __NR_nanosleep 35
#define __NR_getitimer 36
#define __NR_alarm 37
#define __NR_setitimer 38
#define __NR_getpid 39
#define __NR_sendfile 40
#define __NR_socket 41
#define __NR_connect 42
#define __NR_accept 43
#define __NR_sendto 44
#define __NR_recvfrom 45
#define __NR_sendmsg 46
#define __NR_recvmsg 47
#define __NR_shutdown 48
#define __NR_bind 49
#define __NR_listen 50
#define __NR_getsockname 51
#define __NR_getpeername 52
#define __NR_socketpair 53
#define __NR_setsockopt 54
#define __NR_getsockopt 55
#define __NR_clone 56
#define __NR_fork 57
#define __NR_vfork 58
#define __NR_execve 59
#define __NR_exit 60
#define __NR_wait4 61
#define __NR_kill 62
#define __NR_uname 63
#define __NR_semget 64
#define __NR_semop 65
#define __NR_semctl 66
#define __NR_shmdt 67
#define __NR_msgget 68
#define __NR_msgsnd 69
#define __NR_msgrcv 70
#define __NR_msgctl 71
#define __NR_fcntl 72
#define __NR_flock 73
#define __NR_fsync 74
#define __NR_fdatasync 75
#define __NR_truncate 76
#define __NR_ftruncate 77
#define __NR_getdents 78
#define __NR_getcwd 79
#define __NR_chdir 80
#define __NR_fchdir 81
#define __NR_rename 82
#define __NR_mkdir 83
#define __NR_rmdir 84
#define __NR_creat 85
#define __NR_link 86
#define __NR_unlink 87
#define __NR_symlink 88
#define __NR_readlink 89
#define __NR_chmod 90
#define __NR_fchmod 91
#define __NR_chown 92
#define __NR_fchown 93
#define __NR_lchown 94
#define __NR_umask 95
#define __NR_gettimeofday 96
#define __NR_getrlimit 97
#define __NR_getrusage 98
#define __NR_sysinfo 99
#define __NR_times 100
#define __NR_ptrace 101
#define __NR_getuid 102
#define __NR_syslog 103
#define __NR_getgid 104
#define __NR_setuid 105
#define __NR_setgid 106
#define __NR_geteuid 107
#define __NR_getegid 108
#define __NR_setpgid 109
#define __NR_getppid 110
#define __NR_getpgrp 111
#define __NR_setsid 112
#define __NR_setreuid 113
#define __NR_setregid 114
#define __NR_getgroups 115
#define __NR_setgroups 116
#define __NR_setresuid 117
#define __NR_getresuid 118
#define __NR_setresgid 119
#define __NR_getresgid 120
#define __NR_getpgid 121
#define __NR_setfsuid 122
#define __NR_setfsgid 123
#define __NR_getsid 124
#define __NR_capget 125
#define __NR_capset 126
#define __NR_rt_sigpending 127
#define __NR_rt_sigtimedwait 128
#define __NR_rt_sigqueueinfo 129
#define __NR_rt_sigsuspend 130
#define __NR_sigaltstack 131
#define __NR_utime 132
#define __NR_mknod 133
#define __NR_uselib 134
#define __NR_personality 135
#define __NR_ustat 136
#define __NR_statfs 137
#define __NR_fstatfs 138
#define __NR_sysfs 139
#define __NR_getpriority 140
#define __NR_setpriority 141
#define __NR_sched_setparam 142
#define __NR_sched_getparam 143
#define __NR_sched_setscheduler 144
#define __NR_sched_getscheduler 145
#define __NR_sched_get_priority_max 146
#define __NR_sched_get_priority_min 147
#define __NR_sched_rr_get_interval 148
#define __NR_mlock 149
#define __NR_munlock 150
#define __NR_mlockall 151
#define __NR_munlockall 152
#define __NR_vhangup 153
#define __NR_modify_ldt 154
#define __NR_pivot_root 155
#define __NR__sysctl 156
#define __NR_prctl 157
#define __NR_arch_prctl 158
#define __NR_adjtimex 159
#define __NR_setrlimit 160
#define __NR_chroot 161
#define __NR_sync 162
#define __NR_acct 163
#define __NR_settimeofday 164
#define __NR_mount 165
#define __NR_umount2 166
#define __NR_swapon 167
#define __NR_swapoff 168
#define __NR_reboot 169
#define __NR_sethostname 170
#define __NR_setdomainname 171
#define __NR_iopl 172
#define __NR_ioperm 173
#define __NR_create_module 174
#define __NR_init_module 175
#define __NR_delete_module 176
#define __NR_get_kernel_syms 177
#define __NR_query_module 178
#define __NR_quotactl 179
#define __NR_nfsservctl 180
#define __NR_getpmsg 181
#define __NR_putpmsg 182
#define __NR_afs_syscall 183
#define __NR_tuxcall 184
#define __NR_security 185
#define __NR_gettid 186
#define __NR_readahead 187
#define __NR_setxattr 188
#define __NR_lsetxattr 189
#define __NR_fsetxattr 190
#define __NR_getxattr 191
#define __NR_lgetxattr 192
#define __NR_fgetxattr 193
#define __NR_listxattr 194
#define __NR_llistxattr 195
#define __NR_flistxattr 196
#define __NR_removexattr 197
#define __NR_lremovexattr 198
#define __NR_fremovexattr 199
#define __NR_tkill 200
#define __NR_time 201
#define __NR_futex 202
#define __NR_sched_setaffinity 203
#define __NR_sched_getaffinity 204
#define __NR_set_thread_area 205
#define __NR_io_setup 206
#define __NR_io_destroy 207
#define __NR_io_getevents 208
#define __NR_io_submit 209
#define __NR_io_cancel 210
#define __NR_get_thread_area 211
#define __NR_lookup_dcookie 212
#define __NR_epoll_create 213
#define __NR_epoll_ctl_old 214
#define __NR_epoll_wait_old 215
#define __NR_remap_file_pages 216
#define __NR_getdents64 217
#define __NR_set_tid_address 218
#define __NR_restart_syscall 219
#define __NR_semtimedop 220
#define __NR_fadvise64 221
#define __NR_timer_create 222
#define __NR_timer_settime 223
#define __NR_timer_gettime 224
#define __NR_timer_getoverrun 225
#define __NR_timer_delete 226
#define __NR_clock_settime 227
#define __NR_clock_gettime 228
#define __NR_clock_getres 229
#define __NR_clock_nanosleep 230
#define __NR_exit_group 231
#define __NR_epoll_wait 232
#define __NR_epoll_ctl 233
#define __NR_tgkill 234
#define __NR_utimes 235
#define __NR_vserver 236
#define __NR_mbind 237
#define __NR_set_mempolicy 238
#define __NR_get_mempolicy 239
#define __NR_mq_open 240
#define __NR_mq_unlink 241
#define __NR_mq_timedsend 242
#define __NR_mq_timedreceive 243
#define __NR_mq_notify 244
#define __NR_mq_getsetattr 245
#define __NR_kexec_load 246
#define __NR_waitid 247
#define __NR_add_key 248
#define __NR_request_key 249
#define __NR_keyctl 250
#define __NR_ioprio_set 251
#define __NR_ioprio_get 252
#define __NR_inotify_init 253
#define __NR_inotify_add_watch 254
#define __NR_inotify_rm_watch 255
#define __NR_migrate_pages 256
#define __NR_openat 257
#define __NR_mkdirat 258
#define __NR_mknodat 259
#define __NR_fchownat 260
#define __NR_futimesat 261
#define __NR_newfstatat 262
#define __NR_unlinkat 263
#define __NR_renameat 264
#define __NR_linkat 265
#define __NR_symlinkat 266
#define __NR_readlinkat 267
#define __NR_fchmodat 268
#define __NR_faccessat 269
#define __NR_pselect6 270
#define __NR_ppoll 271
#define __NR_unshare 272
#define __NR_set_robust_list 273
#define __NR_get_robust_list 274
#define __NR_splice 275
#define __NR_tee 276
#define __NR_sync_file_range 277
#define __NR_vmsplice 278
#define __NR_move_pages 279
#define __NR_utimensat 280
#define __NR_epoll_pwait 281
#define __NR_signalfd 282
#define __NR_timerfd_create 283
#define __NR_eventfd 284
#define __NR_fallocate 285
#define __NR_timerfd_settime 286
#define __NR_timerfd_gettime 287
#define __NR_accept4 288
#define __NR_signalfd4 289
#define __NR_eventfd2 290
#define __NR_epoll_create1 291
#define __NR_dup3 292
#define __NR_pipe2 293
#define __NR_inotify_init1 294
#define __NR_preadv 295
#define __NR_pwritev 296
#define __NR_rt_tgsigqueueinfo 297
#define __NR_perf_event_open 298
#define __NR_recvmmsg 299
#define __NR_fanotify_init 300
#define __NR_fanotify_mark 301
#define __NR_prlimit64 302
#define __NR_name_to_handle_at 303
#define __NR_open_by_handle_at 304
#define __NR_clock_adjtime 305
#define __NR_syncfs 306
#define __NR_sendmmsg 307
#define __NR_setns 308
#define __NR_getcpu 309
#define __NR_process_vm_readv 310
#define __NR_process_vm_writev 311
#define __NR_kcmp 312
#define __NR_finit_module 313
#define __NR_sched_setattr 314
#define __NR_sched_getattr 315
#define __NR_renameat2 316
#define __NR_seccomp 317
#define __NR_getrandom 318
#define __NR_memfd_create 319
#define __NR_kexec_file_load 320
#define __NR_bpf 321
#define __NR_execveat 322
#define __NR_userfaultfd 323
#define __NR_membarrier 324
#define __NR_mlock2 325
#define __NR_copy_file_range 326
#define __NR_preadv2 327
#define __NR_pwritev2 328
#define __NR_pkey_mprotect 329
#define __NR_pkey_alloc 330
#define __NR_pkey_free 331
#define __NR_statx 332

#endif /* _ASM_X86_UNISTD_64_H */
#ifndef syscall_stubs_h
#define syscall_stubs_h
/*
 These are just wrapped syscalls.
 errno is set, anyways.

 This file (and the other headers) are parsed by 'genheaders.pl',
 and the "real" syscall defines below the mark generated-makros-start created.	

*/

//+header declarations.h
//
///+needs mini_fstream.h


extern int sysret;
extern int errno;

struct stat;
struct timeval;
struct timezone;

// TODO: declarations
// below are untested definitions,
// for the SYSREAL... (expanding to sys"syscallname" ) macros
//typedef long sigset_t;
typedef unsigned long u64;
typedef unsigned long __u64;
typedef unsigned int u32;
typedef unsigned char __s32;

typedef long aio_context_t;
typedef long key_serial_t;
typedef long loff_t;
typedef long qid_t;
typedef long mqd_t;
typedef long stack_t;
typedef long umode_t;
typedef long cap_user_data_t;
typedef long cap_user_header_t;
typedef long semun_u;
struct sockaddr;
struct iovcc;
struct rusage;
struct file_handle;
struct utimbuf;
struct sched_attr;
struct sched_param;
struct itimerspec;
struct kexec_segment;
struct task_struct;
struct msghdr;
struct iocb;
struct io_event;
struct linux_dirent64;
struct pt_regs;
struct perf_event_attr;
struct __sysctl_args;
struct timex;
struct msgbuf;
struct pollfd;
struct getcpu_cache;
struct bpf_attr;
struct shmid_ds;
struct epoll_event;
struct mq_attr;
struct poll_fd;
struct mq_attr;
struct sembuf;
struct statfs;
struct sysinfo;
struct rlimit;
struct ustat;
struct itimerval;
struct linux_dirent;
struct robust_list_head;
struct sigevent;
struct siginfo;
struct bpf_attr;
struct msqid_ds;
struct rlimit64;
struct sigaction;
struct mmsghdr;
struct msqid_ds;
// end of "pre"-definitions


// working and tested syscalls below.

DEF_syscall(gettimeofday,2, struct timeval *a1, struct timezone *a2)

DEF_syscall(getpid,0 )
DEF_syscall(setsid,0 )
DEF_syscall(setgid,1, gid_t gid)
DEF_syscall(setuid,1, uid_t uid)

DEF_syscall(vhangup,0 )
DEF_syscallret(mprotect, *a1, 3, POINTER *a1, POINTER a2, int a3 )

DEF_syscall(close, 1, int fd )
DEF_syscall(read, 3, int fd, void *buf, int len )
DEF_syscall(write,3,int fd,const void *buf, int len )

DEF_syscall(uname,1,struct old_utsname *name )

DEF_syscall(getdents, 3, unsigned int fd, struct dirent *direntry, unsigned int count )


DEF_syscall(rename,2, const char* oldpath, const char* newpath )		
DEF_syscall(unlink,1, const char* a1)		

DEF_syscall(fstat,2,int a1,struct stat* a2)		
DEF_syscall(stat,2,const char* filename,struct stat* a2)		
DEF_syscall(chdir,1,const char* path)		

DEF_syscall(fchown,3, unsigned int fd, uid_t user, gid_t group)
DEF_syscall(fchmod,2, unsigned int fd, mode_t mode)

DEF_syscall(dup,1,int a1)		
DEF_syscall(dup2,2,int a1, int a2)		
DEF_syscall(dup3,3,int a1, int a2, int a3)		

DEF_syscall(getcwd,2,char *buf,long size)		


// below not thouroughly tested (2020/05)
DEF_syscall(fork,0)
DEF_syscall(vfork,0)
DEF_syscall(nanosleep,2, struct timespec *rqtp, struct timespec *rmtp)
DEF_syscall(rt_sigaction,4, int sig,  const struct sigaction *act,  struct sigaction *oact,  size_t sigsetsize)
DEF_syscall(chroot,1, const char *filename)
DEF_syscall(pivot_root,2, const char *new_root,  const char *put_old)

// (char *argv[] is equivalent to **argv)
DEF_syscall(execve,3, const char *filename,  const char **argv,  const char **envp)
DEF_syscall(mkdir,2, const char *pathname, int mode)
DEF_syscall(kill,2, pid_t pid,  int sig)
DEF_syscall(rmdir,1, const char *pathname)


// below untested. 
DEF_syscall(access,2, const char *filename, int mode)
DEF_syscall(fcntl,3, unsigned int fd, unsigned int cmd, unsigned long arg)
DEF_syscall(pipe,1, int *filedes)
DEF_syscall(umask,1, int mask)
DEF_syscall(chmod,2, const char *filename, mode_t mode)
DEF_syscall(chown,3, const char *filename, uid_t user, gid_t group)
DEF_syscall(link,2, const char *oldname, const char *newname)
DEF_syscall(utime,2, char *filename, struct utimbuf *times)
DEF_syscall(getppid,0)
DEF_syscall(setpgid,2, pid_t pid, pid_t pgid)
DEF_syscall(getgid,0)
DEF_syscall(getpgrp,0)
DEF_syscall(brk,1, unsigned long brk)
DEF_syscall(sendfile,4, int out_fd,  int in_fd,  off_t *offset,  size_t count)
DEF_syscall(getcwd,2, char *buf,  unsigned long size)
DEF_syscall(sync,0)
DEF_syscall(mount,5, char *dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)
DEF_syscall(readahead,3, int fd,  loff_t offset,  size_t count)
DEF_syscall(reboot,4, int magic1,  int magic2,  unsigned int cmd,  void *arg)
DEF_syscall(getuid,0)
DEF_syscall(wait4,4, pid_t upid,  int *stat_addr,  int options,  struct rusage *ru)
DEF_syscall(mknod,3, const char *filename,  umode_t mode,  unsigned dev)



#ifndef OSX
DEF_syscall(time,1,unsigned int *a1 )
//DEF_syscallret(time,*a1,1,unsigned int *a1 )
#else
#warning Todo: time osx
#endif

	// problem: ifdef / ifndef now doesnt work anymore for the definitions. 
	// Hopefully, thats not going to be a problem.
	// Will see it when trying to compile at osx again
	//
#if 1
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wint-conversion"

/* --- generated-macros-start: syscalldefs --- */
/* minilib/include/syscall_stubs.h, line: 129 */
REAL_define_syscall(vfork,0)

/* minilib/include/syscall_stubs.h, line: 146 */
REAL_define_syscall(umask,1, int a1) 

/* minilib/include/syscall_stubs.h, line: 99 */
REAL_define_syscallret(mprotect, *a1, 3, POINTER *a1, POINTER a2, int a3)

/* minilib/include/syscall_stubs.h, line: 98 */
REAL_define_syscall(vhangup,0 )

/* minilib/include/syscall_stubs.h, line: 107 */
REAL_define_syscall(getdents, 3, unsigned int a1,  struct dirent *a2,  unsigned int a3) 

/* minilib/include/syscall_stubs.h, line: 159 */
REAL_define_syscall(mount,5, char *a1,   char *a2,   char *a3,   unsigned long a4,   void *a5) 

/* minilib/include/syscall_stubs.h, line: 113 */
REAL_define_syscall(fstat,2,int a1, struct stat* a2) 		

/* minilib/include/syscall_stubs.h, line: 156 */
REAL_define_syscall(sendfile,4, int a1,   int a2,   off_t *a3,   size_t a4) 

/* minilib/include/syscall_stubs.h, line: 122 */
REAL_define_syscall(dup3,3,int a1,  int a2,  int a3) 		

/* minilib/include/syscall_stubs.h, line: 162 */
REAL_define_syscall(getuid,0)

/* minilib/include/syscall_stubs.h, line: 118 */
REAL_define_syscall(fchmod,2, unsigned int a1,  mode_t a2) 

/* minilib/include/syscall_stubs.h, line: 139 */
REAL_define_syscall(rmdir,1, const char *a1) 

/* minilib/include/syscall_stubs.h, line: 111 */
REAL_define_syscall(unlink,1, const char* a1) 		

/* minilib/include/syscall_stubs.h, line: 133 */
REAL_define_syscall(pivot_root,2, const char *a1,   const char *a2) 

/* minilib/include/syscall_stubs.h, line: 128 */
REAL_define_syscall(fork,0)

/* minilib/include/syscall_stubs.h, line: 96 */
REAL_define_syscall(setuid,1, uid_t a1) 

/* minilib/include/syscall_stubs.h, line: 151 */
REAL_define_syscall(getppid,0)

/* minilib/include/lseek.h, line: 17 */
REAL_define_syscall(lseek,3,unsigned int a1,  int a2,  int a3) 

/* minilib/include/syscall_stubs.h, line: 103 */
REAL_define_syscall(write,3,int a1, const void *a2,  int a3) 

/* minilib/include/syscall_stubs.h, line: 115 */
REAL_define_syscall(chdir,1,const char* a1) 		

/* minilib/include/syscall_stubs.h, line: 143 */
REAL_define_syscall(access,2, const char *a1,  int a2) 

/* minilib/include/syscall_stubs.h, line: 114 */
REAL_define_syscall(stat,2,const char* a1, struct stat* a2) 		

/* minilib/include/syscall_stubs.h, line: 163 */
REAL_define_syscall(wait4,4, pid_t a1,   int *a2,   int a3,   struct rusage *a4) 

/* minilib/include/syscall_stubs.h, line: 105 */
REAL_define_syscall(uname,1,struct old_utsname *a1) 

/* minilib/include/syscall_stubs.h, line: 94 */
REAL_define_syscall(setsid,0 )

/* minilib/include/syscall_stubs.h, line: 152 */
REAL_define_syscall(setpgid,2, pid_t a1,  pid_t a2) 

/* minilib/include/syscall_stubs.h, line: 164 */
REAL_define_syscall(mknod,3, const char *a1,   umode_t a2,   unsigned a3) 

/* minilib/include/syscall_stubs.h, line: 120 */
REAL_define_syscall(dup,1,int a1) 		

/* minilib/include/syscall_stubs.h, line: 145 */
REAL_define_syscall(pipe,1, int *a1) 

/* minilib/include/syscall_stubs.h, line: 169 */
REAL_define_syscall(time,1,unsigned int *a1) 

/* minilib/include/syscall_stubs.h, line: 131 */
REAL_define_syscall(rt_sigaction,4, int a1,   const struct sigaction *a2,   struct sigaction *a3,   size_t a4) 

/* minilib/include/syscall_stubs.h, line: 149 */
REAL_define_syscall(link,2, const char *a1,  const char *a2) 

/* minilib/include/syscall_stubs.h, line: 148 */
REAL_define_syscall(chown,3, const char *a1,  uid_t a2,  gid_t a3) 

/* minilib/include/syscall_stubs.h, line: 137 */
REAL_define_syscall(mkdir,2, const char *a1,  int a2) 

/* minilib/include/syscall_stubs.h, line: 101 */
REAL_define_syscall(close, 1, int a1) 

/* minilib/include/syscall_stubs.h, line: 161 */
REAL_define_syscall(reboot,4, int a1,   int a2,   unsigned int a3,   void *a4) 

/* minilib/include/syscall_stubs.h, line: 117 */
REAL_define_syscall(fchown,3, unsigned int a1,  uid_t a2,  gid_t a3) 

/* minilib/include/syscall_stubs.h, line: 153 */
REAL_define_syscall(getgid,0)

/* minilib/include/syscall_stubs.h, line: 102 */
REAL_define_syscall(read, 3, int a1,  void *a2,  int a3) 

/* minilib/include/syscall_stubs.h, line: 154 */
REAL_define_syscall(getpgrp,0)

/* minilib/include/syscall_stubs.h, line: 132 */
REAL_define_syscall(chroot,1, const char *a1) 

/* minilib/include/lseek.h, line: 19 */
REAL_define_syscall(ftruncate,2,unsigned int a1,  unsigned int a2) 

/* minilib/include/syscall_stubs.h, line: 121 */
REAL_define_syscall(dup2,2,int a1,  int a2) 		

/* minilib/include/syscall_stubs.h, line: 138 */
REAL_define_syscall(kill,2, pid_t a1,   int a2) 

/* minilib/include/syscall_stubs.h, line: 147 */
REAL_define_syscall(chmod,2, const char *a1,  mode_t a2) 

/* minilib/include/syscall_stubs.h, line: 93 */
REAL_define_syscall(getpid,0 )

/* minilib/include/syscall_stubs.h, line: 155 */
REAL_define_syscall(brk,1, unsigned long a1) 

/* minilib/include/syscall_stubs.h, line: 130 */
REAL_define_syscall(nanosleep,2, struct timespec *a1,  struct timespec *a2) 

/* minilib/include/syscall_stubs.h, line: 136 */
REAL_define_syscall(execve,3, const char *a1,   const char **a2,   const char **a3) 

/* minilib/include/syscall_stubs.h, line: 91 */
REAL_define_syscall(gettimeofday,2, struct timeval *a1,  struct timezone *a2) 

/* minilib/include/lseek.h, line: 20 */
REAL_define_syscall(fsync,1,int a1) 

/* minilib/include/syscall_stubs.h, line: 158 */
REAL_define_syscall(sync,0)

/* minilib/include/syscall_stubs.h, line: 144 */
REAL_define_syscall(fcntl,3, unsigned int a1,  unsigned int a2,  unsigned long a3) 

/* minilib/include/syscall_stubs.h, line: 95 */
REAL_define_syscall(setgid,1, gid_t a1) 

/* minilib/include/syscall_stubs.h, line: 157 */
REAL_define_syscall(getcwd,2, char *a1,   unsigned long a2) 

/* minilib/include/syscall_stubs.h, line: 150 */
REAL_define_syscall(utime,2, char *a1,  struct utimbuf *a2) 

/* minilib/include/syscall_stubs.h, line: 110 */
REAL_define_syscall(rename,2, const char* a1,  const char* a2) 		

/* minilib/include/syscall_stubs.h, line: 160 */
REAL_define_syscall(readahead,3, int a1,   loff_t a2,   size_t a3) 

/* --- generated-macros-end: syscalldefs --- */

#pragma GCC diagnostic pop
#endif

#endif
#ifndef	SYS_TYPES_H
#define	SYS_TYPES_H

#ifndef POINTER
#ifdef X64
#define POINTER unsigned long int
#else
#define POINTER int
#endif
#endif



typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned u_int32_t;
typedef char *caddr_t;
typedef unsigned char u_char;
typedef unsigned short u_short, ushort;
typedef unsigned u_int, uint;
typedef unsigned long u_long, ulong;
typedef long long quad_t;
typedef unsigned long long u_quad_t;
#ifndef _ENDIAN_H
#define _ENDIAN_H


#define __LITTLE_ENDIAN 1234
#define __BIG_ENDIAN 4321
#define __PDP_ENDIAN 3412
#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)

#define BIG_ENDIAN __BIG_ENDIAN
#define LITTLE_ENDIAN __LITTLE_ENDIAN
#define PDP_ENDIAN __PDP_ENDIAN
#define BYTE_ORDER __BYTE_ORDER

#ifndef _STDINT_H
#define _STDINT_H

#define __NEED_int8_t
#define __NEED_int16_t
#define __NEED_int32_t
#define __NEED_int64_t

#define __NEED_uint8_t
#define __NEED_uint16_t
#define __NEED_uint32_t
#define __NEED_uint64_t

#define __NEED_intptr_t
#define __NEED_uintptr_t

#define __NEED_intmax_t
#define __NEED_uintmax_t


typedef int8_t int_fast8_t;
typedef int64_t int_fast64_t;

typedef int8_t  int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;

typedef uint8_t uint_fast8_t;
typedef uint64_t uint_fast64_t;

typedef uint8_t  uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;

#define INT8_MIN   (-1-0x7f)
#define INT16_MIN  (-1-0x7fff)
#define INT32_MIN  (-1-0x7fffffff)
#define INT64_MIN  (-1-0x7fffffffffffffff)

#define INT8_MAX   (0x7f)
#define INT16_MAX  (0x7fff)
#define INT32_MAX  (0x7fffffff)
#define INT64_MAX  (0x7fffffffffffffff)

#define UINT8_MAX  (0xff)
#define UINT16_MAX (0xffff)
#define UINT32_MAX (0xffffffffu)
#define UINT64_MAX (0xffffffffffffffffu)

#define INT_FAST8_MIN   INT8_MIN
#define INT_FAST64_MIN  INT64_MIN

#define INT_LEAST8_MIN   INT8_MIN
#define INT_LEAST16_MIN  INT16_MIN
#define INT_LEAST32_MIN  INT32_MIN
#define INT_LEAST64_MIN  INT64_MIN

#define INT_FAST8_MAX   INT8_MAX
#define INT_FAST64_MAX  INT64_MAX

#define INT_LEAST8_MAX   INT8_MAX
#define INT_LEAST16_MAX  INT16_MAX
#define INT_LEAST32_MAX  INT32_MAX
#define INT_LEAST64_MAX  INT64_MAX

#define UINT_FAST8_MAX  UINT8_MAX
#define UINT_FAST64_MAX UINT64_MAX

#define UINT_LEAST8_MAX  UINT8_MAX
#define UINT_LEAST16_MAX UINT16_MAX
#define UINT_LEAST32_MAX UINT32_MAX
#define UINT_LEAST64_MAX UINT64_MAX

#define INTMAX_MIN  INT64_MIN
#define INTMAX_MAX  INT64_MAX
#define UINTMAX_MAX UINT64_MAX

#define WINT_MIN 0U
#define WINT_MAX UINT32_MAX

#if L'\0'-1 > 0
#define WCHAR_MAX (0xffffffffu+L'\0')
#define WCHAR_MIN (0+L'\0')
#else
#define WCHAR_MAX (0x7fffffff+L'\0')
#define WCHAR_MIN (-1-0x7fffffff+L'\0')
#endif

#define SIG_ATOMIC_MIN  INT32_MIN
#define SIG_ATOMIC_MAX  INT32_MAX

//#include <bits/stdint.h>

#define INT8_C(c)  c
#define INT16_C(c) c
#define INT32_C(c) c

#define UINT8_C(c)  c
#define UINT16_C(c) c
#define UINT32_C(c) c ## U

#if UINTPTR_MAX == UINT64_MAX
#define INT64_C(c) c ## L
#define UINT64_C(c) c ## UL
#define INTMAX_C(c)  c ## L
#define UINTMAX_C(c) c ## UL
#else
#define INT64_C(c) c ## LL
#define UINT64_C(c) c ## ULL
#define INTMAX_C(c)  c ## LL
#define UINTMAX_C(c) c ## ULL
#endif

#endif

static __inline uint16_t __bswap16(uint16_t __x)
{
	return __x<<8 | __x>>8;
}

static __inline uint32_t __bswap32(uint32_t __x)
{
	return __x>>24 | __x>>8&0xff00 | __x<<8&0xff0000 | __x<<24;
}

static __inline uint64_t __bswap64(uint64_t __x)
{
	return __bswap32(__x)+0ULL<<32 | __bswap32(__x>>32);
}

#if __BYTE_ORDER == __LITTLE_ENDIAN
#define htobe16(x) __bswap16(x)
#define be16toh(x) __bswap16(x)
#define betoh16(x) __bswap16(x)
#define htobe32(x) __bswap32(x)
#define be32toh(x) __bswap32(x)
#define betoh32(x) __bswap32(x)
#define htobe64(x) __bswap64(x)
#define be64toh(x) __bswap64(x)
#define betoh64(x) __bswap64(x)
#define htole16(x) (uint16_t)(x)
#define le16toh(x) (uint16_t)(x)
#define letoh16(x) (uint16_t)(x)
#define htole32(x) (uint32_t)(x)
#define le32toh(x) (uint32_t)(x)
#define letoh32(x) (uint32_t)(x)
#define htole64(x) (uint64_t)(x)
#define le64toh(x) (uint64_t)(x)
#define letoh64(x) (uint64_t)(x)
#else
#define htobe16(x) (uint16_t)(x)
#define be16toh(x) (uint16_t)(x)
#define betoh16(x) (uint16_t)(x)
#define htobe32(x) (uint32_t)(x)
#define be32toh(x) (uint32_t)(x)
#define betoh32(x) (uint32_t)(x)
#define htobe64(x) (uint64_t)(x)
#define be64toh(x) (uint64_t)(x)
#define betoh64(x) (uint64_t)(x)
#define htole16(x) __bswap16(x)
#define le16toh(x) __bswap16(x)
#define letoh16(x) __bswap16(x)
#define htole32(x) __bswap32(x)
#define le32toh(x) __bswap32(x)
#define letoh32(x) __bswap32(x)
#define htole64(x) __bswap64(x)
#define le64toh(x) __bswap64(x)
#define letoh64(x) __bswap64(x)
#endif

#endif

#endif

#define blkcnt64_t blkcnt_t
#define fsblkcnt64_t fsblkcnt_t
#define fsfilcnt64_t fsfilcnt_t
#define ino64_t ino_t
#define off64_t off_t

#endif

#ifdef mini_GETOPTS
#ifndef mini_getoptm_h
#define mini_getoptm_h

//+include


#define DEF_OPTIONS_ENUM_short enum MINI_OPTIONS_short { a=0x1,b=0x2,c=0x4,d=0x8,e=0x10,f=0x20,g=0x40,h=0x80,i=0x100,j=0x200,\
						k=0x400,l=0x800,m=0x1000,n=0x2000,o=0x4000,p=0x8000,q=0x10000,r=0x20000,s=0x40000,\
						t=0x80000,u=0x100000,v=0x200000,w=0x400000,x=0x800000,y=0x1000000,z=0x2000000 };

//+doc Parse "argv" for short options "options", small capitals.
//	Save them in the bitfield (int32) "opts".
//	If there is an unrecognized option, do "unrecognized". char "option" keeps the unrecognized option.
//	Possible options have to be supplied in this form: ( a+l+h+... )
//	e.g.: 
//		PARSEOPTS_short( opts, argv, (a+h+l),{ fprintf(stderr, "Unrecognized option: -%c\n", option); exit(1); });
//
//	Returns a number, pointing to the first regular argument. 
//		(Doesn't check for it's existence, so you can proceed with 
//		e.g.:) for ( int a= ret; argv[a] !=0; a++ ){ ... }
//
//+def
#define PARSEOPTS_short( opts, argv, options, unrecognized ) ({\
		DEF_OPTIONS_ENUM_short;\
		int argp=1;\
		for ( int ap=1; argv[ap]; ap++ ){\
				if ( argv[ap][0] == '-' ){\
						argp = ap+1;\
						for ( int b=1; argv[ap][b]; b++ ){\
								int ti; char option;\
								opts |= (ti=1<< ((option=argv[ap][b])-97) );\
								if ( ! ( (options) & ti ) ){\
									unrecognized;\
									}\
						}\
				}\
		}\
		argp;\
		} )


//+doc Tests, whether a bit (option flag) is set
//+def
#define GETOPT_short( opts, option ) ({\
				DEF_OPTIONS_ENUM_short;\
				opts & option;\
				} )

//+doc Set a option flag(s) (bit(s))  manually.
//		param options: e.g. just a, or ( a+h+l) to check for several flags at once
//+def
#define SETOPT_short( opts, option ) ({\
				DEF_OPTIONS_ENUM_short;\
				opts = (opts | option);\
				} )



#endif
#endif

/* end templates/header.in */
/* templates/minilib.h.in */



/// Debugging macros
#ifdef DEBUG
#define mini_fputc
#define mini_fprintf
static inline int fputc(int c, int fd);


#define dbgwarnf(...) {fprintf(stderr,__VA_ARGS__);fputc('\n',stderr);}
#define dbgwarn(s) {write(stderr,s,sizeof(s));fputc('\n',stderr);}
#define dbgwarnfif(a,...) {if ( a ){dbgwarnf(__VA_ARGS__)};}
#define dbgwarnif(a,s) {if ( a ){dbgwarn(s)};}
#define dbgerr(s) {dbgwarn(s);exit(1);}
#define dbgerrf(...) {dbgwarnf(__VA_ARGS__);exit(1);}
#define dbgerrif(a,s) {if(a){dbgwarn(s);exit(1);};}
#define dbgerrfif(a,...) {if(a){dbgwarnf(__VA_ARGS__);exit(1);};}

#define dbg(s) dbgwarn(s)
#define dbgf(...) dbgwarnf(__VA_ARGS__)

#else

#define dbg(s) {}
#define dbgf(...) {}


#define dbgwarnf(...) {}
#define dbgwarn(s) {} 
#define dbgwarnfif(a,...) {} 
#define dbgwarnif(a,s) {} 
#define dbgerr(s) {}
#define dbgerrf(...) {}
#define dbgerrif(a,s) {}
#define dbgerrfif(a,...) {}

#endif


// ansicolors
#define AC_BLACK "\033[0;30m"
#define AC_RED "\033[0;31m"
#define AC_GREEN "\033[32;0m"
#define AC_BROWN "\033[0;33m"
#define AC_BLUE "\033[0;34m"
#define AC_MAGENTA "\033[0;35m"
#define AC_MARINE "\033[0;36m"
#define AC_LGREY "\033[0;37m"
#define AC_WHITE "\033[0;38m"

#define AC_GREY "\033[1;30m" 
#define AC_LRED "\033[1;31m" 
#define AC_LGREEN "\033[1;32m" 
#define AC_YELLOW "\033[1;33m"
#define AC_LBLUE "\033[1;34m"
#define AC_LMAGENTA "\033[1;35m"
#define AC_LMARINE "\033[1;36m"
#define AC_LWHITE "\033[1;37m"



#ifdef SHORTCOLORNAMES

#define NORM     AC_NORM
#define INVERSE  AC_INVERSE
#define BLINK    AC_BLINK
#define BLACK    AC_BLACK
#define RED      AC_RED
#define GREEN    AC_GREEN
#define BROWN    AC_BROWN
#define BLUE     AC_BLUE
#define MAGENTA  AC_MAGENTA
#define MARINE   AC_MARINE
#define LGREY    AC_LGREY
#define WHITE    AC_WHITE
#define GREY     AC_GREY
#define LRED     AC_LRED
#define LGREEN   AC_LGREEN
#define YELLOW   AC_YELLOW
#define LBLUE    AC_LBLUE
#define LMAGENTA AC_LMAGENTA
#define LMARINE  AC_LMARINE
#define LWHITE   AC_LWHITE

#endif

#ifdef SHRTSHORTCOLORNAMES

#define cN   AC_NORM
#define cBL  AC_BLACK
#define cR   AC_RED
#define cG   AC_GREEN
#define cBR  AC_BROWN
#define cB   AC_BLUE
#define cMG  AC_MAGENTA
#define cM   AC_MARINE
#define cLG  AC_LGREY
#define cW   AC_WHITE
#define cG   AC_GREY
#define cLR  AC_LRED
#define cLGN AC_LGREEN
#define cY   AC_YELLOW
#define cLB  AC_LBLUE
#define cLMG AC_LMAGENTA
#define cLM  AC_LMARINE
#define cLW  AC_LWHITE

#endif






#ifndef vararg_h
#define vararg_h

#define VARARG(A,B) ((A+0) ?: B )
#define SHIFT(A,...) A
#define ARG(A,...) __VA_ARGS__

#endif


//#include "minilib/include/syscall.h"
#ifndef stdarg_h
#define stdarg_h
// copied from musl
// copy more - the builtin list..

#if 1
#if __GNUC__ >= 3
//#warning here 1
typedef __builtin_va_list va_list;
#define va_start(v,l)   __builtin_va_start(v,l)
#define va_end(v)       __builtin_va_end(v)
#define va_arg(v,l)     __builtin_va_arg(v,l)
#define va_copy(d,s)    __builtin_va_copy(d,s)
#else
//#warning here 2

#ifdef __GNUC__
//#warning here 3
//TODO: this gets scrambled if in the same compiler unit as the caller.
typedef __builtin_va_list va_list;
#define __VA_ALIGNED_SIZE(x) ((sizeof(x) + sizeof(int) - 1) & ~(sizeof(int) - 1))

#define va_start(ap, last) ((ap) = (void *)(((char *)&(last)) + __VA_ALIGNED_SIZE(last)))
#define va_end(ap) ((void)0)
#define va_copy(dest, src) ((dest) = (src))

#define va_arg(ap, type) \
	( ((ap) = (va_list)((char *)(ap) + __VA_ALIGNED_SIZE(type))), \
	*(type *)(void *)((char *)(ap) - __VA_ALIGNED_SIZE(type)) )


#else

//#warning here 4
// copied from tcc
#ifdef __x86_64__
//#warning here 5
#ifndef _WIN64
//#warning here 6

typedef void *va_list;

va_list __va_start(void *fp);
void *__va_arg(va_list ap, int arg_type, int size);
va_list __va_copy(va_list src);
void __va_end(va_list ap);

#define va_start(ap, last) ((ap) = __va_start(__builtin_frame_address(0)))
#define va_arg(ap, type)                                                \
		    (*(type *)(__va_arg(ap, __builtin_va_arg_types(type), sizeof(type))))
#define va_copy(dest, src) ((dest) = __va_copy(src))
#define va_end(ap) __va_end(ap)

#else /* _WIN64 */
typedef char *va_list;
#define va_start(ap,last) ap = ((char *)&(last)) + ((sizeof(last)+7)&~7)
#define va_arg(ap,type) (ap += (sizeof(type)+7)&~7, *(type *)(ap - ((sizeof(type)+7)&~7)))
#define va_copy(dest, src) (dest) = (src)
#define va_end(ap)
#endif

#else /* __i386__ */
typedef char *va_list;
/* only correct for i386 */
#define va_start(ap,last) ap = ((char *)&(last)) + ((sizeof(last)+3)&~3)
#define va_arg(ap,type) (ap += (sizeof(type)+3)&~3, *(type *)(ap - ((sizeof(type)+3)&~3)))
#define va_copy(dest, src) (dest) = (src)
#define va_end(ap)
#endif

/* fix a buggy dependency on GCC in libio.h */
typedef va_list __gnuc_va_list;
#define _VA_LIST_DEFINED

#endif
#endif

#endif

#endif


//#include "minilib/headers/common/sys/types.h"
//#include "minilib/include/syscall_stubs.h"
#ifndef minilib_exit_h
#define minilib_exit_h
//+header unistd.h
//+inc

//#include "syscall.h"
//#undef write
//#undef exit


#ifdef X64
#define exit(ret) asm("jmp _exit"::"D"(ret))
#else
#define exit(ret) asm("jmp _exit"::"b"(ret))
#endif


//#else
/* inline void volatile __attribute__((always_inline)) exit( int ret ){
		//setup_syscall3(SYS_write,fd,(int)s,len);
	int r;
		syscall1(r,SCALL(exit),ret);
} */
//#endif

#endif
#ifndef mini_filemodes_h
#define mini_filemodes_h

#ifdef OSX

/* open-only flags */
#define	O_RDONLY	0x0000		/* open for reading only */
#define	O_WRONLY	0x0001		/* open for writing only */
#define	O_RDWR		0x0002		/* open for reading and writing */
#define	O_ACCMODE	0x0003		/* mask for above modes */

#define	FREAD		0x0001
#define	FWRITE		0x0002
#define	O_NONBLOCK	0x0004		/* no delay */
#define	O_APPEND	0x0008		/* set append mode */

#define	O_SHLOCK	0x0010		/* open with shared file lock */
#define	O_EXLOCK	0x0020		/* open with exclusive file lock */
#define	O_ASYNC		0x0040		/* signal pgrp when data ready */
#define	O_FSYNC		O_SYNC		/* source compatibility: do not use */
#define O_NOFOLLOW  0x0100      /* don't follow symlinks */
#define	O_CREAT		0x0200		/* create if nonexistant */
#define	O_TRUNC		0x0400		/* truncate to zero length */
#define	O_EXCL		0x0800		/* error if already exists */

#define	O_EVTONLY	0x8000		/* descriptor requested for event notifications only */

#define	O_NOCTTY	0x20000		/* don't assign controlling terminal */
#define O_DIRECTORY	0x100000
#define O_SYMLINK	0x200000	/* allow open of a symlink */
#define	O_CLOEXEC	0x1000000	/* implicitly set FD_CLOEXEC */
#define O_DP_GETRAWENCRYPTED	0x0001
#define O_DP_GETRAWUNENCRYPTED	0x0002



#else


#define O_ACCMODE	00000003
#define O_RDONLY	00000000
#define O_WRONLY	00000001
#define O_RDWR		00000002
#define O_CREAT		00000100	/* not fcntl */
#define O_EXCL		00000200	/* not fcntl */
#define O_NOCTTY	00000400	/* not fcntl */
#define O_TRUNC		00001000	/* not fcntl */
#define O_APPEND	00002000
#define O_NONBLOCK	00004000
#define O_DSYNC		00010000	/* used to be O_SYNC, see below */
#define FASYNC		00020000	/* fcntl, for BSD compatibility */
#define O_DIRECT	00040000	/* direct disk access hint */
#define O_LARGEFILE	00100000
#define O_DIRECTORY	00200000	/* must be a directory */
#define O_NOFOLLOW	00400000	/* don't follow links */
#define O_NOATIME	01000000
#define O_CLOEXEC	02000000	/* set close_on_exec */

#endif



#endif


//#include "minilib/headers/common/dirent.h"


struct udiv_t { unsigned int quot, rem; };

#ifdef mini_perror
//#define perror(str) fprintf(stderr,str)
//#ifndef mini_fprintf
//#define mini_fprintf
//#endif
#endif


//#ifdef mini_puts
//#define puts(a1) printl(a1)
//#define mini_print
//#endif
//#ifdef mini_print
////#include "print.h"
//extern int print(const char *msg);
//extern int printl(const char *msg);
//#endif

//#ifdef mini_errno / No reason to not define errno Macros by default
#ifndef mini_errno_h
#define mini_errno_h
#define EPERM            1
#define ENOENT           2
#define ESRCH            3
#define EINTR            4
#define EIO              5
#define ENXIO            6
#define E2BIG            7
#define ENOEXEC          8
#define EBADF            9
#define ECHILD          10
#define EAGAIN          11
#define ENOMEM          12
#define EACCES          13
#define EFAULT          14
#define ENOTBLK         15
#define EBUSY           16
#define EEXIST          17
#define EXDEV           18
#define ENODEV          19
#define ENOTDIR         20
#define EISDIR          21
#define EINVAL          22
#define ENFILE          23
#define EMFILE          24
#define ENOTTY          25
#define ETXTBSY         26
#define EFBIG           27
#define ENOSPC          28
#define ESPIPE          29
#define EROFS           30
#define EMLINK          31
#define EPIPE           32
#define EDOM            33
#define ERANGE          34
#define EDEADLK         35
#define ENAMETOOLONG    36
#define ENOLCK          37
#define ENOSYS          38
#define ENOTEMPTY       39
#define ELOOP           40
#define EWOULDBLOCK     EAGAIN
#define ENOMSG          42
#define EIDRM           43
#define ECHRNG          44
#define EL2NSYNC        45
#define EL3HLT          46
#define EL3RST          47
#define ELNRNG          48
#define EUNATCH         49
#define ENOCSI          50
#define EL2HLT          51
#define EBADE           52
#define EBADR           53
#define EXFULL          54
#define ENOANO          55
#define EBADRQC         56
#define EBADSLT         57
#define EDEADLOCK       EDEADLK
#define EBFONT          59
#define ENOSTR          60
#define ENODATA         61
#define ETIME           62
#define ENOSR           63
#define ENONET          64
#define ENOPKG          65
#define EREMOTE         66
#define ENOLINK         67
#define EADV            68
#define ESRMNT          69
#define ECOMM           70
#define EPROTO          71
#define EMULTIHOP       72
#define EDOTDOT         73
#define EBADMSG         74
#define EOVERFLOW       75
#define ENOTUNIQ        76
#define EBADFD          77
#define EREMCHG         78
#define ELIBACC         79
#define ELIBBAD         80
#define ELIBSCN         81
#define ELIBMAX         82
#define ELIBEXEC        83
#define EILSEQ          84
#define ERESTART        85
#define ESTRPIPE        86
#define EUSERS          87
#define ENOTSOCK        88
#define EDESTADDRREQ    89
#define EMSGSIZE        90
#define EPROTOTYPE      91
#define ENOPROTOOPT     92
#define EPROTONOSUPPORT 93
#define ESOCKTNOSUPPORT 94
#define EOPNOTSUPP      95
#define ENOTSUP         EOPNOTSUPP
#define EPFNOSUPPORT    96
#define EAFNOSUPPORT    97
#define EADDRINUSE      98
#define EADDRNOTAVAIL   99
#define ENETDOWN        100
#define ENETUNREACH     101
#define ENETRESET       102
#define ECONNABORTED    103
#define ECONNRESET      104
#define ENOBUFS         105
#define EISCONN         106
#define ENOTCONN        107
#define ESHUTDOWN       108
#define ETOOMANYREFS    109
#define ETIMEDOUT       110
#define ECONNREFUSED    111
#define EHOSTDOWN       112
#define EHOSTUNREACH    113
#define EALREADY        114
#define EINPROGRESS     115
#define ESTALE          116
#define EUCLEAN         117
#define ENOTNAM         118
#define ENAVAIL         119
#define EISNAM          120
#define EREMOTEIO       121
#define EDQUOT          122
#define ENOMEDIUM       123
#define EMEDIUMTYPE     124
#define ECANCELED       125
#define ENOKEY          126
#define EKEYEXPIRED     127
#define EKEYREVOKED     128
#define EKEYREJECTED    129
#define EOWNERDEAD      130
#define ENOTRECOVERABLE 131
#define ERFKILL         132
extern int errno;
#endif
//#endif
//


/* end templates/minilib.h.in */


#ifdef mini_perror
//dep
#ifndef mini_fputs
#define mini_fputs
#endif
#ifndef mini_strerror
#define mini_strerror
#endif
#ifndef mini_strlen
#define mini_strlen
#endif
#endif

#ifdef mini_strcmp
//dep
#ifndef mini__strcmp
#define mini__strcmp
#endif
#endif

#ifdef mini_putc
//dep
#ifndef mini_fputc
#define mini_fputc
#endif
#endif

#ifdef mini_fgetc
//dep
#ifndef mini_fileno
#define mini_fileno
#endif
#ifndef mini_read
#define mini_read
#endif
#endif

#ifdef mini_posix_openpt
//dep
#ifndef mini_open
#define mini_open
#endif
#endif

#ifdef mini__fopen
//dep
#ifndef mini_open
#define mini_open
#endif
#ifndef mini_fileno
#define mini_fileno
#endif
#ifndef mini_close
#define mini_close
#endif
#endif

#ifdef mini_closedir
//dep
#ifndef mini_free
#define mini_free
#endif
#endif

#ifdef mini_getc
//dep
#ifndef mini_fgetc
#define mini_fgetc
#endif
#ifndef mini_fileno
#define mini_fileno
#endif
#ifndef mini_read
#define mini_read
#endif
#endif

#ifdef mini_itohex
//dep
#ifndef mini__itohex
#define mini__itohex
#endif
#endif

#ifdef mini_fgetpos
//dep
#ifndef mini_ftell
#define mini_ftell
#endif
#endif

#ifdef mini_ptsname
//dep
#ifndef mini_ptsname_r
#define mini_ptsname_r
#endif
#endif

#ifdef mini_vsnprintf
//dep
#ifndef mini_write
#define mini_write
#endif
#endif

#ifdef mini_ptsname_r
//dep
#ifndef mini_snprintf
#define mini_snprintf
#endif
#ifndef mini_itodec
#define mini_itodec
#endif
#endif

#ifdef mini_itodec
//dep
#ifndef mini_uitodec
#define mini_uitodec
#endif
#endif

#ifdef mini_snprintf
//dep
#ifndef mini_write
#define mini_write
#endif
#ifndef mini_vsnprintf
#define mini_vsnprintf
#endif
#endif

#ifdef mini_fwrites
//dep
#ifndef mini_write
#define mini_write
#endif
#endif

#ifdef mini_printl
//dep
#ifndef mini_write
#define mini_write
#endif
#endif

#ifdef mini_opendir
//dep
#ifndef mini_open
#define mini_open
#endif
#ifndef mini_close
#define mini_close
#endif
#ifndef mini_malloc
#define mini_malloc
#endif
#endif

#ifdef mini_basename
//dep
#ifndef mini_strlen
#define mini_strlen
#endif
#endif

#ifdef mini_fprintfs
//dep
#ifndef mini_fputs
#define mini_fputs
#endif
#ifndef mini_write
#define mini_write
#endif
#ifndef mini_fileno
#define mini_fileno
#endif
#endif

#ifdef mini_fprint
//dep
#ifndef mini_fprintf
#define mini_fprintf
#endif
#ifndef mini_fileno
#define mini_fileno
#endif
#endif

#ifdef mini_strncmp
//dep
#ifndef mini__strcmp
#define mini__strcmp
#endif
#endif

#ifdef mini_prints
//dep
#ifndef mini__mprints
#define mini__mprints
#endif
#endif

#ifdef mini_fputs
//dep
#ifndef mini_strlen
#define mini_strlen
#endif
#ifndef mini_fileno
#define mini_fileno
#endif
#ifndef mini_write
#define mini_write
#endif
#endif

#ifdef mini_freopen
//dep
#ifndef mini_open
#define mini_open
#endif
#ifndef mini__fopen
#define mini__fopen
#endif
#endif

#ifdef mini_print
//dep
#ifndef mini_write
#define mini_write
#endif
#ifndef mini_strlen
#define mini_strlen
#endif
#endif

#ifdef mini_wait
//dep
#ifndef mini_wait4
#define mini_wait4
#endif
#endif

#ifdef mini_dirname
//dep
#ifndef mini_strlen
#define mini_strlen
#endif
#endif

#ifdef mini_unlockpt
//dep
#ifndef mini_ioctl
#define mini_ioctl
#endif
#endif

#ifdef mini_rewind
//dep
#ifndef mini_fseek
#define mini_fseek
#endif
#endif

#ifdef mini_getchar
//dep
#ifndef mini_fgetc
#define mini_fgetc
#endif
#ifndef mini_fileno
#define mini_fileno
#endif
#ifndef mini_read
#define mini_read
#endif
#endif

#ifdef mini_fgets
//dep
#ifndef mini_fgetc
#define mini_fgetc
#endif
#endif

#ifdef mini_tcgetattr
//dep
#ifndef mini_ioctl
#define mini_ioctl
#endif
#endif

#ifdef mini_fseek
//dep
#ifndef mini_lseek
#define mini_lseek
#endif
#endif

#ifdef mini_dprintf
//dep
#ifndef mini_write
#define mini_write
#endif
#ifndef mini_vsnprintf
#define mini_vsnprintf
#endif
#endif

#ifdef mini_ftell
//dep
#ifndef mini_lseek
#define mini_lseek
#endif
#endif

#ifdef mini_itobin
//dep
#ifndef mini__itobin
#define mini__itobin
#endif
#endif

#ifdef mini_fread
//dep
#ifndef mini_read
#define mini_read
#endif
#endif

#ifdef mini_fprintf
//dep
#ifndef mini_write
#define mini_write
#endif
#ifndef mini_prints
#define mini_prints
#endif
#ifndef mini_dprintf
#define mini_dprintf
#endif
#ifndef mini_sprintf
#define mini_sprintf
#endif
#ifndef mini_fileno
#define mini_fileno
#endif
#endif

#ifdef mini_strncasecmp
//dep
#ifndef mini__strcasecmp
#define mini__strcasecmp
#endif
#endif

#ifdef mini_putchar
//dep
#ifndef mini_fputc
#define mini_fputc
#endif
#endif

#ifdef mini_fwrite
//dep
#ifndef mini_write
#define mini_write
#endif
#endif

#ifdef mini_fprints
//dep
#ifndef mini_fileno
#define mini_fileno
#endif
#ifndef mini_write
#define mini_write
#endif
#ifndef mini_strlen
#define mini_strlen
#endif
#endif

#ifdef mini_waitpid
//dep
#ifndef mini_wait4
#define mini_wait4
#endif
#endif

#ifdef mini_sprintf
//dep
#ifndef mini_snprintf
#define mini_snprintf
#endif
#ifndef mini_vsnprintf
#define mini_vsnprintf
#endif
#endif

#ifdef mini_printsl
//dep
#ifndef mini__mprints
#define mini__mprints
#endif
#endif

#ifdef mini_fsetpos
//dep
#ifndef mini_lseek
#define mini_lseek
#endif
#endif

#ifdef mini_strcasecmp
//dep
#ifndef mini__strcasecmp
#define mini__strcasecmp
#endif
#ifndef mini_tolower
#define mini_tolower
#endif
#endif

#ifdef mini_vfprintf
//dep
#ifndef mini_fprintf
#define mini_fprintf
#endif
#endif

#ifdef mini_puts
//dep
#ifndef mini_printl
#define mini_printl
#endif
#ifndef mini_print
#define mini_print
#endif
#ifndef mini_strlen
#define mini_strlen
#endif
#endif

#ifdef mini_fputc
//dep
#ifndef mini_fileno
#define mini_fileno
#endif
#ifndef mini_write
#define mini_write
#endif
#endif

#ifdef mini_memcmp
//dep
#ifndef mini_0
#define mini_0
#endif
#endif

#ifdef mini_strdup
//dep
#ifndef mini_malloc
#define mini_malloc
#endif
#ifndef mini_strcpy
#define mini_strcpy
#endif
#ifndef mini_strlen
#define mini_strlen
#endif
#endif

#ifdef mini_printf
//dep
#ifndef mini_fprintf
#define mini_fprintf
#endif
#ifndef mini_fileno
#define mini_fileno
#endif
#endif

#ifdef mini__strcasecmp
//dep
#ifndef mini_tolower
#define mini_tolower
#endif
#endif

#ifdef mini_isatty
//dep
#ifndef mini_tcgetattr
#define mini_tcgetattr
#endif
#endif

#ifdef mini_writes
//dep
#ifndef mini_write
#define mini_write
#endif
#endif

#ifdef mini_strncpy
//dep
#ifndef mini_memcpy
#define mini_memcpy
#endif
#endif

#ifdef mini_itoHEX
//dep
#ifndef mini__itohex
#define mini__itohex
#endif
#endif

#ifdef mini_fdopen
//dep
#ifndef mini_open
#define mini_open
#endif
#ifndef mini__fopen
#define mini__fopen
#endif
#endif

#ifdef mini_signal
//dep
#ifndef mini_sigaction
#define mini_sigaction
#endif
#endif

#ifdef mini_tcsetattr
//dep
#ifndef mini_ioctl
#define mini_ioctl
#endif
#endif

#ifdef mini_fclose
//dep
#ifndef mini_close
#define mini_close
#endif
#endif

#ifdef mini_dtodec
//dep
#ifndef mini_itodec
#define mini_itodec
#endif
#ifndef mini_uitodec
#define mini_uitodec
#endif
#endif

#ifdef mini_strcat
//dep
#ifndef mini_strlen
#define mini_strlen
#endif
#endif

#ifdef mini_gets
//dep
#ifndef mini_fgets
#define mini_fgets
#endif
#ifndef mini_fgetc
#define mini_fgetc
#endif
#ifndef mini_fileno
#define mini_fileno
#endif
#ifndef mini_read
#define mini_read
#endif
#endif

#ifdef mini_fopen
//dep
#ifndef mini_open
#define mini_open
#endif
#ifndef mini__fopen
#define mini__fopen
#endif
#endif

#ifdef mini__mprints
//dep
#ifndef mini_dprints
#define mini_dprints
#endif
#endif
// Start incfirst

// minilib/include/fgetc.h
#ifdef mini_fgetc
#ifndef mini_fstream_h
#define mini_fstream_h

#ifndef stdarg_h
#define stdarg_h
// copied from musl
// copy more - the builtin list..

#if 1
#if __GNUC__ >= 3
//#warning here 1
typedef __builtin_va_list va_list;
#define va_start(v,l)   __builtin_va_start(v,l)
#define va_end(v)       __builtin_va_end(v)
#define va_arg(v,l)     __builtin_va_arg(v,l)
#define va_copy(d,s)    __builtin_va_copy(d,s)
#else
//#warning here 2

#ifdef __GNUC__
//#warning here 3
//TODO: this gets scrambled if in the same compiler unit as the caller.
typedef __builtin_va_list va_list;
#define __VA_ALIGNED_SIZE(x) ((sizeof(x) + sizeof(int) - 1) & ~(sizeof(int) - 1))

#define va_start(ap, last) ((ap) = (void *)(((char *)&(last)) + __VA_ALIGNED_SIZE(last)))
#define va_end(ap) ((void)0)
#define va_copy(dest, src) ((dest) = (src))

#define va_arg(ap, type) \
	( ((ap) = (va_list)((char *)(ap) + __VA_ALIGNED_SIZE(type))), \
	*(type *)(void *)((char *)(ap) - __VA_ALIGNED_SIZE(type)) )


#else

//#warning here 4
// copied from tcc
#ifdef __x86_64__
//#warning here 5
#ifndef _WIN64
//#warning here 6

typedef void *va_list;

va_list __va_start(void *fp);
void *__va_arg(va_list ap, int arg_type, int size);
va_list __va_copy(va_list src);
void __va_end(va_list ap);

#define va_start(ap, last) ((ap) = __va_start(__builtin_frame_address(0)))
#define va_arg(ap, type)                                                \
		    (*(type *)(__va_arg(ap, __builtin_va_arg_types(type), sizeof(type))))
#define va_copy(dest, src) ((dest) = __va_copy(src))
#define va_end(ap) __va_end(ap)

#else /* _WIN64 */
typedef char *va_list;
#define va_start(ap,last) ap = ((char *)&(last)) + ((sizeof(last)+7)&~7)
#define va_arg(ap,type) (ap += (sizeof(type)+7)&~7, *(type *)(ap - ((sizeof(type)+7)&~7)))
#define va_copy(dest, src) (dest) = (src)
#define va_end(ap)
#endif

#else /* __i386__ */
typedef char *va_list;
/* only correct for i386 */
#define va_start(ap,last) ap = ((char *)&(last)) + ((sizeof(last)+3)&~3)
#define va_arg(ap,type) (ap += (sizeof(type)+3)&~3, *(type *)(ap - ((sizeof(type)+3)&~3)))
#define va_copy(dest, src) (dest) = (src)
#define va_end(ap)
#endif

/* fix a buggy dependency on GCC in libio.h */
typedef va_list __gnuc_va_list;
#define _VA_LIST_DEFINED

#endif
#endif

#endif

#endif


#ifndef SEEK_SET
#define SEEK_SET        0       /* seek relative to beginning of file */
#define SEEK_CUR        1       /* seek relative to current file position */
#define SEEK_END        2       /* seek relative to end of file */
#define SEEK_MAX        SEEK_END
#endif


#ifdef mini_buf
#ifndef mini_fstream
#define mini_fstream
#endif
#endif


//+header stdio.h
//+include
//+after read close

//+doc This does nothing, since minilib doesn't provide buffered streams yet.
//+doc in order to sync the stream, please use fsync
//+inline
static inline int __attribute__((always_inline)) fflush( FILE *F ){
		return(0);
}



#ifndef mini_fstream

//+doc Return the fd nummber of stdin,-out,-err. 
// this is a boilerplate, in case, no minibuf and no streams are compiled.
//+inline
static inline int __attribute__((always_inline)) fileno( FILE *F ){
		if ( F==stdin )
				return ( 0 );
		if ( F==stdout )
				return(1);
		if ( F==stderr )
	  		return(2);
		exit(-1);
		return(-1);
}

#else

int snprintf( char *buf, size_t size, const char *fmt, ... );

//+doc Return the fd nummber of stdin,-out,-err. 
//+inline
static inline int __attribute__((always_inline)) fileno( FILE *f ){
		return( *f & FD_MASK );
}

////+macro
//#define fileno(stream) ({union ful { FILE *F; int i, fd;};ful.F=stream;ful.fd;})


//+depends close
//+inline
static inline int __attribute__((always_inline)) fclose( FILE* f ){
		int fd = fileno(f);
		*f = -1;
		// empty garbage; go back to first closed stream
		if ( f[1] == ml.stream[ml.pstream] )
				for ( ml.pstream--; ml.stream[ml.pstream-1] == -1; ml.pstream-- ); 

		return( close(fd) );
}

#if 0
#ifndef fprintf
#ifndef mini_sprintf
#define mini_sprintf

///+depends dprintf fileno sprintf
///+def
//#define fprintf(stream,...)  dprintf(fileno(stream),__VA_ARGS__)

#endif
#endif 

#endif

//+depends fprintf fileno
//+macro
#define printf(...) fprintf(stdout,__VA_ARGS__)

//+depends fprintf fileno
//+macro
#define fprint(...) fprintf(__VA_ARGS__)


//+depends fprintf
//+macro
#define vfprintf(...) fprintf(__VA_ARGS__)



//+depends write
//+inline
static inline size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *f){
		const void *p = ptr;
		int a;
		for ( a = 0; a<nmemb; a++ ){
				if ( write( fileno(f), p, size ) != size ){
						*f = *f | ERR_FLAG;
						return(a);
				}
				p = p + size;
		}
		return(a);
}

//+depends lseek
//+inline
static inline long ftell(FILE *f){
	 	return(lseek( fileno(f), 0, SEEK_CUR ));
}

//+depends ftell
//+inline
static inline void fgetpos(FILE *f, long *pos ){
	 	*pos = ftell(f);
}

//+depends lseek
//+inline
static inline int fsetpos(FILE *f, int pos ){
	 	int r = lseek( fileno(f), pos, SEEK_SET );
		if ( r==pos ){ //
				*f = *f & FD_MASK; // unset feof
				return(r);
		}
		return(r); // todo set errno 
}



//+depends lseek
//+inline
static inline int fseek(FILE *f, long offset, int whence ){
	 	int r = lseek( fileno(f), offset, whence );
		if ( r>0 )
				*f = *f & FD_MASK; // clear feof
		return(r);
}


//+depends fseek
//+inline
static inline void rewind( FILE *f ){
		fseek(f, 0, SEEK_SET);
}

//+depends read
//+inline
static inline size_t fread(void *ptr, size_t size, size_t nmemb, FILE *f){
		void *p = ptr;
		int a;
		for ( a = 0; a<nmemb; a++ ){
				if ( read( fileno(f), p, size ) != size ){
						*f = *f | FEOF_FLAG ; // set feof. Could also have been another error.
						return(a);
				}
				p = p + size;
		}
		return(a);
}

//todo: case eagain


///+depends _fread
///+macro
//#define fread(ptr,size,nmemb,f) ((_fread(ptr,size,nmemb,f)==nmemb) ? nmemb : ((int)(f=((int)f|FEOF_FLAG))&0x3fffffff))
	

//+inline
static inline int feof(FILE *f){
		if ( *f & FLAG_MASK )
				return(1);
		return(0);
}

//+inline
static inline int ferror(FILE *f){
		if ( *f & FLAG_MASK )
				return(1);
		return(0);
}

//+inline
static inline void clearerror(FILE *f){
		*f = *f & FD_MASK;
}


//+doc dummy functions.
// There is no buffering implemented for the streams yet.
//+def
static void setbuf(FILE *stream, char *buf){
}

//+doc dummy
//+def
static int setvbuf(FILE *stream, char *buf, int mode, size_t size){
		return(0);
}




// ifdef mini_fstream
#endif 


#endif
#ifndef fgetc_h
#define fgetc_h




//+header stdio.h
//+depends fileno read
//+needs mini_fstream.h
//+inline
static inline int fgetc(FILE *F){
		POINTER buf = 0;
#ifdef mini_ungetc
		if ( *F >> 24 ){
				int r =  *F >> 24;
				*F =  *F & (~UNGETC_MASK);
				return(r);
		}
#endif
		read(fileno(F), &buf, 1 );
		return((int)buf);
}


//+depends fgetc fileno read
//+macro getc(F) fgetc(F)

//+depends fgetc fileno read
//+macro getchar() fgetc(0)

// pushes a char back to the stream.
// overwrites a previous backupushed char
// (according to posix, only one char is guaranteed 
// to be pushed back)
//+def
static int ungetc(int c, FILE *F){
		*F = (*F & ~UNGETC_MASK) | (c<<24);
		return(c);
}		


#endif
#endif

// minilib/include/mini_fstream.h
#ifdef mini_fileno
#ifndef mini_fstream_h
#define mini_fstream_h


#ifndef SEEK_SET
#define SEEK_SET        0       /* seek relative to beginning of file */
#define SEEK_CUR        1       /* seek relative to current file position */
#define SEEK_END        2       /* seek relative to end of file */
#define SEEK_MAX        SEEK_END
#endif


#ifdef mini_buf
#ifndef mini_fstream
#define mini_fstream
#endif
#endif


//+header stdio.h
//+include
//+after read close

//+doc This does nothing, since minilib doesn't provide buffered streams yet.
//+doc in order to sync the stream, please use fsync
//+inline
static inline int __attribute__((always_inline)) fflush( FILE *F ){
		return(0);
}



#ifndef mini_fstream

//+doc Return the fd nummber of stdin,-out,-err. 
// this is a boilerplate, in case, no minibuf and no streams are compiled.
//+inline
static inline int __attribute__((always_inline)) fileno( FILE *F ){
		if ( F==stdin )
				return ( 0 );
		if ( F==stdout )
				return(1);
		if ( F==stderr )
	  		return(2);
		exit(-1);
		return(-1);
}

#else

int snprintf( char *buf, size_t size, const char *fmt, ... );

//+doc Return the fd nummber of stdin,-out,-err. 
//+inline
static inline int __attribute__((always_inline)) fileno( FILE *f ){
		return( *f & FD_MASK );
}

////+macro
//#define fileno(stream) ({union ful { FILE *F; int i, fd;};ful.F=stream;ful.fd;})


//+depends close
//+inline
static inline int __attribute__((always_inline)) fclose( FILE* f ){
		int fd = fileno(f);
		*f = -1;
		// empty garbage; go back to first closed stream
		if ( f[1] == ml.stream[ml.pstream] )
				for ( ml.pstream--; ml.stream[ml.pstream-1] == -1; ml.pstream-- ); 

		return( close(fd) );
}

#if 0
#ifndef fprintf
#ifndef mini_sprintf
#define mini_sprintf

///+depends dprintf fileno sprintf
///+def
//#define fprintf(stream,...)  dprintf(fileno(stream),__VA_ARGS__)

#endif
#endif 

#endif

//+depends fprintf fileno
//+macro
#define printf(...) fprintf(stdout,__VA_ARGS__)

//+depends fprintf fileno
//+macro
#define fprint(...) fprintf(__VA_ARGS__)


//+depends fprintf
//+macro
#define vfprintf(...) fprintf(__VA_ARGS__)



//+depends write
//+inline
static inline size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *f){
		const void *p = ptr;
		int a;
		for ( a = 0; a<nmemb; a++ ){
				if ( write( fileno(f), p, size ) != size ){
						*f = *f | ERR_FLAG;
						return(a);
				}
				p = p + size;
		}
		return(a);
}

//+depends lseek
//+inline
static inline long ftell(FILE *f){
	 	return(lseek( fileno(f), 0, SEEK_CUR ));
}

//+depends ftell
//+inline
static inline void fgetpos(FILE *f, long *pos ){
	 	*pos = ftell(f);
}

//+depends lseek
//+inline
static inline int fsetpos(FILE *f, int pos ){
	 	int r = lseek( fileno(f), pos, SEEK_SET );
		if ( r==pos ){ //
				*f = *f & FD_MASK; // unset feof
				return(r);
		}
		return(r); // todo set errno 
}



//+depends lseek
//+inline
static inline int fseek(FILE *f, long offset, int whence ){
	 	int r = lseek( fileno(f), offset, whence );
		if ( r>0 )
				*f = *f & FD_MASK; // clear feof
		return(r);
}


//+depends fseek
//+inline
static inline void rewind( FILE *f ){
		fseek(f, 0, SEEK_SET);
}

//+depends read
//+inline
static inline size_t fread(void *ptr, size_t size, size_t nmemb, FILE *f){
		void *p = ptr;
		int a;
		for ( a = 0; a<nmemb; a++ ){
				if ( read( fileno(f), p, size ) != size ){
						*f = *f | FEOF_FLAG ; // set feof. Could also have been another error.
						return(a);
				}
				p = p + size;
		}
		return(a);
}

//todo: case eagain


///+depends _fread
///+macro
//#define fread(ptr,size,nmemb,f) ((_fread(ptr,size,nmemb,f)==nmemb) ? nmemb : ((int)(f=((int)f|FEOF_FLAG))&0x3fffffff))
	

//+inline
static inline int feof(FILE *f){
		if ( *f & FLAG_MASK )
				return(1);
		return(0);
}

//+inline
static inline int ferror(FILE *f){
		if ( *f & FLAG_MASK )
				return(1);
		return(0);
}

//+inline
static inline void clearerror(FILE *f){
		*f = *f & FD_MASK;
}


//+doc dummy functions.
// There is no buffering implemented for the streams yet.
//+def
static void setbuf(FILE *stream, char *buf){
}

//+doc dummy
//+def
static int setvbuf(FILE *stream, char *buf, int mode, size_t size){
		return(0);
}




// ifdef mini_fstream
#endif 


#endif
#endif

// minilib/include/mini_fstream.h
#ifdef mini_fseek
#endif

// minilib/include/tcgetattr.h
#ifdef mini_tcgetattr
#ifndef tcgetattr_h
#define tcgetattr_h

//#include <sys/termios.h>
//#include "ioctl.h"
//#include <sys/ttycom.h>

//#ifndef TCGETS
//#warning TCGETS not defined. Applying ugly hack.
//#define TCGETS TIOCGETA
//#endif

//+header unistd.h
//+include
///+needs sys/ttycom.h
//+depends ioctl
//+def
static inline int __attribute__((always_inline)) tcgetattr(int fd, struct termios *io){
	//return(ioctl(fd, 0x5401, io));
	return(ioctl(fd, TCGETS, io));

}



#endif
#endif

// minilib/src/memcpy.c
#ifdef mini_strcpy
char *strcpy(char *dest, const char *src);
#endif

// minilib/src/fgets.c
#ifdef mini_fgets
char* fgets(char *buf, int size, FILE* F);
#endif

// minilib/src/itobin.c
#ifdef mini__itobin
int _itobin(int i, char*buf, int prec, int groups );
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_close
#endif

// minilib/src/itohex.c
#ifdef mini__itohex
int _itohex(int i,char* buf,int padding, int capitals);
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_read
#endif

// minilib/src/malloc.c
#ifdef mini_free
void volatile free(void* p);
#endif

// 
#ifdef mini_0
#endif

// minilib/src/strcmp.c
#ifdef mini__strcmp
int _strcmp(const char*c1,const char*c2,int len);
#endif

// 
#ifdef mini_dprints
#endif

// minilib/src/strerror.c
#ifdef mini_strerror
char* strerror( int errnum );
#endif

// minilib/src/sprintf.c
#ifdef mini_vsnprintf
int vsnprintf(char *buf, size_t size, const char* fmt, va_list args );
#endif

// 
#ifdef mini_tolower
#endif

// minilib/include/mini_fstream.h
#ifdef mini_ftell
#endif

// minilib/src/sprintf.c
#ifdef mini_dprintf
int dprintf( int fd, const char *fmt, ... );
#endif

// minilib/src/malloc.c
#ifdef mini_malloc
void* volatile malloc(int size);
#endif

// minilib/src/sprintf.c
#ifdef mini_fprintf
#define fprintf(stream,...)	write(fileno(stream),ml.mbuf,sprintf(ml.mbuf,__VA_ARGS__))
#endif

// minilib/src/strlen.c
#ifdef mini_strlen
int strlen(const char*str);
#endif

// minilib/src/fopen.c
#ifdef mini__fopen
FILE *_fopen(int fd, const char* filename, const char* mode, FILE *f);
#endif

// minilib/include/fputc.h
#ifdef mini_fputc
#ifndef fputc_c
#define fputc_c

//#include "write.h"

//+header stdio.h
//+depends fileno write
//+needs mini_fstream.h
//+def
static inline int volatile fputc(int c, FILE* F){
		write(fileno(F), &c, 1);
		return(c);
}

//+depends fputc
//+macro  putchar(c) fputc(c,stdout)

//+depends fputc
//+macro  putc(c,stream) fputc(c,stream)


#endif
#endif

// minilib/include/prints.h
#ifdef mini_printl
#define printl() write(STDOUT_FILENO,"\n",1)
#endif

// minilib/src/ioctl.c
#ifdef mini_ioctl
int ioctl( int fd, unsigned long int request, ... );
#endif

// minilib/include/fputs.h
#ifdef mini_fputs
#ifndef fputs_h
#define fputs_h

//#include "write.h"


//+header stdio.h
//+needs mini_fstream.h
//+include

int strlen(const char*str);
// after doesnt ork here. inline. so here's the predef.
// need to rethink the dependency build process
static int fileno(FILE*);

//+depends strlen fileno write
//+needs mini_fstream.h
//+after fileno
//+inline
static inline int volatile fputs(const char *c, FILE *F){
		return(write(fileno(F), c, strlen(c)));
}



#endif
#endif

// minilib/src/strcmp.c
#ifdef mini__strcasecmp
int _strcasecmp(const char*c1,const char*c2,int len);
#endif

// minilib/include/prints.h
#ifdef mini_prints
#define prints(...) _mprints(__VA_ARGS__,0)
#endif

// minilib/src/sprintf.c
#ifdef mini_sprintf
#define sprintf(str,...) snprintf( str, 4096,  __VA_ARGS__)
#endif

// minilib/include/lseek.h
#ifdef mini_lseek
#ifndef mini_lseek_h
#define mini_lseek_h

//+header unistd.h
//+inc

//#include "syscall.h"
#ifndef SEEK_SET
#define SEEK_SET        0       /* seek relative to beginning of file */
#define SEEK_CUR        1       /* seek relative to current file position */
#define SEEK_END        2       /* seek relative to end of file */
#define SEEK_MAX        SEEK_END
#endif

extern int sysret;
extern int errno;

DEF_syscall(lseek,3,unsigned int a1, int a2, int a3 )

DEF_syscall(ftruncate,2,unsigned int a1, unsigned int a2 )
DEF_syscall(fsync,1,int a1 )




#endif

#endif

// minilib/src/itodec.c
#ifdef mini_itodec
int itodec(int i, char *buf, int prec, char limiter );
#endif

// minilib/src/pty.c
#ifdef mini_ptsname_r
int ptsname_r(int fd, char *buf, size_t len);
#endif

// minilib/src/itodec.c
#ifdef mini_uitodec
int uitodec(unsigned int i, char *buf, int prec, char limiter );
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_write
#endif

// minilib/src/sprintf.c
#ifdef mini_snprintf
int snprintf( char *buf, size_t size, const char *fmt, ... );
#endif

// minilib/src/memcpy.c
#ifdef mini_memcpy
void *memcpy( void *d, const void *s, int n );
#endif

// minilib/src/open.c
#ifdef mini_open
int volatile open( const char *s, int flags, ... );
#endif

// minilib/include/prints.h
#ifdef mini_print
#define print(str) write(STDOUT_FILENO,str,strlen(str))
#endif

// minilib/src/sigaction.c
#ifdef mini_sigaction
static int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_wait4
#endif

// minilib/src/prints.c
#ifdef mini__mprints
#define _mprints(...) dprints(STDOUT_FILENO, __VA_ARGS__)
#endif
// End incfirst

// minilib/include/syscalls_x64.h
#ifdef mini__renameat2
#ifndef syscalls_x64_h

#define syscalls_x64_h


SYSDEF_syscall(_read,3, unsigned int fd,  char *buf,  size_t count)

SYSDEF_syscall(_write,3, unsigned int fd,  const char *buf,  size_t count)

SYSDEF_syscall(_open,3, const char *filename,  int flags,  int mode)

SYSDEF_syscall(_close,1, unsigned int fd)

SYSDEF_syscall(_stat,2, const char *filename,  struct stat *statbuf)

SYSDEF_syscall(_fstat,2, unsigned int fd,  struct stat *statbuf)

SYSDEF_syscall(_lstat,2, const char *filename,  struct stat *statbuf)

SYSDEF_syscall(_poll,3, struct poll_fd *ufds,  unsigned int nfds,  long timeout_msecs)

SYSDEF_syscall(_lseek,3, unsigned int fd,  off_t offset,  unsigned int origin)

SYSDEF_syscall(_mmap,6, unsigned long addr,  unsigned long len,  unsigned long prot,  unsigned long flags,  unsigned long fd,  unsigned long off)

SYSDEF_syscall(_mprotect,3, unsigned long start,  size_t len,  unsigned long prot)

SYSDEF_syscall(_munmap,2, unsigned long addr,  size_t len)

SYSDEF_syscall(_brk,1, unsigned long brk)

SYSDEF_syscall(_rt_sigaction,4, int sig,  const struct sigaction *act,  struct sigaction *oact,  size_t sigsetsize)

SYSDEF_syscall(_rt_sigprocmask,4, int how,  sigset_t *nset,  sigset_t *oset,  size_t sigsetsize)

SYSDEF_syscall(_rt_sigreturn,1, unsigned long __unused)

SYSDEF_syscall(_ioctl,3, unsigned int fd,  unsigned int cmd,  unsigned long arg)

SYSDEF_syscall(_pread64,4, unsigned long fd,  char *buf,  size_t count,  loff_t pos)

SYSDEF_syscall(_pwrite64,4, unsigned int fd,  const char *buf,  size_t count,  loff_t pos)

SYSDEF_syscall(_readv,3, unsigned long fd,  const struct iovec *vec,  unsigned long vlen)

SYSDEF_syscall(_writev,3, unsigned long fd,  const struct iovec *vec,  unsigned long vlen)

SYSDEF_syscall(_access,2, const char *filename,  int mode)

SYSDEF_syscall(_pipe,1, int *filedes)

SYSDEF_syscall(_select,5, int n,  fd_set *inp,  fd_set *outp,  fd_set *exp,  struct timeval *tvp)

SYSDEF_syscall(_sched_yield,0)

SYSDEF_syscall(_mremap,5, unsigned long addr,  unsigned long old_len,  unsigned long new_len,  unsigned long flags,  unsigned long new_addr)

SYSDEF_syscall(_msync,3, unsigned long start,  size_t len,  int flags)

SYSDEF_syscall(_mincore,3, unsigned long start,  size_t len,  unsigned char *vec)

SYSDEF_syscall(_madvise,3, unsigned long start,  size_t len_in,  int behavior)

SYSDEF_syscall(_shmget,3, key_t key,  size_t size,  int shmflg)

SYSDEF_syscall(_shmat,3, int shmid,  char *shmaddr,  int shmflg)

SYSDEF_syscall(_shmctl,3, int shmid,  int cmd,  struct shmid_ds *buf)

SYSDEF_syscall(_dup,1, unsigned int fildes)

SYSDEF_syscall(_dup2,2, unsigned int oldfd,  unsigned int newfd)

SYSDEF_syscall(_pause,0)

SYSDEF_syscall(_nanosleep,2, struct timespec *rqtp,  struct timespec *rmtp)

SYSDEF_syscall(_getitimer,2, int which,  struct itimerval *value)

SYSDEF_syscall(_alarm,1, unsigned int seconds)

SYSDEF_syscall(_setitimer,3, int which,  struct itimerval *value,  struct itimerval *ovalue)

SYSDEF_syscall(_getpid,0)

SYSDEF_syscall(_sendfile,4, int out_fd,  int in_fd,  off_t *offset,  size_t count)

SYSDEF_syscall(_socket,3, int family,  int type,  int protocol)

SYSDEF_syscall(_connect,3, int fd,  struct sockaddr *uservaddr,  int addrlen)

SYSDEF_syscall(_accept,3, int fd,  struct sockaddr *upeersockaddr,  int *upeeraddrlen)

SYSDEF_syscall(_sendto,6, int fd,  void *buff,  size_t len,  unsigned flags,  struct sockaddr *addr,  int addr_len)

SYSDEF_syscall(_recvfrom,6, int fd,  void *ubuf,  size_t size,  unsigned flags,  struct sockaddr *addr,  int *addr_len)

SYSDEF_syscall(_sendmsg,3, int fd,  struct msghdr *msg,  unsigned flags)

SYSDEF_syscall(_recvmsg,3, int fd,  struct msghdr *msg,  unsigned int flags)

SYSDEF_syscall(_shutdown,2, int fd,  int how)

SYSDEF_syscall(_bind,3, int fd,  struct sockaddr *umyaddr,  int addrlen)

SYSDEF_syscall(_listen,2, int fd,  int backlog)

SYSDEF_syscall(_getsockname,3, int fd,  struct sockaddr *usockaddr,  int *usockaddr_len)

SYSDEF_syscall(_getpeername,3, int fd,  struct sockaddr *usockaddr,  int *usockaddr_len)

SYSDEF_syscall(_socketpair,4, int family,  int type,  int protocol,  int *usockvec)

SYSDEF_syscall(_setsockopt,5, int fd,  int level,  int optname,  char *optval,  int optlen)

SYSDEF_syscall(_getsockopt,5, int fd,  int level,  int optname,  char *optval,  int *optlen)

SYSDEF_syscall(_clone,4, unsigned long clone_flags,  unsigned long newsp,  void *parent_tid,  void *child_tid)

SYSDEF_syscall(_fork,0)

SYSDEF_syscall(_vfork,0)

SYSDEF_syscall(_execve,3, const char *filename,  const char *const argv[],  const char *const envp[])

SYSDEF_syscall(_exit,1, int error_code)

SYSDEF_syscall(_wait4,4, pid_t upid,  int *stat_addr,  int options,  struct rusage *ru)

SYSDEF_syscall(_kill,2, pid_t pid,  int sig)

SYSDEF_syscall(_uname,1, struct old_utsname *name)

SYSDEF_syscall(_semget,3, key_t key,  int nsems,  int semflg)

SYSDEF_syscall(_semop,3, int semid,  struct sembuf *tsops,  unsigned nsops)

SYSDEF_syscall(_semctl,4, int semid,  int semnum,  int cmd,  semun_u arg)

SYSDEF_syscall(_shmdt,1, char *shmaddr)

SYSDEF_syscall(_msgget,2, key_t key,  int msgflg)

SYSDEF_syscall(_msgsnd,4, int msqid,  struct msgbuf *msgp,  size_t msgsz,  int msgflg)

SYSDEF_syscall(_msgrcv,5, int msqid,  struct msgbuf *msgp,  size_t msgsz,  long msgtyp,  int msgflg)

SYSDEF_syscall(_msgctl,3, int msqid,  int cmd,  struct msqid_ds *buf)

SYSDEF_syscall(_fcntl,3, unsigned int fd,  unsigned int cmd,  unsigned long arg)

SYSDEF_syscall(_flock,2, unsigned int fd,  unsigned int cmd)

SYSDEF_syscall(_fsync,1, unsigned int fd)

SYSDEF_syscall(_fdatasync,1, unsigned int fd)

SYSDEF_syscall(_truncate,2, const char *path,  long length)

SYSDEF_syscall(_ftruncate,2, unsigned int fd,  unsigned long length)

SYSDEF_syscall(_getdents,3, unsigned int fd,  struct linux_dirent *dirent,  unsigned int count)

SYSDEF_syscall(_getcwd,2, char *buf,  unsigned long size)

SYSDEF_syscall(_chdir,1, const char *filename)

SYSDEF_syscall(_fchdir,1, unsigned int fd)

SYSDEF_syscall(_rename,2, const char *oldname,  const char *newname)

SYSDEF_syscall(_mkdir,2, const char *pathname,  int mode)

SYSDEF_syscall(_rmdir,1, const char *pathname)

SYSDEF_syscall(_creat,2, const char *pathname,  int mode)

SYSDEF_syscall(_link,2, const char *oldname,  const char *newname)

SYSDEF_syscall(_unlink,1, const char *pathname)

SYSDEF_syscall(_symlink,2, const char *oldname,  const char *newname)

SYSDEF_syscall(_readlink,3, const char *path,  char *buf,  int bufsiz)

SYSDEF_syscall(_chmod,2, const char *filename,  mode_t mode)

SYSDEF_syscall(_fchmod,2, unsigned int fd,  mode_t mode)

SYSDEF_syscall(_chown,3, const char *filename,  uid_t user,  gid_t group)

SYSDEF_syscall(_fchown,3, unsigned int fd,  uid_t user,  gid_t group)

SYSDEF_syscall(_lchown,3, const char *filename,  uid_t user,  gid_t group)

SYSDEF_syscall(_umask,1, int mask)

SYSDEF_syscall(_gettimeofday,2, struct timeval *tv,  struct timezone *tz)

SYSDEF_syscall(_getrlimit,2, unsigned int resource,  struct rlimit *rlim)

SYSDEF_syscall(_getrusage,2, int who,  struct rusage *ru)

SYSDEF_syscall(_sysinfo,1, struct sysinfo *info)

SYSDEF_syscall(_times,1, struct sysinfo *info)

SYSDEF_syscall(_ptrace,4, long request,  long pid,  unsigned long addr,  unsigned long data)

SYSDEF_syscall(_getuid,0)

SYSDEF_syscall(_syslog,3, int type,  char *buf,  int len)

SYSDEF_syscall(_getgid,0)

SYSDEF_syscall(_setuid,1, uid_t uid)

SYSDEF_syscall(_setgid,1, gid_t gid)

SYSDEF_syscall(_geteuid,0)

SYSDEF_syscall(_getegid,0)

SYSDEF_syscall(_setpgid,2, pid_t pid,  pid_t pgid)

SYSDEF_syscall(_getppid,0)

SYSDEF_syscall(_getpgrp,0)

SYSDEF_syscall(_setsid,0)

SYSDEF_syscall(_setreuid,2, uid_t ruid,  uid_t euid)

SYSDEF_syscall(_setregid,2, gid_t rgid,  gid_t egid)

SYSDEF_syscall(_getgroups,2, int gidsetsize,  gid_t *grouplist)

SYSDEF_syscall(_setgroups,2, int gidsetsize,  gid_t *grouplist)

SYSDEF_syscall(_setresuid,3, uid_t *ruid,  uid_t *euid,  uid_t *suid)

SYSDEF_syscall(_getresuid,3, uid_t *ruid,  uid_t *euid,  uid_t *suid)

SYSDEF_syscall(_setresgid,3, gid_t rgid,  gid_t egid,  gid_t sgid)

SYSDEF_syscall(_getresgid,3, gid_t *rgid,  gid_t *egid,  gid_t *sgid)

SYSDEF_syscall(_getpgid,1, pid_t pid)

SYSDEF_syscall(_setfsuid,1, uid_t uid)

SYSDEF_syscall(_setfsgid,1, gid_t gid)

SYSDEF_syscall(_getsid,1, pid_t pid)

SYSDEF_syscall(_capget,2, cap_user_header_t header,  cap_user_data_t dataptr)

SYSDEF_syscall(_capset,2, cap_user_header_t header,  const cap_user_data_t data)

SYSDEF_syscall(_rt_sigpending,2, sigset_t *set,  size_t sigsetsize)

SYSDEF_syscall(_rt_sigtimedwait,4, const sigset_t *uthese,  siginfo_t *uinfo,  const struct timespec *uts,  size_t sigsetsize)

SYSDEF_syscall(_rt_sigqueueinfo,3, pid_t pid,  int sig,  siginfo_t *uinfo)

SYSDEF_syscall(_rt_sigsuspend,2, sigset_t *unewset,  size_t sigsetsize)

SYSDEF_syscall(_sigaltstack,2, const stack_t *uss,  stack_t *uoss)

SYSDEF_syscall(_utime,2, char *filename,  struct utimbuf *times)

SYSDEF_syscall(_mknod,3, const char *filename,  umode_t mode,  unsigned dev)

SYSDEF_syscall(_personality,1, unsigned int personality)

SYSDEF_syscall(_ustat,2, unsigned dev,  struct ustat *ubuf)

SYSDEF_syscall(_statfs,2, const char *pathname,  struct statfs *buf)

SYSDEF_syscall(_fstatfs,2, unsigned int fd,  struct statfs *buf)

SYSDEF_syscall(_sysfs,3, int option,  unsigned long arg1,  unsigned long arg2)

SYSDEF_syscall(_getpriority,2, int which,  int who)

SYSDEF_syscall(_setpriority,3, int which,  int who,  int niceval)

SYSDEF_syscall(_sched_setparam,2, pid_t pid,  struct sched_param *param)

SYSDEF_syscall(_sched_getparam,2, pid_t pid,  struct sched_param *param)

SYSDEF_syscall(_sched_setscheduler,3, pid_t pid,  int policy,  struct sched_param *param)

SYSDEF_syscall(_sched_getscheduler,1, pid_t pid)

SYSDEF_syscall(_sched_get_priority_max,1, int policy)

SYSDEF_syscall(_sched_get_priority_min,1, int policy)

SYSDEF_syscall(_sched_rr_get_interval,2, pid_t pid,  struct timespec *interval)

SYSDEF_syscall(_mlock,2, unsigned long start,  size_t len)

SYSDEF_syscall(_munlock,2, unsigned long start,  size_t len)

SYSDEF_syscall(_mlockall,1, int flags)

SYSDEF_syscall(_munlockall,0)

SYSDEF_syscall(_vhangup,0)

SYSDEF_syscall(_modify_ldt,3, int func,  void *ptr,  unsigned long bytecount)

SYSDEF_syscall(_pivot_root,2, const char *new_root,  const char *put_old)

SYSDEF_syscall(__sysctl,1, struct __sysctl_args *args)

SYSDEF_syscall(_prctl,5, int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)

SYSDEF_syscall(_arch_prctl,3, struct task_struct *task,  int code,  unsigned long *addr)

SYSDEF_syscall(_adjtimex,1, struct timex *txc_p)

SYSDEF_syscall(_setrlimit,2, unsigned int resource,  struct rlimit *rlim)

SYSDEF_syscall(_chroot,1, const char *filename)

SYSDEF_syscall(_sync,0)

SYSDEF_syscall(_acct,1, const char *name)

SYSDEF_syscall(_settimeofday,2, struct timeval *tv,  struct timezone *tz)

SYSDEF_syscall(_mount,5, char *dev_name,  char *dir_name,  char *type,  unsigned long flags,  void *data)

SYSDEF_syscall(_umount2,2, const char *target,  int flags)

SYSDEF_syscall(_swapon,2, const char *specialfile,  int swap_flags)

SYSDEF_syscall(_swapoff,1, const char *specialfile)

SYSDEF_syscall(_reboot,4, int magic1,  int magic2,  unsigned int cmd,  void *arg)

SYSDEF_syscall(_sethostname,2, char *name,  int len)

SYSDEF_syscall(_setdomainname,2, char *name,  int len)

SYSDEF_syscall(_iopl,2, unsigned int level,  struct pt_regs *regs)

SYSDEF_syscall(_ioperm,3, unsigned long from,  unsigned long num,  int turn_on)

SYSDEF_syscall(_init_module,3, void *umod,  unsigned long len,  const char *uargs)

SYSDEF_syscall(_delete_module,2, const char *name_user,  unsigned int flags)

SYSDEF_syscall(_quotactl,4, unsigned int cmd,  const char *special,  qid_t id,  void *addr)

SYSDEF_syscall(_gettid,0)

SYSDEF_syscall(_readahead,3, int fd,  loff_t offset,  size_t count)

SYSDEF_syscall(_setxattr,5, const char *pathname,  const char *name,  const void *value, size_t size,  int flags)

SYSDEF_syscall(_lsetxattr,5, const char *pathname,  const char *name,  const void *value, size_t size,  int flags)

SYSDEF_syscall(_fsetxattr,5, int fd,  const char *name,  const void *value,  size_t size, int flags)

SYSDEF_syscall(_getxattr,4, const char *pathname,  const char *name,  void *value,  size_t size)

SYSDEF_syscall(_lgetxattr,4, const char *pathname,  const char *name,  void *value,  size_t size)

SYSDEF_syscall(_fgetxattr,4, int fd,  const char *name,  void *value,  size_t size)

SYSDEF_syscall(_listxattr,3, const char *pathname,  char *list,  size_t size)

SYSDEF_syscall(_llistxattr,3, const char *pathname,  char *list,  size_t size)

SYSDEF_syscall(_flistxattr,3, int fd,  char *list,  size_t size)

SYSDEF_syscall(_removexattr,2, const char *pathname,  const char *name)

SYSDEF_syscall(_lremovexattr,2, const char *pathname,  const char *name)

SYSDEF_syscall(_fremovexattr,2, int fd,  const char *name)

SYSDEF_syscall(_tkill,2, pid_t pid,  int sig)

SYSDEF_syscall(_time,1, time_t *tloc)

SYSDEF_syscall(_futex,6, u32 *uaddr,  int op,  u32 val,  struct timespec *utime,  u32 *uaddr2,  u32 val3)

SYSDEF_syscall(_sched_setaffinity,3, pid_t pid,  unsigned int len,  unsigned long *user_mask_ptr)

SYSDEF_syscall(_sched_getaffinity,3, pid_t pid,  unsigned int len,  unsigned long *user_mask_ptr)

SYSDEF_syscall(_io_setup,2, unsigned nr_events,  aio_context_t *ctxp)

SYSDEF_syscall(_io_destroy,1, aio_context_t ctx)

SYSDEF_syscall(_io_getevents,4, aio_context_t ctx_id,  long min_nr,  long nr,  struct io_event *events)

SYSDEF_syscall(_io_submit,3, aio_context_t ctx_id,  long nr,  struct iocb **iocbpp)

SYSDEF_syscall(_io_cancel,3, aio_context_t ctx_id,  struct iocb *iocb,  struct io_event *result)

SYSDEF_syscall(_lookup_dcookie,3, u64 cookie64,  long buf,  long len)

SYSDEF_syscall(_epoll_create,1, int size)

SYSDEF_syscall(_remap_file_pages,5, unsigned long start,  unsigned long size,  unsigned long prot,  unsigned long pgoff,  unsigned long flags)

SYSDEF_syscall(_getdents64,3, unsigned int fd,  struct linux_dirent64 *dirent,  unsigned int count)

SYSDEF_syscall(_set_tid_address,1, int *tidptr)

SYSDEF_syscall(_restart_syscall,0)

SYSDEF_syscall(_semtimedop,4, int semid,  struct sembuf *tsops,  unsigned nsops,  const struct timespec *timeout)

SYSDEF_syscall(_fadvise64,4, int fd,  loff_t offset,  size_t len,  int advice)

SYSDEF_syscall(_timer_create,3, const clockid_t which_clock,  struct sigevent *timer_event_spec,  timer_t *created_timer_id)

SYSDEF_syscall(_timer_settime,4, timer_t timer_id,  int flags,  const struct itimerspec *new_setting,  struct itimerspec *old_setting)

SYSDEF_syscall(_timer_gettime,2, timer_t timer_id,  struct itimerspec *setting)

SYSDEF_syscall(_timer_getoverrun,1, timer_t timer_id)

SYSDEF_syscall(_timer_delete,1, timer_t timer_id)

SYSDEF_syscall(_clock_settime,2, const clockid_t which_clock,  const struct timespec *tp)

SYSDEF_syscall(_clock_gettime,2, const clockid_t which_clock,  struct timespec *tp)

SYSDEF_syscall(_clock_getres,2, const clockid_t which_clock,  struct timespec *tp)

SYSDEF_syscall(_clock_nanosleep,4, const clockid_t which_clock,  int flags,  const struct timespec *rqtp,  struct timespec *rmtp)

SYSDEF_syscall(_exit_group,1, int error_code)

SYSDEF_syscall(_epoll_wait,4, int epfd,  struct epoll_event *events,  int maxevents,  int timeout)

SYSDEF_syscall(_epoll_ctl,4, int epfd,  int op,  int fd,  struct epoll_event *event)

SYSDEF_syscall(_tgkill,3, pid_t tgid,  pid_t pid,  int sig)

SYSDEF_syscall(_utimes,2, char *filename,  struct timeval *utimes)

SYSDEF_syscall(_mbind,6, unsigned long start,  unsigned long len,  unsigned long mode,  unsigned long *nmask,  unsigned long maxnode,  unsigned flags)

SYSDEF_syscall(_set_mempolicy,3, int mode,  unsigned long *nmask,  unsigned long maxnode)

SYSDEF_syscall(_get_mempolicy,5, int *policy,  unsigned long *nmask,  unsigned long maxnode,  unsigned long addr,  unsigned long flags)

SYSDEF_syscall(_mq_open,4, const char *u_name,  int oflag,  mode_t mode,  struct mq_attr *u_attr)

SYSDEF_syscall(_mq_unlink,1, const char *u_name)

SYSDEF_syscall(_mq_timedsend,5, mqd_t mqdes,  const char *u_msg_ptr,  size_t msg_len,  unsigned int msg_prio,  const struct timespec *u_abs_timeout)

SYSDEF_syscall(_mq_timedreceive,5, mqd_t mqdes,  char *u_msg_ptr,  size_t msg_len,  unsigned int *u_msg_prio,  const struct timespec *u_abs_timeout)

SYSDEF_syscall(_mq_notify,2, mqd_t mqdes,  const struct sigevent *u_notification)

SYSDEF_syscall(_mq_getsetattr,3, mqd_t mqdes,  const struct mq_attr *u_mqstat,  struct mq_attr *u_omqstat)

SYSDEF_syscall(_kexec_load,4, unsigned long entry,  unsigned long nr_segments,  struct kexec_segment *segments,  unsigned long flags)

SYSDEF_syscall(_waitid,5, int which,  pid_t upid,  struct siginfo *infop,  int options,  struct rusage *ru)

SYSDEF_syscall(_add_key,4, const char *_type,  const char *_description,  const void *_payload,  size_t plen)

SYSDEF_syscall(_request_key,4, const char *_type,  const char *_description,  const char *_callout_info,  key_serial_t destringid)

SYSDEF_syscall(_keyctl,5, int option,  unsigned long arg2,  unsigned long arg3,  unsigned long arg4,  unsigned long arg5)

SYSDEF_syscall(_ioprio_set,3, int which,  int who,  int ioprio)

SYSDEF_syscall(_ioprio_get,2, int which,  int who)

SYSDEF_syscall(_inotify_init,0)

SYSDEF_syscall(_inotify_add_watch,3, int fd,  const char *pathname,  u32 mask)

SYSDEF_syscall(_inotify_rm_watch,2, int fd,  __s32 wd)

SYSDEF_syscall(_migrate_pages,4, pid_t pid,  unsigned long maxnode,  const unsigned long *old_nodes,  const unsigned long *new_nodes)

SYSDEF_syscall(_openat,4, int dfd,  const char *filename,  int flags,  int mode)

SYSDEF_syscall(_mkdirat,3, int dfd,  const char *pathname,  int mode)

SYSDEF_syscall(_mknodat,4, int dfd,  const char *filename,  int mode,  unsigned dev)

SYSDEF_syscall(_fchownat,5, int dfd,  const char *filename,  uid_t user,  gid_t group,  int flag)

SYSDEF_syscall(_futimesat,3, int dfd,  const char *filename,  struct timeval *utimes)

SYSDEF_syscall(_newfstatat,4, int dfd,  const char *filename,  struct stat *statbuf,  int flag)

SYSDEF_syscall(_unlinkat,3, int dfd,  const char *pathname,  int flag)

SYSDEF_syscall(_renameat,4, int oldfd,  const char *oldname,  int newfd,  const char *newname)

SYSDEF_syscall(_linkat,5, int oldfd,  const char *oldname,  int newfd,  const char *newname,  int flags)

SYSDEF_syscall(_symlinkat,3, const char *oldname,  int newfd,  const char *newname)

SYSDEF_syscall(_readlinkat,4, int dfd,  const char *pathname,  char *buf,  int bufsiz)

SYSDEF_syscall(_fchmodat,3, int dfd,  const char *filename,  mode_t mode)

SYSDEF_syscall(_faccessat,3, int dfd,  const char *filename,  int mode)

SYSDEF_syscall(_pselect6,6, int n,  fd_set *inp,  fd_set *outp,  fd_set *exp,  struct timespec *tsp,  void *sig)

SYSDEF_syscall(_ppoll,5, struct pollfd *ufds,  unsigned int nfds,  struct timespec *tsp,  const sigset_t *sigmask,  size_t sigsetsize)

SYSDEF_syscall(_unshare,1, unsigned long unshare_flags)

SYSDEF_syscall(_set_robust_list,2, struct robust_list_head *head,  size_t len)

SYSDEF_syscall(_get_robust_list,3, int pid,  struct robust_list_head **head_ptr,  size_t *len_ptr)

SYSDEF_syscall(_splice,6, int fd_in,  loff_t *off_in,  int fd_out,  loff_t *off_out, size_t len,  unsigned int flags)

SYSDEF_syscall(_tee,4, int fdin,  int fdout,  size_t len,  unsigned int flags)

SYSDEF_syscall(_sync_file_range,4, long fd,  loff_t offset,  loff_t bytes,  long flags)

SYSDEF_syscall(_vmsplice,4, int fd,  const struct iovec *iov,  unsigned long nr_segs, unsigned int flags)

SYSDEF_syscall(_move_pages,6, pid_t pid,  unsigned long nr_pages,  const void *pages[], const int *nodes,  int *status,  int flags)

SYSDEF_syscall(_utimensat,4, int dfd,  const char *filename,  struct timespec *utimes, int flags)

SYSDEF_syscall(_epoll_pwait,6, int epfd,  struct epoll_event *events,  int maxevents,  int timeout,  const sigset_t *sigmask,  size_t sigsetsize)

SYSDEF_syscall(_signalfd,3, int ufd,  sigset_t *user_mask,  size_t sizemask)

SYSDEF_syscall(_timerfd_create,2, int clockid,  int flags)

SYSDEF_syscall(_eventfd,1, unsigned int count)

SYSDEF_syscall(_fallocate,4, long fd,  long mode,  loff_t offset,  loff_t len)

SYSDEF_syscall(_timerfd_settime,4, int ufd,  int flags,  const struct itimerspec *utmr,  struct itimerspec *otmr)

SYSDEF_syscall(_timerfd_gettime,2, int ufd,  struct itimerspec *otmr)

SYSDEF_syscall(_accept4,4, int fd,  struct sockaddr *upeer_sockaddr,  int *upeer_addrlen,  int flags)

SYSDEF_syscall(_signalfd4,4, int ufd,  sigset_t *user_mask,  size_t sizemask,  int flags)

SYSDEF_syscall(_eventfd2,2, unsigned int count,  int flags)

SYSDEF_syscall(_epoll_create1,1, int flags)

SYSDEF_syscall(_dup3,3, unsigned int oldfd,  unsigned int newfd,  int flags)

SYSDEF_syscall(_pipe2,2, int *filedes,  int flags)

SYSDEF_syscall(_inotify_init1,1, int flags)

SYSDEF_syscall(_preadv,5, unsigned long fd,  const struct iovec *vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)

SYSDEF_syscall(_pwritev,5, unsigned long fd,  const struct iovec *vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)

SYSDEF_syscall(_rt_tgsigqueueinfo,4, pid_t tgid,  pid_t pid,  int sig,  siginfo_t *uinfo)

SYSDEF_syscall(_perf_event_open,5, struct perf_event_attr *attr_uptr,  pid_t pid,  int cpu,  int group_fd,  unsigned long flags)

SYSDEF_syscall(_recvmmsg,5, int fd,  struct msghdr *mmsg,  unsigned int vlen,  unsigned int flags,  struct timespec *timeout)

SYSDEF_syscall(_fanotify_init,2, unsigned int flags,  unsigned int event_f_flags)

SYSDEF_syscall(_fanotify_mark,5, long fanotify_fd,  long flags,  __u64 mask,  long dfd, long pathname)

SYSDEF_syscall(_prlimit64,4, pid_t pid,  unsigned int resource,  const struct rlimit64 *new_rlim,  struct rlimit64 *old_rlim)

SYSDEF_syscall(_name_to_handle_at,5, int dfd,  const char *name,  struct file_handle *handle,  int *mnt_id,  int flag)

SYSDEF_syscall(_open_by_handle_at,5, int dfd,  const char *name,  struct file_handle *handle,  int *mnt_id,  int flags)

SYSDEF_syscall(_clock_adjtime,2, clockid_t which_clock,  struct timex *tx)

SYSDEF_syscall(_syncfs,1, int fd)

SYSDEF_syscall(_sendmmsg,4, int fd,  struct mmsghdr *mmsg,  unsigned int vlen,  unsigned int flags)

SYSDEF_syscall(_setns,2, int fd,  int nstype)

SYSDEF_syscall(_getcpu,3, unsigned *cpup,  unsigned *nodep,  struct getcpu_cache *unused)

SYSDEF_syscall(_process_vm_readv,6, pid_t pid,  const struct iovec *lvec,  unsigned long liovcnt,  const struct iovec *rvec,  unsigned long riovcnt,  unsigned long flags)

SYSDEF_syscall(_process_vm_writev,6, pid_t pid,  const struct iovec *lvec,  unsigned long liovcnt,  const struct iovcc *rvec,  unsigned long riovcnt,  unsigned long flags)

SYSDEF_syscall(_kcmp,5, pid_t pid1,  pid_t pid2,  int type,  unsigned long idx1,  unsigned long idx2)

SYSDEF_syscall(_finit_module,3, int fd,  const char  *uargs,  int flags)

SYSDEF_syscall(_sched_setattr,3, pid_t pid,  struct sched_attr  *attr,  unsigned int flags)

SYSDEF_syscall(_sched_getattr,4, pid_t pid,  struct sched_attr  *attr,  unsigned int size,  unsigned int flags)

SYSDEF_syscall(_renameat2,5, int olddfd,  const char  *oldname,  int newdfd,  const char  *newname,  unsigned int flags)

SYSDEF_syscall(_seccomp,3, unsigned int op,  unsigned int flags,  const char  *uargs)

SYSDEF_syscall(_getrandom,3, char  *buf,  size_t count,  unsigned int flags)

SYSDEF_syscall(_memfd_create,2, const char  *uname_ptr,  unsigned int flags)

SYSDEF_syscall(_kexec_file_load,5, int kernel_fd,  int initrd_fd,  unsigned long cmdline_len,  const char  *cmdline_ptr,  unsigned long flags)

SYSDEF_syscall(_bpf,3, int cmd,  union bpf_attr *attr,  unsigned int size)


#endif

#endif

// minilib/include/syscalls_x64.h
#ifdef mini__pipe2
#endif

// minilib/src/pty.c
#ifdef mini_unlockpt
int unlockpt(int fd);
#endif

// minilib/include/mini_fstream.h
#ifdef mini_ferror
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getpid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__bind
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__migrate_pages
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__lchown
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__pause
#endif

// minilib/include/prints.h
#ifdef mini_fwrites
#define fwrites(fd,str) write(fd,str,sizeof(str))
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mq_open
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__adjtimex
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__shmget
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mlock
#endif

// minilib/include/isprint.h
#ifdef mini_isprint
#ifndef mini_isprint_h
#define mini_isprint_h
#define misprint(A) isprint(A)

//+header ctype.h
//+inc
//+def
static inline int __attribute__((always_inline)) isprint(const char c){
		if ( (c>31) && ( c<127 ))
				return(1);
		return(0);
}


#endif

#endif

// minilib/include/syscalls_x64.h
#ifdef mini__open_by_handle_at
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__socket
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__chown
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_getpgrp
#endif

// minilib/include/syscalls_x64.h
#ifdef mini___sysctl
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__kexec_file_load
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__add_key
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__signalfd
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mremap
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__flistxattr
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getpgrp
#endif

// minilib/src/strerror.c
#ifdef mini_perror
void perror(char *msg);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__msgctl
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__close
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__get_robust_list
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__writev
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__seccomp
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_uname
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__unlink
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__vhangup
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sched_getaffinity
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__restart_syscall
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mount
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__capset
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__capget
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fadvise64
#endif

// minilib/include/mini_fstream.h
#ifdef mini_fsetpos
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_getppid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__madvise
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__dup3
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setpriority
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__brk
#endif

// minilib/include/fputc.h
#ifdef mini_putchar
#define putchar(c) fputc(c,stdout)
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mbind
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__pivot_root
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__unshare
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sched_getattr
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__ioctl
#endif

// minilib/src/ltodec.c
#ifdef mini_ltodec
int ltodec(long i, char *buf, int prec, char limiter );
#endif

// minilib/src/pty.c
#ifdef mini_grantpt
int grantpt(int fd);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setresgid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setresuid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__set_mempolicy
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_getuid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setgroups
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__reboot
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__init_module
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sched_get_priority_min
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__clock_nanosleep
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_getcwd
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__ustat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__vmsplice
#endif

// minilib/include/mini_fstream.h
#ifdef mini_fprint
#define fprint(...) fprintf(__VA_ARGS__)
#endif

// minilib/src/basename.c
#ifdef mini_basename
char *basename(char *path);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__semop
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__inotify_init
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__clock_getres
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_execve
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_getgid
#endif

// minilib/include/mini_fstream.h
#ifdef mini_feof
#endif

// minilib/src/pty.c
#ifdef mini_ptsname
char *ptsname(int fd);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setregid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__semctl
#endif

// minilib/include/mini_fstream.h
#ifdef mini_clearerror
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sigaltstack
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setitimer
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_pipe
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_dup
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__nanosleep
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__access
#endif

// minilib/include/fputc.h
#ifdef mini_putc
#define putc(c,stream) fputc(c,stream)
#endif

// minilib/src/isspace.c
#ifdef mini_isspace
int isspace(int c);
#endif

// minilib/include/mkfifo.h
#ifdef mini_mkfifo
//+header fcntl.h
//+inc
//+def
static int mkfifo( const char* path, mode_t mode ){
		return( mknod(path, mode | S_IFIFO, 0 ) );
}
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sysinfo
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__renameat
#endif

// minilib/src/fopen.c
#ifdef mini_fopen
FILE *fopen(const char* filename, const char* mode);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__gettid
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_setpgid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__preadv
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setsid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setgid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__connect
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getpgid
#endif

// minilib/include/prints.h
#ifdef mini_puts
#define puts(msg) ( print(msg) + printl() )
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__newfstatat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__rt_sigqueueinfo
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__umask
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__chdir
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getcpu
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sched_rr_get_interval
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__timerfd_create
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__geteuid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__write
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__chmod
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__flock
#endif

// minilib/src/itobin.c
#ifdef mini_itobin
#define itobin(A,B,...) _itobin(A,B,VARARG(SHIFT(__VA_ARGS__),0), VARARG(SHIFT(ARG( __VA_ARGS__ )),32) )
#endif

// minilib/src/sigemptyset.c
#ifdef mini_sigemptyset
static int sigemptyset(sigset_t *set);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__rt_sigprocmask
#endif

// minilib/macros/getoptm.h
#ifdef mini_def
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__eventfd
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__recvmsg
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__finit_module
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__lremovexattr
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__dup
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__move_pages
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getresgid
#endif

// minilib/include/mini_fstream.h
#ifdef mini_rewind
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getcwd
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_fcntl
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_rename
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getgroups
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setns
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__tgkill
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getresuid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__get_mempolicy
#endif

// minilib/src/fopen.c
#ifdef mini_freopen
FILE *freopen(const char* filename, const char* mode, FILE *F);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__dup2
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__timer_delete
#endif

// minilib/src/dirent/opendir.c
#ifdef mini_opendir
DIR *opendir(const char *name);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sendto
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__kill
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__rename
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__waitid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__readv
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__clock_adjtime
#endif

// minilib/include/mini_fstream.h
#ifdef mini_fgetpos
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__alarm
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getpriority
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__epoll_ctl
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__memfd_create
#endif

// minilib/include/lseek.h
#ifdef mini_ftruncate
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sched_setparam
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getrusage
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__bpf
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__set_robust_list
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__clock_settime
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_time
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_link
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__time
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mprotect
#endif

// minilib/src/dtodec.c
#ifdef mini_dtodec
int dtodec(double d, char* buf, int precision);
#endif

// minilib/include/mini_fstream.h
#ifdef mini_fflush
#endif

// minilib/src/memset.c
#ifdef mini_memset
void *memset( void *s, int c, int n);
#endif

// minilib/src/memcpy.c
#ifdef mini_strncpy
char *strncpy(char *dest, const char *src, int n);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__perf_event_open
#endif

// minilib/src/rand.c
#ifdef mini_rand
unsigned int rand();
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__munmap
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__inotify_init1
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_setuid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__tkill
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__pread64
#endif

// minilib/src/ltodec.c
#ifdef mini_ultodec
int ultodec(unsigned long i, char *buf, int prec, char limiter );
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_stat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fstat
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_rmdir
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_pivot_root
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__readahead
#endif

// minilib/include/fgetc.h
#ifdef mini_getchar
#define getchar() fgetc(0)
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__timer_settime
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fcntl
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_sync
#endif

// minilib/include/lseek.h
#ifdef mini_fsync
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mknod
#endif

// minilib/src/dirname.c
#ifdef mini_dirname
char *dirname(char *s);
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_setgid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__msgsnd
#endif

// minilib/src/strcmp.c
#ifdef mini_strncmp
int strncmp(const char*c1,const char*c2,int len);
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_chmod
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__munlockall
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_brk
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__rt_tgsigqueueinfo
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__unlinkat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setpgid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__splice
#endif

// minilib/include/fgetc.h
#ifdef mini_getc
#define getc(F) fgetc(F)
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mkdirat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__rt_sigreturn
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__keyctl
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__request_key
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sync_file_range
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getgid
#endif

// minilib/src/sleep.c
#ifdef mini_sleep
unsigned int sleep(unsigned int seconds);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getsid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getdents64
#endif

// minilib/src/fgets.c
#ifdef mini_gets
#define gets(F) fgets(F,0xfffffff,stdin)
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__lseek
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mq_timedreceive
#endif

// minilib/src/fopen.c
#ifdef mini_fdopen
FILE *fdopen(int fd, const char* mode);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sendmsg
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__io_destroy
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__readlink
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fanotify_mark
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_chdir
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__listen
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__statfs
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getitimer
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__clone
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__utime
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__ptrace
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__process_vm_readv
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__socketpair
#endif

// minilib/src/strcmp.c
#ifdef mini_strncasecmp
int strncasecmp(const char*c1,const char*c2,int len);
#endif

// minilib/include/mini_fstream.h
#ifdef mini_fread
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__creat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__semtimedop
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_getdents
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__tee
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fchdir
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__lsetxattr
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sched_setscheduler
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__iopl
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setfsgid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__stat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fgetxattr
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fork
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_gettimeofday
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__io_getevents
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__kexec_load
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__shmctl
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__faccessat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__listxattr
#endif

// minilib/src/fprintfs.c
#ifdef mini_fprintfs
int fprintfs( FILE* F, char *fmt, ...);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__acct
#endif

// minilib/include/fgetc.h
#ifdef mini_ungetc
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fsync
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__ftruncate
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sysfs
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__execve
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__rt_sigaction
#endif

// minilib/include/select.h
#ifdef mini_select
#ifndef select_h
#define select_h
//#include "syscall.h"

//+header unistd.h
//+inc
//
//+def
static inline int volatile __attribute__((always_inline)) select(int fd, volatile fd_set* readfd, volatile fd_set *writefd, volatile fd_set *exceptfd, volatile struct timeval *wait){
		int ret;
		syscall5(ret, SCALL(select),&fd,readfd,(POINTER)writefd,(POINTER)exceptfd,(POINTER) wait);
		return(ret);
}
/*
		//return(syscall5(__NR_select,(long)fd,(long)readfd,(long)writefd,(long)exceptfd, (long)wait));
		int ret;
		syscall5(ret,__NR_select,&fd,readfd,writefd,exceptfd, wait);
		return(ret);
		//return(syscall5(__NR_select,fd,readfd,,0,0));
}
*/



		//int pselect (int, fd_set *, fd_set *, fd_set *, const struct timespec *, const sigset_t *);


#endif

#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getrandom
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__utimensat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fchmod
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__lookup_dcookie
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setfsuid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__timer_create
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__msgrcv
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_mkdir
#endif

// minilib/include/mini_fstream.h
#ifdef mini_setvbuf
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__linkat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__removexattr
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sched_yield
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__open
#endif

// minilib/include/tcsetattr.h
#ifdef mini_tcsetattr
#ifndef tcsetattr_h
#define tcsetattr_h

//#include <termios.h>

//#include <sys/ttycom.h>

#ifndef TCSETS
#warning TCSETS not defined. Applying ugly hack.
#define TCSETS TIOCSETA
#endif

//+needs termios.h ioctl.h
//+header unistd.h
//+include
//+depends ioctl
//+def
static inline int __attribute__((always_inline)) tcsetattr(int fd, int opt, const struct termios *io){
	return(ioctl(fd, TCSETS +opt, io));
	//return(ioctl(fd, 0x5402+opt, io));
}



#endif
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__select
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__io_setup
#endif

// minilib/include/prints.h
#ifdef mini_writes
#define writes(str) write(STDOUT_FILENO,str,sizeof(str))
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mmap
#endif

// minilib/src/strcmp.c
#ifdef mini_memcmp
int memcmp(const void* c1,const void* c2,int len);
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_access
#endif

// minilib/include/prints.h
#ifdef mini_printsl
#define printsl(...) _mprints(__VA_ARGS__,"\n",0)
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__lstat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__remap_file_pages
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sched_getscheduler
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_fchmod
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fanotify_init
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__msgget
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__rt_sigsuspend
#endif

// minilib/include/mini_fstream.h
#ifdef mini_fwrite
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setsockopt
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__epoll_create
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__kcmp
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__exit
#endif

// minilib/src/open.c
#ifdef mini_creat
inline int volatile __attribute__((always_inline)) creat( const char *s, int mode );
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getpeername
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_vhangup
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sendfile
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_mount
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mincore
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__semget
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getsockname
#endif

// minilib/src/wait.c
#ifdef mini_wait
pid_t wait(int *wstatus);
#endif

// minilib/src/rand.c
#ifdef mini_srand
void srand( unsigned int i );
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_utime
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sched_getparam
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setrlimit
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__clock_gettime
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setxattr
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getuid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__process_vm_writev
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__delete_module
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__umount2
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_nanosleep
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__eventfd2
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getdents
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_fchown
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mq_timedsend
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__rt_sigtimedwait
#endif

// minilib/src/dirent/closedir.c
#ifdef mini_closedir
int closedir(DIR *dir);
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_chroot
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__ioperm
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_mknod
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getppid
#endif

// minilib/src/memfrob.c
#ifdef mini_memfrob
void* memfrob(void* s, unsigned int len);
#endif

// minilib/src/strcmp.c
#ifdef mini_strcmp
int strcmp(const char*c1,const char*c2);
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_chown
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__lgetxattr
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__recvfrom
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__name_to_handle_at
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__accept4
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__symlinkat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fsetxattr
#endif

// minilib/include/mini_fstream.h
#ifdef mini_fclose
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__settimeofday
#endif

// minilib/src/itohex.c
#ifdef mini_itoHEX
int itoHEX(int i,char* buf,int padding);
#endif

// minilib/src/signal.c
#ifdef mini_signal
sighandler_t signal(int sig, sighandler_t func );
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__prlimit64
#endif

// minilib/src/isatty.c
#ifdef mini_isatty
int isatty(int fd);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__msync
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__inotify_rm_watch
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mq_notify
#endif

// minilib/src/strdup.c
#ifdef mini_strdup
char *strdup(const char *source);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__arch_prctl
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__io_cancel
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getegid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mkdir
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__timer_gettime
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__pwritev
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__futimesat
#endif

// minilib/include/prints.h
#ifdef mini_fprints
#define fprints(F,str) write(fileno(F),str,strlen(str))
#endif

// minilib/src/wait.c
#ifdef mini_waitpid
pid_t waitpid(pid_t pid, int *wstatus, int options);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__syslog
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_unlink
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__rmdir
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fchownat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__recvmmsg
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_umask
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_mprotect
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mknodat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mq_getsetattr
#endif

// minilib/include/mini_fstream.h
#ifdef mini_setbuf
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_sendfile
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__epoll_wait
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__llistxattr
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sync
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__io_submit
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getsockopt
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__ioprio_set
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_getpid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fdatasync
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__accept
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__syncfs
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fchown
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_dup2
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sched_get_priority_max
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__prctl
#endif

// minilib/src/dirent/readdir.c
#ifdef mini_readdir
struct dirent *readdir(DIR *dir);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__exit_group
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__swapoff
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__link
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__openat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fallocate
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__pwrite64
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__munlock
#endif

// minilib/src/strcat.c
#ifdef mini_strcat
char *strcat(char *dest, const char *src );
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__wait4
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__readlinkat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__timer_getoverrun
#endif

// minilib/src/atoi.c
#ifdef mini_atoi
int atoi(char *c);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sethostname
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__futex
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__epoll_pwait
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mlockall
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__times
#endif

// minilib/src/strcmp.c
#ifdef mini_strcasecmp
int strcasecmp(const char*c1,const char*c2);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__quotactl
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setreuid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__read
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_fork
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__inotify_add_watch
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__rt_sigpending
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_vfork
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_fstat
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_dup3
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__chroot
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setdomainname
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_readahead
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__uname
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__symlink
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_kill
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__pipe
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__signalfd4
#endif

// minilib/src/getenv.c
#ifdef mini_getenv
char *getenv(const char* name);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__timerfd_settime
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__epoll_create1
#endif

// minilib/src/itohex.c
#ifdef mini_itohex
int itohex(int i,char* buf,int padding);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__truncate
#endif

// minilib/src/pty.c
#ifdef mini_posix_openpt
int posix_openpt(int flags);
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__shutdown
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__utimes
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__gettimeofday
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__pselect6
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_reboot
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__shmat
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_rt_sigaction
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fremovexattr
#endif

// minilib/include/syscall_stubs.h
#ifdef mini_setsid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__vfork
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sendmmsg
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sched_setattr
#endif

// minilib/include/mini_fstream.h
#ifdef mini_printf
#define printf(...) fprintf(stdout,__VA_ARGS__)
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__personality
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__swapon
#endif

// minilib/include/mini_fstream.h
#ifdef mini_vfprintf
#define vfprintf(...) fprintf(__VA_ARGS__)
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__ppoll
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__shmdt
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getxattr
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fstatfs
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__timerfd_gettime
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__getrlimit
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__fchmodat
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__setuid
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__set_tid_address
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__ioprio_get
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__sched_setaffinity
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__poll
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__mq_unlink
#endif

// minilib/include/syscalls_x64.h
#ifdef mini__modify_ldt
#endif
#ifdef INCLUDESRC
#ifndef included_minilib_c
/* This file is part of minilib, (c) 2012-2020 Michael Misc Myer.
misc.myer@zoho.com / www.github.com/michael105
Licensed under the terms of the BSD 3-clause License.
Please see the files LICENSE and NOTICE for the exact conditions. 

The lines below are generated by 'make header'. 

*/


#ifndef included_minilib_c
#define included_minilib_c

/* templates/header.in */


#ifndef mini_INCLUDESRC
#ifdef INCLUDESRC
#define mini_INCLUDESRC
#endif
#endif


#ifdef HEADERGUARDS
#ifndef mini_HEADERGUARDS
#define mini_HEADERGUARDS
#endif
#endif


#ifdef HEADERGUARDS
#endif

//#define mini_start
//#define mini_exit


#ifdef mini_GETOPTS
#endif

/* end templates/header.in */
/* templates/minilib.c.in */

//#include "minilib.conf"

#ifndef included_minilib_h
#endif

#ifndef start_c
#define start_c

#ifndef OSX

#ifdef mini_vsyscalls
int __mini_vsys = 0;
#ifndef startc_c
#define startc_c

typedef struct _elf_aux_v {
		unsigned int type;
		unsigned int value;
} elf_aux_v;



void __start_c(char **envp){

		//for ( ; *envp == 0; envp++  );
		while ( *envp++ != 0 );
		elf_aux_v *p = (elf_aux_v*)envp;

		while ( p ){
				if ( p->type == 32 ){
						__mini_vsys = p->value;
						return;
				}
				p++;
		}
}


#endif

#endif

#ifdef mini_start
#ifdef X64
#ifdef mini_start
void _start(){
// This is "callen" just before main.
// 
// dbg("Startup -xx"); // no arguments allowed here. 
// otherwise argv[] gets confused
// Or we would have to add some further bloating bytes
#ifdef mini_buf
ml.mbufsize = mini_buf;
ml.stream[0]=0;
ml.stream[1]=1;
ml.stream[2]=2;
ml.pstream = 3;
#endif

#ifdef mini_errno
errno = 0;
sysret = 0;
#endif


__asm__("\
#.global _start\n\
#_start:\n\
	popq %rdi\n\
	movq %rsp,%rsi\n\
	leaq  8(%rsi,%rdi,8),%rdx\n"
#ifdef mini_getenv
	"movq %rdx, mini_env\n"
#endif

	"call main\n\
	movq %rax, %rdi\n\
.global _exit\n\
_exit:\n\
	movq $60, %rax\n\
	syscall\n"
	);
};
#endif

#else
#ifdef mini_start
//#include "src/start_c.c"
void _start(){
__asm__("\
#.global _start\n\
#_start:\n\
	pop %eax\n\
	leal  12(%esp,%eax,4),%ebx\n"
//	push %ebx\n
//	call __start_c\n
//	pop %ebx\n
  "pop %eax\n\
  mov %esp,%ecx\n\
	push %ebx\n\
	push %ecx\n\
	push %eax\n\
	call main\n\
	mov %eax, %ebx\n\
.global _exit\n\
_exit:\n\
	mov $1, %eax\n\
	int $0x80\n"
	);
};
#endif

#endif
#endif


#else

#ifdef mini_start
#ifdef mini_start
// Not tested yet
//
void start(){
__asm__ volatile (
//		".globl start\n\t"
//		"start:	
		"pushq	$0\n\t"
		"movq	%rsp,%rbp\n\t"
		"andq    $-16,%rsp\n\t"
		"movq	8(%rbp),%rdi\n\t"
		"leaq	16(%rbp),%rsi\n\t"
		"movl	%edi,%edx\n\t"
		"addl	$1,%edx\n\t"
		"sall	$3,%edx\n\t"
		"addq	%rsi,%rdx\n\t"
		"movq	%rdx,%rcx\n\t"
		"jmp	Lapple2\n\t"
		"Lapple:	add	$8,%rcx\n\t"
		"Lapple2:cmpq	$0,(%rcx)\n\t"
		"jne	Lapple		    \n\t"
		"add	$8,%rcx\n\t"
		"call _main\n\t"
		"movq %rax, %rdi\n\t"
		".globl _exit\n\t"
		"_exit:\n\t"
		"movl $0x2000001, %eax\n\t"
		"syscall\n\t"
	);
} 
#endif

#endif


#endif




#endif
#ifndef minilib_globals_c
#define minilib_globals_c

// 
//#ifndef mini_buf
//#warning defining minibuf
//#define mini_buf 1024
//#endif
//
#ifdef mini_buf
minilib_globals ml;
//
//void minilib_global_init(){ // this is callen by startup.c
//	ml.mbufsize = mini_buf;
  //ibuf = (int*)mbuf;
//}
//
#else
//
//void minilib_global_init(){} // this is callen by startup.c
//
#endif

#endif

#ifdef mini_prints
#ifndef prints_c
#define prints_c
//#include "../include/write.h"
#ifndef prints_h
#define prints_h
extern int _mprints(char*msg,...);
extern int dprints(int fd, char *msg,...);
//+header mini_addons.h


//+doc print the string(s) supplied as arg(s) to stdout
//+depends _mprints 
//+macro
#define prints(...) _mprints(__VA_ARGS__,0)


//+doc print the string(s) supplied as arg(s) to stream
//+depends fileno write strlen
//+macro
#define fprints(F,str) write(fileno(F),str,strlen(str))




//+doc print the string(s) supplied as arg(s) and newline to stdout
//+depends _mprints 
//+macro
#define printsl(...) _mprints(__VA_ARGS__,"\n",0)

//+depends write strlen
//+doc write str to stdout. Needs strlen
//+macro print(str) write(STDOUT_FILENO,str,strlen(str))


//+depends write 
//+doc write the constant str to stdout. Computes length with sizeof(str) at compile time.
//+macro writes(str) write(STDOUT_FILENO,str,sizeof(str))


//+depends write 
//+doc write the constant str to stdout. Computes length with sizeof(str) at compile time.
//+macro fwrites(fd,str) write(fd,str,sizeof(str))


//+depends write
//+doc write a newline to stdout
//+macro printl() write(STDOUT_FILENO,"\n",1)


//+depends printl print strlen
//+doc write msg to stdout, append a newline. Needs strlen.
//+macro puts(msg) ( print(msg) + printl() )





#endif
#ifndef stdarg_h
#define stdarg_h
// copied from musl
// copy more - the builtin list..

#if 1
#if __GNUC__ >= 3
//#warning here 1
typedef __builtin_va_list va_list;
#define va_start(v,l)   __builtin_va_start(v,l)
#define va_end(v)       __builtin_va_end(v)
#define va_arg(v,l)     __builtin_va_arg(v,l)
#define va_copy(d,s)    __builtin_va_copy(d,s)
#else
//#warning here 2

#ifdef __GNUC__
//#warning here 3
//TODO: this gets scrambled if in the same compiler unit as the caller.
typedef __builtin_va_list va_list;
#define __VA_ALIGNED_SIZE(x) ((sizeof(x) + sizeof(int) - 1) & ~(sizeof(int) - 1))

#define va_start(ap, last) ((ap) = (void *)(((char *)&(last)) + __VA_ALIGNED_SIZE(last)))
#define va_end(ap) ((void)0)
#define va_copy(dest, src) ((dest) = (src))

#define va_arg(ap, type) \
	( ((ap) = (va_list)((char *)(ap) + __VA_ALIGNED_SIZE(type))), \
	*(type *)(void *)((char *)(ap) - __VA_ALIGNED_SIZE(type)) )


#else

//#warning here 4
// copied from tcc
#ifdef __x86_64__
//#warning here 5
#ifndef _WIN64
//#warning here 6

typedef void *va_list;

va_list __va_start(void *fp);
void *__va_arg(va_list ap, int arg_type, int size);
va_list __va_copy(va_list src);
void __va_end(va_list ap);

#define va_start(ap, last) ((ap) = __va_start(__builtin_frame_address(0)))
#define va_arg(ap, type)                                                \
		    (*(type *)(__va_arg(ap, __builtin_va_arg_types(type), sizeof(type))))
#define va_copy(dest, src) ((dest) = __va_copy(src))
#define va_end(ap) __va_end(ap)

#else /* _WIN64 */
typedef char *va_list;
#define va_start(ap,last) ap = ((char *)&(last)) + ((sizeof(last)+7)&~7)
#define va_arg(ap,type) (ap += (sizeof(type)+7)&~7, *(type *)(ap - ((sizeof(type)+7)&~7)))
#define va_copy(dest, src) (dest) = (src)
#define va_end(ap)
#endif

#else /* __i386__ */
typedef char *va_list;
/* only correct for i386 */
#define va_start(ap,last) ap = ((char *)&(last)) + ((sizeof(last)+3)&~3)
#define va_arg(ap,type) (ap += (sizeof(type)+3)&~3, *(type *)(ap - ((sizeof(type)+3)&~3)))
#define va_copy(dest, src) (dest) = (src)
#define va_end(ap)
#endif

/* fix a buggy dependency on GCC in libio.h */
typedef va_list __gnuc_va_list;
#define _VA_LIST_DEFINED

#endif
#endif

#endif

#endif


#ifndef mini_prints
#define mini_prints
#endif

//+include

//TODO: Handle errors of write (ret == -1)

#if 0
int _prints(char *msg,...){
		int a;
		int ret = 0;

		do {
				a = 0;
				while (msg[a] != 0 ){
						a++;
				}
				ret += write(1,msg,a);
				//msg = 0;//va_arg(args,char*);
				//msg+=4;
				printf("\nmsg: %u\n",msg);
				printf("msg: %u\n",&msg);
				unsigned int i;
				i = &msg;
				printf("i: %u\n",i);
				i+=4;
				printf("i: %u\n",i);
				*msg = i;
				printf("\nmsg: %u\n",msg);
				printf("msg: %u\n",&msg);

				msg=0;
		} while ( msg != 0 );
		return(ret);
}

#else

//+needs write.h prints.h stdarg.h
//+depends write
int dprints(int fd, char *msg,...){
		va_list args;
		va_start(args,msg);
		int a;
		int ret = 0;

		do {
				a = 0;
				while (msg[a] != 0 ){
						a++;
				}
				ret += write(fd,msg,a);
				msg = va_arg(args,char*);
		} while ( msg != 0 );
		va_end(args);
		return(ret);
}

//+needs write.h prints.h stdarg.h
//+depends dprints
//+macro _mprints(...) dprints(STDOUT_FILENO, __VA_ARGS__)


#endif

#endif
#endif

#ifdef mini_errno
int errno;
int sysret;
#endif


/* end templates/minilib.c.in */

// minilib/src/pty.c
#ifdef mini_unlockpt
#ifndef pty_c
#define pty_c

// musl

//+depends open
//+def
int posix_openpt(int flags){
		return open("/dev/ptmx", flags);
}

//+def
int grantpt(int fd){
		return 0;
}


//+depends ioctl
//+def
int unlockpt(int fd){
		int unlock = 0;
		return ioctl(fd, TIOCSPTLCK, &unlock);
}

//+depends snprintf itodec
//+def
int ptsname_r(int fd, char *buf, size_t len){
		int pty, err;
		if (!buf) len = 0;
		if ((err = ioctl( fd, TIOCGPTN, &pty))) return -err;
	//	printf("pts: %d, %d\n",pty,len);
		if (sprintf(buf, "/dev/pts/%d", pty) >= len) return ERANGE;

	//	printf("pts: %s\n",buf);
		return 0;
}

//+depends ptsname_r 
//+def
char *ptsname(int fd){
		static char buf[9 + sizeof(int)*3 + 1];
		int err = ptsname_r(fd, buf, sizeof buf);
		if (err) {
				errno = err;
				return 0;
		}
		return buf;
}


#endif
#endif

// minilib/src/sprintf.c
#ifdef mini_snprintf
#ifndef msprintf_c
#define msprintf_c

#ifndef mini_write
#define mini_write
#endif


#ifndef mini_prints
#define mini_prints
#endif

// Check, if referencing pos would overrun the buffer.
#ifndef overrun_h
#define overrun_h
#ifndef mini_prints
#define mini_prints
#endif
#ifndef minilib_exit_h
#define minilib_exit_h
//+header unistd.h
//+inc

//#include "syscall.h"
//#undef write
//#undef exit


#ifdef X64
#define exit(ret) asm("jmp _exit"::"D"(ret))
#else
#define exit(ret) asm("jmp _exit"::"b"(ret))
#endif


//#else
/* inline void volatile __attribute__((always_inline)) exit( int ret ){
		//setup_syscall3(SYS_write,fd,(int)s,len);
	int r;
		syscall1(r,SCALL(exit),ret);
} */
//#endif

#endif
#define MINI_TEST_OVERRUN(pos) if (pos > ml.mbufsize){\
		printsl("Buffer Overrun. Aborting.");\
		exit(1);}
#endif

//#include "../include/write.h"


#undef MINI_TEST_OVERRUN
#define MINI_TEST_OVERRUN(pos) if ( pos>= size ){ overflow=1; goto msprintfout;}

//+include

//+depends snprintf vsnprintf
//+macro
#define sprintf(str,...) snprintf( str, 4096,  __VA_ARGS__)

// I'm really uncertain about the size arg here, amongst others


//+ansi stdio.h
//+depends write
//+needs exit.h stdarg.h overrun.h
//+after itohex itoHEX
//+def
int vsnprintf(char *buf, size_t size, const char* fmt, va_list args ){

		//va_list args;
		//va_start(args,fmt);
		int a = 0;
		int b = 0;
		int overflow = 0;
		int end, padding, c,groups=0;
		char sep;
		char tmp[16];
		char *s;

#if 1
		while ( fmt[a] != 0){
				if ( fmt[a] == '%' ){
						end=0;
						padding = 0;
						sep = 0;
						groups=0;
						do {
								a++;
								if ( (fmt[a] > 47 ) && (fmt[a] < 58 ) ){
										c = 0;
										do { 
												tmp[c] = fmt[a]; 
												a++;
												c++;
										} while ( (fmt[a] > 47 ) && (fmt[a] < 58 ) );
										tmp[c] = 0;
#ifdef mini_atoi
										padding = atoi(tmp);
#endif
								}
								switch (fmt[a]){
										case '%': 	
												buf[b] = '%';
												end=1;
												b++;
												MINI_TEST_OVERRUN(b);
												break;
#if 1
										case 'u':
#ifdef mini_itodec
												MINI_TEST_OVERRUN(b+13);
												b = b + uitodec(va_arg(args,unsigned int),&buf[b],padding,sep);
#endif
												end=1;
												break;
										case 'd':
#ifdef mini_itodec
												MINI_TEST_OVERRUN(b+13);
												b = b + itodec(va_arg(args,int),&buf[b],padding,sep);
#endif
												end=1;
												break;
#endif
										case 'f':
#ifdef mini_dtodec
												MINI_TEST_OVERRUN(b+27);
												if ( padding==0 )
														padding = 9;
												b = b + dtodec(va_arg(args,double),&buf[b],padding);
#endif
												end=1;
												break;
										case 'l':
#ifdef mini_ltodec
												MINI_TEST_OVERRUN(b+27);
												b = b + ltodec(va_arg(args,long),&buf[b],padding,sep);
#endif
												end=1;
												break;

										case 39:
												sep = '.';
												break;
										case 'x':
#ifdef mini_itohex
												MINI_TEST_OVERRUN(b+8);
												b = b + itohex(va_arg(args,int),&buf[b],padding);
#endif
												end=1;
												break;
										case 'X':
#ifdef mini_itoHEX
												MINI_TEST_OVERRUN(b+8);
												b = b + itoHEX(va_arg(args,int),&buf[b],padding);
#endif
												end=1;
												break;

										case 'b':
#ifdef mini_itobin

												MINI_TEST_OVERRUN(b+32);
												b += itobin(va_arg(args,int),&buf[b],padding,groups);
#endif
												end=1;
												break;
										case '(':
												a++;
												if ( (fmt[a] > 47 ) && (fmt[a] < 58 ) ){
														c = 0;
														do { 
																tmp[c] = fmt[a]; 
																a++;
																c++;
														} while ( (fmt[a] > 47 ) && (fmt[a] < 58 ) );
														a--;
														tmp[c] = 0;
#ifdef mini_atoi
														groups = atoi(tmp);
#endif
												}
												break;
										case 's':
												s = va_arg(args,char*);
												c=0;
												while(s[c] != 0){
														buf[b] = s[c];
														c++;
														b++;
														MINI_TEST_OVERRUN(b);
												}
												end=1;
												break;
										case 'c':
												buf[b] = va_arg(args,int);
												b++;
												end=1;
												MINI_TEST_OVERRUN(b);
												break;
												





								}

						} while ((end==0) && (fmt[a+1] != 0 ));

				} else {
						buf[b] = fmt[a];
						b++;
						MINI_TEST_OVERRUN(b);
				}
				a++;
		}
msprintfout:
		buf[b] = 0;
		va_end(args);

		//write( 2, buf, 20 );
		//return(write(fd,buf,b));
		if ( overflow )
				return(-b);
		else
				return(b);
#endif
}


//+depends write vsnprintf
//+needs stdarg.h
//+def
int dprintf( int fd, const char *fmt, ... ){
		va_list args;
		va_start(args,fmt);
		int r = vsnprintf(ml.mbuf, ml.mbufsize, fmt, args);
		if ( r<0 ){
				write(2,"Buffer Overrun.\n",16);
				exit(1);
		}
		write( fd, ml.mbuf, r );
		va_end(args);
		return(r);
}


//+depends write vsnprintf
//+needs stdarg.h
//+def
int snprintf( char *buf, size_t size, const char *fmt, ... ){
		va_list args;
		va_start(args,fmt);
		int r = vsnprintf(buf, size, fmt, args);
		va_end(args);
		return(r);
}



/// fprintf
/// conversions implemented:
/// %d  
/// %u
/// %f (max precision 8 digits, highest possible number: 2^31
/// %s
/// %c
/// %b : binary output
/// %x/X : hex output
/// %(
/// 
//+header stdio.h
//+depends write prints dprintf sprintf fileno
//+needs mini_fstream.h 
//+after itobin atoi itodec dtodec ltodec itohex
//+macro fprintf(stream,...)	write(fileno(stream),ml.mbuf,sprintf(ml.mbuf,__VA_ARGS__))



#if 0		
		va_list args;
		va_start(args,fmt);
		int a = 0;
		int b = 0;
		int end, padding, c,groups;
		char sep;
		char tmp[16];
		char *s;

		while ( fmt[a] != 0){
				if ( fmt[a] == '%' ){
						end=0;
						padding = 0;
						sep = 0;
						groups=0;
						do {
								a++;
								if ( (fmt[a] > 47 ) && (fmt[a] < 58 ) ){
										c = 0;
										do { 
												tmp[c] = fmt[a]; 
												a++;
												c++;
										} while ( (fmt[a] > 47 ) && (fmt[a] < 58 ) );
										tmp[c] = 0;
#ifdef mini_atoi
										padding = atoi(tmp);
#endif
								}

								switch (fmt[a]){
										case '%': 	
												buf[b] = '%';
												end=1;
												b++;
												MINI_TEST_OVERRUN(b);
												break;
										case 'u':
#ifdef mini_itodec
												MINI_TEST_OVERRUN(b+13);
												b = b + uitodec(va_arg(args,unsigned int),&ml.mbuf[b],padding,sep);
#endif
												end=1;
												break;
										case 'd':
#ifdef mini_itodec
												MINI_TEST_OVERRUN(b+13);
												b = b + itodec(va_arg(args,int),&buf[b],padding,sep);
#endif
												end=1;
												break;
										case 'f':
#ifdef mini_dtodec
												MINI_TEST_OVERRUN(b+27);
												if ( padding==0 )
														padding = 9;
												b = b + dtodec(va_arg(args,double),&buf[b],padding);
#endif
												end=1;
												break;

										case 39:
												sep = '.';
												break;
										case 'x':
										case 'X':
#ifdef mini_itohex
												MINI_TEST_OVERRUN(b+8);
												b = b + itohex(va_arg(args,int),&buf[b],padding);
#endif
												end=1;
												break;
										case 'b':
#ifdef mini_itobin

												MINI_TEST_OVERRUN(b+32);
												b += itobin(va_arg(args,int),&buf[b],padding,groups);
#endif
												end=1;
												break;
										case '(':
												a++;
												if ( (fmt[a] > 47 ) && (fmt[a] < 58 ) ){
														c = 0;
														do { 
																tmp[c] = fmt[a]; 
																a++;
																c++;
														} while ( (fmt[a] > 47 ) && (fmt[a] < 58 ) );
														a--;
														tmp[c] = 0;
#ifdef mini_atoi
														groups = atoi(tmp);
#endif
												}
												break;
										case 's':
												s = va_arg(args,char*);
												c=0;
												while(s[c] != 0){
														buf[b] = s[c];
														c++;
														b++;
														MINI_TEST_OVERRUN(b);
												}
												end=1;
												break;
										case 'c':
												buf[b] = va_arg(args,int);
												b++;
												end=1;
												MINI_TEST_OVERRUN(b);
												break;
												





								}

						} while ((end==0) && (fmt[a+1] != 0 ));

				} else {
						buf[b] = fmt[a];
						b++;
						MINI_TEST_OVERRUN(b);
				}
				a++;
		}
		buf[b] = 0;
		va_end(args);
		//return(write(1,buf,b));
		return(b);
}
#endif
#endif
#endif

// minilib/src/pty.c
#ifdef mini_ptsname_r
#endif

// minilib/src/itohex.c
#ifdef mini__itohex
#ifndef itohex_c
#define itohex_c
//+header stdio.h
//+include
//+def
int _itohex(int i,char* buf,int padding, int capitals){

		if ( capitals>0 )
				capitals = 55;
		else
				capitals = 87;

		padding = padding - 8;
		if ( padding < -7 )
				padding = -7;

		union { int n; char c[4]; } conv[2];
		conv[0].n = (( i & 0xf0f0f0f0 ) >> 4);
		conv[1].n = ( i & 0x0f0f0f0f );
		int p = 0;
		int a,b;

		for ( a=3; a>=0; a-- ){
				for ( b=0; b <=1; b++ ){
						if ( padding != 0 ){
								if ( conv[b].c[a] != 0 ){
										padding = 0;
								}
						}
						if ( padding == 0 ){
								char c = conv[b].c[a];
								if ( c < 0xa )
										c = c + 48;
								else
										c = c + capitals; // 55 for big abc ..
								buf[p] = c;
								p++;
						} else
								padding++;
				}
		}
		buf[p] = 0 ;
		return(p);
}

//+header stdio.h
//+depends _itohex
//+def
int itohex(int i,char* buf,int padding){
		return(_itohex(i,buf,padding,0));
}

//+header stdio.h
//+depends _itohex
//+def
int itoHEX(int i,char* buf,int padding){
		return(_itohex(i,buf,padding,1));
}




#endif

#endif

// minilib/src/strerror.c
#ifdef mini_perror
#ifndef strerror_r
#define strerror_r


char *errstr = "error: 00";

//+header string.h
//+def
char* strerror( int errnum ){
		errstr[7] = '0';
		while ( errnum>9 ){
				errnum-=10;
				errstr[7]++;
		}
		errstr[8] = 48+errnum; // 0+errnum..
		return( errstr );
}

//+header stdio.h
//+depends fputs strerror strlen
//+def
void perror(char *msg){
		if ( msg !=0 && msg[0] != '\0' )
				fputs( msg, stderr );

		fputs( strerror( errno ), stderr );
}


#endif

#endif

// minilib/src/ioctl.c
#ifdef mini_ioctl
#ifndef mini_ioctl_h
#define mini_ioctl_h

//#include "../include/syscall.h"
//#include "/usr/diet/include/stdarg.h"

//+header ioctl.h
//+def
int ioctl( int fd, unsigned long int request, ... ){
		va_list args;
		va_start(args,request);

		int ret;
		syscall3(ret, SCALL(ioctl),fd,request,(long int)va_arg(args,void*));
		va_end(args);
		return(ret);
}


#endif
#endif

// minilib/src/malloc.c
#ifdef mini_malloc
#ifndef mini_malloc_c
#define mini_malloc_c
//+header stdlib.h
//#include "../include/syscall.h"

#ifdef __NR_brk
#define BRK
#else
#ifdef SYS_brk
#define BRK
#endif
#endif

#ifndef minilib_global_h
#define minilib_global_h

// Don't like this pattern.
// Will most likely "bloat" minilib.
// But other options do not seem sensible.

//#ifndef mini_buf
//#warning defining mini_buf
//#define mini_buf 1024
//#endif

#ifdef mini_buf


typedef struct {
		int align;
		int srand;	
		int pstream;
		int mbufsize;
		int stream[mini_FOPEN_MAX];
		union {
				int ibuf[mini_buf>>2];
				char mbuf[mini_buf];
		};
} minilib_globals;

extern minilib_globals ml;
#else

//#warning no mini_buf

#endif

#ifdef mini_getenv
//+doc pointer to env, when mini_getenv is defined.
char **mini_env;
#endif


#endif

/// Debugging macros
#ifdef DEBUG
#define mini_fputc
#define mini_fprintf
static inline int fputc(int c, int fd);


#define dbgwarnf(...) {fprintf(stderr,__VA_ARGS__);fputc('\n',stderr);}
#define dbgwarn(s) {write(stderr,s,sizeof(s));fputc('\n',stderr);}
#define dbgwarnfif(a,...) {if ( a ){dbgwarnf(__VA_ARGS__)};}
#define dbgwarnif(a,s) {if ( a ){dbgwarn(s)};}
#define dbgerr(s) {dbgwarn(s);exit(1);}
#define dbgerrf(...) {dbgwarnf(__VA_ARGS__);exit(1);}
#define dbgerrif(a,s) {if(a){dbgwarn(s);exit(1);};}
#define dbgerrfif(a,...) {if(a){dbgwarnf(__VA_ARGS__);exit(1);};}

#define dbg(s) dbgwarn(s)
#define dbgf(...) dbgwarnf(__VA_ARGS__)

#else

#define dbg(s) {}
#define dbgf(...) {}


#define dbgwarnf(...) {}
#define dbgwarn(s) {} 
#define dbgwarnfif(a,...) {} 
#define dbgwarnif(a,s) {} 
#define dbgerr(s) {}
#define dbgerrf(...) {}
#define dbgerrif(a,s) {}
#define dbgerrfif(a,...) {}

#endif


// ansicolors
#define AC_BLACK "\033[0;30m"
#define AC_RED "\033[0;31m"
#define AC_GREEN "\033[32;0m"
#define AC_BROWN "\033[0;33m"
#define AC_BLUE "\033[0;34m"
#define AC_MAGENTA "\033[0;35m"
#define AC_MARINE "\033[0;36m"
#define AC_LGREY "\033[0;37m"
#define AC_WHITE "\033[0;38m"

#define AC_GREY "\033[1;30m" 
#define AC_LRED "\033[1;31m" 
#define AC_LGREEN "\033[1;32m" 
#define AC_YELLOW "\033[1;33m"
#define AC_LBLUE "\033[1;34m"
#define AC_LMAGENTA "\033[1;35m"
#define AC_LMARINE "\033[1;36m"
#define AC_LWHITE "\033[1;37m"



#ifdef SHORTCOLORNAMES

#define NORM     AC_NORM
#define INVERSE  AC_INVERSE
#define BLINK    AC_BLINK
#define BLACK    AC_BLACK
#define RED      AC_RED
#define GREEN    AC_GREEN
#define BROWN    AC_BROWN
#define BLUE     AC_BLUE
#define MAGENTA  AC_MAGENTA
#define MARINE   AC_MARINE
#define LGREY    AC_LGREY
#define WHITE    AC_WHITE
#define GREY     AC_GREY
#define LRED     AC_LRED
#define LGREEN   AC_LGREEN
#define YELLOW   AC_YELLOW
#define LBLUE    AC_LBLUE
#define LMAGENTA AC_LMAGENTA
#define LMARINE  AC_LMARINE
#define LWHITE   AC_LWHITE

#endif

#ifdef SHRTSHORTCOLORNAMES

#define cN   AC_NORM
#define cBL  AC_BLACK
#define cR   AC_RED
#define cG   AC_GREEN
#define cBR  AC_BROWN
#define cB   AC_BLUE
#define cMG  AC_MAGENTA
#define cM   AC_MARINE
#define cLG  AC_LGREY
#define cW   AC_WHITE
#define cG   AC_GREY
#define cLR  AC_LRED
#define cLGN AC_LGREEN
#define cY   AC_YELLOW
#define cLB  AC_LBLUE
#define cLMG AC_LMAGENTA
#define cLM  AC_LMARINE
#define cLW  AC_LWHITE

#endif






//#include "mbuf.c"

#define MBUF_FREE 0x80000000
#define MBUF_FREEMASK 0x8FFFFFFF
#define MBUF_OCC 0x40000000
// simple checksum whether a area is free or occupied.
// If neither nor, most possibly there's a problem.
#define MBUF_CHK 0xC0000000   

#define MBUF_PREVISFREE 0x20000000
#define MBUF_V 0x1FFFFFFF


// Here we go.. with the .. well. 
// Fastes and smallest malloc/free combi ever. 
// Not the smartest.
// Since it isn't exactly a memory allocation,
// instead it (mis)uses the minilib buf.
// muahaha. 1024 Bytes should be enough for everyone.
//  Ok. If you really do need more memory - 
//  rethink your design, increase mini_mbuf,
//  or use a proper malloc implementation.
//
// Here we misuse mbuf from top to bottom as stack.
// 64 Bytes are left at the bottom as reserve.
// Possibly we'd like to complain
// about the lack of memory, before we exit..
//
// ATM, the 'free' is really lazy. 
// It free's memory, but a real 'free' is only commited,
// when all memory below a freed area is also freed.
// Since the target of minilib atm are tiny tools, 
// this might be ok.
// ;) but, as I told before - 
// probably you should look out for a proper malloc implementation.
//
// I'm not sure yet, 
// whether a better implementation of free would be useful at all.
// Overall, I'd really prefer keeping minilib tiny.
//
// Reusing also sparse freed memory areas leads 
// to a whole bunch of complications.
// cache misses, searching complexity,
// storage overhead,
// just to name a few.
//
// I'm not sure whether it's worth it.
//
// And the existing malloc implementations 
// out there are countless.
//
// ;) It's sometimes smarter to stay special,
// although in this case this means the opposite.
//   ? I'm not sure what this sentence means XD
//misc
//
//+def
void* malloc(int size){
		size = ((size-1) >> 2 ) + 2; // alignment and reserving space for the "pointer"
		if( ml.mbufsize-(size<<2)<64 ){
				write( STDERR_FILENO, "Out of memory.\n",15 );
				return((void*)0);
		}

		ml.ibuf[(ml.mbufsize>>2)] = ml.ibuf[(ml.mbufsize>>2)] & MBUF_V; // clear flag prev_isfree
		ml.mbufsize -= (size<<2);
		ml.ibuf[(ml.mbufsize>>2)] = size;
		return( &ml.mbuf[ml.mbufsize+4] );
}


//+def
void free(void *p){
		char *c = p;
		int *i = p;
		i--;
		c-=4;
		
		if ( &ml.mbuf[ml.mbufsize] == (char*)c ){ // at the bottom of the stack
				ml.mbufsize += (i[0] & MBUF_V) <<2;
				if ( ml.mbufsize == mini_buf )
						return;
				if ( ml.ibuf[ml.mbufsize>>2] & MBUF_FREE )
						ml.mbufsize += ( ( ml.ibuf[ml.mbufsize>>2] & MBUF_V ) << 2 );
				return;
				/*do {
						ml.mbufsize += mbuf[ml.mbufsize] +4;
						} while ( (ml.mbufsize < mini_buf ) && ( mbuf[ml.mbufsize] & MBUF_FREE ) );*/ // next area also free'd
		} else { // Not at the bottom
				if ( ( i[0] & MBUF_PREVISFREE )){ // prev area is free
						i[ - i[-1] -1 ] = ( ( i[ - i[-1] -1 ] + i[0] ) & MBUF_V ) | MBUF_FREE; // add this to prev.
						i = i - ( i[-1] + 1 );
				}
				// prev not free
				if ( (i[( i[0] & MBUF_V)] & MBUF_FREE) ){ // next area free
						i[0] = ((i[0] + i[( i[0] & MBUF_V)]) & MBUF_V) | MBUF_FREE; // add next to current. 
						// MBUF_FREE is already set. But for safety set it again. via mask 
						// adding MBUF_FREE twice wouldn't be that great
						i[( i[0] & MBUF_V) - 1 ] = ( i[0] & MBUF_V) - 1;
						return;
				} // prev area not free, next area not free
				i[( i[0] & MBUF_V) - 1 ] = ( i[0] & MBUF_V) - 1;
				i[( i[0] & MBUF_V)] = ( i[( i[0] & MBUF_V)] | MBUF_PREVISFREE ); 
				i[0] = i[0] | MBUF_FREE;
				return;

		} 

							 /*	(int)c[ -(int)c[-4] ] = (int)c[ -(int)c[-4] ] + ( (int)c[0] & MBUF_V ) + ( (int)c[ ((int)c[0] & MBUF_V) ] & MBUF_V ); // add this and next area to prev area.
								(int)c[(int)c[ ((int)c[0] & MBUF_V)]-4] = (int)c[ -(int)c[-4] ] -4; // write combined free areas
								else { // next not free
										(int)c[ -(int)c[-4] ] += ( (int)c[0] & MBUF_V ); // add this area to prev area.
										(int)c[(int)c[0] & MBUF_V ] = (int)c[(int)c[0]&MBUF_V] | MBUF_PREVISFREE // mark next area 
												(int)c[(int)c[0]-4] = (int)c[ -(int)c[-4] ]-4; //write len of combined free areas there 
								}
						} else { //prev not free
								if ( (int)c[ (int)c[0] & MBUF_V ] & MBUF_FREE ){ // next free
										//mbuf[ (int)c[0]
								}
						}

				}*/
		
}



#if 0

POINTER* ml_brk=0;
extern POINTER _bssend;

//+def
void* volatile malloc(int size){
#ifdef undef
#warning BRK def
		int ret=1;
		mfprintf(stderr,"MALLOC: _bssend: %d\n",_bssend);
		if ( ml_brk == 0 ){
				ml_brk = _bssend;
				syscall1(ret,SCALL(brk),&ml_brk+size);
				if ( ret!=0 ){
						mfprintf(stderr,"MALLOC: 0\n");
						return(0);
				}
				ml_brk+=size;
				return((void*)_bssend);
		} else {
				syscall1(ret,SCALL(brk),size+ml_brk);
				if ( ret!=0 ){
						mfprintf(stderr,"MALLOC: 0\n");
						return(0);
				}
				int old_brk= ml_brk;
				ml_brk += size;
				return((void*)old_brk);
		}
#else 
#warning malloc SYSCALL
/*		void* ret;
		syscall6(ret, SCALL(mmap), 0, size, (0x01|0x02), 0x1002, -1, 0);
		//syscall6(ret, SCALL(mmap), 0, size, PROT_READ|PROT_WRITE, 0x1002, -1, 0);
		return((void*)ret);*/
#endif

		void* ret;
		size=4096;
	  register volatile long int r8 asm ("r8") = -1 ; 
		register volatile long int r9 asm ("r9") = 0; 
		register volatile long int r10 asm ("r10") = 0x1002; 
			asm volatile (
							//"xor %%r9, %%r9;"
							//"mov $-1, %%r8;"
							//"mov $0x1002, %%r10;"
							"syscall" 
							   : "=a" (ret) 
								 : "a" (SCALL(mmap) ) , "D" (0), "S" (size), "d" (0x01|0x02), "r" (r10), "r" (r8), "r" (r9) 
							   : "rcx", "memory" );
			return( (void*)ret );

}

//+def
void volatile free(void* p){

}




//malloc old
		//size = 4096;
/*	  register long int r8 asm ("r8") = -1 ; 
		register long int r9 asm ("r9") = 0; 
		register volatile long int r10 asm ("r10") = 0x1002; 
			asm volatile (
							//"xor %%r9, %%r9;"
							//"mov $-1, %%r8;"
							//"mov $0x1002, %%r10;"
							"syscall" 
							   : "=a" (ret) 
								 : "a" ( ( 197  | 0x2000000 ) ) , "D" (0), "S" (size), "d" (0x01|0x02), "r" (r10), "r" (r8), "r" (r9) 
							   : "ecx", "memory" );
	*/					
 /*
		asm volatile(
						"mov %p6, %%r9\n\t"
						"mov %p5, %%r8\n\t"
						"mov %p4, %%r10\n\t"
						"mov %p3, %%rdx\n\t"
						"mov %p2, %%rsi\n\t"
						"mov %p1, %%rdi\n\t"
						"mov $0x20000000, %%rax\n\t"
						"syscall\n\t"
						:"=a"(ret)
						:[p1]"m"(0),[p2]"m"(1024),[p3]"m"(0x01),[p4]"m"(0x0002),[p5]"m"(-1),[p6]"m"(0));*/
#endif



#endif
#endif

// minilib/src/ltodec.c
#ifdef mini_ltodec
//+include
//+def
int ultodec(unsigned long i, char *buf, int prec, char limiter ){
		int p = 0;
		if ( i>2^16 ){
				p=itodec((unsigned int)i-2^16, buf, prec, limiter);
				strcpy(&buf[p], "*2^16+"); // rude hack. Correct, but..
#todo: write ltodec
				p+=7;
		}
		return(uitodec((uint)i, &buf[p], prec, limiter));
}
//+def
int ltodec(long i, char *buf, int prec, char limiter ){
	if ( i < 0 ){
			buf[0]='-';
			i = -i;
			return(ultodec((unsigned long)i,&buf[1],prec,limiter) + 1 );
	}
	return(ultodec((unsigned long)i,buf,prec,limiter) );
}

#endif

// minilib/src/pty.c
#ifdef mini_grantpt
#endif

// minilib/src/basename.c
#ifdef mini_basename
/*-
 * Copyright (c) 2015-2016 Nuxi, https://nuxi.nl/
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
// source freebsd 

//+depends strlen
//+def
char *basename(char *path){
	char *ptr;

	/*
	 * If path is a null pointer or points to an empty string,
	 * basename() shall return a pointer to the string ".".
	 */
	if (path == NULL || *path == '\0')
		return ( ".");

	/* Find end of last pathname component and null terminate it. */
	ptr = path + strlen(path);
	while (ptr > path + 1 && *(ptr - 1) == '/')
		--ptr;
	*ptr-- = '\0';

	/* Find beginning of last pathname component. */
	while (ptr > path && *(ptr - 1) != '/')
		--ptr;
	return (ptr);
}
#endif

// minilib/src/itodec.c
#ifdef mini_uitodec
#ifndef mini_itodec_c
#define mini_itodec_c
//+ansi stdio.h
//
// convert int to string.
// prec: precision, e.g. 4=> 0087 
//+def
int uitodec(unsigned int i, char *buf, int prec, char limiter ){
		int p = 0;
		int a;
		int t1,t2,t3,dec;
		//unsigned int ut1,ut2,ut3;
		char n;
		prec = prec - 10; // Maximale Stellenanzahl 


		if ( i==0 ){
				buf[0] = '0';
				//p++;
				//return(
		}

		int trailing = 1;

	const int div[13] = {0, 100000000, 10000000, 1000000, 0, 100000, 10000, 1000, 0, 100, 10, 1};
	
	if ( i >= 1000000000){
			//prints("hier.\n");
			p=1;
			prec=0;
			if ( i>=2000000000 ){
					i-=2000000000;
				if ( i>=1000000000 ){
						if ( i>=2000000000 ){
								buf[0] = '4';
								i-=2000000000;
						} else {
								buf[0] = '3';
								i-=1000000000;
						}
					} else {
						buf[0] = '2';
						//i-=2000000000;
					}
			}	else {
					buf[0] = '1'; 
					i-=1000000000;
			}
	trailing = 0;
	} else {
			if ( prec == 0 ){
					buf[0] = ' ';
					p++;
			} else
					prec++;
	}

	

					
			

	for (a=0;a<12;a++){
			if ( div[a] == 0 ){
					if ( (limiter != 0 ) && (prec==0) ){
							buf[p] = limiter;
							p++;
					}
			} else {
			n = '0';

			if ( (t1=(i - div[a])) >= 0 ){
					prec = 0;
					trailing = 0;
					n = '1';
					if ( (t2=(t1-(dec=(div[a]<<2)))) >= 0){
							if ( (t3=t2-dec) >= 0 ){
									n = '9';
									i = t3;
									goto write;
							} else {
									n = '5';
									t1 = t2;
							}
					} 
					if ( (t2=(t1-(div[a]<<1) ) ) >=0 ){
							t1=t2;
							n += 2;
					}
					if ( (t2=(t1-(div[a]) ) ) >=0 ){
							t1=t2;
							n += 1;
					}
					i = t1;
			}

			if ( prec == 0 ){
			write:
					if ( trailing )
							buf[p] = ' ';
					else
							buf[p] = n;
					p++;
			} else
					prec++;
					//buf[p] = 'x';
					//p++;

			}
	}
	if ( p==0 )
			p=1;
	buf[p] = 0;

	return(p);
}

	
//+depends uitodec
//+def
int itodec(int i, char *buf, int prec, char limiter ){
	if ( i < 0 ){
			buf[0]='-';
			i = -i;
			return(uitodec((unsigned int)i,&buf[1],prec,limiter) + 1 );
	}
	return(uitodec((unsigned int)i,buf,prec,limiter) );
}


#endif
#endif

// minilib/src/pty.c
#ifdef mini_ptsname
#endif

// minilib/src/malloc.c
#ifdef mini_free
#endif

// minilib/src/isspace.c
#ifdef mini_isspace
#ifndef isspace_c
#define isspace_c

//+ansi ctype.h
//+def
int isspace(int c){
		switch (c){
				case ' ':
				case '\f':
				case '\n':
				case '\r':
				case '\t':
				case '\v':
						return(1);
		}
		return(0);
}




#endif

#endif

// minilib/src/fopen.c
#ifdef mini_fopen
#ifndef mini_fopen_c
#define mini_fopen_c

#ifndef mini_filemodes_h
#define mini_filemodes_h

#ifdef OSX

/* open-only flags */
#define	O_RDONLY	0x0000		/* open for reading only */
#define	O_WRONLY	0x0001		/* open for writing only */
#define	O_RDWR		0x0002		/* open for reading and writing */
#define	O_ACCMODE	0x0003		/* mask for above modes */

#define	FREAD		0x0001
#define	FWRITE		0x0002
#define	O_NONBLOCK	0x0004		/* no delay */
#define	O_APPEND	0x0008		/* set append mode */

#define	O_SHLOCK	0x0010		/* open with shared file lock */
#define	O_EXLOCK	0x0020		/* open with exclusive file lock */
#define	O_ASYNC		0x0040		/* signal pgrp when data ready */
#define	O_FSYNC		O_SYNC		/* source compatibility: do not use */
#define O_NOFOLLOW  0x0100      /* don't follow symlinks */
#define	O_CREAT		0x0200		/* create if nonexistant */
#define	O_TRUNC		0x0400		/* truncate to zero length */
#define	O_EXCL		0x0800		/* error if already exists */

#define	O_EVTONLY	0x8000		/* descriptor requested for event notifications only */

#define	O_NOCTTY	0x20000		/* don't assign controlling terminal */
#define O_DIRECTORY	0x100000
#define O_SYMLINK	0x200000	/* allow open of a symlink */
#define	O_CLOEXEC	0x1000000	/* implicitly set FD_CLOEXEC */
#define O_DP_GETRAWENCRYPTED	0x0001
#define O_DP_GETRAWUNENCRYPTED	0x0002



#else


#define O_ACCMODE	00000003
#define O_RDONLY	00000000
#define O_WRONLY	00000001
#define O_RDWR		00000002
#define O_CREAT		00000100	/* not fcntl */
#define O_EXCL		00000200	/* not fcntl */
#define O_NOCTTY	00000400	/* not fcntl */
#define O_TRUNC		00001000	/* not fcntl */
#define O_APPEND	00002000
#define O_NONBLOCK	00004000
#define O_DSYNC		00010000	/* used to be O_SYNC, see below */
#define FASYNC		00020000	/* fcntl, for BSD compatibility */
#define O_DIRECT	00040000	/* direct disk access hint */
#define O_LARGEFILE	00100000
#define O_DIRECTORY	00200000	/* must be a directory */
#define O_NOFOLLOW	00400000	/* don't follow links */
#define O_NOATIME	01000000
#define O_CLOEXEC	02000000	/* set close_on_exec */

#endif



#endif

int volatile open( const char *s, int flags, ... );

//+header stdio.h
//+depends open fileno close
//+needs lseek.h
//+doc modes implemented: r, r+, w, w+, a, a+
//+def
FILE *_fopen(int fd, const char* filename, const char* mode, FILE *f){
		int imode;

		switch (mode[0]){
				case 'r': imode = O_RDONLY;
									break;
				case 'w': imode = O_WRONLY | O_TRUNC | O_CREAT;
									break;
				case 'a': imode = O_APPEND | O_RDWR; // somehow only "a+" works. Not sure, why.
									break;
				default: return((FILE*)0); // hopefully a fd cannot be 0.? By reading the manual, 
								 // I conclude only stdin has the fildes 0. So It MIGHT be ok.
								  // Anyways, if someone's trying to open stdin via fopen and is wondering, what's going on..
								 // Here's the answer. But, regarding the bsd manuals, one shouldn't open stdin with fopen at all. so..
		}

		for ( int a=1; (mode[a] != 0) && ( a<6 ); a++ ){
 				if ( mode[a] == '+' ){ 
						imode = ( ( imode | O_RDWR ) & ~( O_WRONLY | O_RDONLY) );
				} else {
#if 0
				//printf("XXX: %c", mode[a]);
						switch (mode[0]){
								case 'r': //imode = O_RDONLY;
										break;
								case 'w': if ( mode[a] == 'x' )
															imode = imode & ( ~(O_CREAT | O_TRUNC) );
													break;
								case 'a': //imode = O_APPEND | O_RDWR; 
													break;
						}
#endif
				}
		}

		if ( f == 0 ){
				int a;
				if ( ml.pstream >= mini_FOPEN_MAX){ // Too many opened streams. Look for an empty storage location
						for ( a=3; ml.stream[a]>=0; a++ )
								if ( a >= mini_FOPEN_MAX ) // 
										return(0);
				} else {
						a = ml.pstream;
						ml.pstream++;
				}

				//printf("a: %d\n",a);
				f = &ml.stream[a];
		} else { // freopen - error handling?
				close(fileno(f));
		}
		if ( filename != 0 )
			*f	 =  open( filename, imode, 0666 );
		else 
			*f = fd;

		return ( f ); // 
}


//+header stdio.h
//+depends open _fopen
//+needs lseek.h
//+doc modes implemented: r, r+, w, w+, a, a+
//+def
FILE *fopen(const char* filename, const char* mode){
		return(_fopen(0,filename, mode,0));
}


//+header stdio.h
//+depends open _fopen
//+needs lseek.h
//+doc modes implemented: r, r+, w, w+, a, a+
//+def
FILE *fdopen(int fd, const char* mode){
		return(_fopen(fd,0, mode,0));
}


//+header stdio.h
//+depends open _fopen
//+needs lseek.h
//+doc modes implemented: r, r+, w, w+, a, a+
//+def
FILE *freopen(const char* filename, const char* mode, FILE *F){
		return(_fopen(0,filename, mode,F));
}




#endif
#endif

// minilib/src/itobin.c
#ifdef mini_itobin
#ifndef mini_itobin_h
#define mini_itobin_h



//+ansi stdio.h
//+def
int _itobin(int i, char*buf, int prec, int groups ){
		prec -= 32;
		int a,p=0;
		int g = 0;
		for ( a=0; a<32; a++ ){
				if (i&0x80000000 ){
						prec = 0;
						buf[p] = '1';
						p++;
				} else {
						if ( prec == 0 ){
								buf[p] = '0';
								p++;
						} else
								prec++;
				}
				i <<= 1;
				g++;
				if ( (prec==0) && (g>=groups) ){
						g=0;
						buf[p] = ' ';
						p++;
				}
		}
		if ( p == 0 ){
				buf[0] = '0';
				p++;
		}
		buf[p] = 0;
		return(p);
}

//+depends _itobin
//+macro itobin(A,B,...) _itobin(A,B,VARARG(SHIFT(__VA_ARGS__),0), VARARG(SHIFT(ARG( __VA_ARGS__ )),32) )


#endif
#endif

// minilib/src/sigemptyset.c
#ifdef mini_sigemptyset
#ifndef sigemptyset_c
#define sigemptyset_c
// copied from musl. 

//+header signal.h
//+include
//+def
static int sigemptyset(sigset_t *set){
		set->__bits[0] = 0;
		if (sizeof(long)==4 || _NSIG > 65) set->__bits[1] = 0;
		if (sizeof(long)==4 && _NSIG > 65) {
				set->__bits[2] = 0;
				set->__bits[3] = 0;
		}
		return 0;
}

#endif

#endif

// minilib/src/fopen.c
#ifdef mini_freopen
#endif

// minilib/src/dirent/opendir.c
#ifdef mini_opendir
#ifndef opendir_c
#define opendir_c
#ifndef	_DIRENT_H
#define	_DIRENT_H

#ifdef __cplusplus
extern "C" {
#endif


#define __NEED_ino_t
#define __NEED_off_t
#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
#define __NEED_size_t
#endif


struct __dirstream
{
	off_t tell;
	int fd;
	int buf_pos;
	int buf_end;
	volatile int lock[1];
	/* Any changes to this struct must preserve the property:
	 * offsetof(struct __dirent, buf) % sizeof(off_t) == 0 */
	char buf[2048];
};
typedef struct __dirstream DIR;

#define _DIRENT_HAVE_D_RECLEN
#define _DIRENT_HAVE_D_OFF
#define _DIRENT_HAVE_D_TYPE

struct dirent {
	ino_t d_ino;
	off_t d_off;
	unsigned short d_reclen;
	//unsigned char d_type;
	char d_name[256];
};

#define d_fileno d_ino
#if 0
int            closedir(DIR *);
DIR           *fdopendir(int);
DIR           *opendir(const char *);
struct dirent *readdir(DIR *);
int            readdir_r(DIR *__restrict, struct dirent *__restrict, struct dirent **__restrict);
void           rewinddir(DIR *);
int            dirfd(DIR *);

int alphasort(const struct dirent **, const struct dirent **);
int scandir(const char *, struct dirent ***, int (*)(const struct dirent *), int (*)(const struct dirent **, const struct dirent **));

#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
void           seekdir(DIR *, long);
long           telldir(DIR *);
#endif
#endif

#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
#define DT_UNKNOWN 0
#define DT_FIFO 1
#define DT_CHR 2
#define DT_DIR 4
#define DT_BLK 6
#define DT_REG 8
#define DT_LNK 10
#define DT_SOCK 12
#define DT_WHT 14
#define IFTODT(x) ((x)>>12 & 017)
#define DTTOIF(x) ((x)<<12)
int getdents(int, struct dirent *, size_t);
#endif

#ifdef _GNU_SOURCE
int versionsort(const struct dirent **, const struct dirent **);
#endif

#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
#define dirent64 dirent
#define readdir64 readdir
#define readdir64_r readdir_r
#define scandir64 scandir
#define alphasort64 alphasort
#define versionsort64 versionsort
#define off64_t off_t
#define ino64_t ino_t
#define getdents64 getdents
#endif

#ifdef __cplusplus
}
#endif

#endif



//+depends open close malloc
//+needs dirent.h
//+def
DIR *opendir(const char *name){
	int fd;
	DIR *dir;

	if ((fd = open(name, O_RDONLY|O_DIRECTORY|O_CLOEXEC)) < 0)
		return 0;
	dir = malloc(sizeof(*dir));
	if ( dir == 0 ){
		//	fprintf("Got: %d\n", dir);
		close( fd );
		return 0;
	}

	dir->fd = fd;
	dir->buf_pos=dir->buf_end=0;
	return dir;
}



#endif

#endif

// minilib/src/prints.c
#ifdef mini__mprints
#endif

// minilib/src/dtodec.c
#ifdef mini_dtodec
//convert double to string
//return number of bytes written to buf.
//doesn't convert numbers > 2^31 (!!!)
//doesn't round(!)
//max. prec after the dot: 8 digits. (!!)

//+ansi stdio.h
//+depends itodec uitodec
//+def
int dtodec(double d, char* buf, int precision){
		int i = (int) d;
		unsigned int i2;
		if ( d >= 0 )
			 i2 = (unsigned int)((d-i)*1000000000+0.1);
		else 
			 i2 = (unsigned int)((double)(-d+i)*1000000000+0.1);


		int p;
		if ( (d<=-1) || (d>0) )
				p = itodec(i,buf,0,0);
		else {
				buf[0] = '-';
				buf[1] = '0';
				p = 1;
		}

	
		buf[p+1]='.';
		int p2 = uitodec(i2,&buf[p+2],9,0);
		return(p+p2+2-9+precision);
}
#endif

// minilib/src/memset.c
#ifdef mini_memset
//+ansi string.h
//+def
void *memset( void *s, int c, int n){
		int a;
		char *sp = s;
		for ( a=0; a<n; a++)
				sp[a] = (char)c;
		return(s);
}
#endif

// minilib/src/memcpy.c
#ifdef mini_strncpy
#ifndef memcpy_c
#define memcpy_c

//+ansi string.h
//+def
void *memcpy( void *d, const void *s, int n ){
		char *dp=d;
		const char *sp = s;
		int a;
		for ( a=0; a<n; a++ )
				dp[a] = sp[a];
		return(d);
}


//+def
char *strcpy(char *dest, const char *src){
		int a;
		for ( a=0; src[a] != 0; a++)
				dest[a] = src[a];
		dest[a] = 0;
		return(dest);
}

//+depends memcpy
//+def
char *strncpy(char *dest, const char *src, int n){
		return( memcpy( dest, src, n ) );
}

#endif

#endif

// minilib/src/rand.c
#ifdef mini_rand
#ifndef rand_c
#define rand_c


//+header stdlib.h
//+def
void srand( unsigned int i ){
		ml.srand = i;
}
	


//+header stdlib.h
//+def
unsigned int rand(){
		// xorshift, algorithm af marsaglia.
		// second round added, it doesn't give more randomness,
		// but isn't so expensive on the other hand.
		if ( ml.srand==0 ){
				ml.srand=1;
		}
		ml.srand ^= ml.srand << 13;
 		ml.srand ^= ml.srand >> 17;
 		ml.srand ^= ml.srand << 5;
		unsigned int t = ml.srand;
		ml.srand ^= ml.srand << 13;
 		ml.srand ^= ml.srand >> 17;
 		ml.srand ^= ml.srand << 5;
		return(t-1);
}









#endif

#endif

// minilib/src/ltodec.c
#ifdef mini_ultodec
#endif

// minilib/src/fgets.c
#ifdef mini_fgets
#ifndef fgets_c
#define fgets_c
//+header stdio.h
//+depends fgetc
//+def
char* fgets(char *buf, int size, FILE* F){
		char *ret = buf;

		*buf = (char)fgetc(F);
		if ( !*buf ) // EOF
				return(0);

		while( --size >0 ){
				buf++;
				*buf = (char)fgetc(F);
				if ( *buf == 0 )
						return(ret);
				if ( *buf == '\n' )
						size=0;
		}
		buf++;
		*buf = 0;
		return(ret);
}

//+depends fgets fgetc fileno read
//+macro gets(F) fgets(F,0xfffffff,stdin)



#endif
#endif

// minilib/src/dirname.c
#ifdef mini_dirname
// source musl
// License MIT



//+depends strlen
//+def
char *dirname(char *s){
		size_t i;
		if (!s || !*s) return ".";
		i = strlen(s)-1;
		for (; s[i]=='/'; i--) if (!i) return "/";
		for (; s[i]!='/'; i--) if (!i) return ".";
		for (; s[i]=='/'; i--) if (!i) return "/";
		s[i+1] = 0;
		return s;
}

#endif

// minilib/src/strcmp.c
#ifdef mini_strncmp
#ifndef strcmp_c
#define strcmp_c

//+include
//+header string.h
//+needs ctype.h

//TODO: not implemented correct. need to return also -1.

// depend onto strncmp. Otherwise thias file will not be compiled.
//+inc
//+def
int _strcmp(const char*c1,const char*c2,int len){
		int a = 0;
		while ( (c1[a] != 0) && (c2[a]!=0 ) && a != len ){
				//write(1,&c1[a],1);
				if ( c1[a] != c2[a] )
						return(1);
				a++;
		}
		if ( (c1[a] == 0 ) && ( c2[a] == 0 ) )
				return(0);
		return (1);
}

//+inc
//+depends tolower
//+needs ctype.h
//+def
int _strcasecmp(const char*c1,const char*c2,int len){
		int a = 0;
		while ( (c1[a] != 0) && (c2[a]!=0 ) && a != len ){
				if ( c1[a] != c2[a] ){
						if ( tolower( c1[a] ) != tolower( c2[a] ) )
								return(1);
				}
				a++;
		}
		if ( (c1[a] == 0 ) && ( c2[a] == 0 ) )
				return(0);
		return (1);
}


//+inc
//+depends _strcasecmp tolower
//+needs ctype.h
//+def
int strcasecmp(const char*c1,const char*c2){
		return( _strcasecmp(c1,c2,-1) );
}


//+depends _strcasecmp
//+inc
//+def
int strncasecmp(const char*c1,const char*c2,int len){
		if ( len <=0 )
				return(-1);
		return(_strcasecmp(c1,c2,len) );
}



//+depends _strcmp
//+inc
//+def
int strcmp(const char*c1,const char*c2){
		return( _strcmp(c1,c2,-1) );
}


//+depends _strcmp
//+inc
//+def
int strncmp(const char*c1,const char*c2,int len){
		if ( len <=0 )
				return(-1);
		return(_strcmp(c1,c2,len) );
}


//+depends
//+def
int memcmp(const void* c1,const void* c2,int len){
		const char* cc1 = c1;
		const char* cc2 = c2;
		if ( len <=0 )
				return(-1);
		int a = 0;
		while ( a != len ){
				//write(1,&c1[a],1);
				if ( cc1[a] != cc2[a] )
						return(1);
				a++;
		}
	 return(0);
}


#endif
#endif

// minilib/src/sleep.c
#ifdef mini_sleep
#ifndef mini_sleep_c
#define mini_sleep_c

//+header unistd.h
//+include
//+needs nanosleep
//+doc nonconformant sleep
// TODO: ignore blocked signals, sigchld
//+def
unsigned int sleep(unsigned int seconds){
		unsigned int res;
		struct timespec ts = { .tv_sec = (long int) seconds, .tv_nsec = 0 };
		res = nanosleep(&ts, &ts);
		if (res) res = (unsigned int) ts.tv_sec + (ts.tv_nsec >= 500000000L);
		return res;
}

#endif

#endif

// minilib/src/fgets.c
#ifdef mini_gets
#endif

// minilib/src/fopen.c
#ifdef mini_fdopen
#endif

// minilib/src/strcmp.c
#ifdef mini_strncasecmp
#endif

// minilib/src/sprintf.c
#ifdef mini_fprintf
#endif

// minilib/src/fprintfs.c
#ifdef mini_fprintfs



//+depends fputs write fileno
//+after fputs
//+doc prints formatted to the stream F.
//+doc only %s is recognized.
//+doc no mini_buf needed, so using fprintfs instead of fprintf can save some sections / bytes.
//+def
int fprintfs( FILE* F, char *fmt, ...){
		va_list args;
		va_start(args,fmt);
		char *msg;
		int fd = fileno(F);
		int a;
		int p=0;
		int ret = 0;

		a = 0;
		while (fmt[a] != 0 ){
				if ( fmt[a] == '%' ){
						a++;
						if (fmt[a] == 's'){
								ret += write(fd,&fmt[p],a-1-p);
								p=a+1;
								msg = va_arg(args,char*);
								ret += fputs( msg, F );
						}
				}
				a++;
		}
		ret += write(fd,&fmt[p],a-p);

		va_end(args);
		return(ret);

}


#endif

// minilib/src/fopen.c
#ifdef mini__fopen
#endif

// minilib/src/strlen.c
#ifdef mini_strlen
#ifndef strlen_c
#define strlen_c

//+header string.h

//+def
int strlen(const char*str){
		int a = 0;
		while ( str[a] != 0 ){
				a++;
		}
		return (a);
}


#endif
#endif

// minilib/src/strcmp.c
#ifdef mini_memcmp
#endif

// minilib/src/memcpy.c
#ifdef mini_memcpy
#endif

// minilib/src/open.c
#ifdef mini_creat
#ifndef open_c
#define open_c
//+header fcntl.h
//+include


//#include "syscall.h"

#ifndef stdarg_h
#define stdarg_h
// copied from musl
// copy more - the builtin list..

#if 1
#if __GNUC__ >= 3
//#warning here 1
typedef __builtin_va_list va_list;
#define va_start(v,l)   __builtin_va_start(v,l)
#define va_end(v)       __builtin_va_end(v)
#define va_arg(v,l)     __builtin_va_arg(v,l)
#define va_copy(d,s)    __builtin_va_copy(d,s)
#else
//#warning here 2

#ifdef __GNUC__
//#warning here 3
//TODO: this gets scrambled if in the same compiler unit as the caller.
typedef __builtin_va_list va_list;
#define __VA_ALIGNED_SIZE(x) ((sizeof(x) + sizeof(int) - 1) & ~(sizeof(int) - 1))

#define va_start(ap, last) ((ap) = (void *)(((char *)&(last)) + __VA_ALIGNED_SIZE(last)))
#define va_end(ap) ((void)0)
#define va_copy(dest, src) ((dest) = (src))

#define va_arg(ap, type) \
	( ((ap) = (va_list)((char *)(ap) + __VA_ALIGNED_SIZE(type))), \
	*(type *)(void *)((char *)(ap) - __VA_ALIGNED_SIZE(type)) )


#else

//#warning here 4
// copied from tcc
#ifdef __x86_64__
//#warning here 5
#ifndef _WIN64
//#warning here 6

typedef void *va_list;

va_list __va_start(void *fp);
void *__va_arg(va_list ap, int arg_type, int size);
va_list __va_copy(va_list src);
void __va_end(va_list ap);

#define va_start(ap, last) ((ap) = __va_start(__builtin_frame_address(0)))
#define va_arg(ap, type)                                                \
		    (*(type *)(__va_arg(ap, __builtin_va_arg_types(type), sizeof(type))))
#define va_copy(dest, src) ((dest) = __va_copy(src))
#define va_end(ap) __va_end(ap)

#else /* _WIN64 */
typedef char *va_list;
#define va_start(ap,last) ap = ((char *)&(last)) + ((sizeof(last)+7)&~7)
#define va_arg(ap,type) (ap += (sizeof(type)+7)&~7, *(type *)(ap - ((sizeof(type)+7)&~7)))
#define va_copy(dest, src) (dest) = (src)
#define va_end(ap)
#endif

#else /* __i386__ */
typedef char *va_list;
/* only correct for i386 */
#define va_start(ap,last) ap = ((char *)&(last)) + ((sizeof(last)+3)&~3)
#define va_arg(ap,type) (ap += (sizeof(type)+3)&~3, *(type *)(ap - ((sizeof(type)+3)&~3)))
#define va_copy(dest, src) (dest) = (src)
#define va_end(ap)
#endif

/* fix a buggy dependency on GCC in libio.h */
typedef va_list __gnuc_va_list;
#define _VA_LIST_DEFINED

#endif
#endif

#endif

#endif


//+def
int volatile open( const char *s, int flags, ... ){
		int ret;
		va_list args;
		va_start(args,flags);
		int mode = va_arg(args,int);
		va_end(args);
		syscall3(ret,SCALL(open),(POINTER)s,flags,mode);
#ifdef mini_errno
		if ( ret<0 )
				errno = -ret;
#endif
		return(ret);
}

/// creat
//d open
//+def
inline int volatile __attribute__((always_inline)) creat( const char *s, int mode ){
		return(open( s, O_CREAT|O_WRONLY|O_TRUNC, mode) );
}



//FILE* volatile fopen( const char *s, const char *mode ){
//		int m = 0;




#endif
#endif

// minilib/src/wait.c
#ifdef mini_wait
#ifndef wait_c
#define wait_c
//+header sys/wait.h

//+depends wait4
//+include
//+def
pid_t wait(int *wstatus){
	return(wait4(-1,wstatus,0,0));
}


//+depends wait4
//+include
//+def
pid_t waitpid(pid_t pid, int *wstatus, int options){
	return(wait4(pid,wstatus,options,0));
}


#endif
#endif

// minilib/src/rand.c
#ifdef mini_srand
#endif

// minilib/src/sprintf.c
#ifdef mini_vsnprintf
#endif

// minilib/src/dirent/closedir.c
#ifdef mini_closedir
#ifndef closedir_c
#define closedir_c

//+depends free
//+def
int closedir(DIR *dir){
	int ret = close(dir->fd);
	free(dir);
	return ret;
}



#endif
#endif

// minilib/src/memcpy.c
#ifdef mini_strcpy
#endif

// minilib/src/memfrob.c
#ifdef mini_memfrob
//+ansi string.h
//+def
void* memfrob(void* s, unsigned int len){
		unsigned int a;
		char *c = s;
		for ( a=0; a<len;a++)
				c[a] = 	c[a] ^ 42;
		return ( s );
}
		
#endif

// minilib/src/strcmp.c
#ifdef mini_strcmp
#endif

// minilib/src/itobin.c
#ifdef mini__itobin
#endif

// minilib/src/itohex.c
#ifdef mini_itoHEX
#endif

// minilib/src/signal.c
#ifdef mini_signal
#ifndef signal_c
#define signal_c

// musl

//+header signal.h
//+depends sigaction
//+def
sighandler_t signal(int sig, sighandler_t func ){
		struct sigaction sa_old = { .sa_handler=0, .sa_flags=0 };
		struct sigaction sa = { .sa_handler = func, .sa_flags = SA_RESTART };
		if (sigaction(sig, &sa, &sa_old) < 0){
				prints("SIGNAL - ERR\n");
				return SIG_ERR;
		}
		return sa_old.sa_handler;
}





#endif
#endif

// minilib/src/isatty.c
#ifdef mini_isatty
#ifndef isatty_c
#define isatty_c
//+header unistd.h
//+include
//+depends tcgetattr
//+def
int isatty(int fd){
	struct termios term;
	return( tcgetattr(fd, &term) == 0 );
}


#endif

#endif

// minilib/src/strdup.c
#ifdef mini_strdup
#ifndef strdup_c
#define strdup_c

//+header string.h
//+depends malloc strcpy strlen
//+def
char *strdup(const char *source){
	char *d =  malloc(strlen(source));
	if ( !d ) return(0);
	strcpy(d,source);
	return(d);
}



#endif

#endif

// minilib/src/wait.c
#ifdef mini_waitpid
#endif

// minilib/src/sprintf.c
#ifdef mini_dprintf
#endif

// minilib/src/dirent/readdir.c
#ifdef mini_readdir
#ifndef readdir_c
#define readdir_c

//typedef char dirstream_buf_alignment_check[1-2*(int)(
//	offsetof(struct __dirstream, buf) % sizeof(off_t))];

//+def
struct dirent *readdir(DIR *dir){
	struct dirent *de;
	
	if (dir->buf_pos >= dir->buf_end) {
		int len = getdents( dir->fd, (struct dirent*) dir->buf, sizeof dir->buf);
		if (len <= 0) {
			if (len < 0 && len != -ENOENT) errno = -len;
			return 0;
		}
		dir->buf_end = len;
		dir->buf_pos = 0;
	}
	de = (void *)(dir->buf + dir->buf_pos);
	dir->buf_pos += de->d_reclen;
	dir->tell = de->d_off;
	return de;
}


#endif
#endif

// minilib/src/strcat.c
#ifdef mini_strcat
#ifndef strcat_c
#define strcat_c

//+ansi string.h
//+depends strlen
//+def
char *strcat(char *dest, const char *src ){
		size_t dest_len = strlen(dest);
		size_t i;

		for (i = 0 ; src[i] != '\0' ; i++)
				dest[dest_len + i] = src[i];
		dest[dest_len + i] = '\0';

		return dest;
}


#endif

#endif

// minilib/src/atoi.c
#ifdef mini_atoi
#ifndef atoi_c
#define atoi_c

//+ansi stdlib.h
//+def
int atoi(char *c){
		int t,a=0;
	 	int ret=0;
		int dez = 1;

		while( c[a] != 0 ){ 
				a++; 
		}
		while ( a>0 ){
				a--;
				if ( (c[a] > 48 ) && ( c[a] < 58 ) ){
						t = c[a] - 48;
						if ( t & 1 )
								ret += dez;
						dez <<= 1;
						if ( t & 2 )
								ret += dez;
						dez <<= 1;
						if ( t & 4 )
								ret += dez;
						dez <<= 1;
						if ( t & 8 )
								ret += dez;
				} else {
						dez <<= 3;
				}
				dez += (dez >> 2);
		}
		if ( c[0] == '-' )
				ret = -ret;
		return(ret);
}


#endif
		
#endif

// minilib/src/strcmp.c
#ifdef mini_strcasecmp
#endif

// minilib/src/open.c
#ifdef mini_open
#endif

// minilib/src/itodec.c
#ifdef mini_itodec
#endif

// minilib/src/getenv.c
#ifdef mini_getenv
#ifndef getenv_c
#define getenv_c

#ifndef dumbsyntaxchecker
char **mini_env;
#endif


//+header stdlib.h
//+def
char *getenv(const char* name){
		int b;
		for ( int a=0; mini_env[a]; a++ ){
				for ( b = 0; mini_env[a][b] == name[b]; b++ ){}
				if ( mini_env[a][b] == '=' ){
						return( &mini_env[a][b+1] );
				}
		}
		return(0);
}



#endif
#endif

// minilib/src/strerror.c
#ifdef mini_strerror
#endif

// minilib/src/strcmp.c
#ifdef mini__strcmp
#endif

// minilib/src/itohex.c
#ifdef mini_itohex
#endif

// minilib/src/pty.c
#ifdef mini_posix_openpt
#endif

// minilib/src/sigaction.c
#ifdef mini_sigaction
#ifndef sigaction_c
#define sigaction_c

//+header signal.h
//+include
//+def
static int sigaction(int sig, const struct sigaction *act, struct sigaction *oact){
		return( rt_sigaction, 4, sig, act, oact, sizeof(act->sa_mask) );
}

// memo: needs static definition, cause the +include
// (mening, including the definition into the header.
// What is the right thing to do for a wrapper call.)

#endif
#endif

// minilib/src/strcmp.c
#ifdef mini__strcasecmp
#endif

// minilib/src/sprintf.c
#ifdef mini_sprintf
#endif

#endif
#endif
#endif

#endif

// ifndef LDSCRIPT
#else

#ifdef LDSCRIPT_script

SECTIONS {                                                                                                                                                    
		/DISCARD/ : { 
			*(.comment) 
			*(.eh_frame)
			*(.plt)
			*(.got.plt)
			*(.rel.plt)
			*(.note*)
		}
}
INSERT AFTER .text

#endif

#ifdef LDSCRIPT_script_onlytext

/*OUTPUT_FORMAT("elf32-i386")
OUTPUT_ARCH(i386)
*/

PHDRS {
	text PT_LOAD FILEHDR PHDRS ;
	/*bss PT_LOAD;*/
}

ENTRY(_start)

SECTIONS
{
		/* Read-only sections, merged into text segment: */
		/*__executable_start = SEGMENT_START("text-segment", 0x08048000); */
		start = _start;
		/*. = SEGMENT_START("text-segment", 0x08048000) + SIZEOF_HEADERS;*/
		. = 0x08048000 + SIZEOF_HEADERS;

		.text           :
		{
				*(.text.unlikely .text.*_unlikely)
						*(.text._start .text._start.*)
						*(.text.main .text.main.*)
						*(.text.cexit)
						*(.text._exit .text._exit.*)
						*(.text.__exit .text.__exit.*)
						*(.text.startup .text.startup.*)
						*(.text.hot .text.hot.*)
						*(.text .stub .text.* .gnu.linkonce.t.*)
						/* .gnu.warning sections are handled specially by elf32.em.  */
						*(.gnu.warning)

/*		 }
		.bss            :
		{ 
*/
/*misc: Seems to work without a bss segment ( for readonly data only) , so commented it out.
saves 15 bytes. ( needs -N for linking )*/


						*(.dynbss)
						*(.bss .bss.* .gnu.linkonce.b.*)
						*(COMMON)
						*(.rodata .rodata.* .gnu.linkonce.r.*)
						/* Align here to ensure that the .bss section occupies space up to
							 _end.  Align after .bss to ensure correct alignment even if the
							 .bss section disappears because there are no input sections.
							 FIXME: Why do we need it? When there is no .bss section, we dont
							 pad the .data section.  
misc: deleted : . = ALIGN(. != 0 ? 32 / 8 : 1);*/
		} :text

		/DISCARD/ : { 
			*(.note.GNU-stack) 
			*(.gnu_debuglink) 
			*(.gnu.lto_*) 
			*(.iplt*) 
			*(.igot*) 
			*(.rel*) 
			*(.comment)
			*(.eh_frame)
			*(.plt*)
			*(.got.plt*)
			*(.rel.*)
			*(.note*)
			*(*)
			}
}


#endif

#ifdef LDSCRIPT_script_text_and_bss

/*OUTPUT_FORMAT("elf32-i386")
OUTPUT_ARCH(i386)*/

PHDRS {
	text PT_LOAD FILEHDR PHDRS ;
	/*bss PT_LOAD;*/
}

ENTRY(_start)

SECTIONS
{
		/* Read-only sections, merged into text segment: */
		/*__executable_start = SEGMENT_START("text-segment", 0x08048000); */
		start = _start;
		/*. = SEGMENT_START("text-segment", 0x08048000) + SIZEOF_HEADERS;*/
		. = 0x08048000 + SIZEOF_HEADERS;

		.text           :
		{
				*(.text.unlikely .text.*_unlikely)
						*(.text.exit .text.exit.*)
						*(.text.startup .text.startup.*)
						*(.text.hot .text.hot.*)
						*(.text .stub .text.* .gnu.linkonce.t.*)
						/* .gnu.warning sections are handled specially by elf32.em.  */
						*(.gnu.warning)

		 }
		.bss            :
		{ 

						*(.dynbss)
						*(.bss .bss.* .gnu.linkonce.b.*)
						*(COMMON)
						*(.rodata .rodata.* .gnu.linkonce.r.*)
						/* Align here to ensure that the .bss section occupies space up to
							 _end.  Align after .bss to ensure correct alignment even if the
							 .bss section disappears because there are no input sections.
							 FIXME: Why do we need it? When there is no .bss section, we dont
							 pad the .data section.  
misc: deleted : . = ALIGN(. != 0 ? 32 / 8 : 1);*/
		} :text

		/DISCARD/ : { 
			*(.note.GNU-stack) 
			*(.gnu_debuglink) 
			*(.gnu.lto_*) 
			*(.iplt*) 
			*(.igot*) 
			*(.rel*) 
			*(.comment)
			*(.eh_frame)
			*(.plt*)
			*(.got.plt*)
			*(.rel.*)
			*(.note*)
			}
}


#endif

#endif

#endif

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="AsciiDoc 8.6.10">
<title></title>
</head>
<body>
<hr>
<h2><a name="_ctype_h"></a> ctype.h</h2>
<dl>
<dt>
isprint
</dt>
<dd>
<p>
  static inline int <em>attribute</em>always_inline isprint(const char c);
<br>
  (<a href="include/isprint.h">include/isprint.h</a> l.8)<br>
</p>
</dd>
<dt>
isspace
</dt>
<dd>
<p>
  int isspace(int c);
<br>
  (<a href="src/isspace.c">src/isspace.c</a> l.6)<br>
</p>
</dd>
</dl>
<hr>
<h2><a name="_declarations_h"></a> declarations.h</h2>
<dl>
<dt>
dup3
</dt>
<dd>
<p>
  dup3(int a1, int a2, int a3)
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.53)<br>
</p>
</dd>
<dt>
fstat
</dt>
<dd>
<p>
  fstat(int a1,struct stat* a2)
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.47)<br>
</p>
</dd>
<dt>
getcwd
</dt>
<dd>
<p>
  getcwd(char *buf,long size)
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.55)<br>
</p>
</dd>
<dt>
getdents
</dt>
<dd>
<p>
  getdents( unsigned int fd, struct dirent *direntry, unsigned int count )
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.39)<br>
</p>
</dd>
<dt>
gettimeofday
</dt>
<dd>
<p>
  gettimeofday( struct timeval *a1, struct timezone *a2)
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.28)<br>
</p>
</dd>
<dt>
mprotect
</dt>
<dd>
<p>
  mprotect( POINTER *a1, POINTER a2, int a3 )
<br>
 Returns: *a1<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.32)<br>
</p>
</dd>
<dt>
stat
</dt>
<dd>
<p>
  stat(const char* filename,struct stat* a2)
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.48)<br>
</p>
</dd>
<dt>
uname
</dt>
<dd>
<p>
  uname(struct old_utsname *name )
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.37)<br>
</p>
</dd>
</dl>
<hr>
<h2><a name="_dirent_h"></a> dirent.h</h2>
<dl>
<dt>
closedir
</dt>
<dd>
<p>
  int closedir(DIR *dir);
<br>
  Defines: free<br>
 (<a href="src/dirent/closedir.c">src/dirent/closedir.c</a> l.6)<br>
</p>
</dd>
<dt>
opendir
</dt>
<dd>
<p>
  DIR *opendir(const char *name);
<br>
  Defines: malloc close open<br>
 (<a href="src/dirent/opendir.c">src/dirent/opendir.c</a> l.10)<br>
</p>
</dd>
<dt>
readdir
</dt>
<dd>
<p>
  struct dirent *readdir(DIR *dir);
<br>
  (<a href="src/dirent/readdir.c">src/dirent/readdir.c</a> l.9)<br>
</p>
</dd>
</dl>
<hr>
<h2><a name="_fcntl_h"></a> fcntl.h</h2>
<dl>
<dt>
creat
</dt>
<dd>
<p>
  inline int volatile <em>attribute</em>always_inline creat( const char *s, int mode );
<br>
  (<a href="src/open.c">src/open.c</a> l.29)<br>
</p>
</dd>
</dl>
<hr>
<h2><a name="_ioctl_h"></a> ioctl.h</h2>
<dl>
<dt>
ioctl
</dt>
<dd>
<p>
  int ioctl( int fd, unsigned long int request, &#8230; );
<br>
  (<a href="src/ioctl.c">src/ioctl.c</a> l.11)<br>
</p>
</dd>
</dl>
<hr>
<h2><a name="_mini_addons_h"></a> mini_addons.h</h2>
<dl>
<dt>
_itobin
</dt>
<dd>
<p>
  int _itobin(int i, char*buf, int prec, int groups );
<br>
  (<a href="src/itobin.c">src/itobin.c</a> l.8)<br>
</p>
</dd>
<dt>
_mprints
</dt>
<dd>
<p>
  #define _mprints(&#8230;) dprints(STDOUT_FILENO, <em>VA_ARGS</em>)
<br>
  Defines: dprints<br>
 (<a href="src/prints.c">src/prints.c</a> l.66)<br>
</p>
</dd>
<dt>
_strcmp
</dt>
<dd>
<p>
  int _strcmp(const char*c1,const char*c2,int len);
<br>
  Defines: 0<br>
 (<a href="src/mstrcmp.c">src/mstrcmp.c</a> l.11)<br>
</p>
</dd>
<dt>
basename
</dt>
<dd>
<p>
  char *basename(char *path);
<br>
  Defines: strlen<br>
 (<a href="src/basename.c">src/basename.c</a> l.29)<br>
</p>
</dd>
<dt>
def
</dt>
<dd>
<p>
  #define SETOPT_short( opts, option ) (;
<br>
  (<a href="macros/getoptm.h">macros/getoptm.h</a> l.52)<br>
Set a option flag(s) (bit(s))  manually.<br>
                param options: e.g. just a, or ( a+h+l) to check for several flags at once<br>
</p>
</dd>
<dt>
dprintf
</dt>
<dd>
<p>
  int dprintf( int fd, const char *fmt, &#8230; );
<br>
  Defines: write<br>
 (<a href="src/sprintf.c">src/sprintf.c</a> l.202)<br>
</p>
</dd>
<dt>
dtodec
</dt>
<dd>
<p>
  int dtodec(double d, char* buf, int precision);
<br>
  Defines: uitodec<br>
 (<a href="src/dtodec.c">src/dtodec.c</a> l.10)<br>
</p>
</dd>
<dt>
fprintfs
</dt>
<dd>
<p>
  int fprintfs( FILE* F, char *fmt, &#8230;);
<br>
  Defines: strlen write fileno<br>
 (<a href="src/fprintfs.c">src/fprintfs.c</a> l.10)<br>
prints formatted to the stream F.only %s is recognized.no mini_buf needed, so using fprintfs instead of fprintf can save some sections / bytes.<br>
</p>
</dd>
<dt>
fprints
</dt>
<dd>
<p>
  #define fprints(F,str) write(fileno(F),str,strlen(str))
<br>
  Defines: strlen fileno write<br>
 (<a href="include/prints.h">include/prints.h</a> l.17)<br>
print the string(s) supplied as arg(s) to stream<br>
</p>
</dd>
<dt>
fwrites
</dt>
<dd>
<p>
  #define fwrites(fd,str) write(fd,str,sizeof(str))
<br>
  Defines: write<br>
 (<a href="include/prints.h">include/prints.h</a> l.39)<br>
write the constant str to stdout. Computes length with sizeof(str) at compile time.<br>
</p>
</dd>
<dt>
itobin
</dt>
<dd>
<p>
  #define itobin(A,B,&#8230;) _itobin(A,B,VARARG(SHIFT(<em>VA_ARGS</em>),0), VARARG(SHIFT(ARG( <em>VA_ARGS</em> )),32) )
<br>
  Defines: <br>
 (<a href="src/itobin.c">src/itobin.c</a> l.41)<br>
</p>
</dd>
<dt>
itodec
</dt>
<dd>
<p>
  int itodec(int i, char *buf, int prec, char limiter );
<br>
  Defines: uitodec<br>
 (<a href="src/itodec.c">src/itodec.c</a> l.121)<br>
</p>
</dd>
<dt>
memfrob
</dt>
<dd>
<p>
  void* memfrob(void* s, unsigned int len);
<br>
  (<a href="src/memfrob.c">src/memfrob.c</a> l.3)<br>
</p>
</dd>
<dt>
print
</dt>
<dd>
<p>
  #define print(str) write(STDOUT_FILENO,str,strlen(str))
<br>
  Defines: strlen write<br>
 (<a href="include/prints.h">include/prints.h</a> l.29)<br>
write str to stdout. Needs strlen<br>
</p>
</dd>
<dt>
printl
</dt>
<dd>
<p>
  #define printl() write(STDOUT_FILENO,"\n",1)
<br>
  Defines: write<br>
 (<a href="include/prints.h">include/prints.h</a> l.44)<br>
write a newline to stdout<br>
</p>
</dd>
<dt>
prints
</dt>
<dd>
<p>
  #define prints(&#8230;) _mprints(<em>VA_ARGS</em>,0)
<br>
  Defines: <br>
 (<a href="include/prints.h">include/prints.h</a> l.11)<br>
print the string(s) supplied as arg(s) to stdout<br>
</p>
</dd>
<dt>
printsl
</dt>
<dd>
<p>
  #define printsl(&#8230;) _mprints(<em>VA_ARGS</em>,"\n",0)
<br>
  Defines: <br>
 (<a href="include/prints.h">include/prints.h</a> l.25)<br>
print the string(s) supplied as arg(s) and newline to stdout<br>
</p>
</dd>
<dt>
snprintf
</dt>
<dd>
<p>
  int snprintf( char *buf, size_t size, const char *fmt, &#8230; );
<br>
  Defines: write<br>
 (<a href="src/sprintf.c">src/sprintf.c</a> l.219)<br>
</p>
</dd>
<dt>
uitodec
</dt>
<dd>
<p>
  int uitodec(unsigned int i, char *buf, int prec, char limiter );
<br>
  (<a href="src/itodec.c">src/itodec.c</a> l.8)<br>
</p>
</dd>
<dt>
vsnprintf
</dt>
<dd>
<p>
  int vsnprintf(char <strong>buf, size_t size, const char</strong> fmt, va_list args );
<br>
  Defines: write<br>
 (<a href="src/sprintf.c">src/sprintf.c</a> l.36)<br>
</p>
</dd>
<dt>
writes
</dt>
<dd>
<p>
  #define writes(str) write(STDOUT_FILENO,str,sizeof(str))
<br>
  Defines: write<br>
 (<a href="include/prints.h">include/prints.h</a> l.34)<br>
write the constant str to stdout. Computes length with sizeof(str) at compile time.<br>
</p>
</dd>
</dl>
<hr>
<h2><a name="_stdio_h"></a> stdio.h</h2>
<dl>
<dt>
_itohex
</dt>
<dd>
<p>
  int _itohex(int i,char* buf,int padding, int capitals);
<br>
  (<a href="src/itohex.c">src/itohex.c</a> l.5)<br>
</p>
</dd>
<dt>
clearerror
</dt>
<dd>
<p>
  static inline void clearerror(FILE *f);
<br>
  (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.198)<br>
</p>
</dd>
<dt>
fclose
</dt>
<dd>
<p>
  static inline int <em>attribute</em>always_inline fclose( FILE* f );
<br>
  Defines: close<br>
 (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.65)<br>
</p>
</dd>
<dt>
feof
</dt>
<dd>
<p>
  static inline int feof(FILE *f);
<br>
  (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.184)<br>
</p>
</dd>
<dt>
ferror
</dt>
<dd>
<p>
  static inline int ferror(FILE *f);
<br>
  (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.191)<br>
</p>
</dd>
<dt>
fflush
</dt>
<dd>
<p>
  static inline int <em>attribute</em>always_inline fflush( FILE *F );
<br>
  (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.28)<br>
This does nothing, since minilib doesn&#8217;t provide buffered streams yet.in order to sync the stream, please use fsync<br>
</p>
</dd>
<dt>
fgetc
</dt>
<dd>
<p>
  static inline int fgetc(FILE *F);
<br>
  Defines: read fileno<br>
 (<a href="include/fgetc.h">include/fgetc.h</a> l.10)<br>
</p>
</dd>
<dt>
fgetpos
</dt>
<dd>
<p>
  static inline void fgetpos(FILE *f, long *pos );
<br>
  Defines: lseek<br>
 (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.127)<br>
</p>
</dd>
<dt>
fileno
</dt>
<dd>
<p>
  static inline int <em>attribute</em>always_inline fileno( FILE *f );
<br>
  (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.55)<br>
</p>
</dd>
<dt>
fopen
</dt>
<dd>
<p>
  FILE <strong>fopen(const char</strong> filename, const char* mode);
<br>
  Defines: open<br>
 (<a href="src/fopen.c">src/fopen.c</a> l.12)<br>
modes implemented: r, r+, w, w+, a, a+<br>
</p>
</dd>
<dt>
fprint
</dt>
<dd>
<p>
  #define fprint(&#8230;) fprintf(<em>VA_ARGS</em>)
<br>
  Defines: write fileno<br>
 (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.95)<br>
</p>
</dd>
<dt>
fprintf
</dt>
<dd>
<p>
  #define fprintf(stream,&#8230;)   write(fileno(stream),ml.mbuf,sprintf(ml.mbuf,<em>VA_ARGS</em>))
<br>
  Defines: write fileno<br>
 (<a href="src/sprintf.c">src/sprintf.c</a> l.244)<br>
</p>
</dd>
<dt>
fputc
</dt>
<dd>
<p>
  static inline int volatile fputc(int c, FILE* F);
<br>
  Defines: write fileno<br>
 (<a href="include/fputc.h">include/fputc.h</a> l.10)<br>
</p>
</dd>
<dt>
fputs
</dt>
<dd>
<p>
  static inline int volatile fputs(const char *c, FILE *F);
<br>
  Defines: strlen write fileno<br>
 (<a href="include/fputs.h">include/fputs.h</a> l.14)<br>
</p>
</dd>
<dt>
fread
</dt>
<dd>
<p>
  static inline size_t fread(void *ptr, size_t size, size_t nmemb, FILE *f);
<br>
  Defines: read<br>
 (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.162)<br>
</p>
</dd>
<dt>
fseek
</dt>
<dd>
<p>
  static inline int fseek(FILE *f, long offset, int whence );
<br>
  Defines: lseek<br>
 (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.146)<br>
</p>
</dd>
<dt>
fsetpos
</dt>
<dd>
<p>
  static inline int fsetpos(FILE *f, int pos );
<br>
  Defines: lseek<br>
 (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.133)<br>
</p>
</dd>
<dt>
ftell
</dt>
<dd>
<p>
  static inline long ftell(FILE *f);
<br>
  Defines: lseek<br>
 (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.121)<br>
</p>
</dd>
<dt>
fwrite
</dt>
<dd>
<p>
  static inline size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *f);
<br>
  Defines: write<br>
 (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.106)<br>
</p>
</dd>
<dt>
getc
</dt>
<dd>
<p>
  #define getc(F) fgetc(F)
<br>
  Defines: fileno read<br>
 (<a href="include/fgetc.h">include/fgetc.h</a> l.18)<br>
</p>
</dd>
<dt>
itoHEX
</dt>
<dd>
<p>
  int itoHEX(int i,char* buf,int padding);
<br>
  Defines: <br>
 (<a href="src/itohex.c">src/itohex.c</a> l.55)<br>
</p>
</dd>
<dt>
itohex
</dt>
<dd>
<p>
  int itohex(int i,char* buf,int padding);
<br>
  Defines: <br>
 (<a href="src/itohex.c">src/itohex.c</a> l.48)<br>
</p>
</dd>
<dt>
perror
</dt>
<dd>
<p>
  void perror(char *msg);
<br>
  Defines: strlen strerror write fileno<br>
 (<a href="src/strerror.c">src/strerror.c</a> l.22)<br>
</p>
</dd>
<dt>
printf
</dt>
<dd>
<p>
  #define printf(&#8230;) fprintf(stdout,<em>VA_ARGS</em>)
<br>
  Defines: write fileno<br>
 (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.91)<br>
</p>
</dd>
<dt>
putc
</dt>
<dd>
<p>
  #define putc(c,stream) fputc(c,stream)
<br>
  Defines: write fileno<br>
 (<a href="include/fputc.h">include/fputc.h</a> l.19)<br>
</p>
</dd>
<dt>
putchar
</dt>
<dd>
<p>
  #define putchar(c) fputc(c,stdout)
<br>
  Defines: write fileno<br>
 (<a href="include/fputc.h">include/fputc.h</a> l.16)<br>
</p>
</dd>
<dt>
puts
</dt>
<dd>
<p>
  #define puts(msg) ( print(msg) + printl() )
<br>
  Defines: strlen write<br>
 (<a href="include/prints.h">include/prints.h</a> l.49)<br>
write msg to stdout, append a newline. Needs strlen.<br>
</p>
</dd>
<dt>
rewind
</dt>
<dd>
<p>
  static inline void rewind( FILE *f );
<br>
  Defines: lseek<br>
 (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.156)<br>
</p>
</dd>
<dt>
setbuf
</dt>
<dd>
<p>
  void setbuf(FILE *stream, char *buf);
<br>
  (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.206)<br>
dummy functions.<br>
  There is no buffering implemented for the streams yet.<br>
</p>
</dd>
<dt>
setvbuf
</dt>
<dd>
<p>
  int setvbuf(FILE *stream, char *buf, int mode, size_t size);
<br>
  (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.210)<br>
dummy<br>
</p>
</dd>
<dt>
sprintf
</dt>
<dd>
<p>
  #define sprintf(str,&#8230;) snprintf( str, 4096,  <em>VA_ARGS</em>)
<br>
  Defines: write<br>
 (<a href="src/sprintf.c">src/sprintf.c</a> l.26)<br>
</p>
</dd>
<dt>
vfprintf
</dt>
<dd>
<p>
  #define vfprintf(&#8230;) fprintf(<em>VA_ARGS</em>)
<br>
  Defines: fileno write<br>
 (<a href="include/mini_fstream.h">include/mini_fstream.h</a> l.100)<br>
</p>
</dd>
</dl>
<hr>
<h2><a name="_stdlib_h"></a> stdlib.h</h2>
<dl>
<dt>
atoi
</dt>
<dd>
<p>
  int atoi(char *c);
<br>
  (<a href="src/atoi.c">src/atoi.c</a> l.6)<br>
</p>
</dd>
<dt>
free
</dt>
<dd>
<p>
  void volatile free(void* p);
<br>
  (<a href="src/malloc.c">src/malloc.c</a> l.200)<br>
</p>
</dd>
<dt>
getenv
</dt>
<dd>
<p>
  char <strong>getenv(const char</strong> name);
<br>
  (<a href="src/getenv.c">src/getenv.c</a> l.11)<br>
</p>
</dd>
<dt>
malloc
</dt>
<dd>
<p>
  void* volatile malloc(int size);
<br>
  (<a href="src/malloc.c">src/malloc.c</a> l.150)<br>
</p>
</dd>
<dt>
rand
</dt>
<dd>
<p>
  unsigned int rand();
<br>
  (<a href="src/rand.c">src/rand.c</a> l.15)<br>
</p>
</dd>
<dt>
srand
</dt>
<dd>
<p>
  void srand( unsigned int i );
<br>
  (<a href="src/rand.c">src/rand.c</a> l.7)<br>
</p>
</dd>
</dl>
<hr>
<h2><a name="_string_h"></a> string.h</h2>
<dl>
<dt>
memcmp
</dt>
<dd>
<p>
  int memcmp(const void* c1,const void* c2,int len);
<br>
  Defines: 0<br>
 (<a href="src/mstrcmp.c">src/mstrcmp.c</a> l.43)<br>
</p>
</dd>
<dt>
memcpy
</dt>
<dd>
<p>
  void *memcpy( void *d, const void *s, int n );
<br>
  (<a href="src/memcpy.c">src/memcpy.c</a> l.6)<br>
</p>
</dd>
<dt>
memset
</dt>
<dd>
<p>
  void *memset( void *s, int c, int n);
<br>
  (<a href="src/memset.c">src/memset.c</a> l.3)<br>
</p>
</dd>
<dt>
strcat
</dt>
<dd>
<p>
  char *strcat(char *dest, const char *src );
<br>
  (<a href="src/strcat.c">src/strcat.c</a> l.6)<br>
</p>
</dd>
<dt>
strcmp
</dt>
<dd>
<p>
  int strcmp(const char*c1,const char*c2);
<br>
  Defines: <br>
 (<a href="src/mstrcmp.c">src/mstrcmp.c</a> l.27)<br>
</p>
</dd>
<dt>
strcpy
</dt>
<dd>
<p>
  char *strcpy(char *dest, const char *src);
<br>
  (<a href="src/memcpy.c">src/memcpy.c</a> l.17)<br>
</p>
</dd>
<dt>
strerror
</dt>
<dd>
<p>
  char* strerror( int errnum );
<br>
  (<a href="src/strerror.c">src/strerror.c</a> l.9)<br>
</p>
</dd>
<dt>
strlen
</dt>
<dd>
<p>
  int strlen(const char*str);
<br>
  (<a href="src/strlen.c">src/strlen.c</a> l.7)<br>
</p>
</dd>
<dt>
strncmp
</dt>
<dd>
<p>
  int strncmp(const char*c1,const char*c2,int len);
<br>
  Defines: <br>
 (<a href="src/mstrcmp.c">src/mstrcmp.c</a> l.34)<br>
</p>
</dd>
<dt>
strncpy
</dt>
<dd>
<p>
  char *strncpy(char *dest, const char *src, int n);
<br>
  Defines: memcpy<br>
 (<a href="src/memcpy.c">src/memcpy.c</a> l.27)<br>
</p>
</dd>
</dl>
<hr>
<h2><a name="_time_h"></a> time.h</h2>
<dl>
<dt>
time
</dt>
<dd>
<p>
  time(unsigned int *a1 )
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.59)<br>
</p>
</dd>
</dl>
<hr>
<h2><a name="_unistd_h"></a> unistd.h</h2>
<dl>
<dt>
chdir
</dt>
<dd>
<p>
  chdir(const char* path)
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.49)<br>
</p>
</dd>
<dt>
close
</dt>
<dd>
<p>
  close( int fd )
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.34)<br>
</p>
</dd>
<dt>
dup
</dt>
<dd>
<p>
  dup(int a1)
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.51)<br>
</p>
</dd>
<dt>
dup2
</dt>
<dd>
<p>
  dup2(int a1, int a2)
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.52)<br>
</p>
</dd>
<dt>
fsync
</dt>
<dd>
<p>
  fsync(int a1 )
<br>
 (<a href="include/lseek.h">include/lseek.h</a> l.20)<br>
</p>
</dd>
<dt>
ftruncate
</dt>
<dd>
<p>
  ftruncate(unsigned int a1, unsigned int a2 )
<br>
 (<a href="include/lseek.h">include/lseek.h</a> l.19)<br>
</p>
</dd>
<dt>
getpid
</dt>
<dd>
<p>
  DEF_syscall(getpid,0 )
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.30)<br>
</p>
</dd>
<dt>
lseek
</dt>
<dd>
<p>
  lseek(unsigned int a1, int a2, int a3 )
<br>
 (<a href="include/lseek.h">include/lseek.h</a> l.17)<br>
</p>
</dd>
<dt>
open
</dt>
<dd>
<p>
  int volatile open( const char *s, int flags, &#8230; );
<br>
  (<a href="src/open.c">src/open.c</a> l.12)<br>
</p>
</dd>
<dt>
read
</dt>
<dd>
<p>
  read( int fd, POINTER *buf, int len )
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.35)<br>
</p>
</dd>
<dt>
rename
</dt>
<dd>
<p>
  rename( const char* a1, const char* a2 )
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.44)<br>
</p>
</dd>
<dt>
select
</dt>
<dd>
<p>
  static inline int volatile <em>attribute</em>always_inline select(int fd, volatile fd_set* readfd, volatile fd_set *writefd, volatile fd_set *exceptfd, volatile struct timeval *wait);
<br>
  (<a href="include/select.h">include/select.h</a> l.10)<br>
</p>
</dd>
<dt>
tcgetattr
</dt>
<dd>
<p>
  static inline int <em>attribute</em>always_inline tcgetattr(int fd, struct termios *io);
<br>
  Defines: ioctl<br>
 (<a href="include/tcgetattr.h">include/tcgetattr.h</a> l.17)<br>
</p>
</dd>
<dt>
tcsetattr
</dt>
<dd>
<p>
  static inline int <em>attribute</em>always_inline tcsetattr(int fd, int opt, const struct termios *io);
<br>
  Defines: ioctl<br>
 (<a href="include/tcsetattr.h">include/tcsetattr.h</a> l.18)<br>
</p>
</dd>
<dt>
unlink
</dt>
<dd>
<p>
  unlink( const char* a1)
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.45)<br>
</p>
</dd>
<dt>
write
</dt>
<dd>
<p>
  write(int fd,const void *buf, int len )
<br>
 (<a href="include/syscall_stubs.h">include/syscall_stubs.h</a> l.41)<br>
</p>
</dd>
</dl>
<p></p>
<p></p>
<hr><p><small>
Last updated
 2020-01-18 18:03:20 CET
</small></p>
</body>
</html>

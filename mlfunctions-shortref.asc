

 ctype.h
---------

isprint::

  static inline int __attribute__((always_inline)) isprint(const char c);
 +
  (link:include/isprint.h[include/isprint.h] l.8) +


isspace::

  int isspace(int c);
 +
  (link:src/isspace.c[src/isspace.c] l.6) +




 declarations.h
----------------

dup3::

  dup3(int a1, int a2, int a3)		
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.53) +


fstat::

  fstat(int a1,struct stat* a2)		
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.47) +


getcwd::

  getcwd(char *buf,long size)		
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.55) +


getdents::

  getdents( unsigned int fd, struct dirent *direntry, unsigned int count )
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.39) +


gettimeofday::

  gettimeofday( struct timeval *a1, struct timezone *a2)
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.28) +


mprotect::

  mprotect( POINTER *a1, POINTER a2, int a3 )
 +
 Returns: *a1 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.32) +


stat::

  stat(const char* filename,struct stat* a2)		
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.48) +


uname::

  uname(struct old_utsname *name )
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.37) +




 dirent.h
----------

closedir::

  int closedir(DIR *dir);
 +
  Defines: free +
 (link:src/dirent/closedir.c[src/dirent/closedir.c] l.6) +


opendir::

  DIR *opendir(const char *name);
 +
  Defines: malloc close open +
 (link:src/dirent/opendir.c[src/dirent/opendir.c] l.10) +


readdir::

  struct dirent *readdir(DIR *dir);
 +
  (link:src/dirent/readdir.c[src/dirent/readdir.c] l.9) +




 fcntl.h
---------

creat::

  inline int volatile __attribute__((always_inline)) creat( const char *s, int mode );
 +
  (link:src/open.c[src/open.c] l.29) +




 ioctl.h
---------

ioctl::

  int ioctl( int fd, unsigned long int request, ... );
 +
  (link:src/ioctl.c[src/ioctl.c] l.11) +




 mini_addons.h
---------------

_itobin::

  int _itobin(int i, char*buf, int prec, int groups );
 +
  (link:src/itobin.c[src/itobin.c] l.8) +


_mprints::

  #define _mprints(...) dprints(STDOUT_FILENO, __VA_ARGS__)
 +
  Defines: dprints +
 (link:src/prints.c[src/prints.c] l.66) +


_strcmp::

  int _strcmp(const char*c1,const char*c2,int len);
 +
  Defines: 0 +
 (link:src/mstrcmp.c[src/mstrcmp.c] l.11) +


basename::

  char *basename(char *path);
 +
  Defines: strlen +
 (link:src/basename.c[src/basename.c] l.29) +


def::

  #define SETOPT_short( opts, option ) (;
 +
  (link:macros/getoptm.h[macros/getoptm.h] l.52) +
Set a option flag(s) (bit(s))  manually. +
 		param options: e.g. just a, or ( a+h+l) to check for several flags at once +
 

dprintf::

  int dprintf( int fd, const char *fmt, ... );
 +
  Defines: write +
 (link:src/sprintf.c[src/sprintf.c] l.202) +


dtodec::

  int dtodec(double d, char* buf, int precision);
 +
  Defines: uitodec +
 (link:src/dtodec.c[src/dtodec.c] l.10) +


fprintfs::

  int fprintfs( FILE* F, char *fmt, ...);
 +
  Defines: strlen write fileno +
 (link:src/fprintfs.c[src/fprintfs.c] l.10) +
prints formatted to the stream F.only %s is recognized.no mini_buf needed, so using fprintfs instead of fprintf can save some sections / bytes. +
 

fprints::

  #define fprints(F,str) write(fileno(F),str,strlen(str))
 +
  Defines: strlen fileno write +
 (link:include/prints.h[include/prints.h] l.17) +
print the string(s) supplied as arg(s) to stream +
 

fwrites::

  #define fwrites(fd,str) write(fd,str,sizeof(str))
 +
  Defines: write +
 (link:include/prints.h[include/prints.h] l.39) +
write the constant str to stdout. Computes length with sizeof(str) at compile time. +
 

itobin::

  #define itobin(A,B,...) _itobin(A,B,VARARG(SHIFT(__VA_ARGS__),0), VARARG(SHIFT(ARG( __VA_ARGS__ )),32) )
 +
  Defines:  +
 (link:src/itobin.c[src/itobin.c] l.41) +


itodec::

  int itodec(int i, char *buf, int prec, char limiter );
 +
  Defines: uitodec +
 (link:src/itodec.c[src/itodec.c] l.121) +


memfrob::

  void* memfrob(void* s, unsigned int len);
 +
  (link:src/memfrob.c[src/memfrob.c] l.3) +


print::

  #define print(str) write(STDOUT_FILENO,str,strlen(str))
 +
  Defines: strlen write +
 (link:include/prints.h[include/prints.h] l.29) +
write str to stdout. Needs strlen +
 

printl::

  #define printl() write(STDOUT_FILENO,"\n",1)
 +
  Defines: write +
 (link:include/prints.h[include/prints.h] l.44) +
write a newline to stdout +
 

prints::

  #define prints(...) _mprints(__VA_ARGS__,0)
 +
  Defines:  +
 (link:include/prints.h[include/prints.h] l.11) +
print the string(s) supplied as arg(s) to stdout +
 

printsl::

  #define printsl(...) _mprints(__VA_ARGS__,"\n",0)
 +
  Defines:  +
 (link:include/prints.h[include/prints.h] l.25) +
print the string(s) supplied as arg(s) and newline to stdout +
 

snprintf::

  int snprintf( char *buf, size_t size, const char *fmt, ... );
 +
  Defines: write +
 (link:src/sprintf.c[src/sprintf.c] l.219) +


uitodec::

  int uitodec(unsigned int i, char *buf, int prec, char limiter );
 +
  (link:src/itodec.c[src/itodec.c] l.8) +


vsnprintf::

  int vsnprintf(char *buf, size_t size, const char* fmt, va_list args );
 +
  Defines: write +
 (link:src/sprintf.c[src/sprintf.c] l.36) +


writes::

  #define writes(str) write(STDOUT_FILENO,str,sizeof(str))
 +
  Defines: write +
 (link:include/prints.h[include/prints.h] l.34) +
write the constant str to stdout. Computes length with sizeof(str) at compile time. +
 



 stdio.h
---------

_itohex::

  int _itohex(int i,char* buf,int padding, int capitals);
 +
  (link:src/itohex.c[src/itohex.c] l.5) +


clearerror::

  static inline void clearerror(FILE *f);
 +
  (link:include/mini_fstream.h[include/mini_fstream.h] l.198) +


fclose::

  static inline int __attribute__((always_inline)) fclose( FILE* f );
 +
  Defines: close +
 (link:include/mini_fstream.h[include/mini_fstream.h] l.65) +


feof::

  static inline int feof(FILE *f);
 +
  (link:include/mini_fstream.h[include/mini_fstream.h] l.184) +


ferror::

  static inline int ferror(FILE *f);
 +
  (link:include/mini_fstream.h[include/mini_fstream.h] l.191) +


fflush::

  static inline int __attribute__((always_inline)) fflush( FILE *F );
 +
  (link:include/mini_fstream.h[include/mini_fstream.h] l.28) +
This does nothing, since minilib doesn't provide buffered streams yet.in order to sync the stream, please use fsync +
 

fgetc::

  static inline int fgetc(FILE *F);
 +
  Defines: read fileno +
 (link:include/fgetc.h[include/fgetc.h] l.10) +


fgetpos::

  static inline void fgetpos(FILE *f, long *pos );
 +
  Defines: lseek +
 (link:include/mini_fstream.h[include/mini_fstream.h] l.127) +


fileno::

  static inline int __attribute__((always_inline)) fileno( FILE *f );
 +
  (link:include/mini_fstream.h[include/mini_fstream.h] l.55) +


fopen::

  FILE *fopen(const char* filename, const char* mode);
 +
  Defines: open +
 (link:src/fopen.c[src/fopen.c] l.12) +
modes implemented: r, r+, w, w+, a, a+ +
 

fprint::

  #define fprint(...) fprintf(__VA_ARGS__)
 +
  Defines: write fileno +
 (link:include/mini_fstream.h[include/mini_fstream.h] l.95) +


fprintf::

  #define fprintf(stream,...)	write(fileno(stream),ml.mbuf,sprintf(ml.mbuf,__VA_ARGS__))
 +
  Defines: write fileno +
 (link:src/sprintf.c[src/sprintf.c] l.244) +


fputc::

  static inline int volatile fputc(int c, FILE* F);
 +
  Defines: write fileno +
 (link:include/fputc.h[include/fputc.h] l.10) +


fputs::

  static inline int volatile fputs(const char *c, FILE *F);
 +
  Defines: strlen write fileno +
 (link:include/fputs.h[include/fputs.h] l.14) +


fread::

  static inline size_t fread(void *ptr, size_t size, size_t nmemb, FILE *f);
 +
  Defines: read +
 (link:include/mini_fstream.h[include/mini_fstream.h] l.162) +


fseek::

  static inline int fseek(FILE *f, long offset, int whence );
 +
  Defines: lseek +
 (link:include/mini_fstream.h[include/mini_fstream.h] l.146) +


fsetpos::

  static inline int fsetpos(FILE *f, int pos );
 +
  Defines: lseek +
 (link:include/mini_fstream.h[include/mini_fstream.h] l.133) +


ftell::

  static inline long ftell(FILE *f);
 +
  Defines: lseek +
 (link:include/mini_fstream.h[include/mini_fstream.h] l.121) +


fwrite::

  static inline size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *f);
 +
  Defines: write +
 (link:include/mini_fstream.h[include/mini_fstream.h] l.106) +


getc::

  #define getc(F) fgetc(F)
 +
  Defines: fileno read +
 (link:include/fgetc.h[include/fgetc.h] l.18) +


itoHEX::

  int itoHEX(int i,char* buf,int padding);
 +
  Defines:  +
 (link:src/itohex.c[src/itohex.c] l.55) +


itohex::

  int itohex(int i,char* buf,int padding);
 +
  Defines:  +
 (link:src/itohex.c[src/itohex.c] l.48) +


perror::

  void perror(char *msg);
 +
  Defines: strlen strerror write fileno +
 (link:src/strerror.c[src/strerror.c] l.22) +


printf::

  #define printf(...) fprintf(stdout,__VA_ARGS__)
 +
  Defines: write fileno +
 (link:include/mini_fstream.h[include/mini_fstream.h] l.91) +


putc::

  #define putc(c,stream) fputc(c,stream)
 +
  Defines: write fileno +
 (link:include/fputc.h[include/fputc.h] l.19) +


putchar::

  #define putchar(c) fputc(c,stdout)
 +
  Defines: write fileno +
 (link:include/fputc.h[include/fputc.h] l.16) +


puts::

  #define puts(msg) ( print(msg) + printl() )
 +
  Defines: strlen write +
 (link:include/prints.h[include/prints.h] l.49) +
write msg to stdout, append a newline. Needs strlen. +
 

rewind::

  static inline void rewind( FILE *f );
 +
  Defines: lseek +
 (link:include/mini_fstream.h[include/mini_fstream.h] l.156) +


setbuf::

  void setbuf(FILE *stream, char *buf);
 +
  (link:include/mini_fstream.h[include/mini_fstream.h] l.206) +
dummy functions. +
  There is no buffering implemented for the streams yet. +
 

setvbuf::

  int setvbuf(FILE *stream, char *buf, int mode, size_t size);
 +
  (link:include/mini_fstream.h[include/mini_fstream.h] l.210) +
dummy +
 

sprintf::

  #define sprintf(str,...) snprintf( str, 4096,  __VA_ARGS__)
 +
  Defines: write +
 (link:src/sprintf.c[src/sprintf.c] l.26) +


vfprintf::

  #define vfprintf(...) fprintf(__VA_ARGS__)
 +
  Defines: fileno write +
 (link:include/mini_fstream.h[include/mini_fstream.h] l.100) +




 stdlib.h
----------

atoi::

  int atoi(char *c);
 +
  (link:src/atoi.c[src/atoi.c] l.6) +


free::

  void volatile free(void* p);
 +
  (link:src/malloc.c[src/malloc.c] l.200) +


getenv::

  char *getenv(const char* name);
 +
  (link:src/getenv.c[src/getenv.c] l.11) +


malloc::

  void* volatile malloc(int size);
 +
  (link:src/malloc.c[src/malloc.c] l.150) +


rand::

  unsigned int rand();
 +
  (link:src/rand.c[src/rand.c] l.15) +


srand::

  void srand( unsigned int i );
 +
  (link:src/rand.c[src/rand.c] l.7) +




 string.h
----------

memcmp::

  int memcmp(const void* c1,const void* c2,int len);
 +
  Defines: 0 +
 (link:src/mstrcmp.c[src/mstrcmp.c] l.43) +


memcpy::

  void *memcpy( void *d, const void *s, int n );
 +
  (link:src/memcpy.c[src/memcpy.c] l.6) +


memset::

  void *memset( void *s, int c, int n);
 +
  (link:src/memset.c[src/memset.c] l.3) +


strcat::

  char *strcat(char *dest, const char *src );
 +
  (link:src/strcat.c[src/strcat.c] l.6) +


strcmp::

  int strcmp(const char*c1,const char*c2);
 +
  Defines:  +
 (link:src/mstrcmp.c[src/mstrcmp.c] l.27) +


strcpy::

  char *strcpy(char *dest, const char *src);
 +
  (link:src/memcpy.c[src/memcpy.c] l.17) +


strerror::

  char* strerror( int errnum );
 +
  (link:src/strerror.c[src/strerror.c] l.9) +


strlen::

  int strlen(const char*str);
 +
  (link:src/strlen.c[src/strlen.c] l.7) +


strncmp::

  int strncmp(const char*c1,const char*c2,int len);
 +
  Defines:  +
 (link:src/mstrcmp.c[src/mstrcmp.c] l.34) +


strncpy::

  char *strncpy(char *dest, const char *src, int n);
 +
  Defines: memcpy +
 (link:src/memcpy.c[src/memcpy.c] l.27) +




 time.h
--------

time::

  time(unsigned int *a1 )
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.59) +




 unistd.h
----------

chdir::

  chdir(const char* path)		
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.49) +


close::

  close( int fd )
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.34) +


dup::

  dup(int a1)		
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.51) +


dup2::

  dup2(int a1, int a2)		
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.52) +


fsync::

  fsync(int a1 )
 +
 (link:include/lseek.h[include/lseek.h] l.20) +


ftruncate::

  ftruncate(unsigned int a1, unsigned int a2 )
 +
 (link:include/lseek.h[include/lseek.h] l.19) +


getpid::

  DEF_syscall(getpid,0 )
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.30) +


lseek::

  lseek(unsigned int a1, int a2, int a3 )
 +
 (link:include/lseek.h[include/lseek.h] l.17) +


open::

  int volatile open( const char *s, int flags, ... );
 +
  (link:src/open.c[src/open.c] l.12) +


read::

  read( int fd, POINTER *buf, int len )
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.35) +


rename::

  rename( const char* a1, const char* a2 )		
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.44) +


select::

  static inline int volatile __attribute__((always_inline)) select(int fd, volatile fd_set* readfd, volatile fd_set *writefd, volatile fd_set *exceptfd, volatile struct timeval *wait);
 +
  (link:include/select.h[include/select.h] l.10) +


tcgetattr::

  static inline int __attribute__((always_inline)) tcgetattr(int fd, struct termios *io);
 +
  Defines: ioctl +
 (link:include/tcgetattr.h[include/tcgetattr.h] l.17) +


tcsetattr::

  static inline int __attribute__((always_inline)) tcsetattr(int fd, int opt, const struct termios *io);
 +
  Defines: ioctl +
 (link:include/tcsetattr.h[include/tcsetattr.h] l.18) +


unlink::

  unlink( const char* a1)		
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.45) +


write::

  write(int fd,const void *buf, int len )
 +
 (link:include/syscall_stubs.h[include/syscall_stubs.h] l.41) +


